{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model.ts","vs/editor/common/model.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAKhG,OAAO,EAAE,MAAM,EAAE,MAAM,8BAA8B,CAAC;AAqBtD;;GAEG;AACH,MAAM,CAAN,IAAY,iBAKX;AALD,WAAY,iBAAiB;IAC5B,yDAAQ,CAAA;IACR,6DAAU,CAAA;IACV,2DAAS,CAAA;IACT,yDAAQ,CAAA;AACT,CAAC,EALW,iBAAiB,KAAjB,iBAAiB,QAK5B;AAED;;GAEG;AACH,MAAM,CAAN,IAAY,eAIX;AAJD,WAAY,eAAe;IAC1B,qDAAQ,CAAA;IACR,yDAAU,CAAA;IACV,uDAAS,CAAA;AACV,CAAC,EAJW,eAAe,KAAf,eAAe,QAI1B;AA2QD;;GAEG;AACH,MAAM,CAAN,IAAY,aAIX;AAJD,WAAY,aAAa;IACxB,+CAAO,CAAA;IAEP,+CAAO,CAAA;AACR,CAAC,EAJW,aAAa,KAAb,aAAa,QAIxB;AAuCD,MAAM,CAAN,IAAY,uBAKX;AALD,WAAY,uBAAuB;IAClC,qEAAI,CAAA;IACJ,uEAAK,CAAA;IACL,qEAAI,CAAA;IACJ,qEAAI,CAAA;AACL,CAAC,EALW,uBAAuB,KAAvB,uBAAuB,QAKlC;AAgMD,MAAM,OAAO,wBAAwB;IAWpC,IAAW,kBAAkB;QAC5B,OAAO,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;IAChE,CAAC;IAED;;OAEG;IACH,YAAY,GAOX;QAxBD,mCAA8B,GAAS,SAAS,CAAC;QAyBhD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;QAC5C,IAAI,GAAG,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;YAClC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;YAC/B,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;QAClC,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;YAClD,IAAI,CAAC,oBAAoB,GAAG,KAAK,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC9C,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC;QACrC,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;QAC1D,IAAI,CAAC,8BAA8B,GAAG,GAAG,CAAC,8BAA8B,CAAC;IAC1E,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAA+B;QAC5C,OAAO,CACN,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO;eAC3B,IAAI,CAAC,oBAAoB,KAAK,KAAK,CAAC,oBAAoB;eACxD,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,UAAU;eACpC,IAAI,CAAC,YAAY,KAAK,KAAK,CAAC,YAAY;eACxC,IAAI,CAAC,UAAU,KAAK,KAAK,CAAC,UAAU;eACpC,IAAI,CAAC,kBAAkB,KAAK,KAAK,CAAC,kBAAkB;eACpD,MAAM,CAAC,IAAI,CAAC,8BAA8B,EAAE,KAAK,CAAC,8BAA8B,CAAC,CACpF,CAAC;IACH,CAAC;IAED;;OAEG;IACI,iBAAiB,CAAC,OAAiC;QACzD,OAAO;YACN,OAAO,EAAE,IAAI,CAAC,OAAO,KAAK,OAAO,CAAC,OAAO;YACzC,UAAU,EAAE,IAAI,CAAC,UAAU,KAAK,OAAO,CAAC,UAAU;YAClD,YAAY,EAAE,IAAI,CAAC,YAAY,KAAK,OAAO,CAAC,YAAY;YACxD,kBAAkB,EAAE,IAAI,CAAC,kBAAkB,KAAK,OAAO,CAAC,kBAAkB;SAC1E,CAAC;IACH,CAAC;CACD;AA8BD,MAAM,OAAO,SAAS;IAMrB;;OAEG;IACH,YAAY,KAAY,EAAE,OAAwB;QARlD,oBAAe,GAAS,SAAS,CAAC;QASjC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;CACD;AAsBD;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,GAAQ;IACvC,OAAO,CAAC,GAAG,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;AAChD,CAAC;AAqvBD;;GAEG;AACH,MAAM,OAAO,2BAA2B;IACvC,YACiB,UAAiD,EACjD,KAAY,EACZ,IAAmB,EACnB,gBAAyB,EACzB,oBAA6B,EAC7B,UAAmB;QALnB,eAAU,GAAV,UAAU,CAAuC;QACjD,UAAK,GAAL,KAAK,CAAO;QACZ,SAAI,GAAJ,IAAI,CAAe;QACnB,qBAAgB,GAAhB,gBAAgB,CAAS;QACzB,yBAAoB,GAApB,oBAAoB,CAAS;QAC7B,eAAU,GAAV,UAAU,CAAS;IAChC,CAAC;CACL;AAuCD;;GAEG;AACH,MAAM,OAAO,UAAU;IAetB,YAAY,KAAa,EAAE,cAA8C,EAAE,YAA2B;QACrG,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IAClC,CAAC;CACD;AAUD;;GAEG;AACH,MAAM,OAAO,gBAAgB;IAE5B,YACiB,YAA0C,EAC1C,OAAsC,EACtC,6BAA8C;QAF9C,iBAAY,GAAZ,YAAY,CAA8B;QAC1C,YAAO,GAAP,OAAO,CAA+B;QACtC,kCAA6B,GAA7B,6BAA6B,CAAiB;IAC3D,CAAC;CAEL;AAUD;;GAEG;AACH,MAAM,UAAU,sBAAsB,CAAC,KAAiB;IACvD,OAAO,CACN,CAAC,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,KAAK,CAAC,iBAAiB,CACzD,CAAC;AACH,CAAC","file":"model.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../base/common/event.js';\nimport { IMarkdownString } from '../../base/common/htmlContent.js';\nimport { IDisposable } from '../../base/common/lifecycle.js';\nimport { equals } from '../../base/common/objects.js';\nimport { ThemeColor } from '../../base/common/themables.js';\nimport { URI } from '../../base/common/uri.js';\nimport { ISingleEditOperation } from './core/editOperation.js';\nimport { IPosition, Position } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { TextChange } from './core/textChange.js';\nimport { WordCharacterClassifier } from './core/wordCharacterClassifier.js';\nimport { IWordAtPosition } from './core/wordHelper.js';\nimport { FormattingOptions } from './languages.js';\nimport { ILanguageSelection } from './languages/language.js';\nimport { IBracketPairsTextModelPart } from './textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelFontChangedEvent, ModelInjectedTextChangedEvent, ModelLineHeightChangedEvent } from './textModelEvents.js';\nimport { IModelContentChange } from './model/mirrorTextModel.js';\nimport { IGuidesTextModelPart } from './textModelGuides.js';\nimport { ITokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { UndoRedoGroup } from '../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from './tokens/lineTokens.js';\nimport { TextModelEditSource } from './textModelEditSource.js';\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3,\n}\n\nexport interface IGlyphMarginLanesModel {\n\t/**\n\t * The number of lanes that should be rendered in the editor.\n\t */\n\treadonly requiredLanes: number;\n\n\t/**\n\t * Gets the lanes that should be rendered starting at a given line number.\n\t */\n\tgetLanesAtLine(lineNumber: number): GlyphMarginLane[];\n\n\t/**\n\t * Resets the model and ensures it can contain at least `maxLine` lines.\n\t */\n\treset(maxLine: number): void;\n\n\t/**\n\t * Registers that a lane should be visible at the Range in the model.\n\t * @param persist - if true, notes that the lane should always be visible,\n\t * even on lines where there's no specific request for that lane.\n\t */\n\tpush(lane: GlyphMarginLane, range: Range, persist?: boolean): void;\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport const enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport const enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\nexport interface IDecorationOptions {\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tcolor: string | ThemeColor | undefined;\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tdarkColor?: string | ThemeColor;\n}\n\nexport interface IModelDecorationGlyphMarginOptions {\n\t/**\n\t * The position in the glyph margin.\n\t */\n\tposition: GlyphMarginLane;\n\n\t/**\n\t * Whether the glyph margin lane in {@link position} should be rendered even\n\t * outside of this decoration's range.\n\t */\n\tpersistLane?: boolean;\n}\n\n/**\n * Options for rendering a model decoration in the overview ruler.\n */\nexport interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {\n\t/**\n\t * The position in the overview ruler.\n\t */\n\tposition: OverviewRulerLane;\n}\n\n/**\n * Options for rendering a model decoration in the minimap.\n */\nexport interface IModelDecorationMinimapOptions extends IDecorationOptions {\n\t/**\n\t * The position in the minimap.\n\t */\n\tposition: MinimapPosition;\n\t/**\n\t * If the decoration is for a section header, which header style.\n\t */\n\tsectionHeaderStyle?: MinimapSectionHeaderStyle | null;\n\t/**\n\t * If the decoration is for a section header, the header text.\n\t */\n\tsectionHeaderText?: string | null;\n}\n\n/**\n * Options for a model decoration.\n */\nexport interface IModelDecorationOptions {\n\t/**\n\t * A debug description that can be used for inspecting model decorations.\n\t * @internal\n\t */\n\tdescription: string;\n\t/**\n\t * Customize the growing behavior of the decoration when typing at the edges of the decoration.\n\t * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t */\n\tstickiness?: TrackedRangeStickiness;\n\t/**\n\t * CSS class name describing the decoration.\n\t */\n\tclassName?: string | null;\n\t/**\n\t * Indicates whether the decoration should span across the entire line when it continues onto the next line.\n\t */\n\tshouldFillLineOnLineBreak?: boolean | null;\n\tblockClassName?: string | null;\n\t/**\n\t * Indicates if this block should be rendered after the last line.\n\t * In this case, the range must be empty and set to the last line.\n\t */\n\tblockIsAfterEnd?: boolean | null;\n\tblockDoesNotCollapse?: boolean | null;\n\tblockPadding?: [top: number, right: number, bottom: number, left: number] | null;\n\n\t/**\n\t * Message to be rendered when hovering over the glyph margin decoration.\n\t */\n\tglyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the decoration message.\n\t */\n\thoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the line number message.\n\t */\n\tlineNumberHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Should the decoration expand to encompass a whole line.\n\t */\n\tisWholeLine?: boolean;\n\t/**\n\t * Always render the decoration (even when the range it encompasses is collapsed).\n\t */\n\tshowIfCollapsed?: boolean;\n\t/**\n\t * Collapse the decoration if its entire range is being replaced via an edit.\n\t * @internal\n\t */\n\tcollapseOnReplaceEdit?: boolean;\n\t/**\n\t * Specifies the stack order of a decoration.\n\t * A decoration with greater stack order is always in front of a decoration with\n\t * a lower stack order when the decorations are on the same line.\n\t */\n\tzIndex?: number;\n\t/**\n\t * If set, render this decoration in the overview ruler.\n\t */\n\toverviewRuler?: IModelDecorationOverviewRulerOptions | null;\n\t/**\n\t * If set, render this decoration in the minimap.\n\t */\n\tminimap?: IModelDecorationMinimapOptions | null;\n\t/**\n\t * If set, the decoration will be rendered in the glyph margin with this CSS class name.\n\t */\n\tglyphMarginClassName?: string | null;\n\t/**\n\t * If set and the decoration has {@link glyphMarginClassName} set, render this decoration\n\t * with the specified {@link IModelDecorationGlyphMarginOptions} in the glyph margin.\n\t */\n\tglyphMargin?: IModelDecorationGlyphMarginOptions | null;\n\t/**\n\t * If set, the decoration will override the line height of the lines it spans. Maximum value is 300px.\n\t */\n\tlineHeight?: number | null;\n\t/**\n\t * Font family\n\t */\n\tfontFamily?: string | null;\n\t/**\n\t * Font size\n\t */\n\tfontSize?: string | null;\n\t/**\n\t * Font weight\n\t */\n\tfontWeight?: string | null;\n\t/**\n\t * Font style\n\t */\n\tfontStyle?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name.\n\t */\n\tlinesDecorationsClassName?: string | null;\n\t/**\n\t * Controls the tooltip text of the line decoration.\n\t */\n\tlinesDecorationsTooltip?: string | null;\n\t/**\n\t * If set, the decoration will be rendered on the line number.\n\t */\n\tlineNumberClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.\n\t */\n\tfirstLineDecorationClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.\n\t */\n\tmarginClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t * Please use this only for CSS rules that must impact the text. For example, use `className`\n\t * to have a background color decoration.\n\t */\n\tinlineClassName?: string | null;\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\tinlineClassNameAffectsLetterSpacing?: boolean;\n\t/**\n\t * If set, the decoration will be rendered before the text with this CSS class name.\n\t */\n\tbeforeContentClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered after the text with this CSS class name.\n\t */\n\tafterContentClassName?: string | null;\n\t/**\n\t * If set, text will be injected in the view after the range.\n\t */\n\tafter?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, text will be injected in the view before the range.\n\t */\n\tbefore?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for comment tokens.\n\t * @internal\n\t*/\n\thideInCommentTokens?: boolean | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for string tokens.\n\t * @internal\n\t*/\n\thideInStringTokens?: boolean | null;\n\n\t/**\n\t * Whether the decoration affects the font.\n\t * @internal\n\t */\n\taffectsFont?: boolean | null;\n\n\t/**\n\t * The text direction of the decoration.\n\t */\n\ttextDirection?: TextDirection | null;\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\n\tRTL = 1,\n}\n\n/**\n * Configures text that is injected into the view without changing the underlying document.\n*/\nexport interface InjectedTextOptions {\n\t/**\n\t * Sets the text to inject. Must be a single line.\n\t */\n\treadonly content: string;\n\n\t/**\n\t * @internal\n\t*/\n\treadonly tokens?: TokenArray | null;\n\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t */\n\treadonly inlineClassName?: string | null;\n\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\treadonly inlineClassNameAffectsLetterSpacing?: boolean;\n\n\t/**\n\t * This field allows to attach data to this injected text.\n\t * The data can be read when injected texts at a given position are queried.\n\t */\n\treadonly attachedData?: unknown;\n\n\t/**\n\t * Configures cursor stops around injected text.\n\t * Defaults to {@link InjectedTextCursorStops.Both}.\n\t*/\n\treadonly cursorStops?: InjectedTextCursorStops | null;\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth,\n\tRight,\n\tLeft,\n\tNone\n}\n\n/**\n * New model decorations.\n */\nexport interface IModelDeltaDecoration {\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * A decoration in the model.\n */\nexport interface IModelDecoration {\n\t/**\n\t * Identifier for a decoration.\n\t */\n\treadonly id: string;\n\t/**\n\t * Identifier for a decoration's owner.\n\t */\n\treadonly ownerId: number;\n\t/**\n\t * Range that this decoration covers.\n\t */\n\treadonly range: Range;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\treadonly options: IModelDecorationOptions;\n}\n\n/**\n * An accessor that can add, change or remove model decorations.\n * @internal\n */\nexport interface IModelDecorationsChangeAccessor {\n\t/**\n\t * Add a new decoration.\n\t * @param range Range that this decoration covers.\n\t * @param options Options associated with this decoration.\n\t * @return An unique identifier associated with this decoration.\n\t */\n\taddDecoration(range: IRange, options: IModelDecorationOptions): string;\n\t/**\n\t * Change the range that an existing decoration covers.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newRange The new range that this decoration covers.\n\t */\n\tchangeDecoration(id: string, newRange: IRange): void;\n\t/**\n\t * Change the options associated with an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newOptions The new options associated with this decoration.\n\t */\n\tchangeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;\n\t/**\n\t * Remove an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t */\n\tremoveDecoration(id: string): void;\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: readonly string[], newDecorations: readonly IModelDeltaDecoration[]): string[];\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport const enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * An identifier for a single edit operation.\n * @internal\n */\nexport interface ISingleEditOperationIdentifier {\n\t/**\n\t * Identifier major\n\t */\n\tmajor: number;\n\t/**\n\t * Identifier minor\n\t */\n\tminor: number;\n}\n\n/**\n * A single edit operation, that has an identifier.\n */\nexport interface IIdentifiedSingleEditOperation extends ISingleEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier?: ISingleEditOperationIdentifier | null;\n\t/**\n\t * This indicates that this operation is inserting automatic whitespace\n\t * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.\n\t * @internal\n\t */\n\tisAutoWhitespaceEdit?: boolean;\n\t/**\n\t * This indicates that this operation is in a set of operations that are tracked and should not be \"simplified\".\n\t * @internal\n\t */\n\t_isTracked?: boolean;\n}\n\nexport interface IValidEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier: ISingleEditOperationIdentifier | null;\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: Range;\n\t/**\n\t * The text to replace with. This can be empty to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * @internal\n\t */\n\ttextChange: TextChange;\n}\n\n/**\n * A callback that can compute the cursor state after applying a series of edit operations.\n */\nexport interface ICursorStateComputer {\n\t/**\n\t * A callback that can compute the resulting cursors state after some edit operations have been executed.\n\t */\n\t(inverseEditOperations: IValidEditOperation[]): Selection[] | null;\n}\n\nexport class TextModelResolvedOptions {\n\t_textModelResolvedOptionsBrand: void = undefined;\n\n\treadonly tabSize: number;\n\treadonly indentSize: number;\n\tprivate readonly _indentSizeIsTabSize: boolean;\n\treadonly insertSpaces: boolean;\n\treadonly defaultEOL: DefaultEndOfLine;\n\treadonly trimAutoWhitespace: boolean;\n\treadonly bracketPairColorizationOptions: BracketPairColorizationOptions;\n\n\tpublic get originalIndentSize(): number | 'tabSize' {\n\t\treturn this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(src: {\n\t\ttabSize: number;\n\t\tindentSize: number | 'tabSize';\n\t\tinsertSpaces: boolean;\n\t\tdefaultEOL: DefaultEndOfLine;\n\t\ttrimAutoWhitespace: boolean;\n\t\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n\t}) {\n\t\tthis.tabSize = Math.max(1, src.tabSize | 0);\n\t\tif (src.indentSize === 'tabSize') {\n\t\t\tthis.indentSize = this.tabSize;\n\t\t\tthis._indentSizeIsTabSize = true;\n\t\t} else {\n\t\t\tthis.indentSize = Math.max(1, src.indentSize | 0);\n\t\t\tthis._indentSizeIsTabSize = false;\n\t\t}\n\t\tthis.insertSpaces = Boolean(src.insertSpaces);\n\t\tthis.defaultEOL = src.defaultEOL | 0;\n\t\tthis.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n\t\tthis.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic equals(other: TextModelResolvedOptions): boolean {\n\t\treturn (\n\t\t\tthis.tabSize === other.tabSize\n\t\t\t&& this._indentSizeIsTabSize === other._indentSizeIsTabSize\n\t\t\t&& this.indentSize === other.indentSize\n\t\t\t&& this.insertSpaces === other.insertSpaces\n\t\t\t&& this.defaultEOL === other.defaultEOL\n\t\t\t&& this.trimAutoWhitespace === other.trimAutoWhitespace\n\t\t\t&& equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions)\n\t\t);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent {\n\t\treturn {\n\t\t\ttabSize: this.tabSize !== newOpts.tabSize,\n\t\t\tindentSize: this.indentSize !== newOpts.indentSize,\n\t\t\tinsertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n\t\t\ttrimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n\t\t};\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextModelCreationOptions {\n\ttabSize: number;\n\tindentSize: number | 'tabSize';\n\tinsertSpaces: boolean;\n\tdetectIndentation: boolean;\n\ttrimAutoWhitespace: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n\tisForSimpleWidget: boolean;\n\tlargeFileOptimizations: boolean;\n\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n}\n\nexport interface BracketPairColorizationOptions {\n\tenabled: boolean;\n\tindependentColorPoolPerBracketType: boolean;\n}\n\nexport interface ITextModelUpdateOptions {\n\ttabSize?: number;\n\tindentSize?: number | 'tabSize';\n\tinsertSpaces?: boolean;\n\ttrimAutoWhitespace?: boolean;\n\tbracketColorizationOptions?: BracketPairColorizationOptions;\n}\n\nexport class FindMatch {\n\t_findMatchBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly matches: string[] | null;\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(range: Range, matches: string[] | null) {\n\t\tthis.range = range;\n\t\tthis.matches = matches;\n\t}\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport const enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3,\n}\n\n/**\n * Text snapshot that works like an iterator.\n * Will try to return chunks of roughly ~64KB size.\n * Will return null when finished.\n */\nexport interface ITextSnapshot {\n\tread(): string | null;\n}\n\n/**\n * @internal\n */\nexport function isITextSnapshot(obj: any): obj is ITextSnapshot {\n\treturn (obj && typeof obj.read === 'function');\n}\n\n/**\n * A model.\n */\nexport interface ITextModel {\n\n\t/**\n\t * Gets the resource associated with this editor model.\n\t */\n\treadonly uri: URI;\n\n\t/**\n\t * A unique identifier associated with this model.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * This model is constructed for a simple widget code editor.\n\t * @internal\n\t */\n\treadonly isForSimpleWidget: boolean;\n\n\t/**\n\t * If true, the text model might contain RTL.\n\t * If false, the text model **contains only** contain LTR.\n\t * @internal\n\t */\n\tmightContainRTL(): boolean;\n\n\t/**\n\t * If true, the text model might contain LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).\n\t * If false, the text model definitely does not contain these.\n\t * @internal\n\t */\n\tmightContainUnusualLineTerminators(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\tremoveUnusualLineTerminators(selections?: Selection[]): void;\n\n\t/**\n\t * If true, the text model might contain non basic ASCII.\n\t * If false, the text model **contains only** basic ASCII.\n\t * @internal\n\t */\n\tmightContainNonBasicASCII(): boolean;\n\n\t/**\n\t * Get the resolved options for this model.\n\t */\n\tgetOptions(): TextModelResolvedOptions;\n\n\t/**\n\t * Get the formatting options for this model.\n\t * @internal\n\t */\n\tgetFormattingOptions(): FormattingOptions;\n\n\t/**\n\t * Get the current version id of the model.\n\t * Anytime a change happens to the model (even undo/redo),\n\t * the version id is incremented.\n\t */\n\tgetVersionId(): number;\n\n\t/**\n\t * Get the alternative version id of the model.\n\t * This alternative version id is not always incremented,\n\t * it will return the same values in the case of undo-redo.\n\t */\n\tgetAlternativeVersionId(): number;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t */\n\tsetValue(newValue: string | ITextSnapshot): void;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text.\n\t */\n\tgetValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text snapshot (it is safe to consume it asynchronously).\n\t */\n\tcreateSnapshot(preserveBOM?: boolean): ITextSnapshot;\n\n\t/**\n\t * Get the length of the text stored in this model.\n\t */\n\tgetValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;\n\n\t/**\n\t * Get the text in a certain range.\n\t * @param range The range describing what text to get.\n\t * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @return The text.\n\t */\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n\n\t/**\n\t * Get the length of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t * @return The text length.\n\t */\n\tgetValueLengthInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Get the character count of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t */\n\tgetCharacterCountInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Splits characters in two buckets. First bucket (A) is of characters that\n\t * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of\n\t * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.\n\t * If count(B) > count(A) return true. Returns false otherwise.\n\t * @internal\n\t */\n\tisDominatedByLongLines(): boolean;\n\n\t/**\n\t * Get the number of lines in the model.\n\t */\n\tgetLineCount(): number;\n\n\t/**\n\t * Get the text for a certain line.\n\t */\n\tgetLineContent(lineNumber: number): string;\n\n\t/**\n\t * Get the text length for a certain line.\n\t */\n\tgetLineLength(lineNumber: number): number;\n\n\t/**\n\t * Get the text for all lines.\n\t */\n\tgetLinesContent(): string[];\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t * @return EOL char sequence (e.g.: '\\n' or '\\r\\n').\n\t */\n\tgetEOL(): string;\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t */\n\tgetEndOfLineSequence(): EndOfLineSequence;\n\n\t/**\n\t * Get the minimum legal column for line at `lineNumber`\n\t */\n\tgetLineMinColumn(lineNumber: number): number;\n\n\t/**\n\t * Get the maximum legal column for line at `lineNumber`\n\t */\n\tgetLineMaxColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column before the first non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column after the last non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Create a valid position.\n\t */\n\tvalidatePosition(position: IPosition): Position;\n\n\t/**\n\t * Advances the given position by the given offset (negative offsets are also accepted)\n\t * and returns it as a new valid position.\n\t *\n\t * If the offset and position are such that their combination goes beyond the beginning or\n\t * end of the model, throws an exception.\n\t *\n\t * If the offset is such that the new position would be in the middle of a multi-byte\n\t * line terminator, throws an exception.\n\t */\n\tmodifyPosition(position: IPosition, offset: number): Position;\n\n\t/**\n\t * Create a valid range.\n\t */\n\tvalidateRange(range: IRange): Range;\n\n\t/**\n\t * Verifies the range is valid.\n\t */\n\tisValidRange(range: IRange): boolean;\n\n\t/**\n\t * Converts the position to a zero-based offset.\n\t *\n\t * The position will be [adjusted](#TextDocument.validatePosition).\n\t *\n\t * @param position A position.\n\t * @return A valid zero-based offset.\n\t */\n\tgetOffsetAt(position: IPosition): number;\n\n\t/**\n\t * Converts a zero-based offset to a position.\n\t *\n\t * @param offset A zero-based offset.\n\t * @return A valid [position](#Position).\n\t */\n\tgetPositionAt(offset: number): Position;\n\n\t/**\n\t * Get a range covering the entire model.\n\t */\n\tgetFullModelRange(): Range;\n\n\t/**\n\t * Returns if the model was disposed or not.\n\t */\n\tisDisposed(): boolean;\n\n\t/**\n\t * This model is so large that it would not be a good idea to sync it over\n\t * to web workers or other places.\n\t * @internal\n\t */\n\tisTooLargeForSyncing(): boolean;\n\n\t/**\n\t * The file is so large, that even tokenization is disabled.\n\t * @internal\n\t */\n\tisTooLargeForTokenization(): boolean;\n\n\t/**\n\t * The file is so large, that operations on it might be too large for heap\n\t * and can lead to OOM crashes so they should be disabled.\n\t * @internal\n\t */\n\tisTooLargeForHeapOperation(): boolean;\n\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if not matches have been found.\n\t */\n\tfindMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchScope Limit the searching to only search inside these ranges.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if no matches have been found.\n\t */\n\tfindMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model for the next match. Loops to the beginning of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the next match is. It is null if no next match has been found.\n\t */\n\tfindNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\t/**\n\t * Search the model for the previous match. Loops to the end of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the previous match is. It is null if no previous match has been found.\n\t */\n\tfindPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\n\n\t/**\n\t * Get the language associated with this model.\n\t */\n\tgetLanguageId(): string;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageId The new language.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageId: string, source?: string): void;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageSelection The new language selection.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageSelection: ILanguageSelection, source?: string): void;\n\n\t/**\n\t * Returns the real (inner-most) language mode at a given position.\n\t * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\t/**\n\t * Get the word under or besides `position`.\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Might be null.\n\t */\n\tgetWordAtPosition(position: IPosition): IWordAtPosition | null;\n\n\t/**\n\t * Get the word under or besides `position` trimmed to `position`.column\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Will never be null.\n\t */\n\tgetWordUntilPosition(position: IPosition): IWordAtPosition;\n\n\t/**\n\t * Change the decorations. The callback will be called with a change accessor\n\t * that becomes invalid as soon as the callback finishes executing.\n\t * This allows for all events to be queued up until the change\n\t * is completed. Returns whatever the callback returns.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @internal\n\t */\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;\n\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];\n\n\t/**\n\t * Remove all decorations that have been added with this specific ownerId.\n\t * @param ownerId The owner id to search for.\n\t * @internal\n\t */\n\tremoveAllDecorationsWithOwnerId(ownerId: number): void;\n\n\t/**\n\t * Get the options associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration options or null if the decoration was not found.\n\t */\n\tgetDecorationOptions(id: string): IModelDecorationOptions | null;\n\n\t/**\n\t * Get the range associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration range or null if the decoration was not found.\n\t */\n\tgetDecorationRange(id: string): Range | null;\n\n\t/**\n\t * Gets all the decorations for the line `lineNumber` as an array.\n\t * @param lineNumber The line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the font decorations for the line `lineNumber` as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @internal\n\t */\n\tgetFontDecorationsInRange(range: IRange, ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.\n\t * So for now it returns all the decorations on the same line as `range`.\n\t * @param range The range to search in\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @param onlyMinimapDecorations If set, it will return only decorations that render in the minimap.\n\t * @param onlyMarginDecorations If set, it will return only decorations that render in the glyph margin.\n\t * @return An array with the decorations\n\t */\n\tgetDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean, onlyMinimapDecorations?: boolean, onlyMarginDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all decorations that render in the glyph margin as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetAllMarginDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that should be rendered in the overview ruler as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain injected text.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetInjectedTextDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain custom line heights.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetCustomLineHeightsDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * @internal\n\t */\n\t_getTrackedRange(id: string): Range | null;\n\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: TrackedRangeStickiness): null;\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: TrackedRangeStickiness): string;\n\n\t/**\n\t * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).\n\t */\n\tnormalizeIndentation(str: string): string;\n\n\t/**\n\t * Change the options of this model.\n\t */\n\tupdateOptions(newOpts: ITextModelUpdateOptions): void;\n\n\t/**\n\t * Detect the indentation options for this model from its content.\n\t */\n\tdetectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;\n\n\t/**\n\t * Close the current undo-redo element.\n\t * This offers a way to create an undo/redo stop point.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Open the current undo-redo element.\n\t * This offers a way to remove the current undo/redo stop point.\n\t */\n\tpopStackElement(): void;\n\n\t/**\n\t * Push edit operations, basically editing the model. This is the preferred way\n\t * of editing the model. The edit operations will land on the undo stack.\n\t * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when `undo` or `redo` are invoked.\n\t * @param editOperations The edit operations.\n\t * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.\n\t * @return The cursor state returned by the `cursorStateComputer`.\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;\n\t/**\n\t * @internal\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null;\n\n\t/**\n\t * Change the end of line sequence. This is the preferred way of\n\t * changing the eol sequence. This will land on the undo stack.\n\t */\n\tpushEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * Edit the model without adding the edits to the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.\n\t * @param operations The edit operations.\n\t * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.\n\t */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[]): void;\n\t/** @internal */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], reason: TextModelEditSource): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];\n\n\t/**\n\t * Change the end of line sequence without recording in the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.\n\t */\n\tsetEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyUndo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyRedo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * Undo edit operations until the previous undo/redo point.\n\t * The inverse edit operations will be pushed on the redo stack.\n\t */\n\tundo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the undo stack?\n\t */\n\tcanUndo(): boolean;\n\n\t/**\n\t * Redo edit operations until the next undo/redo point.\n\t * The inverse edit operations will be pushed on the undo stack.\n\t */\n\tredo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the redo stack?\n\t */\n\tcanRedo(): boolean;\n\n\t/**\n\t * @deprecated Please use `onDidChangeContent` instead.\n\t * An event emitted when the contents of the model have changed.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeContentOrInjectedText: Event<InternalModelContentChangeEvent | ModelInjectedTextChangedEvent>;\n\t/**\n\t * An event emitted when the contents of the model have changed.\n\t * @event\n\t */\n\tonDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when decorations of the model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when line heights from decorations changes.\n\t * This event is emitted only when adding, removing or changing a decoration\n\t * and not when doing edits in the model (i.e. when decoration ranges change)\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\t/**\n\t* An event emitted when the font from decorations changes.\n\t* This event is emitted only when adding, removing or changing a decoration\n\t* and not when doing edits in the model (i.e. when decoration ranges change)\n\t* @internal\n\t* @event\n\t*/\n\treadonly onDidChangeFont: Event<ModelFontChangedEvent>;\n\t/**\n\t * An event emitted when the model options have changed.\n\t * @event\n\t */\n\treadonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the language associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the tokens associated with the model have changed.\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the model has been attached to the first editor or detached from the last editor.\n\t * @event\n\t */\n\treadonly onDidChangeAttached: Event<void>;\n\t/**\n\t * An event emitted right before disposing the model.\n\t * @event\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * Destroy this model.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeAttached(): IAttachedView;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeDetached(view: IAttachedView): void;\n\n\t/**\n\t * Returns if this model is attached to an editor or not.\n\t */\n\tisAttachedToEditor(): boolean;\n\n\t/**\n\t * Returns the count of editors this model is attached to.\n\t * @internal\n\t */\n\tgetAttachedEditorCount(): number;\n\n\t/**\n\t * Among all positions that are projected to the same position in the underlying text model as\n\t * the given position, select a unique position as indicated by the affinity.\n\t *\n\t * PositionAffinity.Left:\n\t * The normalized position must be equal or left to the requested position.\n\t *\n\t * PositionAffinity.Right:\n\t * The normalized position must be equal or right to the requested position.\n\t *\n\t * @internal\n\t */\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns an object that can be used to query brackets.\n\t * @internal\n\t*/\n\treadonly bracketPairs: IBracketPairsTextModelPart;\n\n\t/**\n\t * Returns an object that can be used to query indent guides.\n\t * @internal\n\t*/\n\treadonly guides: IGuidesTextModelPart;\n\n\t/**\n\t * @internal\n\t */\n\treadonly tokenization: ITokenizationTextModelPart;\n}\n\n/**\n * @internal\n */\nexport interface IAttachedView {\n\t/**\n\t * @param stabilized Indicates if the visible lines are probably going to change soon or can be considered stable.\n\t * Is true on reveal range and false on scroll.\n\t * Tokenizers should tokenize synchronously if stabilized is true.\n\t */\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void;\n}\n\nexport const enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4,\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferBuilder {\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferFactory {\n\tcreate(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable };\n}\n\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {\n\tconstructor(\n\t\tpublic readonly identifier: ISingleEditOperationIdentifier | null,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string | null,\n\t\tpublic readonly forceMoveMarkers: boolean,\n\t\tpublic readonly isAutoWhitespaceEdit: boolean,\n\t\tpublic readonly _isTracked: boolean,\n\t) { }\n}\n\n/**\n * @internal\n *\n * `lineNumber` is 1 based.\n */\nexport interface IReadonlyTextBuffer {\n\tmightContainRTL(): boolean;\n\tmightContainUnusualLineTerminators(): boolean;\n\tresetMightContainUnusualLineTerminators(): void;\n\tmightContainNonBasicASCII(): boolean;\n\tgetBOM(): string;\n\tgetEOL(): string;\n\n\tgetOffsetAt(lineNumber: number, column: number): number;\n\tgetPositionAt(offset: number): Position;\n\tgetRangeAt(offset: number, length: number): Range;\n\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tcreateSnapshot(preserveBOM: boolean): ITextSnapshot;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetLength(): number;\n\tgetLineCount(): number;\n\tgetLinesContent(): string[];\n\tgetLineContent(lineNumber: number): string;\n\tgetLineCharCode(lineNumber: number, index: number): number;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];\n\n\t/**\n\t * Get nearest chunk of text after `offset` in the text buffer.\n\t */\n\tgetNearestChunk(offset: number): string;\n}\n\n/**\n * @internal\n */\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextBuffer extends IReadonlyTextBuffer, IDisposable {\n\tsetEOL(newEOL: '\\r\\n' | '\\n'): void;\n\tapplyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;\n}\n\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n\n\tconstructor(\n\t\tpublic readonly reverseEdits: IValidEditOperation[] | null,\n\t\tpublic readonly changes: IInternalModelContentChange[],\n\t\tpublic readonly trimAutoWhitespaceLineNumbers: number[] | null\n\t) { }\n\n}\n\n/**\n * @internal\n */\nexport interface IInternalModelContentChange extends IModelContentChange {\n\trange: Range;\n\tforceMoveMarkers: boolean;\n}\n\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model: ITextModel): boolean {\n\treturn (\n\t\t!model.isTooLargeForSyncing() && !model.isForSimpleWidget\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../base/common/event.js';\nimport { IMarkdownString } from '../../base/common/htmlContent.js';\nimport { IDisposable } from '../../base/common/lifecycle.js';\nimport { equals } from '../../base/common/objects.js';\nimport { ThemeColor } from '../../base/common/themables.js';\nimport { URI } from '../../base/common/uri.js';\nimport { ISingleEditOperation } from './core/editOperation.js';\nimport { IPosition, Position } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { TextChange } from './core/textChange.js';\nimport { WordCharacterClassifier } from './core/wordCharacterClassifier.js';\nimport { IWordAtPosition } from './core/wordHelper.js';\nimport { FormattingOptions } from './languages.js';\nimport { ILanguageSelection } from './languages/language.js';\nimport { IBracketPairsTextModelPart } from './textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelFontChangedEvent, ModelInjectedTextChangedEvent, ModelLineHeightChangedEvent } from './textModelEvents.js';\nimport { IModelContentChange } from './model/mirrorTextModel.js';\nimport { IGuidesTextModelPart } from './textModelGuides.js';\nimport { ITokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { UndoRedoGroup } from '../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from './tokens/lineTokens.js';\nimport { TextModelEditSource } from './textModelEditSource.js';\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3,\n}\n\nexport interface IGlyphMarginLanesModel {\n\t/**\n\t * The number of lanes that should be rendered in the editor.\n\t */\n\treadonly requiredLanes: number;\n\n\t/**\n\t * Gets the lanes that should be rendered starting at a given line number.\n\t */\n\tgetLanesAtLine(lineNumber: number): GlyphMarginLane[];\n\n\t/**\n\t * Resets the model and ensures it can contain at least `maxLine` lines.\n\t */\n\treset(maxLine: number): void;\n\n\t/**\n\t * Registers that a lane should be visible at the Range in the model.\n\t * @param persist - if true, notes that the lane should always be visible,\n\t * even on lines where there's no specific request for that lane.\n\t */\n\tpush(lane: GlyphMarginLane, range: Range, persist?: boolean): void;\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport const enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport const enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\nexport interface IDecorationOptions {\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tcolor: string | ThemeColor | undefined;\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tdarkColor?: string | ThemeColor;\n}\n\nexport interface IModelDecorationGlyphMarginOptions {\n\t/**\n\t * The position in the glyph margin.\n\t */\n\tposition: GlyphMarginLane;\n\n\t/**\n\t * Whether the glyph margin lane in {@link position} should be rendered even\n\t * outside of this decoration's range.\n\t */\n\tpersistLane?: boolean;\n}\n\n/**\n * Options for rendering a model decoration in the overview ruler.\n */\nexport interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {\n\t/**\n\t * The position in the overview ruler.\n\t */\n\tposition: OverviewRulerLane;\n}\n\n/**\n * Options for rendering a model decoration in the minimap.\n */\nexport interface IModelDecorationMinimapOptions extends IDecorationOptions {\n\t/**\n\t * The position in the minimap.\n\t */\n\tposition: MinimapPosition;\n\t/**\n\t * If the decoration is for a section header, which header style.\n\t */\n\tsectionHeaderStyle?: MinimapSectionHeaderStyle | null;\n\t/**\n\t * If the decoration is for a section header, the header text.\n\t */\n\tsectionHeaderText?: string | null;\n}\n\n/**\n * Options for a model decoration.\n */\nexport interface IModelDecorationOptions {\n\t/**\n\t * A debug description that can be used for inspecting model decorations.\n\t * @internal\n\t */\n\tdescription: string;\n\t/**\n\t * Customize the growing behavior of the decoration when typing at the edges of the decoration.\n\t * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t */\n\tstickiness?: TrackedRangeStickiness;\n\t/**\n\t * CSS class name describing the decoration.\n\t */\n\tclassName?: string | null;\n\t/**\n\t * Indicates whether the decoration should span across the entire line when it continues onto the next line.\n\t */\n\tshouldFillLineOnLineBreak?: boolean | null;\n\tblockClassName?: string | null;\n\t/**\n\t * Indicates if this block should be rendered after the last line.\n\t * In this case, the range must be empty and set to the last line.\n\t */\n\tblockIsAfterEnd?: boolean | null;\n\tblockDoesNotCollapse?: boolean | null;\n\tblockPadding?: [top: number, right: number, bottom: number, left: number] | null;\n\n\t/**\n\t * Message to be rendered when hovering over the glyph margin decoration.\n\t */\n\tglyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the decoration message.\n\t */\n\thoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the line number message.\n\t */\n\tlineNumberHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Should the decoration expand to encompass a whole line.\n\t */\n\tisWholeLine?: boolean;\n\t/**\n\t * Always render the decoration (even when the range it encompasses is collapsed).\n\t */\n\tshowIfCollapsed?: boolean;\n\t/**\n\t * Collapse the decoration if its entire range is being replaced via an edit.\n\t * @internal\n\t */\n\tcollapseOnReplaceEdit?: boolean;\n\t/**\n\t * Specifies the stack order of a decoration.\n\t * A decoration with greater stack order is always in front of a decoration with\n\t * a lower stack order when the decorations are on the same line.\n\t */\n\tzIndex?: number;\n\t/**\n\t * If set, render this decoration in the overview ruler.\n\t */\n\toverviewRuler?: IModelDecorationOverviewRulerOptions | null;\n\t/**\n\t * If set, render this decoration in the minimap.\n\t */\n\tminimap?: IModelDecorationMinimapOptions | null;\n\t/**\n\t * If set, the decoration will be rendered in the glyph margin with this CSS class name.\n\t */\n\tglyphMarginClassName?: string | null;\n\t/**\n\t * If set and the decoration has {@link glyphMarginClassName} set, render this decoration\n\t * with the specified {@link IModelDecorationGlyphMarginOptions} in the glyph margin.\n\t */\n\tglyphMargin?: IModelDecorationGlyphMarginOptions | null;\n\t/**\n\t * If set, the decoration will override the line height of the lines it spans. Maximum value is 300px.\n\t */\n\tlineHeight?: number | null;\n\t/**\n\t * Font family\n\t */\n\tfontFamily?: string | null;\n\t/**\n\t * Font size\n\t */\n\tfontSize?: string | null;\n\t/**\n\t * Font weight\n\t */\n\tfontWeight?: string | null;\n\t/**\n\t * Font style\n\t */\n\tfontStyle?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name.\n\t */\n\tlinesDecorationsClassName?: string | null;\n\t/**\n\t * Controls the tooltip text of the line decoration.\n\t */\n\tlinesDecorationsTooltip?: string | null;\n\t/**\n\t * If set, the decoration will be rendered on the line number.\n\t */\n\tlineNumberClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.\n\t */\n\tfirstLineDecorationClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.\n\t */\n\tmarginClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t * Please use this only for CSS rules that must impact the text. For example, use `className`\n\t * to have a background color decoration.\n\t */\n\tinlineClassName?: string | null;\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\tinlineClassNameAffectsLetterSpacing?: boolean;\n\t/**\n\t * If set, the decoration will be rendered before the text with this CSS class name.\n\t */\n\tbeforeContentClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered after the text with this CSS class name.\n\t */\n\tafterContentClassName?: string | null;\n\t/**\n\t * If set, text will be injected in the view after the range.\n\t */\n\tafter?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, text will be injected in the view before the range.\n\t */\n\tbefore?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for comment tokens.\n\t * @internal\n\t*/\n\thideInCommentTokens?: boolean | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for string tokens.\n\t * @internal\n\t*/\n\thideInStringTokens?: boolean | null;\n\n\t/**\n\t * Whether the decoration affects the font.\n\t * @internal\n\t */\n\taffectsFont?: boolean | null;\n\n\t/**\n\t * The text direction of the decoration.\n\t */\n\ttextDirection?: TextDirection | null;\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\n\tRTL = 1,\n}\n\n/**\n * Configures text that is injected into the view without changing the underlying document.\n*/\nexport interface InjectedTextOptions {\n\t/**\n\t * Sets the text to inject. Must be a single line.\n\t */\n\treadonly content: string;\n\n\t/**\n\t * @internal\n\t*/\n\treadonly tokens?: TokenArray | null;\n\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t */\n\treadonly inlineClassName?: string | null;\n\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\treadonly inlineClassNameAffectsLetterSpacing?: boolean;\n\n\t/**\n\t * This field allows to attach data to this injected text.\n\t * The data can be read when injected texts at a given position are queried.\n\t */\n\treadonly attachedData?: unknown;\n\n\t/**\n\t * Configures cursor stops around injected text.\n\t * Defaults to {@link InjectedTextCursorStops.Both}.\n\t*/\n\treadonly cursorStops?: InjectedTextCursorStops | null;\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth,\n\tRight,\n\tLeft,\n\tNone\n}\n\n/**\n * New model decorations.\n */\nexport interface IModelDeltaDecoration {\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * A decoration in the model.\n */\nexport interface IModelDecoration {\n\t/**\n\t * Identifier for a decoration.\n\t */\n\treadonly id: string;\n\t/**\n\t * Identifier for a decoration's owner.\n\t */\n\treadonly ownerId: number;\n\t/**\n\t * Range that this decoration covers.\n\t */\n\treadonly range: Range;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\treadonly options: IModelDecorationOptions;\n}\n\n/**\n * An accessor that can add, change or remove model decorations.\n * @internal\n */\nexport interface IModelDecorationsChangeAccessor {\n\t/**\n\t * Add a new decoration.\n\t * @param range Range that this decoration covers.\n\t * @param options Options associated with this decoration.\n\t * @return An unique identifier associated with this decoration.\n\t */\n\taddDecoration(range: IRange, options: IModelDecorationOptions): string;\n\t/**\n\t * Change the range that an existing decoration covers.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newRange The new range that this decoration covers.\n\t */\n\tchangeDecoration(id: string, newRange: IRange): void;\n\t/**\n\t * Change the options associated with an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newOptions The new options associated with this decoration.\n\t */\n\tchangeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;\n\t/**\n\t * Remove an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t */\n\tremoveDecoration(id: string): void;\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: readonly string[], newDecorations: readonly IModelDeltaDecoration[]): string[];\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport const enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * An identifier for a single edit operation.\n * @internal\n */\nexport interface ISingleEditOperationIdentifier {\n\t/**\n\t * Identifier major\n\t */\n\tmajor: number;\n\t/**\n\t * Identifier minor\n\t */\n\tminor: number;\n}\n\n/**\n * A single edit operation, that has an identifier.\n */\nexport interface IIdentifiedSingleEditOperation extends ISingleEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier?: ISingleEditOperationIdentifier | null;\n\t/**\n\t * This indicates that this operation is inserting automatic whitespace\n\t * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.\n\t * @internal\n\t */\n\tisAutoWhitespaceEdit?: boolean;\n\t/**\n\t * This indicates that this operation is in a set of operations that are tracked and should not be \"simplified\".\n\t * @internal\n\t */\n\t_isTracked?: boolean;\n}\n\nexport interface IValidEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier: ISingleEditOperationIdentifier | null;\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: Range;\n\t/**\n\t * The text to replace with. This can be empty to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * @internal\n\t */\n\ttextChange: TextChange;\n}\n\n/**\n * A callback that can compute the cursor state after applying a series of edit operations.\n */\nexport interface ICursorStateComputer {\n\t/**\n\t * A callback that can compute the resulting cursors state after some edit operations have been executed.\n\t */\n\t(inverseEditOperations: IValidEditOperation[]): Selection[] | null;\n}\n\nexport class TextModelResolvedOptions {\n\t_textModelResolvedOptionsBrand: void = undefined;\n\n\treadonly tabSize: number;\n\treadonly indentSize: number;\n\tprivate readonly _indentSizeIsTabSize: boolean;\n\treadonly insertSpaces: boolean;\n\treadonly defaultEOL: DefaultEndOfLine;\n\treadonly trimAutoWhitespace: boolean;\n\treadonly bracketPairColorizationOptions: BracketPairColorizationOptions;\n\n\tpublic get originalIndentSize(): number | 'tabSize' {\n\t\treturn this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(src: {\n\t\ttabSize: number;\n\t\tindentSize: number | 'tabSize';\n\t\tinsertSpaces: boolean;\n\t\tdefaultEOL: DefaultEndOfLine;\n\t\ttrimAutoWhitespace: boolean;\n\t\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n\t}) {\n\t\tthis.tabSize = Math.max(1, src.tabSize | 0);\n\t\tif (src.indentSize === 'tabSize') {\n\t\t\tthis.indentSize = this.tabSize;\n\t\t\tthis._indentSizeIsTabSize = true;\n\t\t} else {\n\t\t\tthis.indentSize = Math.max(1, src.indentSize | 0);\n\t\t\tthis._indentSizeIsTabSize = false;\n\t\t}\n\t\tthis.insertSpaces = Boolean(src.insertSpaces);\n\t\tthis.defaultEOL = src.defaultEOL | 0;\n\t\tthis.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n\t\tthis.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic equals(other: TextModelResolvedOptions): boolean {\n\t\treturn (\n\t\t\tthis.tabSize === other.tabSize\n\t\t\t&& this._indentSizeIsTabSize === other._indentSizeIsTabSize\n\t\t\t&& this.indentSize === other.indentSize\n\t\t\t&& this.insertSpaces === other.insertSpaces\n\t\t\t&& this.defaultEOL === other.defaultEOL\n\t\t\t&& this.trimAutoWhitespace === other.trimAutoWhitespace\n\t\t\t&& equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions)\n\t\t);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent {\n\t\treturn {\n\t\t\ttabSize: this.tabSize !== newOpts.tabSize,\n\t\t\tindentSize: this.indentSize !== newOpts.indentSize,\n\t\t\tinsertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n\t\t\ttrimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n\t\t};\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextModelCreationOptions {\n\ttabSize: number;\n\tindentSize: number | 'tabSize';\n\tinsertSpaces: boolean;\n\tdetectIndentation: boolean;\n\ttrimAutoWhitespace: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n\tisForSimpleWidget: boolean;\n\tlargeFileOptimizations: boolean;\n\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n}\n\nexport interface BracketPairColorizationOptions {\n\tenabled: boolean;\n\tindependentColorPoolPerBracketType: boolean;\n}\n\nexport interface ITextModelUpdateOptions {\n\ttabSize?: number;\n\tindentSize?: number | 'tabSize';\n\tinsertSpaces?: boolean;\n\ttrimAutoWhitespace?: boolean;\n\tbracketColorizationOptions?: BracketPairColorizationOptions;\n}\n\nexport class FindMatch {\n\t_findMatchBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly matches: string[] | null;\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(range: Range, matches: string[] | null) {\n\t\tthis.range = range;\n\t\tthis.matches = matches;\n\t}\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport const enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3,\n}\n\n/**\n * Text snapshot that works like an iterator.\n * Will try to return chunks of roughly ~64KB size.\n * Will return null when finished.\n */\nexport interface ITextSnapshot {\n\tread(): string | null;\n}\n\n/**\n * @internal\n */\nexport function isITextSnapshot(obj: any): obj is ITextSnapshot {\n\treturn (obj && typeof obj.read === 'function');\n}\n\n/**\n * A model.\n */\nexport interface ITextModel {\n\n\t/**\n\t * Gets the resource associated with this editor model.\n\t */\n\treadonly uri: URI;\n\n\t/**\n\t * A unique identifier associated with this model.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * This model is constructed for a simple widget code editor.\n\t * @internal\n\t */\n\treadonly isForSimpleWidget: boolean;\n\n\t/**\n\t * If true, the text model might contain RTL.\n\t * If false, the text model **contains only** contain LTR.\n\t * @internal\n\t */\n\tmightContainRTL(): boolean;\n\n\t/**\n\t * If true, the text model might contain LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).\n\t * If false, the text model definitely does not contain these.\n\t * @internal\n\t */\n\tmightContainUnusualLineTerminators(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\tremoveUnusualLineTerminators(selections?: Selection[]): void;\n\n\t/**\n\t * If true, the text model might contain non basic ASCII.\n\t * If false, the text model **contains only** basic ASCII.\n\t * @internal\n\t */\n\tmightContainNonBasicASCII(): boolean;\n\n\t/**\n\t * Get the resolved options for this model.\n\t */\n\tgetOptions(): TextModelResolvedOptions;\n\n\t/**\n\t * Get the formatting options for this model.\n\t * @internal\n\t */\n\tgetFormattingOptions(): FormattingOptions;\n\n\t/**\n\t * Get the current version id of the model.\n\t * Anytime a change happens to the model (even undo/redo),\n\t * the version id is incremented.\n\t */\n\tgetVersionId(): number;\n\n\t/**\n\t * Get the alternative version id of the model.\n\t * This alternative version id is not always incremented,\n\t * it will return the same values in the case of undo-redo.\n\t */\n\tgetAlternativeVersionId(): number;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t */\n\tsetValue(newValue: string | ITextSnapshot): void;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text.\n\t */\n\tgetValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text snapshot (it is safe to consume it asynchronously).\n\t */\n\tcreateSnapshot(preserveBOM?: boolean): ITextSnapshot;\n\n\t/**\n\t * Get the length of the text stored in this model.\n\t */\n\tgetValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;\n\n\t/**\n\t * Get the text in a certain range.\n\t * @param range The range describing what text to get.\n\t * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @return The text.\n\t */\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n\n\t/**\n\t * Get the length of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t * @return The text length.\n\t */\n\tgetValueLengthInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Get the character count of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t */\n\tgetCharacterCountInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Splits characters in two buckets. First bucket (A) is of characters that\n\t * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of\n\t * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.\n\t * If count(B) > count(A) return true. Returns false otherwise.\n\t * @internal\n\t */\n\tisDominatedByLongLines(): boolean;\n\n\t/**\n\t * Get the number of lines in the model.\n\t */\n\tgetLineCount(): number;\n\n\t/**\n\t * Get the text for a certain line.\n\t */\n\tgetLineContent(lineNumber: number): string;\n\n\t/**\n\t * Get the text length for a certain line.\n\t */\n\tgetLineLength(lineNumber: number): number;\n\n\t/**\n\t * Get the text for all lines.\n\t */\n\tgetLinesContent(): string[];\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t * @return EOL char sequence (e.g.: '\\n' or '\\r\\n').\n\t */\n\tgetEOL(): string;\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t */\n\tgetEndOfLineSequence(): EndOfLineSequence;\n\n\t/**\n\t * Get the minimum legal column for line at `lineNumber`\n\t */\n\tgetLineMinColumn(lineNumber: number): number;\n\n\t/**\n\t * Get the maximum legal column for line at `lineNumber`\n\t */\n\tgetLineMaxColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column before the first non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column after the last non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Create a valid position.\n\t */\n\tvalidatePosition(position: IPosition): Position;\n\n\t/**\n\t * Advances the given position by the given offset (negative offsets are also accepted)\n\t * and returns it as a new valid position.\n\t *\n\t * If the offset and position are such that their combination goes beyond the beginning or\n\t * end of the model, throws an exception.\n\t *\n\t * If the offset is such that the new position would be in the middle of a multi-byte\n\t * line terminator, throws an exception.\n\t */\n\tmodifyPosition(position: IPosition, offset: number): Position;\n\n\t/**\n\t * Create a valid range.\n\t */\n\tvalidateRange(range: IRange): Range;\n\n\t/**\n\t * Verifies the range is valid.\n\t */\n\tisValidRange(range: IRange): boolean;\n\n\t/**\n\t * Converts the position to a zero-based offset.\n\t *\n\t * The position will be [adjusted](#TextDocument.validatePosition).\n\t *\n\t * @param position A position.\n\t * @return A valid zero-based offset.\n\t */\n\tgetOffsetAt(position: IPosition): number;\n\n\t/**\n\t * Converts a zero-based offset to a position.\n\t *\n\t * @param offset A zero-based offset.\n\t * @return A valid [position](#Position).\n\t */\n\tgetPositionAt(offset: number): Position;\n\n\t/**\n\t * Get a range covering the entire model.\n\t */\n\tgetFullModelRange(): Range;\n\n\t/**\n\t * Returns if the model was disposed or not.\n\t */\n\tisDisposed(): boolean;\n\n\t/**\n\t * This model is so large that it would not be a good idea to sync it over\n\t * to web workers or other places.\n\t * @internal\n\t */\n\tisTooLargeForSyncing(): boolean;\n\n\t/**\n\t * The file is so large, that even tokenization is disabled.\n\t * @internal\n\t */\n\tisTooLargeForTokenization(): boolean;\n\n\t/**\n\t * The file is so large, that operations on it might be too large for heap\n\t * and can lead to OOM crashes so they should be disabled.\n\t * @internal\n\t */\n\tisTooLargeForHeapOperation(): boolean;\n\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if not matches have been found.\n\t */\n\tfindMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchScope Limit the searching to only search inside these ranges.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if no matches have been found.\n\t */\n\tfindMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model for the next match. Loops to the beginning of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the next match is. It is null if no next match has been found.\n\t */\n\tfindNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\t/**\n\t * Search the model for the previous match. Loops to the end of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the previous match is. It is null if no previous match has been found.\n\t */\n\tfindPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\n\n\t/**\n\t * Get the language associated with this model.\n\t */\n\tgetLanguageId(): string;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageId The new language.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageId: string, source?: string): void;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageSelection The new language selection.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageSelection: ILanguageSelection, source?: string): void;\n\n\t/**\n\t * Returns the real (inner-most) language mode at a given position.\n\t * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\t/**\n\t * Get the word under or besides `position`.\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Might be null.\n\t */\n\tgetWordAtPosition(position: IPosition): IWordAtPosition | null;\n\n\t/**\n\t * Get the word under or besides `position` trimmed to `position`.column\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Will never be null.\n\t */\n\tgetWordUntilPosition(position: IPosition): IWordAtPosition;\n\n\t/**\n\t * Change the decorations. The callback will be called with a change accessor\n\t * that becomes invalid as soon as the callback finishes executing.\n\t * This allows for all events to be queued up until the change\n\t * is completed. Returns whatever the callback returns.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @internal\n\t */\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;\n\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];\n\n\t/**\n\t * Remove all decorations that have been added with this specific ownerId.\n\t * @param ownerId The owner id to search for.\n\t * @internal\n\t */\n\tremoveAllDecorationsWithOwnerId(ownerId: number): void;\n\n\t/**\n\t * Get the options associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration options or null if the decoration was not found.\n\t */\n\tgetDecorationOptions(id: string): IModelDecorationOptions | null;\n\n\t/**\n\t * Get the range associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration range or null if the decoration was not found.\n\t */\n\tgetDecorationRange(id: string): Range | null;\n\n\t/**\n\t * Gets all the decorations for the line `lineNumber` as an array.\n\t * @param lineNumber The line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the font decorations for the line `lineNumber` as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @internal\n\t */\n\tgetFontDecorationsInRange(range: IRange, ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.\n\t * So for now it returns all the decorations on the same line as `range`.\n\t * @param range The range to search in\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @param onlyMinimapDecorations If set, it will return only decorations that render in the minimap.\n\t * @param onlyMarginDecorations If set, it will return only decorations that render in the glyph margin.\n\t * @return An array with the decorations\n\t */\n\tgetDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean, onlyMinimapDecorations?: boolean, onlyMarginDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all decorations that render in the glyph margin as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetAllMarginDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that should be rendered in the overview ruler as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain injected text.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetInjectedTextDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain custom line heights.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetCustomLineHeightsDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * @internal\n\t */\n\t_getTrackedRange(id: string): Range | null;\n\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: TrackedRangeStickiness): null;\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: TrackedRangeStickiness): string;\n\n\t/**\n\t * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).\n\t */\n\tnormalizeIndentation(str: string): string;\n\n\t/**\n\t * Change the options of this model.\n\t */\n\tupdateOptions(newOpts: ITextModelUpdateOptions): void;\n\n\t/**\n\t * Detect the indentation options for this model from its content.\n\t */\n\tdetectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;\n\n\t/**\n\t * Close the current undo-redo element.\n\t * This offers a way to create an undo/redo stop point.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Open the current undo-redo element.\n\t * This offers a way to remove the current undo/redo stop point.\n\t */\n\tpopStackElement(): void;\n\n\t/**\n\t * Push edit operations, basically editing the model. This is the preferred way\n\t * of editing the model. The edit operations will land on the undo stack.\n\t * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when `undo` or `redo` are invoked.\n\t * @param editOperations The edit operations.\n\t * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.\n\t * @return The cursor state returned by the `cursorStateComputer`.\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;\n\t/**\n\t * @internal\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null;\n\n\t/**\n\t * Change the end of line sequence. This is the preferred way of\n\t * changing the eol sequence. This will land on the undo stack.\n\t */\n\tpushEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * Edit the model without adding the edits to the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.\n\t * @param operations The edit operations.\n\t * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.\n\t */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[]): void;\n\t/** @internal */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], reason: TextModelEditSource): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];\n\n\t/**\n\t * Change the end of line sequence without recording in the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.\n\t */\n\tsetEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyUndo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyRedo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * Undo edit operations until the previous undo/redo point.\n\t * The inverse edit operations will be pushed on the redo stack.\n\t */\n\tundo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the undo stack?\n\t */\n\tcanUndo(): boolean;\n\n\t/**\n\t * Redo edit operations until the next undo/redo point.\n\t * The inverse edit operations will be pushed on the undo stack.\n\t */\n\tredo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the redo stack?\n\t */\n\tcanRedo(): boolean;\n\n\t/**\n\t * @deprecated Please use `onDidChangeContent` instead.\n\t * An event emitted when the contents of the model have changed.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeContentOrInjectedText: Event<InternalModelContentChangeEvent | ModelInjectedTextChangedEvent>;\n\t/**\n\t * An event emitted when the contents of the model have changed.\n\t * @event\n\t */\n\tonDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when decorations of the model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when line heights from decorations changes.\n\t * This event is emitted only when adding, removing or changing a decoration\n\t * and not when doing edits in the model (i.e. when decoration ranges change)\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\t/**\n\t* An event emitted when the font from decorations changes.\n\t* This event is emitted only when adding, removing or changing a decoration\n\t* and not when doing edits in the model (i.e. when decoration ranges change)\n\t* @internal\n\t* @event\n\t*/\n\treadonly onDidChangeFont: Event<ModelFontChangedEvent>;\n\t/**\n\t * An event emitted when the model options have changed.\n\t * @event\n\t */\n\treadonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the language associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the tokens associated with the model have changed.\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the model has been attached to the first editor or detached from the last editor.\n\t * @event\n\t */\n\treadonly onDidChangeAttached: Event<void>;\n\t/**\n\t * An event emitted right before disposing the model.\n\t * @event\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * Destroy this model.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeAttached(): IAttachedView;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeDetached(view: IAttachedView): void;\n\n\t/**\n\t * Returns if this model is attached to an editor or not.\n\t */\n\tisAttachedToEditor(): boolean;\n\n\t/**\n\t * Returns the count of editors this model is attached to.\n\t * @internal\n\t */\n\tgetAttachedEditorCount(): number;\n\n\t/**\n\t * Among all positions that are projected to the same position in the underlying text model as\n\t * the given position, select a unique position as indicated by the affinity.\n\t *\n\t * PositionAffinity.Left:\n\t * The normalized position must be equal or left to the requested position.\n\t *\n\t * PositionAffinity.Right:\n\t * The normalized position must be equal or right to the requested position.\n\t *\n\t * @internal\n\t */\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns an object that can be used to query brackets.\n\t * @internal\n\t*/\n\treadonly bracketPairs: IBracketPairsTextModelPart;\n\n\t/**\n\t * Returns an object that can be used to query indent guides.\n\t * @internal\n\t*/\n\treadonly guides: IGuidesTextModelPart;\n\n\t/**\n\t * @internal\n\t */\n\treadonly tokenization: ITokenizationTextModelPart;\n}\n\n/**\n * @internal\n */\nexport interface IAttachedView {\n\t/**\n\t * @param stabilized Indicates if the visible lines are probably going to change soon or can be considered stable.\n\t * Is true on reveal range and false on scroll.\n\t * Tokenizers should tokenize synchronously if stabilized is true.\n\t */\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void;\n}\n\nexport const enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4,\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferBuilder {\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferFactory {\n\tcreate(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable };\n}\n\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {\n\tconstructor(\n\t\tpublic readonly identifier: ISingleEditOperationIdentifier | null,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string | null,\n\t\tpublic readonly forceMoveMarkers: boolean,\n\t\tpublic readonly isAutoWhitespaceEdit: boolean,\n\t\tpublic readonly _isTracked: boolean,\n\t) { }\n}\n\n/**\n * @internal\n *\n * `lineNumber` is 1 based.\n */\nexport interface IReadonlyTextBuffer {\n\tmightContainRTL(): boolean;\n\tmightContainUnusualLineTerminators(): boolean;\n\tresetMightContainUnusualLineTerminators(): void;\n\tmightContainNonBasicASCII(): boolean;\n\tgetBOM(): string;\n\tgetEOL(): string;\n\n\tgetOffsetAt(lineNumber: number, column: number): number;\n\tgetPositionAt(offset: number): Position;\n\tgetRangeAt(offset: number, length: number): Range;\n\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tcreateSnapshot(preserveBOM: boolean): ITextSnapshot;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetLength(): number;\n\tgetLineCount(): number;\n\tgetLinesContent(): string[];\n\tgetLineContent(lineNumber: number): string;\n\tgetLineCharCode(lineNumber: number, index: number): number;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];\n\n\t/**\n\t * Get nearest chunk of text after `offset` in the text buffer.\n\t */\n\tgetNearestChunk(offset: number): string;\n}\n\n/**\n * @internal\n */\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextBuffer extends IReadonlyTextBuffer, IDisposable {\n\tsetEOL(newEOL: '\\r\\n' | '\\n'): void;\n\tapplyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;\n}\n\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n\n\tconstructor(\n\t\tpublic readonly reverseEdits: IValidEditOperation[] | null,\n\t\tpublic readonly changes: IInternalModelContentChange[],\n\t\tpublic readonly trimAutoWhitespaceLineNumbers: number[] | null\n\t) { }\n\n}\n\n/**\n * @internal\n */\nexport interface IInternalModelContentChange extends IModelContentChange {\n\trange: Range;\n\tforceMoveMarkers: boolean;\n}\n\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model: ITextModel): boolean {\n\treturn (\n\t\t!model.isTooLargeForSyncing() && !model.isForSimpleWidget\n\t);\n}\n"]}