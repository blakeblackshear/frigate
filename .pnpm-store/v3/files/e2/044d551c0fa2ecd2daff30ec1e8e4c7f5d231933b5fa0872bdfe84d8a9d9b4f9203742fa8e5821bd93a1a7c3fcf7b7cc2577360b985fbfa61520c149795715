{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/changeTracker.ts","vs/base/common/observableInternal/changeTracker.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,kBAAkB,EAAE,MAAM,wBAAwB,CAAC;AAmB5D;;;EAGE;AACF,MAAM,UAAU,aAAa,CAA4D,GAAS;IAGjG,OAAO;QACN,mBAAmB,EAAE,CAAC,sBAAsB,EAAE,EAAE;YAC/C,OAAO;gBACN,OAAO,EAAE,EAAE;aACJ,CAAC;QACV,CAAC;QACD,YAAY,CAAC,GAAG,EAAE,aAAa;YAC9B,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;gBACvB,IAAI,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;oBAC5B,aAAa,CAAC,OAAe,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;gBAClE,CAAC;YACF,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QACD,YAAY,CAAC,MAAM,EAAE,aAAa;YACjC,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;gBACvB,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;oBACvB,MAAM,IAAI,kBAAkB,CAAC,yDAAyD,CAAC,CAAC;gBACzF,CAAC;gBACD,aAAa,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5C,CAAC;QACF,CAAC;KACD,CAAC;AACH,CAAC;AAED;;;EAGE;AACF,MAAM,UAAU,iBAAiB,CAA4D,MAAkB;IAG9G,IAAI,GAAG,GAAqB,SAAS,CAAC;IACtC,OAAO;QACN,mBAAmB,EAAE,CAAC,sBAAsB,EAAE,EAAE;YAC/C,OAAO;gBACN,OAAO,EAAE,EAAE;aACJ,CAAC;QACV,CAAC;QACD,YAAY,CAAC,GAAG,EAAE,aAAa;YAC9B,IAAI,CAAC,GAAG,EAAE,CAAC;gBACV,GAAG,GAAG,MAAM,EAAE,CAAC;YAChB,CAAC;YACD,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;gBACvB,IAAI,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;oBAC5B,aAAa,CAAC,OAAe,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;gBAClE,CAAC;YACF,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QACD,YAAY,CAAC,MAAM,EAAE,aAAa;YACjC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACV,GAAG,GAAG,MAAM,EAAE,CAAC;YAChB,CAAC;YACD,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;gBACvB,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;oBACvB,MAAM,IAAI,kBAAkB,CAAC,yDAAyD,CAAC,CAAC;gBACzF,CAAC;gBACD,aAAa,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5C,CAAC;QACF,CAAC;KACD,CAAC;AACH,CAAC","file":"changeTracker.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from './commonFacade/deps.js';\nimport { IObservableWithChange, IReader } from './base.js';\n\nexport interface IChangeTracker<TChangeSummary> {\n\tcreateChangeSummary(previousChangeSummary: TChangeSummary | undefined): TChangeSummary;\n\thandleChange(ctx: IChangeContext, change: TChangeSummary): boolean;\n\tbeforeUpdate?(reader: IReader, change: TChangeSummary): void;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservableWithChange<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservableWithChange<T, TChange>): this is { change: TChange };\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChanges<TObs extends Record<any, IObservableWithChange<any, any>>>(obs: TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChangesLazy<TObs extends Record<any, IObservableWithChange<any, any>>>(getObs: () => TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\tlet obs: TObs | undefined = undefined;\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from './commonFacade/deps.js';\nimport { IObservableWithChange, IReader } from './base.js';\n\nexport interface IChangeTracker<TChangeSummary> {\n\tcreateChangeSummary(previousChangeSummary: TChangeSummary | undefined): TChangeSummary;\n\thandleChange(ctx: IChangeContext, change: TChangeSummary): boolean;\n\tbeforeUpdate?(reader: IReader, change: TChangeSummary): void;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservableWithChange<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservableWithChange<T, TChange>): this is { change: TChange };\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChanges<TObs extends Record<any, IObservableWithChange<any, any>>>(obs: TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChangesLazy<TObs extends Record<any, IObservableWithChange<any, any>>>(getObs: () => TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\tlet obs: TObs | undefined = undefined;\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n"]}