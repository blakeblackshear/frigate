{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export type DefaultEventMap = {\n  [eventType: string]: TypedEvent<any, any>\n}\n\nexport interface TypedEvent<\n  DataType = void,\n  ReturnType = any,\n  EventType extends string = string,\n> extends Omit<MessageEvent<DataType>, 'type'> {\n  type: EventType\n}\n\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\nconst kPropagationStopped = Symbol('kPropagationStopped')\nconst kImmediatePropagationStopped = Symbol('kImmediatePropagationStopped')\n\nexport class TypedEvent<\n    DataType = void,\n    ReturnType = any,\n    EventType extends string = string,\n  >\n  extends MessageEvent<DataType>\n  implements TypedEvent<DataType, ReturnType, EventType>\n{\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType: ReturnType;\n\n  [kDefaultPrevented]: boolean;\n  [kPropagationStopped]?: Emitter<any>;\n  [kImmediatePropagationStopped]?: boolean\n\n  constructor(\n    ...args: [DataType] extends [void]\n      ? [type: EventType]\n      : [type: EventType, init: { data: DataType }]\n  ) {\n    super(args[0], args[1])\n    this[kDefaultPrevented] = false\n  }\n\n  get defaultPrevented(): boolean {\n    return this[kDefaultPrevented]\n  }\n\n  public preventDefault(): void {\n    super.preventDefault()\n    this[kDefaultPrevented] = true\n  }\n\n  public stopImmediatePropagation(): void {\n    /**\n     * @note Despite `.stopPropagation()` and `.stopImmediatePropagation()` being defined\n     * in Node.js, they do nothing. It is safe to re-define them.\n     */\n    super.stopImmediatePropagation()\n    this[kImmediatePropagationStopped] = true\n  }\n}\n\n/**\n * Brands a TypedEvent or its subclass while preserving its (narrower) type.\n */\ntype Brand<Event extends TypedEvent, EventType extends string> = Event & {\n  type: EventType\n}\n\ntype InferEventMap<Target extends Emitter<any>> = Target extends Emitter<\n  infer EventMap\n>\n  ? EventMap\n  : never\n\ntype InternalListenersMap<\n  Target extends Emitter<any>,\n  EventMap extends DefaultEventMap = InferEventMap<Target>,\n  EventType extends string = keyof EventMap & string,\n> = Record<\n  keyof EventMap,\n  Array<Emitter.ListenerType<Target, EventType, EventMap>>\n>\n\nexport type TypedListenerOptions = {\n  once?: boolean\n  signal?: AbortSignal\n}\n\nconst kListenerOptions = Symbol('kListenerOptions')\n\nexport namespace Emitter {\n  /**\n   * Returns an appropriate `Event` type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ greeting: TypedEvent<string> }>()\n   * type GreetingEvent = Emitter.InferEventType<typeof emitter, 'greeting'>\n   * // TypedEvent<string>\n   */\n  export type EventType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = Brand<EventMap[EventType], EventType>\n\n  export type EventDataType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<infer DataType> ? DataType : never\n\n  /**\n   * Returns the listener type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type Listener = Emitter.ListenerType<typeof emitter, 'getTotalPrice'>\n   * // (event: TypedEvent<Cart>) => number\n   */\n  export type ListenerType<\n    Target extends Emitter<any>,\n    Type extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = (\n    event: Emitter.EventType<Target, Type, EventMap>,\n  ) => Emitter.ListenerReturnType<Target, Type, EventMap> extends [void]\n    ? void\n    : Emitter.ListenerReturnType<Target, Type, EventMap>\n\n  /**\n   * Returns the return type of the listener for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type ListenerReturnType = Emitter.InferListenerReturnType<typeof emitter, 'getTotalPrice'>\n   * // number\n   */\n  export type ListenerReturnType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<unknown, infer ReturnType>\n    ? ReturnType\n    : never\n}\n\nexport class Emitter<EventMap extends DefaultEventMap> {\n  #listeners: InternalListenersMap<typeof this, EventMap>\n\n  constructor() {\n    this.#listeners = {} as InternalListenersMap<typeof this, EventMap>\n  }\n\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public on<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options)\n  }\n\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public once<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.on(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public earlyOn<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options, 'prepend')\n  }\n\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  public earlyOnce<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.earlyOn(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  public emit<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): boolean {\n    if (this.listenerCount(event.type) === 0) {\n      return false\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return false\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n\n    return true\n  }\n\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  public async emitAsPromise<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Promise<\n    Array<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n  > {\n    if (this.listenerCount(event.type) === 0) {\n      return []\n    }\n\n    const pendingListeners: Array<\n      Promise<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n    > = []\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return []\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      pendingListeners.push(\n        // Awaiting individual listeners guarantees their call order.\n        await Promise.resolve(this.#callListener(proxiedEvent.event, listener)),\n      )\n    }\n\n    proxiedEvent.revoke()\n\n    return Promise.allSettled(pendingListeners).then((results) => {\n      return results.map((result) =>\n        result.status === 'fulfilled' ? result.value : result.reason,\n      )\n    })\n  }\n\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  public *emitAsGenerator<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Generator<Emitter.ListenerReturnType<typeof this, EventType, EventMap>> {\n    if (this.listenerCount(event.type) === 0) {\n      return\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      yield this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n  }\n\n  /**\n   * Removes a listener for the given event type.\n   */\n  public removeListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n  ): void {\n    if (this.listenerCount(type) === 0) {\n      return\n    }\n\n    const nextListeners: Array<\n      Emitter.ListenerType<typeof this, EventType, EventMap>\n    > = []\n\n    for (const existingListener of this.#listeners[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener)\n      }\n    }\n\n    this.#listeners[type] = nextListeners\n  }\n\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  public removeAllListeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): void {\n    if (type == null) {\n      this.#listeners = {} as InternalListenersMap<typeof this>\n      return\n    }\n\n    this.#listeners[type] = []\n  }\n\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  public listeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): Array<Emitter.ListenerType<typeof this, EventType, EventMap>> {\n    if (type == null) {\n      return Object.values(this.#listeners).flat()\n    }\n\n    return this.#listeners[type] || []\n  }\n\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  public listenerCount<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): number {\n    return this.listeners(type).length\n  }\n\n  #addListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options: TypedListenerOptions | undefined,\n    insertMode: 'append' | 'prepend' = 'append',\n  ): typeof this {\n    this.#listeners[type] ??= []\n\n    if (insertMode === 'prepend') {\n      this.#listeners[type].unshift(listener)\n    } else {\n      this.#listeners[type].push(listener)\n    }\n\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false,\n      })\n\n      if (options.signal) {\n        options.signal.addEventListener(\n          'abort',\n          () => {\n            this.removeListener(type, listener)\n          },\n          { once: true },\n        )\n      }\n    }\n\n    return this\n  }\n\n  #proxyEvent<Event extends TypedEvent>(\n    event: Event,\n  ): { event: Event; revoke: () => void } {\n    const { stopPropagation } = event\n\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this\n        return Reflect.apply(target, thisArg, argArray)\n      },\n    })\n\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation\n      },\n    }\n  }\n\n  #callListener<EventType extends keyof EventMap & string>(\n    event: Event,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap> & {\n      [kListenerOptions]?: TypedListenerOptions\n    },\n  ) {\n    const returnValue = listener.call(this, event)\n\n    if (listener[kListenerOptions]?.once) {\n      this.removeListener(event.type, listener)\n    }\n\n    return returnValue\n  }\n}\n"],"mappings":"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","names":[]}