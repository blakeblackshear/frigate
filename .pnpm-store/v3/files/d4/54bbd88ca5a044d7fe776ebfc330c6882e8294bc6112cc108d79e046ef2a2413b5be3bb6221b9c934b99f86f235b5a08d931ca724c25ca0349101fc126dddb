{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/languages/supports/indentationLineProcessor.ts","vs/editor/common/languages/supports/indentationLineProcessor.ts"],"names":[],"mappings":"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","file":"indentationLineProcessor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ITextModel } from '../../model.js';\nimport { ILanguageConfigurationService } from '../languageConfigurationRegistry.js';\nimport { createScopedLineTokens, ScopedLineTokens } from '../supports.js';\nimport { IVirtualModel } from '../autoIndent.js';\nimport { IViewLineTokens, LineTokens } from '../../tokens/lineTokens.js';\nimport { IndentRulesSupport } from './indentRules.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { Position } from '../../core/position.js';\n\n/**\n * This class is a wrapper class around {@link IndentRulesSupport}.\n * It processes the lines by removing the language configuration brackets from the regex, string and comment tokens.\n * It then calls into the {@link IndentRulesSupport} to validate the indentation conditions.\n */\nexport class ProcessedIndentRulesSupport {\n\n\tprivate readonly _indentRulesSupport: IndentRulesSupport;\n\tprivate readonly _indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: IVirtualModel,\n\t\tindentRulesSupport: IndentRulesSupport,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis._indentRulesSupport = indentRulesSupport;\n\t\tthis._indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be increased after the given line number\n\t */\n\tpublic shouldIncrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIncrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be decreased after the given line number\n\t */\n\tpublic shouldDecrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldDecrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number\n\t */\n\tpublic shouldIgnore(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIgnore(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should increase on the line after the given line number\n\t */\n\tpublic shouldIndentNextLine(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIndentNextLine(processedLine);\n\t}\n\n}\n\n/**\n * This class fetches the processed text around a range which can be used for indentation evaluation.\n * It returns:\n * - The processed text before the given range and on the same start line\n * - The processed text after the given range and on the same end line\n * - The processed text on the previous line\n */\nexport class IndentationContextProcessor {\n\n\tprivate readonly model: ITextModel;\n\tprivate readonly indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis.model = model;\n\t\tthis.indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range\n\t */\n\tgetProcessedTokenContextAroundRange(range: Range): {\n\t\tbeforeRangeProcessedTokens: IViewLineTokens;\n\t\tafterRangeProcessedTokens: IViewLineTokens;\n\t\tpreviousLineProcessedTokens: IViewLineTokens;\n\t} {\n\t\tconst beforeRangeProcessedTokens = this._getProcessedTokensBeforeRange(range);\n\t\tconst afterRangeProcessedTokens = this._getProcessedTokensAfterRange(range);\n\t\tconst previousLineProcessedTokens = this._getProcessedPreviousLineTokens(range);\n\t\treturn { beforeRangeProcessedTokens, afterRangeProcessedTokens, previousLineProcessedTokens };\n\t}\n\n\tprivate _getProcessedTokensBeforeRange(range: Range): IViewLineTokens {\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tlet slicedTokens: IViewLineTokens;\n\t\tif (isLanguageDifferentFromLineStart(this.model, range.getStartPosition())) {\n\t\t\tconst columnIndexWithinScope = (range.startColumn - 1) - scopedLineTokens.firstCharOffset;\n\t\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset;\n\t\t\tconst lastCharacterOffset = firstCharacterOffset + columnIndexWithinScope;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\t} else {\n\t\t\tconst columnWithinLine = range.startColumn - 1;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(0, columnWithinLine, 0);\n\t\t}\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedTokensAfterRange(range: Range): IViewLineTokens {\n\t\tconst position: Position = range.isEmpty() ? range.getStartPosition() : range.getEndPosition();\n\t\tthis.model.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(position.lineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\t\tconst columnIndexWithinScope = position.column - 1 - scopedLineTokens.firstCharOffset;\n\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset + columnIndexWithinScope;\n\t\tconst lastCharacterOffset = scopedLineTokens.firstCharOffset + scopedLineTokens.getLineLength();\n\t\tconst slicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedPreviousLineTokens(range: Range): IViewLineTokens {\n\t\tconst getScopedLineTokensAtEndColumnOfLine = (lineNumber: number): ScopedLineTokens => {\n\t\t\tthis.model.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst endColumnOfLine = this.model.getLineMaxColumn(lineNumber) - 1;\n\t\t\tconst scopedLineTokensAtEndColumn = createScopedLineTokens(lineTokens, endColumnOfLine);\n\t\t\treturn scopedLineTokensAtEndColumn;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tconst emptyTokens = LineTokens.createEmpty('', scopedLineTokens.languageIdCodec);\n\t\tconst previousLineNumber = range.startLineNumber - 1;\n\t\tconst isFirstLine = previousLineNumber === 0;\n\t\tif (isFirstLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst canScopeExtendOnPreviousLine = scopedLineTokens.firstCharOffset === 0;\n\t\tif (!canScopeExtendOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst scopedLineTokensAtEndColumnOfPreviousLine = getScopedLineTokensAtEndColumnOfLine(previousLineNumber);\n\t\tconst doesLanguageContinueOnPreviousLine = scopedLineTokens.languageId === scopedLineTokensAtEndColumnOfPreviousLine.languageId;\n\t\tif (!doesLanguageContinueOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst previousSlicedLineTokens = scopedLineTokensAtEndColumnOfPreviousLine.toIViewLineTokens();\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(previousSlicedLineTokens);\n\t\treturn processedTokens;\n\t}\n}\n\n/**\n * This class performs the actual processing of the indentation lines.\n * The brackets of the language configuration are removed from the regex, string and comment tokens.\n */\nclass IndentationLineProcessor {\n\n\tconstructor(\n\t\tprivate readonly model: IVirtualModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) { }\n\n\t/**\n\t * Get the processed line for the given line number and potentially adjust the indentation level.\n\t * Remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedLine(lineNumber: number, newIndentation?: string): string {\n\t\tconst replaceIndentation = (line: string, newIndentation: string): string => {\n\t\t\tconst currentIndentation = strings.getLeadingWhitespace(line);\n\t\t\tconst adjustedLine = newIndentation + line.substring(currentIndentation.length);\n\t\t\treturn adjustedLine;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization?.(lineNumber);\n\t\tconst tokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\tlet processedLine = this.getProcessedTokens(tokens).getLineContent();\n\t\tif (newIndentation !== undefined) {\n\t\t\tprocessedLine = replaceIndentation(processedLine, newIndentation);\n\t\t}\n\t\treturn processedLine;\n\t}\n\n\t/**\n\t * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedTokens(tokens: IViewLineTokens): IViewLineTokens {\n\n\t\tconst shouldRemoveBracketsFromTokenType = (tokenType: StandardTokenType): boolean => {\n\t\t\treturn tokenType === StandardTokenType.String\n\t\t\t\t|| tokenType === StandardTokenType.RegEx\n\t\t\t\t|| tokenType === StandardTokenType.Comment;\n\t\t};\n\n\t\tconst languageId = tokens.getLanguageId(0);\n\t\tconst bracketsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\tconst bracketsRegExp = bracketsConfiguration.getBracketRegExp({ global: true });\n\t\tconst textAndMetadata: { text: string; metadata: number }[] = [];\n\t\ttokens.forEach((tokenIndex: number) => {\n\t\t\tconst tokenType = tokens.getStandardTokenType(tokenIndex);\n\t\t\tlet text = tokens.getTokenText(tokenIndex);\n\t\t\tif (shouldRemoveBracketsFromTokenType(tokenType)) {\n\t\t\t\ttext = text.replace(bracketsRegExp, '');\n\t\t\t}\n\t\t\tconst metadata = tokens.getMetadata(tokenIndex);\n\t\t\ttextAndMetadata.push({ text, metadata });\n\t\t});\n\t\tconst processedLineTokens = LineTokens.createFromTextAndMetadata(textAndMetadata, tokens.languageIdCodec);\n\t\treturn processedLineTokens;\n\t}\n}\n\nexport function isLanguageDifferentFromLineStart(model: ITextModel, position: Position): boolean {\n\tmodel.tokenization.forceTokenization(position.lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\tconst doesScopeStartAtOffsetZero = scopedLineTokens.firstCharOffset === 0;\n\tconst isScopedLanguageEqualToFirstLanguageOnLine = lineTokens.getLanguageId(0) === scopedLineTokens.languageId;\n\tconst languageIsDifferentFromLineStart = !doesScopeStartAtOffsetZero && !isScopedLanguageEqualToFirstLanguageOnLine;\n\treturn languageIsDifferentFromLineStart;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ITextModel } from '../../model.js';\nimport { ILanguageConfigurationService } from '../languageConfigurationRegistry.js';\nimport { createScopedLineTokens, ScopedLineTokens } from '../supports.js';\nimport { IVirtualModel } from '../autoIndent.js';\nimport { IViewLineTokens, LineTokens } from '../../tokens/lineTokens.js';\nimport { IndentRulesSupport } from './indentRules.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { Position } from '../../core/position.js';\n\n/**\n * This class is a wrapper class around {@link IndentRulesSupport}.\n * It processes the lines by removing the language configuration brackets from the regex, string and comment tokens.\n * It then calls into the {@link IndentRulesSupport} to validate the indentation conditions.\n */\nexport class ProcessedIndentRulesSupport {\n\n\tprivate readonly _indentRulesSupport: IndentRulesSupport;\n\tprivate readonly _indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: IVirtualModel,\n\t\tindentRulesSupport: IndentRulesSupport,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis._indentRulesSupport = indentRulesSupport;\n\t\tthis._indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be increased after the given line number\n\t */\n\tpublic shouldIncrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIncrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should be decreased after the given line number\n\t */\n\tpublic shouldDecrease(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldDecrease(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number\n\t */\n\tpublic shouldIgnore(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIgnore(processedLine);\n\t}\n\n\t/**\n\t * Apply the new indentation and return whether the indentation level should increase on the line after the given line number\n\t */\n\tpublic shouldIndentNextLine(lineNumber: number, newIndentation?: string): boolean {\n\t\tconst processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n\t\treturn this._indentRulesSupport.shouldIndentNextLine(processedLine);\n\t}\n\n}\n\n/**\n * This class fetches the processed text around a range which can be used for indentation evaluation.\n * It returns:\n * - The processed text before the given range and on the same start line\n * - The processed text after the given range and on the same end line\n * - The processed text on the previous line\n */\nexport class IndentationContextProcessor {\n\n\tprivate readonly model: ITextModel;\n\tprivate readonly indentationLineProcessor: IndentationLineProcessor;\n\n\tconstructor(\n\t\tmodel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tthis.model = model;\n\t\tthis.indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n\t}\n\n\t/**\n\t * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range\n\t */\n\tgetProcessedTokenContextAroundRange(range: Range): {\n\t\tbeforeRangeProcessedTokens: IViewLineTokens;\n\t\tafterRangeProcessedTokens: IViewLineTokens;\n\t\tpreviousLineProcessedTokens: IViewLineTokens;\n\t} {\n\t\tconst beforeRangeProcessedTokens = this._getProcessedTokensBeforeRange(range);\n\t\tconst afterRangeProcessedTokens = this._getProcessedTokensAfterRange(range);\n\t\tconst previousLineProcessedTokens = this._getProcessedPreviousLineTokens(range);\n\t\treturn { beforeRangeProcessedTokens, afterRangeProcessedTokens, previousLineProcessedTokens };\n\t}\n\n\tprivate _getProcessedTokensBeforeRange(range: Range): IViewLineTokens {\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tlet slicedTokens: IViewLineTokens;\n\t\tif (isLanguageDifferentFromLineStart(this.model, range.getStartPosition())) {\n\t\t\tconst columnIndexWithinScope = (range.startColumn - 1) - scopedLineTokens.firstCharOffset;\n\t\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset;\n\t\t\tconst lastCharacterOffset = firstCharacterOffset + columnIndexWithinScope;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\t} else {\n\t\t\tconst columnWithinLine = range.startColumn - 1;\n\t\t\tslicedTokens = lineTokens.sliceAndInflate(0, columnWithinLine, 0);\n\t\t}\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedTokensAfterRange(range: Range): IViewLineTokens {\n\t\tconst position: Position = range.isEmpty() ? range.getStartPosition() : range.getEndPosition();\n\t\tthis.model.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(position.lineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\t\tconst columnIndexWithinScope = position.column - 1 - scopedLineTokens.firstCharOffset;\n\t\tconst firstCharacterOffset = scopedLineTokens.firstCharOffset + columnIndexWithinScope;\n\t\tconst lastCharacterOffset = scopedLineTokens.firstCharOffset + scopedLineTokens.getLineLength();\n\t\tconst slicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n\t\treturn processedTokens;\n\t}\n\n\tprivate _getProcessedPreviousLineTokens(range: Range): IViewLineTokens {\n\t\tconst getScopedLineTokensAtEndColumnOfLine = (lineNumber: number): ScopedLineTokens => {\n\t\t\tthis.model.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst endColumnOfLine = this.model.getLineMaxColumn(lineNumber) - 1;\n\t\t\tconst scopedLineTokensAtEndColumn = createScopedLineTokens(lineTokens, endColumnOfLine);\n\t\t\treturn scopedLineTokensAtEndColumn;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization(range.startLineNumber);\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tconst emptyTokens = LineTokens.createEmpty('', scopedLineTokens.languageIdCodec);\n\t\tconst previousLineNumber = range.startLineNumber - 1;\n\t\tconst isFirstLine = previousLineNumber === 0;\n\t\tif (isFirstLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst canScopeExtendOnPreviousLine = scopedLineTokens.firstCharOffset === 0;\n\t\tif (!canScopeExtendOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst scopedLineTokensAtEndColumnOfPreviousLine = getScopedLineTokensAtEndColumnOfLine(previousLineNumber);\n\t\tconst doesLanguageContinueOnPreviousLine = scopedLineTokens.languageId === scopedLineTokensAtEndColumnOfPreviousLine.languageId;\n\t\tif (!doesLanguageContinueOnPreviousLine) {\n\t\t\treturn emptyTokens;\n\t\t}\n\t\tconst previousSlicedLineTokens = scopedLineTokensAtEndColumnOfPreviousLine.toIViewLineTokens();\n\t\tconst processedTokens = this.indentationLineProcessor.getProcessedTokens(previousSlicedLineTokens);\n\t\treturn processedTokens;\n\t}\n}\n\n/**\n * This class performs the actual processing of the indentation lines.\n * The brackets of the language configuration are removed from the regex, string and comment tokens.\n */\nclass IndentationLineProcessor {\n\n\tconstructor(\n\t\tprivate readonly model: IVirtualModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) { }\n\n\t/**\n\t * Get the processed line for the given line number and potentially adjust the indentation level.\n\t * Remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedLine(lineNumber: number, newIndentation?: string): string {\n\t\tconst replaceIndentation = (line: string, newIndentation: string): string => {\n\t\t\tconst currentIndentation = strings.getLeadingWhitespace(line);\n\t\t\tconst adjustedLine = newIndentation + line.substring(currentIndentation.length);\n\t\t\treturn adjustedLine;\n\t\t};\n\n\t\tthis.model.tokenization.forceTokenization?.(lineNumber);\n\t\tconst tokens = this.model.tokenization.getLineTokens(lineNumber);\n\t\tlet processedLine = this.getProcessedTokens(tokens).getLineContent();\n\t\tif (newIndentation !== undefined) {\n\t\t\tprocessedLine = replaceIndentation(processedLine, newIndentation);\n\t\t}\n\t\treturn processedLine;\n\t}\n\n\t/**\n\t * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.\n\t */\n\tgetProcessedTokens(tokens: IViewLineTokens): IViewLineTokens {\n\n\t\tconst shouldRemoveBracketsFromTokenType = (tokenType: StandardTokenType): boolean => {\n\t\t\treturn tokenType === StandardTokenType.String\n\t\t\t\t|| tokenType === StandardTokenType.RegEx\n\t\t\t\t|| tokenType === StandardTokenType.Comment;\n\t\t};\n\n\t\tconst languageId = tokens.getLanguageId(0);\n\t\tconst bracketsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\tconst bracketsRegExp = bracketsConfiguration.getBracketRegExp({ global: true });\n\t\tconst textAndMetadata: { text: string; metadata: number }[] = [];\n\t\ttokens.forEach((tokenIndex: number) => {\n\t\t\tconst tokenType = tokens.getStandardTokenType(tokenIndex);\n\t\t\tlet text = tokens.getTokenText(tokenIndex);\n\t\t\tif (shouldRemoveBracketsFromTokenType(tokenType)) {\n\t\t\t\ttext = text.replace(bracketsRegExp, '');\n\t\t\t}\n\t\t\tconst metadata = tokens.getMetadata(tokenIndex);\n\t\t\ttextAndMetadata.push({ text, metadata });\n\t\t});\n\t\tconst processedLineTokens = LineTokens.createFromTextAndMetadata(textAndMetadata, tokens.languageIdCodec);\n\t\treturn processedLineTokens;\n\t}\n}\n\nexport function isLanguageDifferentFromLineStart(model: ITextModel, position: Position): boolean {\n\tmodel.tokenization.forceTokenization(position.lineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n\tconst doesScopeStartAtOffsetZero = scopedLineTokens.firstCharOffset === 0;\n\tconst isScopedLanguageEqualToFirstLanguageOnLine = lineTokens.getLanguageId(0) === scopedLineTokens.languageId;\n\tconst languageIsDifferentFromLineStart = !doesScopeStartAtOffsetZero && !isScopedLanguageEqualToFirstLanguageOnLine;\n\treturn languageIsDifferentFromLineStart;\n}\n"]}