{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/filters.ts","vs/base/common/filters.ts"],"names":[],"mappings":"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","file":"filters.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n\t.split('')\n\t.forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA: number, codeB: number): boolean {\n\treturn (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\n\nconst alternateCharsCache: Map<number, ArrayLike<number> | undefined> = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code: number): ArrayLike<number> | undefined {\n\tif (alternateCharsCache.has(code)) {\n\t\treturn alternateCharsCache.get(code);\n\t}\n\n\t// NOTE: This function is written in such a way that it can be extended in\n\t// the future, but right now the return type takes into account it's only\n\t// supported by a single \"alt codes provider\".\n\t// `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n\tlet result: ArrayLike<number> | undefined;\n\tconst codes = getKoreanAltChars(code);\n\tif (codes) {\n\t\tresult = codes;\n\t}\n\n\talternateCharsCache.set(code, result);\n\treturn result;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\t// TODO: Consider removing this check\n\tif (camelCaseWord.length > 60) {\n\t\tcamelCaseWord = camelCaseWord.substring(0, 60);\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet targetIndex = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (targetIndex < target.length) {\n\t\tresult = _matchesWords(word, target, 0, targetIndex, contiguous);\n\t\tif (result !== null) {\n\t\t\tbreak;\n\t\t}\n\t\ttargetIndex = nextWord(target, targetIndex + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, wordIndex: number, targetIndex: number, contiguous: boolean): IMatch[] | null {\n\tlet targetIndexOffset = 0;\n\n\tif (wordIndex === word.length) {\n\t\treturn [];\n\t} else if (targetIndex === target.length) {\n\t\treturn null;\n\t} else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\ttargetIndexOffset += altChars.length - 1;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet nextWordIndex = targetIndex + targetIndexOffset + 1;\n\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\tif (!contiguous) {\n\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\t\t\tnextWordIndex++;\n\t\t}\n\t}\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\t// If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n\t// We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n\tif (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn result;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tif (isWordSeparator(word.charCodeAt(i)) ||\n\t\t\t(i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number): FuzzyScore {\n\tconst max = Math.min(13, pattern.length);\n\tfor (; patternPos < max; patternPos++) {\n\t\tconst result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn [0, wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\tconst res: IMatch[] = [];\n\tconst wordPos = score[1];\n\tfor (let i = score.length - 1; i > 1; i--) {\n\t\tconst pos = score[i] + wordPos;\n\t\tconst last = res[res.length - 1];\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end = pos + 1;\n\t\t} else {\n\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\ttable.push(row.slice(0));\n\t}\n\treturn table;\n}\n\nfunction initArr(maxLen: number) {\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\treturn row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction printTables(pattern: string, patternStart: number, word: string, wordStart: number): void {\n\tpattern = pattern.substr(patternStart);\n\tword = word.substr(wordStart);\n\tconsole.log(printTable(_table, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.codePointAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\tcase CharCode.LessThan:\n\t\tcase CharCode.GreaterThan:\n\t\tcase CharCode.OpenParen:\n\t\tcase CharCode.CloseParen:\n\t\tcase CharCode.OpenSquareBracket:\n\t\tcase CharCode.CloseSquareBracket:\n\t\tcase CharCode.OpenCurlyBrace:\n\t\tcase CharCode.CloseCurlyBrace:\n\t\t\treturn true;\n\t\tcase undefined:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tif (strings.isEmojiImprecise(code)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number, fillMinWordPosArr = false): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tif (fillMinWordPosArr) {\n\t\t\t\t// Remember the min word position for each pattern position\n\t\t\t\t_minWordMatchPos[patternPos] = wordPos;\n\t\t\t}\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Diag = 1, Left = 2, LeftLeft = 3 }\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\nexport type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: FuzzyScore = ([-100, 0]);\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0] {\n\t\treturn !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n\t}\n}\n\nexport abstract class FuzzyScoreOptions {\n\n\tstatic default = { boostFullMatch: true, firstMatchCanBeWeak: false };\n\n\tconstructor(\n\t\treadonly firstMatchCanBeWeak: boolean,\n\t\treadonly boostFullMatch: boolean,\n\t) { }\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternStart: number, word: string, wordLow: string, wordStart: number, options: FuzzyScoreOptions = FuzzyScoreOptions.default): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n\t\treturn undefined;\n\t}\n\n\t// Find the max matching word position for each pattern position\n\t// NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\t_fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n\tlet row: number = 1;\n\tlet column: number = 1;\n\tlet patternPos = patternStart;\n\tlet wordPos = wordStart;\n\n\tconst hasStrongFirstMatch = [false];\n\n\t// There will be a match, fill in tables\n\tfor (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n\n\t\t// Reduce search space to possible matching word positions and to possible access from next row\n\t\tconst minWordMatchPos = _minWordMatchPos[patternPos];\n\t\tconst maxWordMatchPos = _maxWordMatchPos[patternPos];\n\t\tconst nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n\n\t\tfor (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n\n\t\t\tlet score = Number.MIN_SAFE_INTEGER;\n\t\t\tlet canComeDiag = false;\n\n\t\t\tif (wordPos <= maxWordMatchPos) {\n\t\t\t\tscore = _doScore(\n\t\t\t\t\tpattern, patternLow, patternPos, patternStart,\n\t\t\t\t\tword, wordLow, wordPos, wordLen, wordStart,\n\t\t\t\t\t_diag[row - 1][column - 1] === 0,\n\t\t\t\t\thasStrongFirstMatch\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet diagScore = 0;\n\t\t\tif (score !== Number.MIN_SAFE_INTEGER) {\n\t\t\t\tcanComeDiag = true;\n\t\t\t\tdiagScore = score + _table[row - 1][column - 1];\n\t\t\t}\n\n\t\t\tconst canComeLeft = wordPos > minWordMatchPos;\n\t\t\tconst leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tconst canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n\t\t\tconst leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tif (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftLeftScore;\n\t\t\t\t_arrows[row][column] = Arrow.LeftLeft;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left since that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftScore;\n\t\t\t\t_arrows[row][column] = Arrow.Left;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeDiag) {\n\t\t\t\t_table[row][column] = diagScore;\n\t\t\t\t_arrows[row][column] = Arrow.Diag;\n\t\t\t\t_diag[row][column] = _diag[row - 1][column - 1] + 1;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`not possible`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tprintTables(pattern, patternStart, word, wordStart);\n\t}\n\n\tif (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n\t\treturn undefined;\n\t}\n\n\trow--;\n\tcolumn--;\n\n\tconst result: FuzzyScore = [_table[row][column], wordStart];\n\n\tlet backwardsDiagLength = 0;\n\tlet maxMatchColumn = 0;\n\n\twhile (row >= 1) {\n\t\t// Find the column where we go diagonally up\n\t\tlet diagColumn = column;\n\t\tdo {\n\t\t\tconst arrow = _arrows[row][diagColumn];\n\t\t\tif (arrow === Arrow.LeftLeft) {\n\t\t\t\tdiagColumn = diagColumn - 2;\n\t\t\t} else if (arrow === Arrow.Left) {\n\t\t\t\tdiagColumn = diagColumn - 1;\n\t\t\t} else {\n\t\t\t\t// found the diagonal\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (diagColumn >= 1);\n\n\t\t// Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\t\tif (\n\t\t\tbackwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n\t\t\t&& patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n\t\t\t&& !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n\t\t\t&& backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n\t\t) {\n\t\t\tdiagColumn = column;\n\t\t}\n\n\t\tif (diagColumn === column) {\n\t\t\t// this is a contiguous match\n\t\t\tbackwardsDiagLength++;\n\t\t} else {\n\t\t\tbackwardsDiagLength = 1;\n\t\t}\n\n\t\tif (!maxMatchColumn) {\n\t\t\t// remember the last matched column\n\t\t\tmaxMatchColumn = diagColumn;\n\t\t}\n\n\t\trow--;\n\t\tcolumn = diagColumn - 1;\n\t\tresult.push(column);\n\t}\n\n\tif (wordLen - wordStart === patternLen && options.boostFullMatch) {\n\t\t// the word matches the pattern with all characters!\n\t\t// giving the score a total match boost (to come up ahead other words)\n\t\tresult[0] += 2;\n\t}\n\n\t// Add 1 penalty for each skipped character in the word\n\tconst skippedCharsCount = maxMatchColumn - patternLen;\n\tresult[0] -= skippedCharsCount;\n\n\treturn result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen: number, wordLen: number, patternStart: number, wordStart: number, patternLow: string, wordLow: string) {\n\tlet patternPos = patternLen - 1;\n\tlet wordPos = wordLen - 1;\n\twhile (patternPos >= patternStart && wordPos >= wordStart) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\t_maxWordMatchPos[patternPos] = wordPos;\n\t\t\tpatternPos--;\n\t\t}\n\t\twordPos--;\n\t}\n}\n\nfunction _doScore(\n\tpattern: string, patternLow: string, patternPos: number, patternStart: number,\n\tword: string, wordLow: string, wordPos: number, wordLen: number, wordStart: number,\n\tnewMatchStart: boolean,\n\toutFirstMatchStrong: boolean[],\n): number {\n\tif (patternLow[patternPos] !== wordLow[wordPos]) {\n\t\treturn Number.MIN_SAFE_INTEGER;\n\t}\n\n\tlet score = 1;\n\tlet isGapLocation = false;\n\tif (wordPos === (patternPos - patternStart)) {\n\t\t// common prefix: `foobar <-> foobaz`\n\t\t//                            ^^^^^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\n\t} else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t//                              ^^ ^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t\tisGapLocation = true;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n\t\t// hitting a separator: `. <-> foo.bar`\n\t\t//                                ^\n\t\tscore = 5;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n\t\t// post separator: `foo <-> bar_foo`\n\t\t//                              ^^^\n\t\tscore = 5;\n\t\tisGapLocation = true;\n\t}\n\n\tif (score > 1 && patternPos === patternStart) {\n\t\toutFirstMatchStrong[0] = true;\n\t}\n\n\tif (!isGapLocation) {\n\t\tisGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n\t}\n\n\t//\n\tif (patternPos === patternStart) { // first character in pattern\n\t\tif (wordPos > wordStart) {\n\t\t\t// the first pattern character would match a word character that is not at the word start\n\t\t\t// so introduce a penalty to account for the gap preceding this match\n\t\t\tscore -= isGapLocation ? 3 : 5;\n\t\t}\n\t} else {\n\t\tif (newMatchStart) {\n\t\t\t// this would be the beginning of a new match (i.e. there would be a gap before this location)\n\t\t\tscore += isGapLocation ? 2 : 0;\n\t\t} else {\n\t\t\t// this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n\t\t\tscore += isGapLocation ? 0 : 1;\n\t\t}\n\t}\n\n\tif (wordPos + 1 === wordLen) {\n\t\t// we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n\t\t// so pretend there is a gap after the last character in the word to normalize things\n\t\tscore -= isGapLocation ? 3 : 5;\n\t}\n\n\treturn score;\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n\t.split('')\n\t.forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA: number, codeB: number): boolean {\n\treturn (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\n\nconst alternateCharsCache: Map<number, ArrayLike<number> | undefined> = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code: number): ArrayLike<number> | undefined {\n\tif (alternateCharsCache.has(code)) {\n\t\treturn alternateCharsCache.get(code);\n\t}\n\n\t// NOTE: This function is written in such a way that it can be extended in\n\t// the future, but right now the return type takes into account it's only\n\t// supported by a single \"alt codes provider\".\n\t// `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n\tlet result: ArrayLike<number> | undefined;\n\tconst codes = getKoreanAltChars(code);\n\tif (codes) {\n\t\tresult = codes;\n\t}\n\n\talternateCharsCache.set(code, result);\n\treturn result;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\t// TODO: Consider removing this check\n\tif (camelCaseWord.length > 60) {\n\t\tcamelCaseWord = camelCaseWord.substring(0, 60);\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet targetIndex = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (targetIndex < target.length) {\n\t\tresult = _matchesWords(word, target, 0, targetIndex, contiguous);\n\t\tif (result !== null) {\n\t\t\tbreak;\n\t\t}\n\t\ttargetIndex = nextWord(target, targetIndex + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, wordIndex: number, targetIndex: number, contiguous: boolean): IMatch[] | null {\n\tlet targetIndexOffset = 0;\n\n\tif (wordIndex === word.length) {\n\t\treturn [];\n\t} else if (targetIndex === target.length) {\n\t\treturn null;\n\t} else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\ttargetIndexOffset += altChars.length - 1;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet nextWordIndex = targetIndex + targetIndexOffset + 1;\n\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\tif (!contiguous) {\n\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\tresult = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n\t\t\tnextWordIndex++;\n\t\t}\n\t}\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\t// If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n\t// We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n\tif (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n\t\t// Verify alternate characters before exiting\n\t\tconst altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n\t\tif (!altChars) {\n\t\t\treturn result;\n\t\t}\n\t\tfor (let k = 0; k < altChars.length; k++) {\n\t\t\tif (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tif (isWordSeparator(word.charCodeAt(i)) ||\n\t\t\t(i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number): FuzzyScore {\n\tconst max = Math.min(13, pattern.length);\n\tfor (; patternPos < max; patternPos++) {\n\t\tconst result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn [0, wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\tconst res: IMatch[] = [];\n\tconst wordPos = score[1];\n\tfor (let i = score.length - 1; i > 1; i--) {\n\t\tconst pos = score[i] + wordPos;\n\t\tconst last = res[res.length - 1];\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end = pos + 1;\n\t\t} else {\n\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\ttable.push(row.slice(0));\n\t}\n\treturn table;\n}\n\nfunction initArr(maxLen: number) {\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\treturn row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction printTables(pattern: string, patternStart: number, word: string, wordStart: number): void {\n\tpattern = pattern.substr(patternStart);\n\tword = word.substr(wordStart);\n\tconsole.log(printTable(_table, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.codePointAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\tcase CharCode.LessThan:\n\t\tcase CharCode.GreaterThan:\n\t\tcase CharCode.OpenParen:\n\t\tcase CharCode.CloseParen:\n\t\tcase CharCode.OpenSquareBracket:\n\t\tcase CharCode.CloseSquareBracket:\n\t\tcase CharCode.OpenCurlyBrace:\n\t\tcase CharCode.CloseCurlyBrace:\n\t\t\treturn true;\n\t\tcase undefined:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tif (strings.isEmojiImprecise(code)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number, fillMinWordPosArr = false): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tif (fillMinWordPosArr) {\n\t\t\t\t// Remember the min word position for each pattern position\n\t\t\t\t_minWordMatchPos[patternPos] = wordPos;\n\t\t\t}\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Diag = 1, Left = 2, LeftLeft = 3 }\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\nexport type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: FuzzyScore = ([-100, 0]);\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0] {\n\t\treturn !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n\t}\n}\n\nexport abstract class FuzzyScoreOptions {\n\n\tstatic default = { boostFullMatch: true, firstMatchCanBeWeak: false };\n\n\tconstructor(\n\t\treadonly firstMatchCanBeWeak: boolean,\n\t\treadonly boostFullMatch: boolean,\n\t) { }\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternStart: number, word: string, wordLow: string, wordStart: number, options: FuzzyScoreOptions = FuzzyScoreOptions.default): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n\t\treturn undefined;\n\t}\n\n\t// Find the max matching word position for each pattern position\n\t// NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\t_fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n\tlet row: number = 1;\n\tlet column: number = 1;\n\tlet patternPos = patternStart;\n\tlet wordPos = wordStart;\n\n\tconst hasStrongFirstMatch = [false];\n\n\t// There will be a match, fill in tables\n\tfor (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n\n\t\t// Reduce search space to possible matching word positions and to possible access from next row\n\t\tconst minWordMatchPos = _minWordMatchPos[patternPos];\n\t\tconst maxWordMatchPos = _maxWordMatchPos[patternPos];\n\t\tconst nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n\n\t\tfor (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n\n\t\t\tlet score = Number.MIN_SAFE_INTEGER;\n\t\t\tlet canComeDiag = false;\n\n\t\t\tif (wordPos <= maxWordMatchPos) {\n\t\t\t\tscore = _doScore(\n\t\t\t\t\tpattern, patternLow, patternPos, patternStart,\n\t\t\t\t\tword, wordLow, wordPos, wordLen, wordStart,\n\t\t\t\t\t_diag[row - 1][column - 1] === 0,\n\t\t\t\t\thasStrongFirstMatch\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet diagScore = 0;\n\t\t\tif (score !== Number.MIN_SAFE_INTEGER) {\n\t\t\t\tcanComeDiag = true;\n\t\t\t\tdiagScore = score + _table[row - 1][column - 1];\n\t\t\t}\n\n\t\t\tconst canComeLeft = wordPos > minWordMatchPos;\n\t\t\tconst leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tconst canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n\t\t\tconst leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tif (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftLeftScore;\n\t\t\t\t_arrows[row][column] = Arrow.LeftLeft;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left since that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftScore;\n\t\t\t\t_arrows[row][column] = Arrow.Left;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeDiag) {\n\t\t\t\t_table[row][column] = diagScore;\n\t\t\t\t_arrows[row][column] = Arrow.Diag;\n\t\t\t\t_diag[row][column] = _diag[row - 1][column - 1] + 1;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`not possible`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tprintTables(pattern, patternStart, word, wordStart);\n\t}\n\n\tif (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n\t\treturn undefined;\n\t}\n\n\trow--;\n\tcolumn--;\n\n\tconst result: FuzzyScore = [_table[row][column], wordStart];\n\n\tlet backwardsDiagLength = 0;\n\tlet maxMatchColumn = 0;\n\n\twhile (row >= 1) {\n\t\t// Find the column where we go diagonally up\n\t\tlet diagColumn = column;\n\t\tdo {\n\t\t\tconst arrow = _arrows[row][diagColumn];\n\t\t\tif (arrow === Arrow.LeftLeft) {\n\t\t\t\tdiagColumn = diagColumn - 2;\n\t\t\t} else if (arrow === Arrow.Left) {\n\t\t\t\tdiagColumn = diagColumn - 1;\n\t\t\t} else {\n\t\t\t\t// found the diagonal\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (diagColumn >= 1);\n\n\t\t// Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\t\tif (\n\t\t\tbackwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n\t\t\t&& patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n\t\t\t&& !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n\t\t\t&& backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n\t\t) {\n\t\t\tdiagColumn = column;\n\t\t}\n\n\t\tif (diagColumn === column) {\n\t\t\t// this is a contiguous match\n\t\t\tbackwardsDiagLength++;\n\t\t} else {\n\t\t\tbackwardsDiagLength = 1;\n\t\t}\n\n\t\tif (!maxMatchColumn) {\n\t\t\t// remember the last matched column\n\t\t\tmaxMatchColumn = diagColumn;\n\t\t}\n\n\t\trow--;\n\t\tcolumn = diagColumn - 1;\n\t\tresult.push(column);\n\t}\n\n\tif (wordLen - wordStart === patternLen && options.boostFullMatch) {\n\t\t// the word matches the pattern with all characters!\n\t\t// giving the score a total match boost (to come up ahead other words)\n\t\tresult[0] += 2;\n\t}\n\n\t// Add 1 penalty for each skipped character in the word\n\tconst skippedCharsCount = maxMatchColumn - patternLen;\n\tresult[0] -= skippedCharsCount;\n\n\treturn result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen: number, wordLen: number, patternStart: number, wordStart: number, patternLow: string, wordLow: string) {\n\tlet patternPos = patternLen - 1;\n\tlet wordPos = wordLen - 1;\n\twhile (patternPos >= patternStart && wordPos >= wordStart) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\t_maxWordMatchPos[patternPos] = wordPos;\n\t\t\tpatternPos--;\n\t\t}\n\t\twordPos--;\n\t}\n}\n\nfunction _doScore(\n\tpattern: string, patternLow: string, patternPos: number, patternStart: number,\n\tword: string, wordLow: string, wordPos: number, wordLen: number, wordStart: number,\n\tnewMatchStart: boolean,\n\toutFirstMatchStrong: boolean[],\n): number {\n\tif (patternLow[patternPos] !== wordLow[wordPos]) {\n\t\treturn Number.MIN_SAFE_INTEGER;\n\t}\n\n\tlet score = 1;\n\tlet isGapLocation = false;\n\tif (wordPos === (patternPos - patternStart)) {\n\t\t// common prefix: `foobar <-> foobaz`\n\t\t//                            ^^^^^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\n\t} else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t//                              ^^ ^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t\tisGapLocation = true;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n\t\t// hitting a separator: `. <-> foo.bar`\n\t\t//                                ^\n\t\tscore = 5;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n\t\t// post separator: `foo <-> bar_foo`\n\t\t//                              ^^^\n\t\tscore = 5;\n\t\tisGapLocation = true;\n\t}\n\n\tif (score > 1 && patternPos === patternStart) {\n\t\toutFirstMatchStrong[0] = true;\n\t}\n\n\tif (!isGapLocation) {\n\t\tisGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n\t}\n\n\t//\n\tif (patternPos === patternStart) { // first character in pattern\n\t\tif (wordPos > wordStart) {\n\t\t\t// the first pattern character would match a word character that is not at the word start\n\t\t\t// so introduce a penalty to account for the gap preceding this match\n\t\t\tscore -= isGapLocation ? 3 : 5;\n\t\t}\n\t} else {\n\t\tif (newMatchStart) {\n\t\t\t// this would be the beginning of a new match (i.e. there would be a gap before this location)\n\t\t\tscore += isGapLocation ? 2 : 0;\n\t\t} else {\n\t\t\t// this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n\t\t\tscore += isGapLocation ? 0 : 1;\n\t\t}\n\t}\n\n\tif (wordPos + 1 === wordLen) {\n\t\t// we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n\t\t// so pretend there is a gap after the last character in the word to normalize things\n\t\tscore -= isGapLocation ? 3 : 5;\n\t}\n\n\treturn score;\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n"]}