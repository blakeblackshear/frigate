{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/ranges/lineRange.ts","vs/editor/common/core/ranges/lineRange.ts"],"names":[],"mappings":"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","file":"lineRange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n"]}