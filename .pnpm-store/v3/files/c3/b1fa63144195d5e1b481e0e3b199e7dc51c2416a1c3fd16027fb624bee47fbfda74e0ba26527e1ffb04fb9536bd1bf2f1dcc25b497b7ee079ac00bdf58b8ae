{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/dropOrPasteInto/browser/edit.ts","vs/editor/contrib/dropOrPasteInto/browser/edit.ts"],"names":[],"mappings":"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","file":"edit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { DocumentDropEdit, DocumentPasteEdit, DropYieldTo, WorkspaceEdit } from '../../../common/languages.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\n\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri: URI, ranges: readonly Range[], edit: DocumentPasteEdit | DocumentDropEdit): WorkspaceEdit {\n\t// If the edit insert text is empty, skip applying at each range\n\tif (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n\t\treturn {\n\t\t\tedits: edit.additionalEdit?.edits ?? []\n\t\t};\n\t}\n\n\treturn {\n\t\tedits: [\n\t\t\t...ranges.map(range =>\n\t\t\t\tnew ResourceTextEdit(uri,\n\t\t\t\t\t{ range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true }\n\t\t\t\t)),\n\t\t\t...(edit.additionalEdit?.edits ?? [])\n\t\t]\n\t};\n}\n\nexport function sortEditsByYieldTo<T extends {\n\treadonly kind: HierarchicalKind | undefined;\n\treadonly handledMimeType?: string;\n\treadonly yieldTo?: readonly DropYieldTo[];\n}>(edits: readonly T[]): T[] {\n\tfunction yieldsTo(yTo: DropYieldTo, other: T): boolean {\n\t\tif ('mimeType' in yTo) {\n\t\t\treturn yTo.mimeType === other.handledMimeType;\n\t\t}\n\t\treturn !!other.kind && yTo.kind.contains(other.kind);\n\t}\n\n\t// Build list of nodes each node yields to\n\tconst yieldsToMap = new Map<T, T[]>();\n\tfor (const edit of edits) {\n\t\tfor (const yTo of edit.yieldTo ?? []) {\n\t\t\tfor (const other of edits) {\n\t\t\t\tif (other === edit) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (yieldsTo(yTo, other)) {\n\t\t\t\t\tlet arr = yieldsToMap.get(edit);\n\t\t\t\t\tif (!arr) {\n\t\t\t\t\t\tarr = [];\n\t\t\t\t\t\tyieldsToMap.set(edit, arr);\n\t\t\t\t\t}\n\t\t\t\t\tarr.push(other);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!yieldsToMap.size) {\n\t\treturn Array.from(edits);\n\t}\n\n\t// Topological sort\n\tconst visited = new Set<T>();\n\tconst tempStack: T[] = [];\n\n\tfunction visit(nodes: T[]): T[] {\n\t\tif (!nodes.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = nodes[0];\n\t\tif (tempStack.includes(node)) {\n\t\t\tconsole.warn('Yield to cycle detected', node);\n\t\t\treturn nodes;\n\t\t}\n\n\t\tif (visited.has(node)) {\n\t\t\treturn visit(nodes.slice(1));\n\t\t}\n\n\t\tlet pre: T[] = [];\n\t\tconst yTo = yieldsToMap.get(node);\n\t\tif (yTo) {\n\t\t\ttempStack.push(node);\n\t\t\tpre = visit(yTo);\n\t\t\ttempStack.pop();\n\t\t}\n\n\t\tvisited.add(node);\n\n\t\treturn [...pre, node, ...visit(nodes.slice(1))];\n\t}\n\n\treturn visit(Array.from(edits));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri.js';\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { DocumentDropEdit, DocumentPasteEdit, DropYieldTo, WorkspaceEdit } from '../../../common/languages.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\n\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri: URI, ranges: readonly Range[], edit: DocumentPasteEdit | DocumentDropEdit): WorkspaceEdit {\n\t// If the edit insert text is empty, skip applying at each range\n\tif (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n\t\treturn {\n\t\t\tedits: edit.additionalEdit?.edits ?? []\n\t\t};\n\t}\n\n\treturn {\n\t\tedits: [\n\t\t\t...ranges.map(range =>\n\t\t\t\tnew ResourceTextEdit(uri,\n\t\t\t\t\t{ range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true }\n\t\t\t\t)),\n\t\t\t...(edit.additionalEdit?.edits ?? [])\n\t\t]\n\t};\n}\n\nexport function sortEditsByYieldTo<T extends {\n\treadonly kind: HierarchicalKind | undefined;\n\treadonly handledMimeType?: string;\n\treadonly yieldTo?: readonly DropYieldTo[];\n}>(edits: readonly T[]): T[] {\n\tfunction yieldsTo(yTo: DropYieldTo, other: T): boolean {\n\t\tif ('mimeType' in yTo) {\n\t\t\treturn yTo.mimeType === other.handledMimeType;\n\t\t}\n\t\treturn !!other.kind && yTo.kind.contains(other.kind);\n\t}\n\n\t// Build list of nodes each node yields to\n\tconst yieldsToMap = new Map<T, T[]>();\n\tfor (const edit of edits) {\n\t\tfor (const yTo of edit.yieldTo ?? []) {\n\t\t\tfor (const other of edits) {\n\t\t\t\tif (other === edit) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (yieldsTo(yTo, other)) {\n\t\t\t\t\tlet arr = yieldsToMap.get(edit);\n\t\t\t\t\tif (!arr) {\n\t\t\t\t\t\tarr = [];\n\t\t\t\t\t\tyieldsToMap.set(edit, arr);\n\t\t\t\t\t}\n\t\t\t\t\tarr.push(other);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!yieldsToMap.size) {\n\t\treturn Array.from(edits);\n\t}\n\n\t// Topological sort\n\tconst visited = new Set<T>();\n\tconst tempStack: T[] = [];\n\n\tfunction visit(nodes: T[]): T[] {\n\t\tif (!nodes.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = nodes[0];\n\t\tif (tempStack.includes(node)) {\n\t\t\tconsole.warn('Yield to cycle detected', node);\n\t\t\treturn nodes;\n\t\t}\n\n\t\tif (visited.has(node)) {\n\t\t\treturn visit(nodes.slice(1));\n\t\t}\n\n\t\tlet pre: T[] = [];\n\t\tconst yTo = yieldsToMap.get(node);\n\t\tif (yTo) {\n\t\t\ttempStack.push(node);\n\t\t\tpre = visit(yTo);\n\t\t\ttempStack.pop();\n\t\t}\n\n\t\tvisited.add(node);\n\n\t\treturn [...pre, node, ...visit(nodes.slice(1))];\n\t}\n\n\treturn visit(Array.from(edits));\n}\n"]}