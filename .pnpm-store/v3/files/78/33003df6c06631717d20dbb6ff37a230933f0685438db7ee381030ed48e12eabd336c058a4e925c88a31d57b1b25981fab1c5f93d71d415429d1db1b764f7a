{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/oneCursor.ts","vs/editor/common/cursor/oneCursor.ts"],"names":[],"mappings":"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","file":"oneCursor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorState, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { PositionAffinity, TrackedRangeStickiness } from '../model.js';\n\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n\n\tpublic modelState!: SingleCursorState;\n\tpublic viewState!: SingleCursorState;\n\n\tprivate _selTrackedRange: string | null;\n\tprivate _trackSelection: boolean;\n\n\tconstructor(context: CursorContext) {\n\t\tthis._selTrackedRange = null;\n\t\tthis._trackSelection = true;\n\n\t\tthis._setState(\n\t\t\tcontext,\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0),\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0)\n\t\t);\n\t}\n\n\tpublic dispose(context: CursorContext): void {\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tpublic startTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = true;\n\t\tthis._updateTrackedRange(context);\n\t}\n\n\tpublic stopTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = false;\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tprivate _updateTrackedRange(context: CursorContext): void {\n\t\tif (!this._trackSelection) {\n\t\t\t// don't track the selection\n\t\t\treturn;\n\t\t}\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tprivate _removeTrackedRange(context: CursorContext): void {\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tpublic asCursorState(): CursorState {\n\t\treturn new CursorState(this.modelState, this.viewState);\n\t}\n\n\tpublic readSelectionFromMarkers(context: CursorContext): Selection {\n\t\tconst range = context.model._getTrackedRange(this._selTrackedRange!)!;\n\n\t\tif (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n\t\t\t// Avoid selecting text when recovering from markers\n\t\t\treturn Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n\t\t}\n\n\t\treturn Selection.fromRange(range, this.modelState.selection.getDirection());\n\t}\n\n\tpublic ensureValidState(context: CursorContext): void {\n\t\tthis._setState(context, this.modelState, this.viewState);\n\t}\n\n\tpublic setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tthis._setState(context, modelState, viewState);\n\t}\n\n\tprivate static _validatePositionWithCache(viewModel: ICursorSimpleModel, position: Position, cacheInput: Position, cacheOutput: Position): Position {\n\t\tif (position.equals(cacheInput)) {\n\t\t\treturn cacheOutput;\n\t\t}\n\t\treturn viewModel.normalizePosition(position, PositionAffinity.None);\n\t}\n\n\tprivate static _validateViewState(viewModel: ICursorSimpleModel, viewState: SingleCursorState): SingleCursorState {\n\t\tconst position = viewState.position;\n\t\tconst sStartPosition = viewState.selectionStart.getStartPosition();\n\t\tconst sEndPosition = viewState.selectionStart.getEndPosition();\n\n\t\tconst validPosition = viewModel.normalizePosition(position, PositionAffinity.None);\n\t\tconst validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n\t\tconst validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n\n\t\tif (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n\t\t\t// fast path: the state is valid\n\t\t\treturn viewState;\n\t\t}\n\n\t\treturn new SingleCursorState(\n\t\t\tRange.fromPositions(validSStartPosition, validSEndPosition),\n\t\t\tviewState.selectionStartKind,\n\t\t\tviewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column,\n\t\t\tvalidPosition,\n\t\t\tviewState.leftoverVisibleColumns + position.column - validPosition.column,\n\t\t);\n\t}\n\n\tprivate _setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tif (viewState) {\n\t\t\tviewState = Cursor._validateViewState(context.viewModel, viewState);\n\t\t}\n\n\t\tif (!modelState) {\n\t\t\tif (!viewState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We only have the view state => compute the model state\n\t\t\tconst selectionStart = context.model.validateRange(\n\t\t\t\tcontext.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart)\n\t\t\t);\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tcontext.coordinatesConverter.convertViewPositionToModelPosition(viewState.position)\n\t\t\t);\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new model state\n\t\t\tconst selectionStart = context.model.validateRange(modelState.selectionStart);\n\t\t\tconst selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tmodelState.position\n\t\t\t);\n\t\t\tconst leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\t// We only have the model state => compute the view state\n\t\t\tconst viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n\t\t\tconst viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n\t\t\tconst viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n\t\t\tconst viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new view state\n\t\t\tconst viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n\t\t\tconst viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t}\n\n\t\tthis.modelState = modelState;\n\t\tthis.viewState = viewState;\n\n\t\tthis._updateTrackedRange(context);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorState, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { PositionAffinity, TrackedRangeStickiness } from '../model.js';\n\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n\n\tpublic modelState!: SingleCursorState;\n\tpublic viewState!: SingleCursorState;\n\n\tprivate _selTrackedRange: string | null;\n\tprivate _trackSelection: boolean;\n\n\tconstructor(context: CursorContext) {\n\t\tthis._selTrackedRange = null;\n\t\tthis._trackSelection = true;\n\n\t\tthis._setState(\n\t\t\tcontext,\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0),\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0)\n\t\t);\n\t}\n\n\tpublic dispose(context: CursorContext): void {\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tpublic startTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = true;\n\t\tthis._updateTrackedRange(context);\n\t}\n\n\tpublic stopTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = false;\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tprivate _updateTrackedRange(context: CursorContext): void {\n\t\tif (!this._trackSelection) {\n\t\t\t// don't track the selection\n\t\t\treturn;\n\t\t}\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tprivate _removeTrackedRange(context: CursorContext): void {\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tpublic asCursorState(): CursorState {\n\t\treturn new CursorState(this.modelState, this.viewState);\n\t}\n\n\tpublic readSelectionFromMarkers(context: CursorContext): Selection {\n\t\tconst range = context.model._getTrackedRange(this._selTrackedRange!)!;\n\n\t\tif (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n\t\t\t// Avoid selecting text when recovering from markers\n\t\t\treturn Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n\t\t}\n\n\t\treturn Selection.fromRange(range, this.modelState.selection.getDirection());\n\t}\n\n\tpublic ensureValidState(context: CursorContext): void {\n\t\tthis._setState(context, this.modelState, this.viewState);\n\t}\n\n\tpublic setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tthis._setState(context, modelState, viewState);\n\t}\n\n\tprivate static _validatePositionWithCache(viewModel: ICursorSimpleModel, position: Position, cacheInput: Position, cacheOutput: Position): Position {\n\t\tif (position.equals(cacheInput)) {\n\t\t\treturn cacheOutput;\n\t\t}\n\t\treturn viewModel.normalizePosition(position, PositionAffinity.None);\n\t}\n\n\tprivate static _validateViewState(viewModel: ICursorSimpleModel, viewState: SingleCursorState): SingleCursorState {\n\t\tconst position = viewState.position;\n\t\tconst sStartPosition = viewState.selectionStart.getStartPosition();\n\t\tconst sEndPosition = viewState.selectionStart.getEndPosition();\n\n\t\tconst validPosition = viewModel.normalizePosition(position, PositionAffinity.None);\n\t\tconst validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n\t\tconst validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n\n\t\tif (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n\t\t\t// fast path: the state is valid\n\t\t\treturn viewState;\n\t\t}\n\n\t\treturn new SingleCursorState(\n\t\t\tRange.fromPositions(validSStartPosition, validSEndPosition),\n\t\t\tviewState.selectionStartKind,\n\t\t\tviewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column,\n\t\t\tvalidPosition,\n\t\t\tviewState.leftoverVisibleColumns + position.column - validPosition.column,\n\t\t);\n\t}\n\n\tprivate _setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tif (viewState) {\n\t\t\tviewState = Cursor._validateViewState(context.viewModel, viewState);\n\t\t}\n\n\t\tif (!modelState) {\n\t\t\tif (!viewState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We only have the view state => compute the model state\n\t\t\tconst selectionStart = context.model.validateRange(\n\t\t\t\tcontext.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart)\n\t\t\t);\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tcontext.coordinatesConverter.convertViewPositionToModelPosition(viewState.position)\n\t\t\t);\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new model state\n\t\t\tconst selectionStart = context.model.validateRange(modelState.selectionStart);\n\t\t\tconst selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tmodelState.position\n\t\t\t);\n\t\t\tconst leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\t// We only have the model state => compute the view state\n\t\t\tconst viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n\t\t\tconst viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n\t\t\tconst viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n\t\t\tconst viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new view state\n\t\t\tconst viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n\t\t\tconst viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t}\n\n\t\tthis.modelState = modelState;\n\t\tthis.viewState = viewState;\n\n\t\tthis._updateTrackedRange(context);\n\t}\n}\n"]}