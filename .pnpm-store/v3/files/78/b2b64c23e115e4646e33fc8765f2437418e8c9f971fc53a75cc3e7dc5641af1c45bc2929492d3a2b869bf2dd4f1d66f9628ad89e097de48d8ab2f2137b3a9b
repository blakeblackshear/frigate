{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/equals.ts","vs/base/common/equals.ts"],"names":[],"mappings":"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","file":"equals.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from './arrays.js';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\n\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals<T>(itemEquals: EqualityComparer<T> = strictEquals): EqualityComparer<readonly T[]> {\n\treturn (a, b) => arrays.equals(a, b, itemEquals);\n}\n\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals<T extends { equals(other: T): boolean }>(): EqualityComparer<T> {\n\treturn (a, b) => a.equals(b);\n}\n\n/**\n * Checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(v1: T | undefined | null, v2: T | undefined | null, equals: EqualityComparer<T>): boolean;\n/**\n * Returns an equality comparer that checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(equals: EqualityComparer<T>): EqualityComparer<T | undefined | null>;\nexport function equalsIfDefined<T>(equalsOrV1: EqualityComparer<T> | T, v2?: T | undefined | null, equals?: EqualityComparer<T>): EqualityComparer<T | undefined | null> | boolean {\n\tif (equals !== undefined) {\n\t\tconst v1 = equalsOrV1 as T | undefined;\n\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\treturn v2 === v1;\n\t\t}\n\t\treturn equals(v1, v2);\n\t} else {\n\t\tconst equals = equalsOrV1 as EqualityComparer<T>;\n\t\treturn (v1, v2) => {\n\t\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\t\treturn v2 === v1;\n\t\t\t}\n\t\t\treturn equals(v1, v2);\n\t\t};\n\t}\n}\n\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals<T>(a: T, b: T): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (!structuralEquals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (a && typeof a === 'object' && b && typeof b === 'object') {\n\t\tif (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n\t\t\tconst aObj = a as Record<string, unknown>;\n\t\t\tconst bObj = b as Record<string, unknown>;\n\t\t\tconst keysA = Object.keys(aObj);\n\t\t\tconst keysB = Object.keys(bObj);\n\t\t\tconst keysBSet = new Set(keysB);\n\n\t\t\tif (keysA.length !== keysB.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (const key of keysA) {\n\t\t\t\tif (!keysBSet.has(key)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!structuralEquals(aObj[key], bObj[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nconst objIds = new WeakMap<object, number>();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from './arrays.js';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\n\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals<T>(itemEquals: EqualityComparer<T> = strictEquals): EqualityComparer<readonly T[]> {\n\treturn (a, b) => arrays.equals(a, b, itemEquals);\n}\n\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals<T extends { equals(other: T): boolean }>(): EqualityComparer<T> {\n\treturn (a, b) => a.equals(b);\n}\n\n/**\n * Checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(v1: T | undefined | null, v2: T | undefined | null, equals: EqualityComparer<T>): boolean;\n/**\n * Returns an equality comparer that checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(equals: EqualityComparer<T>): EqualityComparer<T | undefined | null>;\nexport function equalsIfDefined<T>(equalsOrV1: EqualityComparer<T> | T, v2?: T | undefined | null, equals?: EqualityComparer<T>): EqualityComparer<T | undefined | null> | boolean {\n\tif (equals !== undefined) {\n\t\tconst v1 = equalsOrV1 as T | undefined;\n\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\treturn v2 === v1;\n\t\t}\n\t\treturn equals(v1, v2);\n\t} else {\n\t\tconst equals = equalsOrV1 as EqualityComparer<T>;\n\t\treturn (v1, v2) => {\n\t\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\t\treturn v2 === v1;\n\t\t\t}\n\t\t\treturn equals(v1, v2);\n\t\t};\n\t}\n}\n\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals<T>(a: T, b: T): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (!structuralEquals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (a && typeof a === 'object' && b && typeof b === 'object') {\n\t\tif (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n\t\t\tconst aObj = a as Record<string, unknown>;\n\t\t\tconst bObj = b as Record<string, unknown>;\n\t\t\tconst keysA = Object.keys(aObj);\n\t\t\tconst keysB = Object.keys(bObj);\n\t\t\tconst keysBSet = new Set(keysB);\n\n\t\t\tif (keysA.length !== keysB.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (const key of keysA) {\n\t\t\t\tif (!keysBSet.has(key)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!structuralEquals(aObj[key], bObj[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nconst objIds = new WeakMap<object, number>();\n"]}