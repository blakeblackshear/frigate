{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts"],"names":[],"mappings":"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","file":"pieceTreeTextBuffer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from '../../model.js';\nimport { PieceTreeBase, StringBuffer } from './pieceTreeBase.js';\nimport { countEOL, StringEOL } from '../../core/misc/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from '../../model.js';\nimport { PieceTreeBase, StringBuffer } from './pieceTreeBase.js';\nimport { countEOL, StringEOL } from '../../core/misc/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n"]}