{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/raster/glyphRasterizer.ts","vs/editor/browser/gpu/raster/glyphRasterizer.ts"],"names":[],"mappings":"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","file":"glyphRasterizer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FontStyle, TokenMetadata } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { type IBoundingBox, type IGlyphRasterizer, type IRasterizedGlyph } from './raster.js';\n\nlet nextId = 0;\n\nexport class GlyphRasterizer extends Disposable implements IGlyphRasterizer {\n\tpublic readonly id = nextId++;\n\n\t@memoize\n\tpublic get cacheKey(): string {\n\t\treturn `${this.fontFamily}_${this.fontSize}px`;\n\t}\n\n\tprivate _canvas: OffscreenCanvas;\n\tprivate _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _textMetrics: TextMetrics;\n\n\tprivate _workGlyph: IRasterizedGlyph = {\n\t\tsource: null!,\n\t\tboundingBox: {\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t},\n\t\toriginOffset: {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t},\n\t\tfontBoundingBoxAscent: 0,\n\t\tfontBoundingBoxDescent: 0,\n\t};\n\tprivate _workGlyphConfig: { chars: string | undefined; tokenMetadata: number; decorationStyleSetId: number } = { chars: undefined, tokenMetadata: 0, decorationStyleSetId: 0 };\n\n\t// TODO: Support workbench.fontAliasing correctly\n\tprivate _antiAliasing: 'subpixel' | 'greyscale' = isMacintosh ? 'greyscale' : 'subpixel';\n\n\tconstructor(\n\t\treadonly fontSize: number,\n\t\treadonly fontFamily: string,\n\t\treadonly devicePixelRatio: number,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t) {\n\t\tsuper();\n\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * devicePixelRatio);\n\t\tthis._canvas = new OffscreenCanvas(devicePixelFontSize * 3, devicePixelFontSize * 3);\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true,\n\t\t\talpha: this._antiAliasing === 'greyscale',\n\t\t}));\n\t\tthis._ctx.textBaseline = 'top';\n\t\tthis._ctx.fillStyle = '#FFFFFF';\n\t\tthis._ctx.font = `${devicePixelFontSize}px ${this.fontFamily}`;\n\t\tthis._textMetrics = this._ctx.measureText('A');\n\t}\n\n\t/**\n\t * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n\t * therefore is only safe for synchronous access.\n\t */\n\tpublic rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tif (chars === '') {\n\t\t\treturn {\n\t\t\t\tsource: this._canvas,\n\t\t\t\tboundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n\t\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\t\tfontBoundingBoxAscent: 0,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t};\n\t\t}\n\t\t// Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n\t\t// work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n\t\t// page.\n\t\tif (this._workGlyphConfig.chars === chars && this._workGlyphConfig.tokenMetadata === tokenMetadata && this._workGlyphConfig.decorationStyleSetId === decorationStyleSetId) {\n\t\t\treturn this._workGlyph;\n\t\t}\n\t\tthis._workGlyphConfig.chars = chars;\n\t\tthis._workGlyphConfig.tokenMetadata = tokenMetadata;\n\t\tthis._workGlyphConfig.decorationStyleSetId = decorationStyleSetId;\n\t\treturn this._rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap);\n\t}\n\n\tpublic _rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * this.devicePixelRatio);\n\t\tconst canvasDim = devicePixelFontSize * 3;\n\t\tif (this._canvas.width !== canvasDim) {\n\t\t\tthis._canvas.width = canvasDim;\n\t\t\tthis._canvas.height = canvasDim;\n\t\t}\n\n\t\tthis._ctx.save();\n\n\t\t// The sub-pixel x offset is the fractional part of the x pixel coordinate of the cell, this\n\t\t// is used to improve the spacing between rendered characters.\n\t\tconst xSubPixelXOffset = (tokenMetadata & 0b1111) / 10;\n\n\t\tconst bgId = TokenMetadata.getBackground(tokenMetadata);\n\t\tconst bg = colorMap[bgId];\n\n\t\tconst decorationStyleSet = this._decorationStyleCache.getStyleSet(decorationStyleSetId);\n\n\t\t// When SPAA is used, the background color must be present to get the right glyph\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tthis._ctx.fillStyle = bg;\n\t\t\tthis._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t} else {\n\t\t\tthis._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t}\n\n\t\tconst fontSb = new StringBuilder(200);\n\t\tconst fontStyle = TokenMetadata.getFontStyle(tokenMetadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tfontSb.appendString('italic ');\n\t\t}\n\t\tif (decorationStyleSet?.bold !== undefined) {\n\t\t\tif (decorationStyleSet.bold) {\n\t\t\t\tfontSb.appendString('bold ');\n\t\t\t}\n\t\t} else if (fontStyle & FontStyle.Bold) {\n\t\t\tfontSb.appendString('bold ');\n\t\t}\n\t\tfontSb.appendString(`${devicePixelFontSize}px ${this.fontFamily}`);\n\t\tthis._ctx.font = fontSb.build();\n\n\t\t// TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n\t\t//       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n\t\t//       underlines.\n\n\t\tconst originX = devicePixelFontSize;\n\t\tconst originY = devicePixelFontSize;\n\t\tif (decorationStyleSet?.color !== undefined) {\n\t\t\tthis._ctx.fillStyle = `#${decorationStyleSet.color.toString(16).padStart(8, '0')}`;\n\t\t} else {\n\t\t\tthis._ctx.fillStyle = colorMap[TokenMetadata.getForeground(tokenMetadata)];\n\t\t}\n\t\tthis._ctx.textBaseline = 'top';\n\n\t\tif (decorationStyleSet?.opacity !== undefined) {\n\t\t\tthis._ctx.globalAlpha = decorationStyleSet.opacity;\n\t\t}\n\n\t\tthis._ctx.fillText(chars, originX + xSubPixelXOffset, originY);\n\t\tthis._ctx.restore();\n\n\t\tconst imageData = this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tconst bgR = parseInt(bg.substring(1, 3), 16);\n\t\t\tconst bgG = parseInt(bg.substring(3, 5), 16);\n\t\t\tconst bgB = parseInt(bg.substring(5, 7), 16);\n\t\t\tthis._clearColor(imageData, bgR, bgG, bgB);\n\t\t\tthis._ctx.putImageData(imageData, 0, 0);\n\t\t}\n\t\tthis._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n\t\t// const offset = {\n\t\t// \tx: textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxAscent\n\t\t// };\n\t\t// const size = {\n\t\t// \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n\t\t// \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n\t\t// \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n\t\t// };\n\t\t// console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n\t\tthis._workGlyph.source = this._canvas;\n\t\tthis._workGlyph.originOffset.x = this._workGlyph.boundingBox.left - originX;\n\t\tthis._workGlyph.originOffset.y = this._workGlyph.boundingBox.top - originY;\n\t\tthis._workGlyph.fontBoundingBoxAscent = this._textMetrics.fontBoundingBoxAscent;\n\t\tthis._workGlyph.fontBoundingBoxDescent = this._textMetrics.fontBoundingBoxDescent;\n\n\t\t// const result2: IRasterizedGlyph = {\n\t\t// \tsource: this._canvas,\n\t\t// \tboundingBox: {\n\t\t// \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n\t\t// \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n\t\t// \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n\t\t// \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n\t\t// \t},\n\t\t// \toriginOffset: {\n\t\t// \t\tx: Math.floor(boundingBox.left - originX),\n\t\t// \t\ty: Math.floor(boundingBox.top - originY)\n\t\t// \t}\n\t\t// };\n\n\t\t// TODO: Verify result 1 and 2 are the same\n\n\t\t// if (result2.boundingBox.left > result.boundingBox.left) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.top > result.boundingBox.top) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.right < result.boundingBox.right) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n\t\t// \tdebugger;\n\t\t// }\n\n\n\n\t\treturn this._workGlyph;\n\t}\n\n\tprivate _clearColor(imageData: ImageData, r: number, g: number, b: number) {\n\t\tfor (let offset = 0; offset < imageData.data.length; offset += 4) {\n\t\t\t// Check exact match\n\t\t\tif (imageData.data[offset] === r &&\n\t\t\t\timageData.data[offset + 1] === g &&\n\t\t\t\timageData.data[offset + 2] === b) {\n\t\t\t\timageData.data[offset + 3] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: Does this even need to happen when measure text is used?\n\tprivate _findGlyphBoundingBox(imageData: ImageData, outBoundingBox: IBoundingBox) {\n\t\tconst height = this._canvas.height;\n\t\tconst width = this._canvas.width;\n\t\tlet found = false;\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.top = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.left = 0;\n\t\tfound = false;\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.left = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.right = width;\n\t\tfound = false;\n\t\tfor (let x = width - 1; x >= outBoundingBox.left; x--) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.right = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.bottom = outBoundingBox.top;\n\t\tfound = false;\n\t\tfor (let y = height - 1; y >= 0; y--) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.bottom = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getTextMetrics(text: string): TextMetrics {\n\t\treturn this._ctx.measureText(text);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FontStyle, TokenMetadata } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { type IBoundingBox, type IGlyphRasterizer, type IRasterizedGlyph } from './raster.js';\n\nlet nextId = 0;\n\nexport class GlyphRasterizer extends Disposable implements IGlyphRasterizer {\n\tpublic readonly id = nextId++;\n\n\t@memoize\n\tpublic get cacheKey(): string {\n\t\treturn `${this.fontFamily}_${this.fontSize}px`;\n\t}\n\n\tprivate _canvas: OffscreenCanvas;\n\tprivate _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _textMetrics: TextMetrics;\n\n\tprivate _workGlyph: IRasterizedGlyph = {\n\t\tsource: null!,\n\t\tboundingBox: {\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t},\n\t\toriginOffset: {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t},\n\t\tfontBoundingBoxAscent: 0,\n\t\tfontBoundingBoxDescent: 0,\n\t};\n\tprivate _workGlyphConfig: { chars: string | undefined; tokenMetadata: number; decorationStyleSetId: number } = { chars: undefined, tokenMetadata: 0, decorationStyleSetId: 0 };\n\n\t// TODO: Support workbench.fontAliasing correctly\n\tprivate _antiAliasing: 'subpixel' | 'greyscale' = isMacintosh ? 'greyscale' : 'subpixel';\n\n\tconstructor(\n\t\treadonly fontSize: number,\n\t\treadonly fontFamily: string,\n\t\treadonly devicePixelRatio: number,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t) {\n\t\tsuper();\n\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * devicePixelRatio);\n\t\tthis._canvas = new OffscreenCanvas(devicePixelFontSize * 3, devicePixelFontSize * 3);\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true,\n\t\t\talpha: this._antiAliasing === 'greyscale',\n\t\t}));\n\t\tthis._ctx.textBaseline = 'top';\n\t\tthis._ctx.fillStyle = '#FFFFFF';\n\t\tthis._ctx.font = `${devicePixelFontSize}px ${this.fontFamily}`;\n\t\tthis._textMetrics = this._ctx.measureText('A');\n\t}\n\n\t/**\n\t * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n\t * therefore is only safe for synchronous access.\n\t */\n\tpublic rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tif (chars === '') {\n\t\t\treturn {\n\t\t\t\tsource: this._canvas,\n\t\t\t\tboundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n\t\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\t\tfontBoundingBoxAscent: 0,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t};\n\t\t}\n\t\t// Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n\t\t// work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n\t\t// page.\n\t\tif (this._workGlyphConfig.chars === chars && this._workGlyphConfig.tokenMetadata === tokenMetadata && this._workGlyphConfig.decorationStyleSetId === decorationStyleSetId) {\n\t\t\treturn this._workGlyph;\n\t\t}\n\t\tthis._workGlyphConfig.chars = chars;\n\t\tthis._workGlyphConfig.tokenMetadata = tokenMetadata;\n\t\tthis._workGlyphConfig.decorationStyleSetId = decorationStyleSetId;\n\t\treturn this._rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap);\n\t}\n\n\tpublic _rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * this.devicePixelRatio);\n\t\tconst canvasDim = devicePixelFontSize * 3;\n\t\tif (this._canvas.width !== canvasDim) {\n\t\t\tthis._canvas.width = canvasDim;\n\t\t\tthis._canvas.height = canvasDim;\n\t\t}\n\n\t\tthis._ctx.save();\n\n\t\t// The sub-pixel x offset is the fractional part of the x pixel coordinate of the cell, this\n\t\t// is used to improve the spacing between rendered characters.\n\t\tconst xSubPixelXOffset = (tokenMetadata & 0b1111) / 10;\n\n\t\tconst bgId = TokenMetadata.getBackground(tokenMetadata);\n\t\tconst bg = colorMap[bgId];\n\n\t\tconst decorationStyleSet = this._decorationStyleCache.getStyleSet(decorationStyleSetId);\n\n\t\t// When SPAA is used, the background color must be present to get the right glyph\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tthis._ctx.fillStyle = bg;\n\t\t\tthis._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t} else {\n\t\t\tthis._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t}\n\n\t\tconst fontSb = new StringBuilder(200);\n\t\tconst fontStyle = TokenMetadata.getFontStyle(tokenMetadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tfontSb.appendString('italic ');\n\t\t}\n\t\tif (decorationStyleSet?.bold !== undefined) {\n\t\t\tif (decorationStyleSet.bold) {\n\t\t\t\tfontSb.appendString('bold ');\n\t\t\t}\n\t\t} else if (fontStyle & FontStyle.Bold) {\n\t\t\tfontSb.appendString('bold ');\n\t\t}\n\t\tfontSb.appendString(`${devicePixelFontSize}px ${this.fontFamily}`);\n\t\tthis._ctx.font = fontSb.build();\n\n\t\t// TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n\t\t//       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n\t\t//       underlines.\n\n\t\tconst originX = devicePixelFontSize;\n\t\tconst originY = devicePixelFontSize;\n\t\tif (decorationStyleSet?.color !== undefined) {\n\t\t\tthis._ctx.fillStyle = `#${decorationStyleSet.color.toString(16).padStart(8, '0')}`;\n\t\t} else {\n\t\t\tthis._ctx.fillStyle = colorMap[TokenMetadata.getForeground(tokenMetadata)];\n\t\t}\n\t\tthis._ctx.textBaseline = 'top';\n\n\t\tif (decorationStyleSet?.opacity !== undefined) {\n\t\t\tthis._ctx.globalAlpha = decorationStyleSet.opacity;\n\t\t}\n\n\t\tthis._ctx.fillText(chars, originX + xSubPixelXOffset, originY);\n\t\tthis._ctx.restore();\n\n\t\tconst imageData = this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tconst bgR = parseInt(bg.substring(1, 3), 16);\n\t\t\tconst bgG = parseInt(bg.substring(3, 5), 16);\n\t\t\tconst bgB = parseInt(bg.substring(5, 7), 16);\n\t\t\tthis._clearColor(imageData, bgR, bgG, bgB);\n\t\t\tthis._ctx.putImageData(imageData, 0, 0);\n\t\t}\n\t\tthis._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n\t\t// const offset = {\n\t\t// \tx: textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxAscent\n\t\t// };\n\t\t// const size = {\n\t\t// \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n\t\t// \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n\t\t// \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n\t\t// };\n\t\t// console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n\t\tthis._workGlyph.source = this._canvas;\n\t\tthis._workGlyph.originOffset.x = this._workGlyph.boundingBox.left - originX;\n\t\tthis._workGlyph.originOffset.y = this._workGlyph.boundingBox.top - originY;\n\t\tthis._workGlyph.fontBoundingBoxAscent = this._textMetrics.fontBoundingBoxAscent;\n\t\tthis._workGlyph.fontBoundingBoxDescent = this._textMetrics.fontBoundingBoxDescent;\n\n\t\t// const result2: IRasterizedGlyph = {\n\t\t// \tsource: this._canvas,\n\t\t// \tboundingBox: {\n\t\t// \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n\t\t// \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n\t\t// \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n\t\t// \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n\t\t// \t},\n\t\t// \toriginOffset: {\n\t\t// \t\tx: Math.floor(boundingBox.left - originX),\n\t\t// \t\ty: Math.floor(boundingBox.top - originY)\n\t\t// \t}\n\t\t// };\n\n\t\t// TODO: Verify result 1 and 2 are the same\n\n\t\t// if (result2.boundingBox.left > result.boundingBox.left) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.top > result.boundingBox.top) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.right < result.boundingBox.right) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n\t\t// \tdebugger;\n\t\t// }\n\n\n\n\t\treturn this._workGlyph;\n\t}\n\n\tprivate _clearColor(imageData: ImageData, r: number, g: number, b: number) {\n\t\tfor (let offset = 0; offset < imageData.data.length; offset += 4) {\n\t\t\t// Check exact match\n\t\t\tif (imageData.data[offset] === r &&\n\t\t\t\timageData.data[offset + 1] === g &&\n\t\t\t\timageData.data[offset + 2] === b) {\n\t\t\t\timageData.data[offset + 3] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: Does this even need to happen when measure text is used?\n\tprivate _findGlyphBoundingBox(imageData: ImageData, outBoundingBox: IBoundingBox) {\n\t\tconst height = this._canvas.height;\n\t\tconst width = this._canvas.width;\n\t\tlet found = false;\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.top = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.left = 0;\n\t\tfound = false;\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.left = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.right = width;\n\t\tfound = false;\n\t\tfor (let x = width - 1; x >= outBoundingBox.left; x--) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.right = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.bottom = outBoundingBox.top;\n\t\tfound = false;\n\t\tfor (let y = height - 1; y >= 0; y--) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.bottom = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getTextMetrics(text: string): TextMetrics {\n\t\treturn this._ctx.measureText(text);\n\t}\n}\n"]}