{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlayHints/browser/inlayHints.ts","vs/editor/contrib/inlayHints/browser/inlayHints.ts"],"names":[],"mappings":"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","file":"inlayHints.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { IPosition, Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { InlayHint, InlayHintList, InlayHintsProvider, Command } from '../../../common/languages.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { URI } from '../../../../base/common/uri.js';\n\nexport class InlayHintAnchor {\n\tconstructor(readonly range: Range, readonly direction: 'before' | 'after') { }\n}\n\nexport class InlayHintItem {\n\n\tprivate _isResolved: boolean = false;\n\tprivate _currentResolve?: Promise<void>;\n\n\tconstructor(readonly hint: InlayHint, readonly anchor: InlayHintAnchor, readonly provider: InlayHintsProvider) { }\n\n\twith(delta: { anchor: InlayHintAnchor }): InlayHintItem {\n\t\tconst result = new InlayHintItem(this.hint, delta.anchor, this.provider);\n\t\tresult._isResolved = this._isResolved;\n\t\tresult._currentResolve = this._currentResolve;\n\t\treturn result;\n\t}\n\n\tasync resolve(token: CancellationToken): Promise<void> {\n\t\tif (typeof this.provider.resolveInlayHint !== 'function') {\n\t\t\treturn;\n\t\t}\n\t\tif (this._currentResolve) {\n\t\t\t// wait for an active resolve operation and try again\n\t\t\t// when that's done.\n\t\t\tawait this._currentResolve;\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn this.resolve(token);\n\t\t}\n\t\tif (!this._isResolved) {\n\t\t\tthis._currentResolve = this._doResolve(token)\n\t\t\t\t.finally(() => this._currentResolve = undefined);\n\t\t}\n\t\tawait this._currentResolve;\n\t}\n\n\tprivate async _doResolve(token: CancellationToken) {\n\t\ttry {\n\t\t\tconst newHint = await Promise.resolve(this.provider.resolveInlayHint!(this.hint, token));\n\t\t\tthis.hint.tooltip = newHint?.tooltip ?? this.hint.tooltip;\n\t\t\tthis.hint.label = newHint?.label ?? this.hint.label;\n\t\t\tthis.hint.textEdits = newHint?.textEdits ?? this.hint.textEdits;\n\t\t\tthis._isResolved = true;\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tthis._isResolved = false;\n\t\t}\n\t}\n}\n\nexport class InlayHintsFragments {\n\n\tprivate static _emptyInlayHintList: InlayHintList = Object.freeze({ dispose() { }, hints: [] });\n\n\tstatic async create(registry: LanguageFeatureRegistry<InlayHintsProvider>, model: ITextModel, ranges: Range[], token: CancellationToken): Promise<InlayHintsFragments> {\n\n\t\tconst data: [InlayHintList, InlayHintsProvider][] = [];\n\n\t\tconst promises = registry.ordered(model).reverse().map(provider => ranges.map(async range => {\n\t\t\ttry {\n\t\t\t\tconst result = await provider.provideInlayHints(model, range, token);\n\t\t\t\tif (result?.hints.length || provider.onDidChangeInlayHints) {\n\t\t\t\t\tdata.push([result ?? InlayHintsFragments._emptyInlayHintList, provider]);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tonUnexpectedExternalError(err);\n\t\t\t}\n\t\t}));\n\n\t\tawait Promise.all(promises.flat());\n\n\t\tif (token.isCancellationRequested || model.isDisposed()) {\n\t\t\tthrow new CancellationError();\n\t\t}\n\n\t\treturn new InlayHintsFragments(ranges, data, model);\n\t}\n\n\tprivate readonly _disposables = new DisposableStore();\n\n\treadonly items: readonly InlayHintItem[];\n\treadonly ranges: readonly Range[];\n\treadonly provider: Set<InlayHintsProvider>;\n\n\tprivate constructor(ranges: Range[], data: [InlayHintList, InlayHintsProvider][], model: ITextModel) {\n\t\tthis.ranges = ranges;\n\t\tthis.provider = new Set();\n\t\tconst items: InlayHintItem[] = [];\n\t\tfor (const [list, provider] of data) {\n\t\t\tthis._disposables.add(list);\n\t\t\tthis.provider.add(provider);\n\n\t\t\tfor (const hint of list.hints) {\n\t\t\t\t// compute the range to which the item should be attached to\n\t\t\t\tconst position = model.validatePosition(hint.position);\n\t\t\t\tlet direction: 'before' | 'after' = 'before';\n\n\t\t\t\tconst wordRange = InlayHintsFragments._getRangeAtPosition(model, position);\n\t\t\t\tlet range: Range;\n\n\t\t\t\tif (wordRange.getStartPosition().isBefore(position)) {\n\t\t\t\t\trange = Range.fromPositions(wordRange.getStartPosition(), position);\n\t\t\t\t\tdirection = 'after';\n\t\t\t\t} else {\n\t\t\t\t\trange = Range.fromPositions(position, wordRange.getEndPosition());\n\t\t\t\t\tdirection = 'before';\n\t\t\t\t}\n\n\t\t\t\titems.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));\n\t\t\t}\n\t\t}\n\t\tthis.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t}\n\n\tprivate static _getRangeAtPosition(model: ITextModel, position: IPosition): Range {\n\t\tconst line = position.lineNumber;\n\t\tconst word = model.getWordAtPosition(position);\n\t\tif (word) {\n\t\t\t// always prefer the word range\n\t\t\treturn new Range(line, word.startColumn, line, word.endColumn);\n\t\t}\n\n\t\tmodel.tokenization.tokenizeIfCheap(line);\n\t\tconst tokens = model.tokenization.getLineTokens(line);\n\t\tconst offset = position.column - 1;\n\t\tconst idx = tokens.findTokenIndexAtOffset(offset);\n\n\t\tlet start = tokens.getStartOffset(idx);\n\t\tlet end = tokens.getEndOffset(idx);\n\n\t\tif (end - start === 1) {\n\t\t\t// single character token, when at its end try leading/trailing token instead\n\t\t\tif (start === offset && idx > 1) {\n\t\t\t\t// leading token\n\t\t\t\tstart = tokens.getStartOffset(idx - 1);\n\t\t\t\tend = tokens.getEndOffset(idx - 1);\n\t\t\t} else if (end === offset && idx < tokens.getCount() - 1) {\n\t\t\t\t// trailing token\n\t\t\t\tstart = tokens.getStartOffset(idx + 1);\n\t\t\t\tend = tokens.getEndOffset(idx + 1);\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(line, start + 1, line, end + 1);\n\t}\n}\n\nexport function asCommandLink(command: Command): string {\n\treturn URI.from({\n\t\tscheme: Schemas.command,\n\t\tpath: command.id,\n\t\tquery: command.arguments && encodeURIComponent(JSON.stringify(command.arguments))\n\t}).toString();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { IPosition, Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { InlayHint, InlayHintList, InlayHintsProvider, Command } from '../../../common/languages.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { URI } from '../../../../base/common/uri.js';\n\nexport class InlayHintAnchor {\n\tconstructor(readonly range: Range, readonly direction: 'before' | 'after') { }\n}\n\nexport class InlayHintItem {\n\n\tprivate _isResolved: boolean = false;\n\tprivate _currentResolve?: Promise<void>;\n\n\tconstructor(readonly hint: InlayHint, readonly anchor: InlayHintAnchor, readonly provider: InlayHintsProvider) { }\n\n\twith(delta: { anchor: InlayHintAnchor }): InlayHintItem {\n\t\tconst result = new InlayHintItem(this.hint, delta.anchor, this.provider);\n\t\tresult._isResolved = this._isResolved;\n\t\tresult._currentResolve = this._currentResolve;\n\t\treturn result;\n\t}\n\n\tasync resolve(token: CancellationToken): Promise<void> {\n\t\tif (typeof this.provider.resolveInlayHint !== 'function') {\n\t\t\treturn;\n\t\t}\n\t\tif (this._currentResolve) {\n\t\t\t// wait for an active resolve operation and try again\n\t\t\t// when that's done.\n\t\t\tawait this._currentResolve;\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn this.resolve(token);\n\t\t}\n\t\tif (!this._isResolved) {\n\t\t\tthis._currentResolve = this._doResolve(token)\n\t\t\t\t.finally(() => this._currentResolve = undefined);\n\t\t}\n\t\tawait this._currentResolve;\n\t}\n\n\tprivate async _doResolve(token: CancellationToken) {\n\t\ttry {\n\t\t\tconst newHint = await Promise.resolve(this.provider.resolveInlayHint!(this.hint, token));\n\t\t\tthis.hint.tooltip = newHint?.tooltip ?? this.hint.tooltip;\n\t\t\tthis.hint.label = newHint?.label ?? this.hint.label;\n\t\t\tthis.hint.textEdits = newHint?.textEdits ?? this.hint.textEdits;\n\t\t\tthis._isResolved = true;\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tthis._isResolved = false;\n\t\t}\n\t}\n}\n\nexport class InlayHintsFragments {\n\n\tprivate static _emptyInlayHintList: InlayHintList = Object.freeze({ dispose() { }, hints: [] });\n\n\tstatic async create(registry: LanguageFeatureRegistry<InlayHintsProvider>, model: ITextModel, ranges: Range[], token: CancellationToken): Promise<InlayHintsFragments> {\n\n\t\tconst data: [InlayHintList, InlayHintsProvider][] = [];\n\n\t\tconst promises = registry.ordered(model).reverse().map(provider => ranges.map(async range => {\n\t\t\ttry {\n\t\t\t\tconst result = await provider.provideInlayHints(model, range, token);\n\t\t\t\tif (result?.hints.length || provider.onDidChangeInlayHints) {\n\t\t\t\t\tdata.push([result ?? InlayHintsFragments._emptyInlayHintList, provider]);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tonUnexpectedExternalError(err);\n\t\t\t}\n\t\t}));\n\n\t\tawait Promise.all(promises.flat());\n\n\t\tif (token.isCancellationRequested || model.isDisposed()) {\n\t\t\tthrow new CancellationError();\n\t\t}\n\n\t\treturn new InlayHintsFragments(ranges, data, model);\n\t}\n\n\tprivate readonly _disposables = new DisposableStore();\n\n\treadonly items: readonly InlayHintItem[];\n\treadonly ranges: readonly Range[];\n\treadonly provider: Set<InlayHintsProvider>;\n\n\tprivate constructor(ranges: Range[], data: [InlayHintList, InlayHintsProvider][], model: ITextModel) {\n\t\tthis.ranges = ranges;\n\t\tthis.provider = new Set();\n\t\tconst items: InlayHintItem[] = [];\n\t\tfor (const [list, provider] of data) {\n\t\t\tthis._disposables.add(list);\n\t\t\tthis.provider.add(provider);\n\n\t\t\tfor (const hint of list.hints) {\n\t\t\t\t// compute the range to which the item should be attached to\n\t\t\t\tconst position = model.validatePosition(hint.position);\n\t\t\t\tlet direction: 'before' | 'after' = 'before';\n\n\t\t\t\tconst wordRange = InlayHintsFragments._getRangeAtPosition(model, position);\n\t\t\t\tlet range: Range;\n\n\t\t\t\tif (wordRange.getStartPosition().isBefore(position)) {\n\t\t\t\t\trange = Range.fromPositions(wordRange.getStartPosition(), position);\n\t\t\t\t\tdirection = 'after';\n\t\t\t\t} else {\n\t\t\t\t\trange = Range.fromPositions(position, wordRange.getEndPosition());\n\t\t\t\t\tdirection = 'before';\n\t\t\t\t}\n\n\t\t\t\titems.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));\n\t\t\t}\n\t\t}\n\t\tthis.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t}\n\n\tprivate static _getRangeAtPosition(model: ITextModel, position: IPosition): Range {\n\t\tconst line = position.lineNumber;\n\t\tconst word = model.getWordAtPosition(position);\n\t\tif (word) {\n\t\t\t// always prefer the word range\n\t\t\treturn new Range(line, word.startColumn, line, word.endColumn);\n\t\t}\n\n\t\tmodel.tokenization.tokenizeIfCheap(line);\n\t\tconst tokens = model.tokenization.getLineTokens(line);\n\t\tconst offset = position.column - 1;\n\t\tconst idx = tokens.findTokenIndexAtOffset(offset);\n\n\t\tlet start = tokens.getStartOffset(idx);\n\t\tlet end = tokens.getEndOffset(idx);\n\n\t\tif (end - start === 1) {\n\t\t\t// single character token, when at its end try leading/trailing token instead\n\t\t\tif (start === offset && idx > 1) {\n\t\t\t\t// leading token\n\t\t\t\tstart = tokens.getStartOffset(idx - 1);\n\t\t\t\tend = tokens.getEndOffset(idx - 1);\n\t\t\t} else if (end === offset && idx < tokens.getCount() - 1) {\n\t\t\t\t// trailing token\n\t\t\t\tstart = tokens.getStartOffset(idx + 1);\n\t\t\t\tend = tokens.getEndOffset(idx + 1);\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(line, start + 1, line, end + 1);\n\t}\n}\n\nexport function asCommandLink(command: Command): string {\n\treturn URI.from({\n\t\tscheme: Schemas.command,\n\t\tpath: command.id,\n\t\tquery: command.arguments && encodeURIComponent(JSON.stringify(command.arguments))\n\t}).toString();\n}\n"]}