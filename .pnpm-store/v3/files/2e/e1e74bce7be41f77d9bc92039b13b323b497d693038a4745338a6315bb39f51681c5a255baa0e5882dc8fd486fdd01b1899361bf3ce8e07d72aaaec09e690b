{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableValue.ts","vs/base/common/observableInternal/observables/observableValue.ts"],"names":[],"mappings":"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","file":"observableValue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\n\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\n\t\tgetLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: undefined, didChange: true, oldValue: undefined });\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as T;\n\t}\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\n\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\n\t\tgetLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: undefined, didChange: true, oldValue: undefined });\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as T;\n\t}\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n"]}