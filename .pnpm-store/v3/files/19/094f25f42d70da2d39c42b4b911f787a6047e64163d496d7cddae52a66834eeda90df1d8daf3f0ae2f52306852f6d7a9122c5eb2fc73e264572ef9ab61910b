{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/model/typingSpeed.ts","vs/editor/contrib/inlineCompletions/browser/model/typingSpeed.ts"],"names":[],"mappings":"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","file":"typingSpeed.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sum } from '../../../../../base/common/arrays.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { IModelContentChangedEvent } from '../../../../common/textModelEvents.js';\n\ninterface TypingSession {\n\tstartTime: number;\n\tendTime: number;\n\tcharacterCount: number; // Effective character count for typing interval calculation\n}\n\ninterface TypingIntervalResult {\n\taverageInterval: number; // Average milliseconds between keystrokes\n\tcharacterCount: number; // Number of characters involved in the computation\n}\n\n/**\n * Tracks typing speed as average milliseconds between keystrokes.\n * Higher values indicate slower typing.\n */\nexport class TypingInterval extends Disposable {\n\n\tprivate readonly _typingSessions: TypingSession[] = [];\n\tprivate _currentSession: TypingSession | null = null;\n\tprivate _lastChangeTime = 0;\n\tprivate _cachedTypingIntervalResult: TypingIntervalResult | null = null;\n\tprivate _cacheInvalidated = true;\n\n\t// Configuration constants\n\tprivate static readonly MAX_SESSION_GAP_MS = 3_000; // 3 seconds max gap between keystrokes in a session\n\tprivate static readonly MIN_SESSION_DURATION_MS = 1_000; // Minimum session duration to consider\n\tprivate static readonly SESSION_HISTORY_LIMIT = 50; // Keep last 50 sessions for calculation\n\tprivate static readonly TYPING_SPEED_WINDOW_MS = 300_000; // 5 minutes window for speed calculation\n\tprivate static readonly MIN_CHARS_FOR_RELIABLE_SPEED = 20; // Minimum characters needed for reliable speed calculation\n\n\t/**\n\t * Gets the current typing interval as average milliseconds between keystrokes\n\t * and the number of characters involved in the computation.\n\t * Higher interval values indicate slower typing.\n\t * Returns { interval: 0, characterCount: 0 } if no typing data is available.\n\t */\n\tpublic getTypingInterval(): TypingIntervalResult {\n\t\tif (this._cacheInvalidated || this._cachedTypingIntervalResult === null) {\n\t\t\tthis._cachedTypingIntervalResult = this._calculateTypingInterval();\n\t\t\tthis._cacheInvalidated = false;\n\t\t}\n\t\treturn this._cachedTypingIntervalResult;\n\t}\n\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\n\t\tthis._register(this._textModel.onDidChangeContent(e => this._updateTypingSpeed(e)));\n\t}\n\n\tprivate _updateTypingSpeed(change: IModelContentChangedEvent): void {\n\t\tconst now = Date.now();\n\n\t\tif (!this._isUserTyping(change)) {\n\t\t\tthis._finalizeCurrentSession();\n\t\t\treturn;\n\t\t}\n\n\t\t// If too much time has passed since last change, start a new session\n\t\tif (this._currentSession && (now - this._lastChangeTime) > TypingInterval.MAX_SESSION_GAP_MS) {\n\t\t\tthis._finalizeCurrentSession();\n\t\t}\n\n\t\t// Start new session if none exists\n\t\tif (!this._currentSession) {\n\t\t\tthis._currentSession = {\n\t\t\t\tstartTime: now,\n\t\t\t\tendTime: now,\n\t\t\t\tcharacterCount: 0\n\t\t\t};\n\t\t}\n\n\t\t// Update current session\n\t\tthis._currentSession.endTime = now;\n\t\tthis._currentSession.characterCount += this._getActualCharacterCount(change);\n\n\t\tthis._lastChangeTime = now;\n\t\tthis._cacheInvalidated = true;\n\t}\n\n\tprivate _getActualCharacterCount(change: IModelContentChangedEvent): number {\n\t\tlet totalChars = 0;\n\t\tfor (const c of change.changes) {\n\t\t\t// Count characters added or removed (use the larger of the two)\n\t\t\ttotalChars += Math.max(c.text.length, c.rangeLength);\n\t\t}\n\t\treturn totalChars;\n\t}\n\n\tprivate _isUserTyping(change: IModelContentChangedEvent): boolean {\n\t\t// If no detailed reasons, assume user typing\n\t\tif (!change.detailedReasons || change.detailedReasons.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if any of the reasons indicate actual user typing\n\t\tfor (const reason of change.detailedReasons) {\n\t\t\tif (this._isUserTypingReason(reason)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _isUserTypingReason(reason: any): boolean {\n\t\t// Handle undo/redo - not considered user typing\n\t\tif (reason.metadata.isUndoing || reason.metadata.isRedoing) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Handle different source types\n\t\tswitch (reason.metadata.source) {\n\t\t\tcase 'cursor': {\n\t\t\t\t// Direct user input via cursor\n\t\t\t\tconst kind = reason.metadata.kind;\n\t\t\t\treturn kind === 'type' || kind === 'compositionType' || kind === 'compositionEnd';\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\t// All other sources (paste, suggestions, code actions, etc.) are not user typing\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate _finalizeCurrentSession(): void {\n\t\tif (!this._currentSession) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst sessionDuration = this._currentSession.endTime - this._currentSession.startTime;\n\n\t\t// Only keep sessions that meet minimum duration and have actual content\n\t\tif (sessionDuration >= TypingInterval.MIN_SESSION_DURATION_MS && this._currentSession.characterCount > 0) {\n\t\t\tthis._typingSessions.push(this._currentSession);\n\n\t\t\t// Limit session history\n\t\t\tif (this._typingSessions.length > TypingInterval.SESSION_HISTORY_LIMIT) {\n\t\t\t\tthis._typingSessions.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._currentSession = null;\n\t}\n\n\tprivate _calculateTypingInterval(): TypingIntervalResult {\n\t\t// Finalize current session for calculation\n\t\tif (this._currentSession) {\n\t\t\tconst tempSession = { ...this._currentSession };\n\t\t\tconst sessionDuration = tempSession.endTime - tempSession.startTime;\n\t\t\tif (sessionDuration >= TypingInterval.MIN_SESSION_DURATION_MS && tempSession.characterCount > 0) {\n\t\t\t\tconst allSessions = [...this._typingSessions, tempSession];\n\t\t\t\treturn this._calculateSpeedFromSessions(allSessions);\n\t\t\t}\n\t\t}\n\n\t\treturn this._calculateSpeedFromSessions(this._typingSessions);\n\t}\n\n\tprivate _calculateSpeedFromSessions(sessions: TypingSession[]): TypingIntervalResult {\n\t\tif (sessions.length === 0) {\n\t\t\treturn { averageInterval: 0, characterCount: 0 };\n\t\t}\n\n\t\t// Sort sessions by recency (most recent first) to ensure we get the most recent sessions\n\t\tconst sortedSessions = [...sessions].sort((a, b) => b.endTime - a.endTime);\n\n\t\t// First, try the standard window\n\t\tconst cutoffTime = Date.now() - TypingInterval.TYPING_SPEED_WINDOW_MS;\n\t\tconst recentSessions = sortedSessions.filter(session => session.endTime > cutoffTime);\n\t\tconst olderSessions = sortedSessions.splice(recentSessions.length);\n\n\t\tlet totalChars = sum(recentSessions.map(session => session.characterCount));\n\n\t\t// If we don't have enough characters in the standard window, expand to include older sessions\n\t\tfor (let i = 0; i < olderSessions.length && totalChars < TypingInterval.MIN_CHARS_FOR_RELIABLE_SPEED; i++) {\n\t\t\trecentSessions.push(olderSessions[i]);\n\t\t\ttotalChars += olderSessions[i].characterCount;\n\t\t}\n\n\t\tconst totalTime = sum(recentSessions.map(session => session.endTime - session.startTime));\n\t\tif (totalTime === 0 || totalChars <= 1) {\n\t\t\treturn { averageInterval: 0, characterCount: totalChars };\n\t\t}\n\n\t\t// Calculate average milliseconds between keystrokes\n\t\tconst keystrokeIntervals = Math.max(1, totalChars - 1);\n\t\tconst avgMsBetweenKeystrokes = totalTime / keystrokeIntervals;\n\n\t\treturn {\n\t\t\taverageInterval: Math.round(avgMsBetweenKeystrokes),\n\t\t\tcharacterCount: totalChars\n\t\t};\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._finalizeCurrentSession();\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sum } from '../../../../../base/common/arrays.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { IModelContentChangedEvent } from '../../../../common/textModelEvents.js';\n\ninterface TypingSession {\n\tstartTime: number;\n\tendTime: number;\n\tcharacterCount: number; // Effective character count for typing interval calculation\n}\n\ninterface TypingIntervalResult {\n\taverageInterval: number; // Average milliseconds between keystrokes\n\tcharacterCount: number; // Number of characters involved in the computation\n}\n\n/**\n * Tracks typing speed as average milliseconds between keystrokes.\n * Higher values indicate slower typing.\n */\nexport class TypingInterval extends Disposable {\n\n\tprivate readonly _typingSessions: TypingSession[] = [];\n\tprivate _currentSession: TypingSession | null = null;\n\tprivate _lastChangeTime = 0;\n\tprivate _cachedTypingIntervalResult: TypingIntervalResult | null = null;\n\tprivate _cacheInvalidated = true;\n\n\t// Configuration constants\n\tprivate static readonly MAX_SESSION_GAP_MS = 3_000; // 3 seconds max gap between keystrokes in a session\n\tprivate static readonly MIN_SESSION_DURATION_MS = 1_000; // Minimum session duration to consider\n\tprivate static readonly SESSION_HISTORY_LIMIT = 50; // Keep last 50 sessions for calculation\n\tprivate static readonly TYPING_SPEED_WINDOW_MS = 300_000; // 5 minutes window for speed calculation\n\tprivate static readonly MIN_CHARS_FOR_RELIABLE_SPEED = 20; // Minimum characters needed for reliable speed calculation\n\n\t/**\n\t * Gets the current typing interval as average milliseconds between keystrokes\n\t * and the number of characters involved in the computation.\n\t * Higher interval values indicate slower typing.\n\t * Returns { interval: 0, characterCount: 0 } if no typing data is available.\n\t */\n\tpublic getTypingInterval(): TypingIntervalResult {\n\t\tif (this._cacheInvalidated || this._cachedTypingIntervalResult === null) {\n\t\t\tthis._cachedTypingIntervalResult = this._calculateTypingInterval();\n\t\t\tthis._cacheInvalidated = false;\n\t\t}\n\t\treturn this._cachedTypingIntervalResult;\n\t}\n\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\n\t\tthis._register(this._textModel.onDidChangeContent(e => this._updateTypingSpeed(e)));\n\t}\n\n\tprivate _updateTypingSpeed(change: IModelContentChangedEvent): void {\n\t\tconst now = Date.now();\n\n\t\tif (!this._isUserTyping(change)) {\n\t\t\tthis._finalizeCurrentSession();\n\t\t\treturn;\n\t\t}\n\n\t\t// If too much time has passed since last change, start a new session\n\t\tif (this._currentSession && (now - this._lastChangeTime) > TypingInterval.MAX_SESSION_GAP_MS) {\n\t\t\tthis._finalizeCurrentSession();\n\t\t}\n\n\t\t// Start new session if none exists\n\t\tif (!this._currentSession) {\n\t\t\tthis._currentSession = {\n\t\t\t\tstartTime: now,\n\t\t\t\tendTime: now,\n\t\t\t\tcharacterCount: 0\n\t\t\t};\n\t\t}\n\n\t\t// Update current session\n\t\tthis._currentSession.endTime = now;\n\t\tthis._currentSession.characterCount += this._getActualCharacterCount(change);\n\n\t\tthis._lastChangeTime = now;\n\t\tthis._cacheInvalidated = true;\n\t}\n\n\tprivate _getActualCharacterCount(change: IModelContentChangedEvent): number {\n\t\tlet totalChars = 0;\n\t\tfor (const c of change.changes) {\n\t\t\t// Count characters added or removed (use the larger of the two)\n\t\t\ttotalChars += Math.max(c.text.length, c.rangeLength);\n\t\t}\n\t\treturn totalChars;\n\t}\n\n\tprivate _isUserTyping(change: IModelContentChangedEvent): boolean {\n\t\t// If no detailed reasons, assume user typing\n\t\tif (!change.detailedReasons || change.detailedReasons.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if any of the reasons indicate actual user typing\n\t\tfor (const reason of change.detailedReasons) {\n\t\t\tif (this._isUserTypingReason(reason)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _isUserTypingReason(reason: any): boolean {\n\t\t// Handle undo/redo - not considered user typing\n\t\tif (reason.metadata.isUndoing || reason.metadata.isRedoing) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Handle different source types\n\t\tswitch (reason.metadata.source) {\n\t\t\tcase 'cursor': {\n\t\t\t\t// Direct user input via cursor\n\t\t\t\tconst kind = reason.metadata.kind;\n\t\t\t\treturn kind === 'type' || kind === 'compositionType' || kind === 'compositionEnd';\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\t// All other sources (paste, suggestions, code actions, etc.) are not user typing\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate _finalizeCurrentSession(): void {\n\t\tif (!this._currentSession) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst sessionDuration = this._currentSession.endTime - this._currentSession.startTime;\n\n\t\t// Only keep sessions that meet minimum duration and have actual content\n\t\tif (sessionDuration >= TypingInterval.MIN_SESSION_DURATION_MS && this._currentSession.characterCount > 0) {\n\t\t\tthis._typingSessions.push(this._currentSession);\n\n\t\t\t// Limit session history\n\t\t\tif (this._typingSessions.length > TypingInterval.SESSION_HISTORY_LIMIT) {\n\t\t\t\tthis._typingSessions.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._currentSession = null;\n\t}\n\n\tprivate _calculateTypingInterval(): TypingIntervalResult {\n\t\t// Finalize current session for calculation\n\t\tif (this._currentSession) {\n\t\t\tconst tempSession = { ...this._currentSession };\n\t\t\tconst sessionDuration = tempSession.endTime - tempSession.startTime;\n\t\t\tif (sessionDuration >= TypingInterval.MIN_SESSION_DURATION_MS && tempSession.characterCount > 0) {\n\t\t\t\tconst allSessions = [...this._typingSessions, tempSession];\n\t\t\t\treturn this._calculateSpeedFromSessions(allSessions);\n\t\t\t}\n\t\t}\n\n\t\treturn this._calculateSpeedFromSessions(this._typingSessions);\n\t}\n\n\tprivate _calculateSpeedFromSessions(sessions: TypingSession[]): TypingIntervalResult {\n\t\tif (sessions.length === 0) {\n\t\t\treturn { averageInterval: 0, characterCount: 0 };\n\t\t}\n\n\t\t// Sort sessions by recency (most recent first) to ensure we get the most recent sessions\n\t\tconst sortedSessions = [...sessions].sort((a, b) => b.endTime - a.endTime);\n\n\t\t// First, try the standard window\n\t\tconst cutoffTime = Date.now() - TypingInterval.TYPING_SPEED_WINDOW_MS;\n\t\tconst recentSessions = sortedSessions.filter(session => session.endTime > cutoffTime);\n\t\tconst olderSessions = sortedSessions.splice(recentSessions.length);\n\n\t\tlet totalChars = sum(recentSessions.map(session => session.characterCount));\n\n\t\t// If we don't have enough characters in the standard window, expand to include older sessions\n\t\tfor (let i = 0; i < olderSessions.length && totalChars < TypingInterval.MIN_CHARS_FOR_RELIABLE_SPEED; i++) {\n\t\t\trecentSessions.push(olderSessions[i]);\n\t\t\ttotalChars += olderSessions[i].characterCount;\n\t\t}\n\n\t\tconst totalTime = sum(recentSessions.map(session => session.endTime - session.startTime));\n\t\tif (totalTime === 0 || totalChars <= 1) {\n\t\t\treturn { averageInterval: 0, characterCount: totalChars };\n\t\t}\n\n\t\t// Calculate average milliseconds between keystrokes\n\t\tconst keystrokeIntervals = Math.max(1, totalChars - 1);\n\t\tconst avgMsBetweenKeystrokes = totalTime / keystrokeIntervals;\n\n\t\treturn {\n\t\t\taverageInterval: Math.round(avgMsBetweenKeystrokes),\n\t\t\tcharacterCount: totalChars\n\t\t};\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._finalizeCurrentSession();\n\t\tsuper.dispose();\n\t}\n}\n"]}