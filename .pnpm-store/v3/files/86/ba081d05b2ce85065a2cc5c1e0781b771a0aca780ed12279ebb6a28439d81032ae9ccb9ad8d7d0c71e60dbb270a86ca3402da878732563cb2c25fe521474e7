{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/modelLineProjectionData.ts","vs/editor/common/modelLineProjectionData.ts"],"names":[],"mappings":"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","file":"modelLineProjectionData.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../base/common/assert.js';\nimport { WrappingIndent } from './config/editorOptions.js';\nimport { FontInfo } from './config/fontInfo.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops, InjectedTextOptions, PositionAffinity } from './model.js';\nimport { LineInjectedText } from './textModelEvents.js';\n\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n\tconstructor(\n\t\tpublic injectionOffsets: number[] | null,\n\t\t/**\n\t\t * `injectionOptions.length` must equal `injectionOffsets.length`\n\t\t */\n\t\tpublic injectionOptions: InjectedTextOptions[] | null,\n\t\t/**\n\t\t * Refers to offsets after applying injections to the source.\n\t\t * The last break offset indicates the length of the source after applying injections.\n\t\t */\n\t\tpublic breakOffsets: number[],\n\t\t/**\n\t\t * Refers to offsets after applying injections\n\t\t */\n\t\tpublic breakOffsetsVisibleColumn: number[],\n\t\tpublic wrappedTextIndentLength: number\n\t) {\n\t}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this.breakOffsets.length;\n\t}\n\n\tpublic getMinOutputOffset(outputLineIndex: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\treturn this.wrappedTextIndentLength;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getLineLength(outputLineIndex: number): number {\n\t\t// These offsets refer to model text with injected text.\n\t\tconst startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst endOffset = this.breakOffsets[outputLineIndex];\n\n\t\tlet lineLength = endOffset - startOffset;\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineLength += this.wrappedTextIndentLength;\n\t\t}\n\t\treturn lineLength;\n\t}\n\n\tpublic getMaxOutputOffset(outputLineIndex: number): number {\n\t\treturn this.getLineLength(outputLineIndex);\n\t}\n\n\tpublic translateToInputOffset(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\n\t\tconst offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n\t\tlet offsetInInput = offsetInInputWithInjection;\n\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (offsetInInput > this.injectionOffsets[i]) {\n\t\t\t\t\tif (offsetInInput < this.injectionOffsets[i] + this.injectionOptions![i].content.length) {\n\t\t\t\t\t\t// `inputOffset` is within injected text\n\t\t\t\t\t\toffsetInInput = this.injectionOffsets[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffsetInInput -= this.injectionOptions![i].content.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offsetInInput;\n\t}\n\n\tpublic translateToOutputPosition(inputOffset: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet inputOffsetInInputWithInjection = inputOffset;\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (inputOffset < this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (affinity !== PositionAffinity.Right && inputOffset === this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputOffsetInInputWithInjection += this.injectionOptions![i].content.length;\n\t\t\t}\n\t\t}\n\n\t\treturn this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n\t}\n\n\tprivate offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet low = 0;\n\t\tlet high = this.breakOffsets.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tconst midStop = this.breakOffsets[mid];\n\t\t\tmidStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n\t\t\tif (affinity === PositionAffinity.Left) {\n\t\t\t\tif (offsetInInputWithInjections <= midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections > midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offsetInInputWithInjections < midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections >= midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet outputOffset = offsetInInputWithInjections - midStart;\n\t\tif (mid > 0) {\n\t\t\toutputOffset += this.wrappedTextIndentLength;\n\t\t}\n\n\t\treturn new OutputPosition(mid, outputOffset);\n\t}\n\n\tpublic normalizeOutputPosition(outputLineIndex: number, outputOffset: number, affinity: PositionAffinity): OutputPosition {\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tconst offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\t\tconst normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n\t\t\tif (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n\t\t\t\t// injected text caused a change\n\t\t\t\treturn this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n\t\t\t}\n\t\t}\n\n\t\tif (affinity === PositionAffinity.Left) {\n\t\t\tif (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n\t\t\t}\n\t\t}\n\t\telse if (affinity === PositionAffinity.Right) {\n\t\t\tconst maxOutputLineIndex = this.getOutputLineCount() - 1;\n\t\t\tif (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n\t\t\t}\n\t\t}\n\n\t\treturn new OutputPosition(outputLineIndex, outputOffset);\n\t}\n\n\tprivate outputPositionToOffsetInInputWithInjections(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\t\tconst result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n\t\treturn result;\n\t}\n\n\tprivate normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections: number, affinity: PositionAffinity): number {\n\t\tconst injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n\t\tif (!injectedText) {\n\t\t\treturn offsetInInputWithInjections;\n\t\t}\n\n\t\tif (affinity === PositionAffinity.None) {\n\t\t\tif (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n\t\t\t\t&& hasRightCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\treturn injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\t} else {\n\t\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tlet index = injectedText.injectedTextIndex - 1;\n\t\t\t\twhile (index >= 0 && this.injectionOffsets![index] === this.injectionOffsets![injectedText.injectedTextIndex]) {\n\t\t\t\t\tif (hasRightCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresult -= this.injectionOptions![index].content.length;\n\t\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else if (affinity === PositionAffinity.Right || affinity === PositionAffinity.RightOfInjectedText) {\n\t\t\tlet result = injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index + 1 < this.injectionOffsets!.length && this.injectionOffsets![index + 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult += this.injectionOptions![index + 1].content.length;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (affinity === PositionAffinity.Left || affinity === PositionAffinity.LeftOfInjectedText) {\n\t\t\t// affinity is left\n\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index - 1 >= 0 && this.injectionOffsets![index - 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult -= this.injectionOptions![index - 1].content.length;\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tassertNever(affinity);\n\t}\n\n\tpublic getInjectedText(outputLineIndex: number, outputOffset: number): InjectedText | null {\n\t\tconst offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\tconst injectedText = this.getInjectedTextAtOffset(offset);\n\t\tif (!injectedText) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\toptions: this.injectionOptions![injectedText.injectedTextIndex]\n\t\t};\n\t}\n\n\tprivate getInjectedTextAtOffset(offsetInInputWithInjections: number): { injectedTextIndex: number; offsetInInputWithInjections: number; length: number } | undefined {\n\t\tconst injectionOffsets = this.injectionOffsets;\n\t\tconst injectionOptions = this.injectionOptions;\n\n\t\tif (injectionOffsets !== null) {\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tfor (let i = 0; i < injectionOffsets.length; i++) {\n\t\t\t\tconst length = injectionOptions![i].content.length;\n\t\t\t\tconst injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n\t\t\t\tconst injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n\t\t\t\tif (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n\t\t\t\t\t// Injected text starts later.\n\t\t\t\t\tbreak; // All later injected texts have an even larger offset.\n\t\t\t\t}\n\n\t\t\t\tif (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n\t\t\t\t\t// Injected text ends after or with the given position (but also starts with or before it).\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinjectedTextIndex: i,\n\t\t\t\t\t\toffsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n\t\t\t\t\t\tlength\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nfunction hasRightCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\n\nexport class InjectedText {\n\tconstructor(public readonly options: InjectedTextOptions) { }\n}\n\nexport class OutputPosition {\n\toutputLineIndex: number;\n\toutputOffset: number;\n\n\tconstructor(outputLineIndex: number, outputOffset: number) {\n\t\tthis.outputLineIndex = outputLineIndex;\n\t\tthis.outputOffset = outputOffset;\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.outputLineIndex}:${this.outputOffset}`;\n\t}\n\n\ttoPosition(baseLineNumber: number): Position {\n\t\treturn new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n\t}\n}\n\nexport interface ILineBreaksComputerFactory {\n\tcreateLineBreaksComputer(fontInfo: FontInfo, tabSize: number, wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll', wrapOnEscapedLineFeeds: boolean): ILineBreaksComputer;\n}\n\nexport interface ILineBreaksComputer {\n\t/**\n\t * Pass in `previousLineBreakData` if the only difference is in breaking columns!!!\n\t */\n\taddRequest(lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null): void;\n\tfinalize(): (ModelLineProjectionData | null)[];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../base/common/assert.js';\nimport { WrappingIndent } from './config/editorOptions.js';\nimport { FontInfo } from './config/fontInfo.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops, InjectedTextOptions, PositionAffinity } from './model.js';\nimport { LineInjectedText } from './textModelEvents.js';\n\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n\tconstructor(\n\t\tpublic injectionOffsets: number[] | null,\n\t\t/**\n\t\t * `injectionOptions.length` must equal `injectionOffsets.length`\n\t\t */\n\t\tpublic injectionOptions: InjectedTextOptions[] | null,\n\t\t/**\n\t\t * Refers to offsets after applying injections to the source.\n\t\t * The last break offset indicates the length of the source after applying injections.\n\t\t */\n\t\tpublic breakOffsets: number[],\n\t\t/**\n\t\t * Refers to offsets after applying injections\n\t\t */\n\t\tpublic breakOffsetsVisibleColumn: number[],\n\t\tpublic wrappedTextIndentLength: number\n\t) {\n\t}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this.breakOffsets.length;\n\t}\n\n\tpublic getMinOutputOffset(outputLineIndex: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\treturn this.wrappedTextIndentLength;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getLineLength(outputLineIndex: number): number {\n\t\t// These offsets refer to model text with injected text.\n\t\tconst startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n\t\tconst endOffset = this.breakOffsets[outputLineIndex];\n\n\t\tlet lineLength = endOffset - startOffset;\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineLength += this.wrappedTextIndentLength;\n\t\t}\n\t\treturn lineLength;\n\t}\n\n\tpublic getMaxOutputOffset(outputLineIndex: number): number {\n\t\treturn this.getLineLength(outputLineIndex);\n\t}\n\n\tpublic translateToInputOffset(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\n\t\tconst offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n\t\tlet offsetInInput = offsetInInputWithInjection;\n\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (offsetInInput > this.injectionOffsets[i]) {\n\t\t\t\t\tif (offsetInInput < this.injectionOffsets[i] + this.injectionOptions![i].content.length) {\n\t\t\t\t\t\t// `inputOffset` is within injected text\n\t\t\t\t\t\toffsetInInput = this.injectionOffsets[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffsetInInput -= this.injectionOptions![i].content.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offsetInInput;\n\t}\n\n\tpublic translateToOutputPosition(inputOffset: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet inputOffsetInInputWithInjection = inputOffset;\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tfor (let i = 0; i < this.injectionOffsets.length; i++) {\n\t\t\t\tif (inputOffset < this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (affinity !== PositionAffinity.Right && inputOffset === this.injectionOffsets[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputOffsetInInputWithInjection += this.injectionOptions![i].content.length;\n\t\t\t}\n\t\t}\n\n\t\treturn this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n\t}\n\n\tprivate offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections: number, affinity: PositionAffinity = PositionAffinity.None): OutputPosition {\n\t\tlet low = 0;\n\t\tlet high = this.breakOffsets.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tconst midStop = this.breakOffsets[mid];\n\t\t\tmidStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n\t\t\tif (affinity === PositionAffinity.Left) {\n\t\t\t\tif (offsetInInputWithInjections <= midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections > midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offsetInInputWithInjections < midStart) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else if (offsetInInputWithInjections >= midStop) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet outputOffset = offsetInInputWithInjections - midStart;\n\t\tif (mid > 0) {\n\t\t\toutputOffset += this.wrappedTextIndentLength;\n\t\t}\n\n\t\treturn new OutputPosition(mid, outputOffset);\n\t}\n\n\tpublic normalizeOutputPosition(outputLineIndex: number, outputOffset: number, affinity: PositionAffinity): OutputPosition {\n\t\tif (this.injectionOffsets !== null) {\n\t\t\tconst offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\t\tconst normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n\t\t\tif (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n\t\t\t\t// injected text caused a change\n\t\t\t\treturn this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n\t\t\t}\n\t\t}\n\n\t\tif (affinity === PositionAffinity.Left) {\n\t\t\tif (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n\t\t\t}\n\t\t}\n\t\telse if (affinity === PositionAffinity.Right) {\n\t\t\tconst maxOutputLineIndex = this.getOutputLineCount() - 1;\n\t\t\tif (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n\t\t\t\treturn new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n\t\t\t}\n\t\t}\n\n\t\treturn new OutputPosition(outputLineIndex, outputOffset);\n\t}\n\n\tprivate outputPositionToOffsetInInputWithInjections(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n\t\t}\n\t\tconst result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n\t\treturn result;\n\t}\n\n\tprivate normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections: number, affinity: PositionAffinity): number {\n\t\tconst injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n\t\tif (!injectedText) {\n\t\t\treturn offsetInInputWithInjections;\n\t\t}\n\n\t\tif (affinity === PositionAffinity.None) {\n\t\t\tif (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n\t\t\t\t&& hasRightCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\treturn injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\t} else {\n\t\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![injectedText.injectedTextIndex].cursorStops)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tlet index = injectedText.injectedTextIndex - 1;\n\t\t\t\twhile (index >= 0 && this.injectionOffsets![index] === this.injectionOffsets![injectedText.injectedTextIndex]) {\n\t\t\t\t\tif (hasRightCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresult -= this.injectionOptions![index].content.length;\n\t\t\t\t\tif (hasLeftCursorStop(this.injectionOptions![index].cursorStops)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else if (affinity === PositionAffinity.Right || affinity === PositionAffinity.RightOfInjectedText) {\n\t\t\tlet result = injectedText.offsetInInputWithInjections + injectedText.length;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index + 1 < this.injectionOffsets!.length && this.injectionOffsets![index + 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult += this.injectionOptions![index + 1].content.length;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (affinity === PositionAffinity.Left || affinity === PositionAffinity.LeftOfInjectedText) {\n\t\t\t// affinity is left\n\t\t\tlet result = injectedText.offsetInInputWithInjections;\n\t\t\tlet index = injectedText.injectedTextIndex;\n\t\t\t// traverse all injected text that touch each other\n\t\t\twhile (index - 1 >= 0 && this.injectionOffsets![index - 1] === this.injectionOffsets![index]) {\n\t\t\t\tresult -= this.injectionOptions![index - 1].content.length;\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tassertNever(affinity);\n\t}\n\n\tpublic getInjectedText(outputLineIndex: number, outputOffset: number): InjectedText | null {\n\t\tconst offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n\t\tconst injectedText = this.getInjectedTextAtOffset(offset);\n\t\tif (!injectedText) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\toptions: this.injectionOptions![injectedText.injectedTextIndex]\n\t\t};\n\t}\n\n\tprivate getInjectedTextAtOffset(offsetInInputWithInjections: number): { injectedTextIndex: number; offsetInInputWithInjections: number; length: number } | undefined {\n\t\tconst injectionOffsets = this.injectionOffsets;\n\t\tconst injectionOptions = this.injectionOptions;\n\n\t\tif (injectionOffsets !== null) {\n\t\t\tlet totalInjectedTextLengthBefore = 0;\n\t\t\tfor (let i = 0; i < injectionOffsets.length; i++) {\n\t\t\t\tconst length = injectionOptions![i].content.length;\n\t\t\t\tconst injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n\t\t\t\tconst injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n\t\t\t\tif (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n\t\t\t\t\t// Injected text starts later.\n\t\t\t\t\tbreak; // All later injected texts have an even larger offset.\n\t\t\t\t}\n\n\t\t\t\tif (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n\t\t\t\t\t// Injected text ends after or with the given position (but also starts with or before it).\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinjectedTextIndex: i,\n\t\t\t\t\t\toffsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n\t\t\t\t\t\tlength\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\ttotalInjectedTextLengthBefore += length;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nfunction hasRightCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop: InjectedTextCursorStops | null | undefined): boolean {\n\tif (cursorStop === null || cursorStop === undefined) { return true; }\n\treturn cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\n\nexport class InjectedText {\n\tconstructor(public readonly options: InjectedTextOptions) { }\n}\n\nexport class OutputPosition {\n\toutputLineIndex: number;\n\toutputOffset: number;\n\n\tconstructor(outputLineIndex: number, outputOffset: number) {\n\t\tthis.outputLineIndex = outputLineIndex;\n\t\tthis.outputOffset = outputOffset;\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.outputLineIndex}:${this.outputOffset}`;\n\t}\n\n\ttoPosition(baseLineNumber: number): Position {\n\t\treturn new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n\t}\n}\n\nexport interface ILineBreaksComputerFactory {\n\tcreateLineBreaksComputer(fontInfo: FontInfo, tabSize: number, wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll', wrapOnEscapedLineFeeds: boolean): ILineBreaksComputer;\n}\n\nexport interface ILineBreaksComputer {\n\t/**\n\t * Pass in `previousLineBreakData` if the only difference is in breaking columns!!!\n\t */\n\taddRequest(lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null): void;\n\tfinalize(): (ModelLineProjectionData | null)[];\n}\n"]}