{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/lineEdit.ts","vs/editor/common/core/edits/lineEdit.ts"],"names":[],"mappings":"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","file":"lineEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n}\n\nexport class LineReplacement {\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n","\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n}\n\nexport class LineReplacement {\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n"]}