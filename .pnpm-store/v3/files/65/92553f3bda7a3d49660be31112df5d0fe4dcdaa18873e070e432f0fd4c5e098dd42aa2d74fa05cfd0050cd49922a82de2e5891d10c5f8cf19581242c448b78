{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts","vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts"],"names":[],"mappings":"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","file":"decorationCssRuleExtractor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tfor (const rule of stylesheet.cssRules) {\n\t\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\t\tstylesheets.push(rule.styleSheet);\n\t\t\t\t\t}\n\t\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t\t// returned styles.\n\t\t\t\t\t//\n\t\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t\t// it.\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :]/)) {\n\t\t\t\t\t\t\trules.push(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tfor (const rule of stylesheet.cssRules) {\n\t\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\t\tstylesheets.push(rule.styleSheet);\n\t\t\t\t\t}\n\t\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t\t// returned styles.\n\t\t\t\t\t//\n\t\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t\t// it.\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :]/)) {\n\t\t\t\t\t\t\trules.push(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t}\n}\n"]}