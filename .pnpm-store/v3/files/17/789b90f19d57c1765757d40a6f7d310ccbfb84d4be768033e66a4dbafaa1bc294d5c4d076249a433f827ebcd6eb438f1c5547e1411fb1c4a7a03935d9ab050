{"version":3,"sources":["vs/platform/contextkey/common/scanner.ts"],"names":[],"mappings":"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","file":"scanner.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { localize } from '../../../nls.js';\n\nexport const enum TokenType {\n\tLParen,\n\tRParen,\n\tNeg,\n\tEq,\n\tNotEq,\n\tLt,\n\tLtEq,\n\tGt,\n\tGtEq,\n\tRegexOp,\n\tRegexStr,\n\tTrue,\n\tFalse,\n\tIn,\n\tNot,\n\tAnd,\n\tOr,\n\tStr,\n\tQuotedStr,\n\tError,\n\tEOF,\n}\n\nexport type Token =\n\t| { type: TokenType.LParen; offset: number }\n\t| { type: TokenType.RParen; offset: number }\n\t| { type: TokenType.Neg; offset: number }\n\t| { type: TokenType.Eq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.NotEq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.Lt; offset: number }\n\t| { type: TokenType.LtEq; offset: number }\n\t| { type: TokenType.Gt; offset: number }\n\t| { type: TokenType.GtEq; offset: number }\n\t| { type: TokenType.RegexOp; offset: number }\n\t| { type: TokenType.RegexStr; offset: number; lexeme: string }\n\t| { type: TokenType.True; offset: number }\n\t| { type: TokenType.False; offset: number }\n\t| { type: TokenType.In; offset: number }\n\t| { type: TokenType.Not; offset: number }\n\t| { type: TokenType.And; offset: number }\n\t| { type: TokenType.Or; offset: number }\n\t| { type: TokenType.Str; offset: number; lexeme: string }\n\t| { type: TokenType.QuotedStr; offset: number; lexeme: string }\n\t| { type: TokenType.Error; offset: number; lexeme: string }\n\t| { type: TokenType.EOF; offset: number };\n\ntype KeywordTokenType = TokenType.Not | TokenType.In | TokenType.False | TokenType.True;\ntype TokenTypeWithoutLexeme =\n\tTokenType.LParen |\n\tTokenType.RParen |\n\tTokenType.Neg |\n\tTokenType.Lt |\n\tTokenType.LtEq |\n\tTokenType.Gt |\n\tTokenType.GtEq |\n\tTokenType.RegexOp |\n\tTokenType.True |\n\tTokenType.False |\n\tTokenType.In |\n\tTokenType.Not |\n\tTokenType.And |\n\tTokenType.Or |\n\tTokenType.EOF;\n\n/**\n * Example:\n * `foo == bar'` - note how single quote doesn't have a corresponding closing quote,\n * so it's reported as unexpected\n */\nexport type LexingError = {\n\toffset: number; /** note that this doesn't take into account escape characters from the original encoding of the string, e.g., within an extension manifest file's JSON encoding  */\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nfunction hintDidYouMean(...meant: string[]) {\n\tswitch (meant.length) {\n\t\tcase 1:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean1', \"Did you mean {0}?\", meant[0]);\n\t\tcase 2:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean2', \"Did you mean {0} or {1}?\", meant[0], meant[1]);\n\t\tcase 3:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean3', \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]);\n\t\tdefault: // we just don't expect that many\n\t\t\treturn undefined;\n\t}\n}\n\nconst hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', \"Did you forget to open or close the quote?\");\nconst hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\");\n\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n\n\tstatic getLexeme(token: Token): string {\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.LParen:\n\t\t\t\treturn '(';\n\t\t\tcase TokenType.RParen:\n\t\t\t\treturn ')';\n\t\t\tcase TokenType.Neg:\n\t\t\t\treturn '!';\n\t\t\tcase TokenType.Eq:\n\t\t\t\treturn token.isTripleEq ? '===' : '==';\n\t\t\tcase TokenType.NotEq:\n\t\t\t\treturn token.isTripleEq ? '!==' : '!=';\n\t\t\tcase TokenType.Lt:\n\t\t\t\treturn '<';\n\t\t\tcase TokenType.LtEq:\n\t\t\t\treturn '<=';\n\t\t\tcase TokenType.Gt:\n\t\t\t\treturn '>=';\n\t\t\tcase TokenType.GtEq:\n\t\t\t\treturn '>=';\n\t\t\tcase TokenType.RegexOp:\n\t\t\t\treturn '=~';\n\t\t\tcase TokenType.RegexStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\treturn 'true';\n\t\t\tcase TokenType.False:\n\t\t\t\treturn 'false';\n\t\t\tcase TokenType.In:\n\t\t\t\treturn 'in';\n\t\t\tcase TokenType.Not:\n\t\t\t\treturn 'not';\n\t\t\tcase TokenType.And:\n\t\t\t\treturn '&&';\n\t\t\tcase TokenType.Or:\n\t\t\t\treturn '||';\n\t\t\tcase TokenType.Str:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.Error:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.EOF:\n\t\t\t\treturn 'EOF';\n\t\t\tdefault:\n\t\t\t\tthrow illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n\t\t}\n\t}\n\n\tprivate static _regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0)));\n\n\tprivate static _keywords = new Map<string, KeywordTokenType>([\n\t\t['not', TokenType.Not],\n\t\t['in', TokenType.In],\n\t\t['false', TokenType.False],\n\t\t['true', TokenType.True],\n\t]);\n\n\tprivate _input: string = '';\n\tprivate _start: number = 0;\n\tprivate _current: number = 0;\n\tprivate _tokens: Token[] = [];\n\tprivate _errors: LexingError[] = [];\n\n\treset(value: string) {\n\t\tthis._input = value;\n\n\t\tthis._start = 0;\n\t\tthis._current = 0;\n\t\tthis._tokens = [];\n\t\tthis._errors = [];\n\n\t\treturn this;\n\t}\n\n\tscan() {\n\t\twhile (!this._isAtEnd()) {\n\n\t\t\tthis._start = this._current;\n\n\t\t\tconst ch = this._advance();\n\t\t\tswitch (ch) {\n\t\t\t\tcase CharCode.OpenParen: this._addToken(TokenType.LParen); break;\n\t\t\t\tcase CharCode.CloseParen: this._addToken(TokenType.RParen); break;\n\n\t\t\t\tcase CharCode.ExclamationMark:\n\t\t\t\t\tif (this._match(CharCode.Equals)) {\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `!==`\n\t\t\t\t\t\tthis._tokens.push({ type: TokenType.NotEq, offset: this._start, isTripleEq });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._addToken(TokenType.Neg);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.SingleQuote: this._quotedString(); break;\n\t\t\t\tcase CharCode.Slash: this._regex(); break;\n\n\t\t\t\tcase CharCode.Equals:\n\t\t\t\t\tif (this._match(CharCode.Equals)) { // support `==`\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `===`\n\t\t\t\t\t\tthis._tokens.push({ type: TokenType.Eq, offset: this._start, isTripleEq });\n\t\t\t\t\t} else if (this._match(CharCode.Tilde)) {\n\t\t\t\t\t\tthis._addToken(TokenType.RegexOp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('==', '=~'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.LessThan: this._addToken(this._match(CharCode.Equals) ? TokenType.LtEq : TokenType.Lt); break;\n\n\t\t\t\tcase CharCode.GreaterThan: this._addToken(this._match(CharCode.Equals) ? TokenType.GtEq : TokenType.Gt); break;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tif (this._match(CharCode.Ampersand)) {\n\t\t\t\t\t\tthis._addToken(TokenType.And);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('&&'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Pipe:\n\t\t\t\t\tif (this._match(CharCode.Pipe)) {\n\t\t\t\t\t\tthis._addToken(TokenType.Or);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('||'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n\t\t\t\tcase CharCode.Space:\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\tcase CharCode.LineFeed:\n\t\t\t\tcase CharCode.NoBreakSpace: // &nbsp\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._string();\n\t\t\t}\n\t\t}\n\n\t\tthis._start = this._current;\n\t\tthis._addToken(TokenType.EOF);\n\n\t\treturn Array.from(this._tokens);\n\t}\n\n\tprivate _match(expected: number): boolean {\n\t\tif (this._isAtEnd()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._input.charCodeAt(this._current) !== expected) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._current++;\n\t\treturn true;\n\t}\n\n\tprivate _advance(): number {\n\t\treturn this._input.charCodeAt(this._current++);\n\t}\n\n\tprivate _peek(): number {\n\t\treturn this._isAtEnd() ? CharCode.Null : this._input.charCodeAt(this._current);\n\t}\n\n\tprivate _addToken(type: TokenTypeWithoutLexeme) {\n\t\tthis._tokens.push({ type, offset: this._start });\n\t}\n\n\tprivate _error(additional?: string) {\n\t\tconst offset = this._start;\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tconst errToken: Token = { type: TokenType.Error, offset: this._start, lexeme };\n\t\tthis._errors.push({ offset, lexeme, additionalInfo: additional });\n\t\tthis._tokens.push(errToken);\n\t}\n\n\t// u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n\tprivate stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n\tprivate _string() {\n\t\tthis.stringRe.lastIndex = this._start;\n\t\tconst match = this.stringRe.exec(this._input);\n\t\tif (match) {\n\t\t\tthis._current = this._start + match[0].length;\n\t\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\t\tconst keyword = Scanner._keywords.get(lexeme);\n\t\t\tif (keyword) {\n\t\t\t\tthis._addToken(keyword);\n\t\t\t} else {\n\t\t\t\tthis._tokens.push({ type: TokenType.Str, lexeme, offset: this._start });\n\t\t\t}\n\t\t}\n\t}\n\n\t// captures the lexeme without the leading and trailing '\n\tprivate _quotedString() {\n\t\twhile (this._peek() !== CharCode.SingleQuote && !this._isAtEnd()) { // TODO@ulugbekna: add support for escaping ' ?\n\t\t\tthis._advance();\n\t\t}\n\n\t\tif (this._isAtEnd()) {\n\t\t\tthis._error(hintDidYouForgetToOpenOrCloseQuote);\n\t\t\treturn;\n\t\t}\n\n\t\t// consume the closing '\n\t\tthis._advance();\n\n\t\tthis._tokens.push({ type: TokenType.QuotedStr, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });\n\t}\n\n\t/*\n\t * Lexing a regex expression: /.../[igsmyu]*\n\t * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n\t *\n\t * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n\t */\n\tprivate _regex() {\n\t\tlet p = this._current;\n\n\t\tlet inEscape = false;\n\t\tlet inCharacterClass = false;\n\t\twhile (true) {\n\t\t\tif (p >= this._input.length) {\n\t\t\t\tthis._current = p;\n\t\t\t\tthis._error(hintDidYouForgetToEscapeSlash);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst ch = this._input.charCodeAt(p);\n\n\t\t\tif (inEscape) { // parsing an escape character\n\t\t\t\tinEscape = false;\n\t\t\t} else if (ch === CharCode.Slash && !inCharacterClass) { // end of regex\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t} else if (ch === CharCode.OpenSquareBracket) {\n\t\t\t\tinCharacterClass = true;\n\t\t\t} else if (ch === CharCode.Backslash) {\n\t\t\t\tinEscape = true;\n\t\t\t} else if (ch === CharCode.CloseSquareBracket) {\n\t\t\t\tinCharacterClass = false;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\t// Consume flags // TODO@ulugbekna: use regex instead\n\t\twhile (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {\n\t\t\tp++;\n\t\t}\n\n\t\tthis._current = p;\n\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tthis._tokens.push({ type: TokenType.RegexStr, lexeme, offset: this._start });\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._current >= this._input.length;\n\t}\n}\n"]}