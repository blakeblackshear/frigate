{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/baseObservable.ts","vs/base/common/observableInternal/observables/baseObservable.ts"],"names":[],"mappings":"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","file":"baseObservable.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, IObserver, IReader, IObservable } from '../base.js';\nimport { DisposableStore } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, getFunctionName } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { keepObserved, recomputeInitiallyAndOnChange } from '../utils/utils.js';\nimport { derivedOpts } from './derived.js';\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservableWithChange<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: DebugOwner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew, debugLocation: DebugLocation = DebugLocation.ofCaller()): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as DebugOwner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t*/\n\tpublic flatten<TNew>(this: IObservable<IObservableWithChange<TNew, any>>): IObservable<TNew> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader)\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly _observers = new Set<IObserver>();\n\n\tconstructor(debugLocation: DebugLocation) {\n\t\tsuper();\n\t\tgetLogger()?.handleObservableCreated(this, debugLocation);\n\t}\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this._observers.size;\n\t\tthis._observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t\tif (len !== this._observers.size) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this._observers.delete(observer);\n\t\tif (deleted && this._observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t\tif (deleted) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n\n\tpublic debugGetObservers() {\n\t\treturn this._observers;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, IObserver, IReader, IObservable } from '../base.js';\nimport { DisposableStore } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, getFunctionName } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { keepObserved, recomputeInitiallyAndOnChange } from '../utils/utils.js';\nimport { derivedOpts } from './derived.js';\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservableWithChange<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: DebugOwner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew, debugLocation: DebugLocation = DebugLocation.ofCaller()): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as DebugOwner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t*/\n\tpublic flatten<TNew>(this: IObservable<IObservableWithChange<TNew, any>>): IObservable<TNew> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader)\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly _observers = new Set<IObserver>();\n\n\tconstructor(debugLocation: DebugLocation) {\n\t\tsuper();\n\t\tgetLogger()?.handleObservableCreated(this, debugLocation);\n\t}\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this._observers.size;\n\t\tthis._observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t\tif (len !== this._observers.size) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this._observers.delete(observer);\n\t\tif (deleted && this._observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t\tif (deleted) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n\n\tpublic debugGetObservers() {\n\t\treturn this._observers;\n\t}\n}\n"]}