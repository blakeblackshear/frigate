{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/touch.ts","vs/base/browser/touch.ts"],"names":[],"mappings":"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","file":"touch.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DomUtils from './dom.js';\nimport { mainWindow } from './window.js';\nimport { memoize } from '../common/decorators.js';\nimport { Event as EventUtils } from '../common/event.js';\nimport { Disposable, IDisposable, markAsSingleton, toDisposable } from '../common/lifecycle.js';\nimport { LinkedList } from '../common/linkedList.js';\n\nexport namespace EventType {\n\texport const Tap = '-monaco-gesturetap';\n\texport const Change = '-monaco-gesturechange';\n\texport const Start = '-monaco-gesturestart';\n\texport const End = '-monaco-gesturesend';\n\texport const Contextmenu = '-monaco-gesturecontextmenu';\n}\n\ninterface TouchData {\n\tid: number;\n\tinitialTarget: EventTarget;\n\tinitialTimeStamp: number;\n\tinitialPageX: number;\n\tinitialPageY: number;\n\trollingTimestamps: number[];\n\trollingPageX: number[];\n\trollingPageY: number[];\n}\n\nexport interface GestureEvent extends MouseEvent {\n\tinitialTarget: EventTarget | undefined;\n\ttranslationX: number;\n\ttranslationY: number;\n\tpageX: number;\n\tpageY: number;\n\ttapCount: number;\n}\n\ninterface Touch {\n\tidentifier: number;\n\tpageX: number;\n\tpageY: number;\n\ttarget: Element;\n}\n\ninterface TouchList {\n\t[i: number]: Touch;\n\tlength: number;\n\titem(index: number): Touch;\n}\n\ninterface TouchEvent extends Event {\n\ttouches: TouchList;\n\ttargetTouches: TouchList;\n\tchangedTouches: TouchList;\n}\n\nexport class Gesture extends Disposable {\n\n\tprivate static readonly SCROLL_FRICTION = -0.005;\n\tprivate static INSTANCE: Gesture;\n\tprivate static readonly HOLD_DELAY = 700;\n\n\tprivate dispatched = false;\n\tprivate readonly targets = new LinkedList<HTMLElement>();\n\tprivate readonly ignoreTargets = new LinkedList<HTMLElement>();\n\tprivate handle: IDisposable | null;\n\n\tprivate readonly activeTouches: { [id: number]: TouchData };\n\n\tprivate _lastSetTapCountTime: number;\n\n\tprivate static readonly CLEAR_TAP_COUNT_TIME = 400; // ms\n\n\n\tprivate constructor() {\n\t\tsuper();\n\n\t\tthis.activeTouches = {};\n\t\tthis.handle = null;\n\t\tthis._lastSetTapCountTime = 0;\n\n\t\tthis._register(EventUtils.runAndSubscribe(DomUtils.onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchstart', (e: TouchEvent) => this.onTouchStart(e), { passive: false }));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchend', (e: TouchEvent) => this.onTouchEnd(window, e)));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchmove', (e: TouchEvent) => this.onTouchMove(e), { passive: false }));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\t}\n\n\tpublic static addTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.targets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\tpublic static ignoreTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.ignoreTargets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\t@memoize\n\tstatic isTouchDevice(): boolean {\n\t\t// `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n\t\t// `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n\t\treturn 'ontouchstart' in mainWindow || navigator.maxTouchPoints > 0;\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTouchStart(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tfor (let i = 0, len = e.targetTouches.length; i < len; i++) {\n\t\t\tconst touch = e.targetTouches.item(i);\n\n\t\t\tthis.activeTouches[touch.identifier] = {\n\t\t\t\tid: touch.identifier,\n\t\t\t\tinitialTarget: touch.target,\n\t\t\t\tinitialTimeStamp: timestamp,\n\t\t\t\tinitialPageX: touch.pageX,\n\t\t\t\tinitialPageY: touch.pageY,\n\t\t\t\trollingTimestamps: [timestamp],\n\t\t\t\trollingPageX: [touch.pageX],\n\t\t\t\trollingPageY: [touch.pageY]\n\t\t\t};\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Start, touch.target);\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate onTouchEnd(targetWindow: Window, e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tconst activeTouchCount = Object.keys(this.activeTouches).length;\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('move of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier],\n\t\t\t\tholdTime = Date.now() - data.initialTimeStamp;\n\n\t\t\tif (holdTime < Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - data.rollingPageX.at(-1)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - data.rollingPageY.at(-1)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n\t\t\t\tevt.pageX = data.rollingPageX.at(-1)!;\n\t\t\t\tevt.pageY = data.rollingPageY.at(-1)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (holdTime >= Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - data.rollingPageX.at(-1)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - data.rollingPageY.at(-1)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n\t\t\t\tevt.pageX = data.rollingPageX.at(-1)!;\n\t\t\t\tevt.pageY = data.rollingPageY.at(-1)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (activeTouchCount === 1) {\n\t\t\t\tconst finalX = data.rollingPageX.at(-1)!;\n\t\t\t\tconst finalY = data.rollingPageY.at(-1)!;\n\n\t\t\t\tconst deltaT = data.rollingTimestamps.at(-1)! - data.rollingTimestamps[0];\n\t\t\t\tconst deltaX = finalX - data.rollingPageX[0];\n\t\t\t\tconst deltaY = finalY - data.rollingPageY[0];\n\n\t\t\t\t// We need to get all the dispatch targets on the start of the inertia event\n\t\t\t\tconst dispatchTo = [...this.targets].filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, timestamp,\t// time now\n\t\t\t\t\tMath.abs(deltaX) / deltaT,\t\t\t\t\t\t// speed\n\t\t\t\t\tdeltaX > 0 ? 1 : -1,\t\t\t\t\t\t\t// x direction\n\t\t\t\t\tfinalX,\t\t\t\t\t\t\t\t\t\t\t// x now\n\t\t\t\t\tMath.abs(deltaY) / deltaT,  \t\t\t\t\t// y speed\n\t\t\t\t\tdeltaY > 0 ? 1 : -1,\t\t\t\t\t\t\t// y direction\n\t\t\t\t\tfinalY\t\t\t\t\t\t\t\t\t\t\t// y now\n\t\t\t\t);\n\t\t\t}\n\n\n\t\t\tthis.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n\t\t\t// forget about this touch\n\t\t\tdelete this.activeTouches[touch.identifier];\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate newGestureEvent(type: string, initialTarget?: EventTarget): GestureEvent {\n\t\tconst event = document.createEvent('CustomEvent') as unknown as GestureEvent;\n\t\tevent.initEvent(type, false, true);\n\t\tevent.initialTarget = initialTarget;\n\t\tevent.tapCount = 0;\n\t\treturn event;\n\t}\n\n\tprivate dispatchEvent(event: GestureEvent): void {\n\t\tif (event.type === EventType.Tap) {\n\t\t\tconst currentTime = (new Date()).getTime();\n\t\t\tlet setTapCount = 0;\n\t\t\tif (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n\t\t\t\tsetTapCount = 1;\n\t\t\t} else {\n\t\t\t\tsetTapCount = 2;\n\t\t\t}\n\n\t\t\tthis._lastSetTapCountTime = currentTime;\n\t\t\tevent.tapCount = setTapCount;\n\t\t} else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n\t\t\t// tap is canceled by scrolling or context menu\n\t\t\tthis._lastSetTapCountTime = 0;\n\t\t}\n\n\t\tif (event.initialTarget instanceof Node) {\n\t\t\tfor (const ignoreTarget of this.ignoreTargets) {\n\t\t\t\tif (ignoreTarget.contains(event.initialTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst targets: [number, HTMLElement][] = [];\n\t\t\tfor (const target of this.targets) {\n\t\t\t\tif (target.contains(event.initialTarget)) {\n\t\t\t\t\tlet depth = 0;\n\t\t\t\t\tlet now: Node | null = event.initialTarget;\n\t\t\t\t\twhile (now && now !== target) {\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\tnow = now.parentElement;\n\t\t\t\t\t}\n\t\t\t\t\ttargets.push([depth, target]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargets.sort((a, b) => a[0] - b[0]);\n\n\t\t\tfor (const [_, target] of targets) {\n\t\t\t\ttarget.dispatchEvent(event);\n\t\t\t\tthis.dispatched = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate inertia(targetWindow: Window, dispatchTo: readonly EventTarget[], t1: number, vX: number, dirX: number, x: number, vY: number, dirY: number, y: number): void {\n\t\tthis.handle = DomUtils.scheduleAtNextAnimationFrame(targetWindow, () => {\n\t\t\tconst now = Date.now();\n\n\t\t\t// velocity: old speed + accel_over_time\n\t\t\tconst deltaT = now - t1;\n\t\t\tlet delta_pos_x = 0, delta_pos_y = 0;\n\t\t\tlet stopped = true;\n\n\t\t\tvX += Gesture.SCROLL_FRICTION * deltaT;\n\t\t\tvY += Gesture.SCROLL_FRICTION * deltaT;\n\n\t\t\tif (vX > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_x = dirX * vX * deltaT;\n\t\t\t}\n\n\t\t\tif (vY > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_y = dirY * vY * deltaT;\n\t\t\t}\n\n\t\t\t// dispatch translation event\n\t\t\tconst evt = this.newGestureEvent(EventType.Change);\n\t\t\tevt.translationX = delta_pos_x;\n\t\t\tevt.translationY = delta_pos_y;\n\t\t\tdispatchTo.forEach(d => d.dispatchEvent(evt));\n\n\t\t\tif (!stopped) {\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onTouchMove(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('end of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier];\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n\t\t\tevt.translationX = touch.pageX - data.rollingPageX.at(-1)!;\n\t\t\tevt.translationY = touch.pageY - data.rollingPageY.at(-1)!;\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t// only keep a few data points, to average the final speed\n\t\t\tif (data.rollingPageX.length > 3) {\n\t\t\t\tdata.rollingPageX.shift();\n\t\t\t\tdata.rollingPageY.shift();\n\t\t\t\tdata.rollingTimestamps.shift();\n\t\t\t}\n\n\t\t\tdata.rollingPageX.push(touch.pageX);\n\t\t\tdata.rollingPageY.push(touch.pageY);\n\t\t\tdata.rollingTimestamps.push(timestamp);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DomUtils from './dom.js';\nimport { mainWindow } from './window.js';\nimport { memoize } from '../common/decorators.js';\nimport { Event as EventUtils } from '../common/event.js';\nimport { Disposable, IDisposable, markAsSingleton, toDisposable } from '../common/lifecycle.js';\nimport { LinkedList } from '../common/linkedList.js';\n\nexport namespace EventType {\n\texport const Tap = '-monaco-gesturetap';\n\texport const Change = '-monaco-gesturechange';\n\texport const Start = '-monaco-gesturestart';\n\texport const End = '-monaco-gesturesend';\n\texport const Contextmenu = '-monaco-gesturecontextmenu';\n}\n\ninterface TouchData {\n\tid: number;\n\tinitialTarget: EventTarget;\n\tinitialTimeStamp: number;\n\tinitialPageX: number;\n\tinitialPageY: number;\n\trollingTimestamps: number[];\n\trollingPageX: number[];\n\trollingPageY: number[];\n}\n\nexport interface GestureEvent extends MouseEvent {\n\tinitialTarget: EventTarget | undefined;\n\ttranslationX: number;\n\ttranslationY: number;\n\tpageX: number;\n\tpageY: number;\n\ttapCount: number;\n}\n\ninterface Touch {\n\tidentifier: number;\n\tpageX: number;\n\tpageY: number;\n\ttarget: Element;\n}\n\ninterface TouchList {\n\t[i: number]: Touch;\n\tlength: number;\n\titem(index: number): Touch;\n}\n\ninterface TouchEvent extends Event {\n\ttouches: TouchList;\n\ttargetTouches: TouchList;\n\tchangedTouches: TouchList;\n}\n\nexport class Gesture extends Disposable {\n\n\tprivate static readonly SCROLL_FRICTION = -0.005;\n\tprivate static INSTANCE: Gesture;\n\tprivate static readonly HOLD_DELAY = 700;\n\n\tprivate dispatched = false;\n\tprivate readonly targets = new LinkedList<HTMLElement>();\n\tprivate readonly ignoreTargets = new LinkedList<HTMLElement>();\n\tprivate handle: IDisposable | null;\n\n\tprivate readonly activeTouches: { [id: number]: TouchData };\n\n\tprivate _lastSetTapCountTime: number;\n\n\tprivate static readonly CLEAR_TAP_COUNT_TIME = 400; // ms\n\n\n\tprivate constructor() {\n\t\tsuper();\n\n\t\tthis.activeTouches = {};\n\t\tthis.handle = null;\n\t\tthis._lastSetTapCountTime = 0;\n\n\t\tthis._register(EventUtils.runAndSubscribe(DomUtils.onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchstart', (e: TouchEvent) => this.onTouchStart(e), { passive: false }));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchend', (e: TouchEvent) => this.onTouchEnd(window, e)));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchmove', (e: TouchEvent) => this.onTouchMove(e), { passive: false }));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\t}\n\n\tpublic static addTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.targets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\tpublic static ignoreTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.ignoreTargets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\t@memoize\n\tstatic isTouchDevice(): boolean {\n\t\t// `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n\t\t// `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n\t\treturn 'ontouchstart' in mainWindow || navigator.maxTouchPoints > 0;\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTouchStart(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tfor (let i = 0, len = e.targetTouches.length; i < len; i++) {\n\t\t\tconst touch = e.targetTouches.item(i);\n\n\t\t\tthis.activeTouches[touch.identifier] = {\n\t\t\t\tid: touch.identifier,\n\t\t\t\tinitialTarget: touch.target,\n\t\t\t\tinitialTimeStamp: timestamp,\n\t\t\t\tinitialPageX: touch.pageX,\n\t\t\t\tinitialPageY: touch.pageY,\n\t\t\t\trollingTimestamps: [timestamp],\n\t\t\t\trollingPageX: [touch.pageX],\n\t\t\t\trollingPageY: [touch.pageY]\n\t\t\t};\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Start, touch.target);\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate onTouchEnd(targetWindow: Window, e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tconst activeTouchCount = Object.keys(this.activeTouches).length;\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('move of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier],\n\t\t\t\tholdTime = Date.now() - data.initialTimeStamp;\n\n\t\t\tif (holdTime < Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - data.rollingPageX.at(-1)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - data.rollingPageY.at(-1)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n\t\t\t\tevt.pageX = data.rollingPageX.at(-1)!;\n\t\t\t\tevt.pageY = data.rollingPageY.at(-1)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (holdTime >= Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - data.rollingPageX.at(-1)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - data.rollingPageY.at(-1)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n\t\t\t\tevt.pageX = data.rollingPageX.at(-1)!;\n\t\t\t\tevt.pageY = data.rollingPageY.at(-1)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (activeTouchCount === 1) {\n\t\t\t\tconst finalX = data.rollingPageX.at(-1)!;\n\t\t\t\tconst finalY = data.rollingPageY.at(-1)!;\n\n\t\t\t\tconst deltaT = data.rollingTimestamps.at(-1)! - data.rollingTimestamps[0];\n\t\t\t\tconst deltaX = finalX - data.rollingPageX[0];\n\t\t\t\tconst deltaY = finalY - data.rollingPageY[0];\n\n\t\t\t\t// We need to get all the dispatch targets on the start of the inertia event\n\t\t\t\tconst dispatchTo = [...this.targets].filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, timestamp,\t// time now\n\t\t\t\t\tMath.abs(deltaX) / deltaT,\t\t\t\t\t\t// speed\n\t\t\t\t\tdeltaX > 0 ? 1 : -1,\t\t\t\t\t\t\t// x direction\n\t\t\t\t\tfinalX,\t\t\t\t\t\t\t\t\t\t\t// x now\n\t\t\t\t\tMath.abs(deltaY) / deltaT,  \t\t\t\t\t// y speed\n\t\t\t\t\tdeltaY > 0 ? 1 : -1,\t\t\t\t\t\t\t// y direction\n\t\t\t\t\tfinalY\t\t\t\t\t\t\t\t\t\t\t// y now\n\t\t\t\t);\n\t\t\t}\n\n\n\t\t\tthis.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n\t\t\t// forget about this touch\n\t\t\tdelete this.activeTouches[touch.identifier];\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate newGestureEvent(type: string, initialTarget?: EventTarget): GestureEvent {\n\t\tconst event = document.createEvent('CustomEvent') as unknown as GestureEvent;\n\t\tevent.initEvent(type, false, true);\n\t\tevent.initialTarget = initialTarget;\n\t\tevent.tapCount = 0;\n\t\treturn event;\n\t}\n\n\tprivate dispatchEvent(event: GestureEvent): void {\n\t\tif (event.type === EventType.Tap) {\n\t\t\tconst currentTime = (new Date()).getTime();\n\t\t\tlet setTapCount = 0;\n\t\t\tif (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n\t\t\t\tsetTapCount = 1;\n\t\t\t} else {\n\t\t\t\tsetTapCount = 2;\n\t\t\t}\n\n\t\t\tthis._lastSetTapCountTime = currentTime;\n\t\t\tevent.tapCount = setTapCount;\n\t\t} else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n\t\t\t// tap is canceled by scrolling or context menu\n\t\t\tthis._lastSetTapCountTime = 0;\n\t\t}\n\n\t\tif (event.initialTarget instanceof Node) {\n\t\t\tfor (const ignoreTarget of this.ignoreTargets) {\n\t\t\t\tif (ignoreTarget.contains(event.initialTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst targets: [number, HTMLElement][] = [];\n\t\t\tfor (const target of this.targets) {\n\t\t\t\tif (target.contains(event.initialTarget)) {\n\t\t\t\t\tlet depth = 0;\n\t\t\t\t\tlet now: Node | null = event.initialTarget;\n\t\t\t\t\twhile (now && now !== target) {\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\tnow = now.parentElement;\n\t\t\t\t\t}\n\t\t\t\t\ttargets.push([depth, target]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargets.sort((a, b) => a[0] - b[0]);\n\n\t\t\tfor (const [_, target] of targets) {\n\t\t\t\ttarget.dispatchEvent(event);\n\t\t\t\tthis.dispatched = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate inertia(targetWindow: Window, dispatchTo: readonly EventTarget[], t1: number, vX: number, dirX: number, x: number, vY: number, dirY: number, y: number): void {\n\t\tthis.handle = DomUtils.scheduleAtNextAnimationFrame(targetWindow, () => {\n\t\t\tconst now = Date.now();\n\n\t\t\t// velocity: old speed + accel_over_time\n\t\t\tconst deltaT = now - t1;\n\t\t\tlet delta_pos_x = 0, delta_pos_y = 0;\n\t\t\tlet stopped = true;\n\n\t\t\tvX += Gesture.SCROLL_FRICTION * deltaT;\n\t\t\tvY += Gesture.SCROLL_FRICTION * deltaT;\n\n\t\t\tif (vX > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_x = dirX * vX * deltaT;\n\t\t\t}\n\n\t\t\tif (vY > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_y = dirY * vY * deltaT;\n\t\t\t}\n\n\t\t\t// dispatch translation event\n\t\t\tconst evt = this.newGestureEvent(EventType.Change);\n\t\t\tevt.translationX = delta_pos_x;\n\t\t\tevt.translationY = delta_pos_y;\n\t\t\tdispatchTo.forEach(d => d.dispatchEvent(evt));\n\n\t\t\tif (!stopped) {\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onTouchMove(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('end of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier];\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n\t\t\tevt.translationX = touch.pageX - data.rollingPageX.at(-1)!;\n\t\t\tevt.translationY = touch.pageY - data.rollingPageY.at(-1)!;\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t// only keep a few data points, to average the final speed\n\t\t\tif (data.rollingPageX.length > 3) {\n\t\t\t\tdata.rollingPageX.shift();\n\t\t\t\tdata.rollingPageY.shift();\n\t\t\t\tdata.rollingTimestamps.shift();\n\t\t\t}\n\n\t\t\tdata.rollingPageX.push(touch.pageX);\n\t\t\tdata.rollingPageY.push(touch.pageY);\n\t\t\tdata.rollingTimestamps.push(timestamp);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n}\n"]}