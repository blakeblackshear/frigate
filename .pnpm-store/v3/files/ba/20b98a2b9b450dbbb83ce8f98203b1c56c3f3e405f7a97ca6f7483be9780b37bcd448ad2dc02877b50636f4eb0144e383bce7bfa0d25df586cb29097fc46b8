{"version":3,"sources":["../src/index.ts","../src/emojify.ts","../src/findByName.ts","../src/data.ts","../src/utils.ts","../src/findByCode.ts","../src/find.ts","../src/get.ts","../src/has.ts","../src/random.ts","../src/replace.ts","../src/search.ts","../src/strip.ts","../src/unemojify.ts","../src/which.ts"],"sourcesContent":["export * from './emojify.js'\nexport * from './find.js'\nexport * from './get.js'\nexport * from './has.js'\nexport * from './random.js'\nexport * from './replace.js'\nexport * from './search.js'\nexport * from './strip.js'\nexport * from './unemojify.js'\nexport * from './which.js'\n","import is from '@sindresorhus/is'\n\nimport { findByName } from './findByName.js'\nimport { asFunction, normalizeName } from './utils.js'\n\nexport type EmojifyFormat = (\n  name: string,\n  part?: string,\n  input?: string,\n) => string\n\nexport interface EmojifyOptions {\n  /**\n   * The string to fallback to if an emoji was not found.\n   */\n  fallback?: ((part: string) => string) | string\n\n  /**\n   * Adds a middleware layer to modify each matched emoji after parsing.\n   */\n  format?: EmojifyFormat\n}\n\n/**\n * Parse all markdown-encoded emojis in a string.\n */\nexport const emojify = (\n  input: string,\n  { fallback, format = name => name }: EmojifyOptions = {},\n) => {\n  const fallbackFunction =\n    fallback === undefined ? fallback : asFunction(fallback)\n\n  is.assert.string(input)\n  is.assert.any([is.default.undefined, is.default.function_], fallbackFunction)\n  is.assert.function_(format)\n\n  return input.replace(/:[\\w\\-+]+:/g, part => {\n    const found = findByName(part)\n    if (found) {\n      return format(found.emoji, part, input)\n    }\n\n    if (fallbackFunction) {\n      return format(fallbackFunction(normalizeName(part)))\n    }\n\n    return format(part)\n  })\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName } from './data.js'\nimport { normalizeName } from './utils.js'\n\nexport const findByName = (name: string) => {\n  assert.string(name)\n\n  const nameNormalized = normalizeName(name)\n  const emoji = emojiCodesByName.get(nameNormalized)\n\n  return emoji ? { emoji, key: nameNormalized } : undefined\n}\n","import emojilib from 'emojilib'\n\nimport { normalizeCode } from './utils.js'\n\nexport interface Emoji {\n  emoji: string\n  key: string\n}\n\nexport const emojiData = Object.entries(emojilib.lib).map(\n  ([name, { char: emoji }]) => [name, emoji] as const,\n)\n\nexport const emojiCodesByName = new Map(emojiData)\n\nexport const emojiNamesByCode = new Map(\n  emojiData.map(([name, emoji]) => [normalizeCode(emoji), name]),\n)\n","import charRegex from 'char-regex'\n\nexport const charRegexMatcher = charRegex()\n\nexport function asFunction<T extends PropertyKey, Args extends unknown[]>(\n  input: ((...args: Args) => T) | T,\n): (...args: Args) => T {\n  return typeof input === 'function' ? input : () => input\n}\n\n/**\n * Non spacing mark contained by some emoticons (65039 - 'Ô∏è' - 0xFE0F).\n *\n * It's the 'Variant Form', which provides more information so that emoticons\n * can be rendered as more colorful graphics. FE0E is a unicode text version\n * whereas FE0F should be rendered as a graphical version.\n * The code gracefully degrades.\n */\nconst NON_SPACING_MARK = String.fromCharCode(65039)\n\nconst nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g')\n\n/**\n * Removes the non-spacing-mark from the emoji code.\n *\n * Never send a stripped version to clients, as it kills graphical emoticons.\n */\nexport function normalizeCode(code: string) {\n  return code.replace(nonSpacingRegex, '')\n}\n\nexport function normalizeName(name: string) {\n  return /:.+:/.test(name) ? name.slice(1, -1) : name\n}\n\nexport function randomItem<T>(array: T[]) {\n  return array[Math.floor(Math.random() * array.length)]\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiNamesByCode } from './data.js'\nimport { normalizeCode } from './utils.js'\n\nexport const findByCode = (code: string) => {\n  assert.string(code)\n\n  const emojiNormalized = normalizeCode(code)\n  const key = emojiNamesByCode.get(emojiNormalized)\n\n  return key ? { emoji: emojiNormalized, key } : undefined\n}\n","import { findByCode } from './findByCode.js'\nimport { findByName } from './findByName.js'\n\n/**\n * Get the name and character of an emoji.\n */\nexport const find = (codeOrName: string) => {\n  return findByCode(codeOrName) ?? findByName(codeOrName)\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName } from './data.js'\nimport { normalizeName } from './utils.js'\n\n/**\n * Get an emoji from an emoji name.\n */\nexport const get = (codeOrName: string) => {\n  assert.string(codeOrName)\n\n  return emojiCodesByName.get(normalizeName(codeOrName))\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName, emojiNamesByCode } from './data.js'\nimport { normalizeCode, normalizeName } from './utils.js'\n\n/**\n * Check if this library supports a specific emoji.\n */\nexport const has = (codeOrName: string) => {\n  assert.string(codeOrName)\n\n  return (\n    emojiCodesByName.has(normalizeName(codeOrName)) ||\n    emojiNamesByCode.has(normalizeCode(codeOrName))\n  )\n}\n","import { emojiData } from './data.js'\nimport { randomItem } from './utils.js'\n\n/**\n * Get a random emoji.\n */\nexport const random = () => {\n  const [name, emoji] = randomItem(emojiData)\n  return { emoji, name }\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { Emoji } from './data.js'\nimport { findByCode } from './findByCode.js'\nimport { asFunction, charRegexMatcher } from './utils.js'\n\nexport type ReplaceReplacement = (\n  emoji: Emoji,\n  index: number,\n  string: string,\n) => string\n\n/**\n * Replace the emojis in a string.\n */\nexport const replace = (\n  input: string,\n  replacement: ReplaceReplacement | string,\n  { preserveSpaces = false } = {},\n) => {\n  const replace = asFunction(replacement)\n\n  assert.string(input)\n  assert.function_(replace)\n  assert.boolean(preserveSpaces)\n\n  const characters = input.match(charRegexMatcher)\n  if (characters === null) {\n    return input\n  }\n\n  return characters\n    .map((character, index) => {\n      const found = findByCode(character)\n      if (!found) {\n        return character\n      }\n\n      if (!preserveSpaces && characters[index + 1] === ' ') {\n        characters[index + 1] = ''\n      }\n\n      return replace(found, index, input)\n    })\n    .join('')\n}\n","import is, { assert } from '@sindresorhus/is'\n\nimport { emojiData } from './data.js'\nimport { normalizeName } from './utils.js'\n\n/**\n * Search for emojis containing the provided name or pattern in their name.\n */\nexport const search = (keyword: RegExp | string) => {\n  assert.any([is.default.string, is.default.regExp], keyword)\n\n  if (is.default.string(keyword)) {\n    keyword = normalizeName(keyword)\n  }\n\n  if (is.default.regExp(keyword)) {\n    const normalizedPattern = normalizeName(keyword.source)\n    keyword = new RegExp(normalizedPattern)\n  }\n\n  return emojiData\n    .filter(([name]) => name.match(keyword))\n    .map(([name, emoji]) => ({ emoji, name }))\n}\n","import { replace } from './replace.js'\n\nexport interface StripOptions {\n  /**\n   * Whether to keep the extra space after a stripped emoji.\n   */\n  preserveSpaces?: boolean\n}\n\n/**\n * Remove all the emojis from a string.\n */\nexport const strip = (input: string, { preserveSpaces }: StripOptions = {}) =>\n  replace(input, '', { preserveSpaces })\n","import { assert } from '@sindresorhus/is'\n\nimport { charRegexMatcher } from './utils.js'\nimport { which } from './which.js'\n\n/**\n * Convert all emojis in a string to their markdown-encoded counterparts.\n */\nexport const unemojify = (input: string) => {\n  assert.string(input)\n\n  const characters = input.match(charRegexMatcher)\n  if (characters === null) {\n    return input\n  }\n\n  return characters\n    .map(character => which(character, { markdown: true }) ?? character)\n    .join('')\n}\n","import { assert } from '@sindresorhus/is'\nimport skinTone from 'skin-tone'\n\nimport { findByCode } from './findByCode.js'\n\nexport interface WhichOptions {\n  markdown?: boolean\n}\n\n/**\n * Get an emoji name from an emoji.\n */\nexport const which = (\n  emoji: string,\n  { markdown = false }: WhichOptions = {},\n) => {\n  assert.string(emoji)\n  assert.boolean(markdown)\n\n  const result = findByCode(skinTone(emoji, 'none'))\n  if (result === undefined) {\n    return undefined\n  }\n\n  return markdown ? `:${result.key}:` : result.key\n}\n"],"mappings":"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","names":["import_is","charRegex","emojilib","is","import_is","import_is","import_is","import_is","replace","import_is","is","import_is","import_is","skinTone"]}