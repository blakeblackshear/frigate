{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/naturalLanguage/korean.ts","vs/base/common/naturalLanguage/korean.ts"],"names":[],"mappings":"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","file":"korean.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// allow-any-unicode-comment-file\n\n/**\n * Gets alternative Korean characters for the character code. This will return the ascii\n * character code(s) that a Hangul character may have been input with using a qwerty layout.\n *\n * This only aims to cover modern (not archaic) Hangul syllables.\n *\n * @param code The character code to get alternate characters for\n */\nexport function getKoreanAltChars(code: number): ArrayLike<number> | undefined {\n\tconst result = disassembleKorean(code);\n\tif (result && result.length > 0) {\n\t\treturn new Uint32Array(result);\n\t}\n\treturn undefined;\n}\n\nlet codeBufferLength = 0;\nconst codeBuffer = new Uint32Array(10);\nfunction disassembleKorean(code: number): Uint32Array | undefined {\n\tcodeBufferLength = 0;\n\n\t// Initial consonants (초성)\n\tgetCodesFromArray(code, modernConsonants, HangulRangeStartCode.InitialConsonant);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Vowels (중성)\n\tgetCodesFromArray(code, modernVowels, HangulRangeStartCode.Vowel);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Final consonants (종성)\n\tgetCodesFromArray(code, modernFinalConsonants, HangulRangeStartCode.FinalConsonant);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Hangul Compatibility Jamo\n\tgetCodesFromArray(code, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\tif (codeBufferLength) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Hangul Syllables\n\tif (code >= 0xAC00 && code <= 0xD7A3) {\n\t\tconst hangulIndex = code - 0xAC00;\n\t\tconst vowelAndFinalConsonantProduct = hangulIndex % 588;\n\n\t\t// 0-based starting at 0x1100\n\t\tconst initialConsonantIndex = Math.floor(hangulIndex / 588);\n\t\t// 0-based starting at 0x1161\n\t\tconst vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);\n\t\t// 0-based starting at 0x11A8\n\t\t// Subtract 1 as the standard algorithm uses the 0 index to represent no\n\t\t// final consonant\n\t\tconst finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;\n\n\t\tif (initialConsonantIndex < modernConsonants.length) {\n\t\t\tgetCodesFromArray(initialConsonantIndex, modernConsonants, 0);\n\t\t} else if (HangulRangeStartCode.InitialConsonant + initialConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\tgetCodesFromArray(HangulRangeStartCode.InitialConsonant + initialConsonantIndex, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t}\n\n\t\tif (vowelIndex < modernVowels.length) {\n\t\t\tgetCodesFromArray(vowelIndex, modernVowels, 0);\n\t\t} else if (HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\tgetCodesFromArray(HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t}\n\n\t\tif (finalConsonantIndex >= 0) {\n\t\t\tif (finalConsonantIndex < modernFinalConsonants.length) {\n\t\t\t\tgetCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);\n\t\t\t} else if (HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\t\tgetCodesFromArray(HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t\t}\n\t\t}\n\n\t\tif (codeBufferLength > 0) {\n\t\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction getCodesFromArray(code: number, array: ArrayLike<number>, arrayStartIndex: number): void {\n\t// Verify the code is within the array's range\n\tif (code >= arrayStartIndex && code < arrayStartIndex + array.length) {\n\t\taddCodesToBuffer(array[code - arrayStartIndex]);\n\t}\n}\n\nfunction addCodesToBuffer(codes: number): void {\n\t// NUL is ignored, this is used for archaic characters to avoid using a Map\n\t// for the data\n\tif (codes === AsciiCode.NUL) {\n\t\treturn;\n\t}\n\t// Number stored in format: OptionalThirdCode << 16 | OptionalSecondCode << 8 | Code\n\tcodeBuffer[codeBufferLength++] = codes & 0xFF;\n\tif (codes >> 8) {\n\t\tcodeBuffer[codeBufferLength++] = (codes >> 8) & 0xFF;\n\t}\n\tif (codes >> 16) {\n\t\tcodeBuffer[codeBufferLength++] = (codes >> 16) & 0xFF;\n\t}\n}\n\nconst enum HangulRangeStartCode {\n\tInitialConsonant = 0x1100,\n\tVowel = 0x1161,\n\tFinalConsonant = 0x11A8,\n\tCompatibilityJamo = 0x3131,\n}\n\nconst enum AsciiCode {\n\tNUL = 0,\n\tA = 65,\n\tB = 66,\n\tC = 67,\n\tD = 68,\n\tE = 69,\n\tF = 70,\n\tG = 71,\n\tH = 72,\n\tI = 73,\n\tJ = 74,\n\tK = 75,\n\tL = 76,\n\tM = 77,\n\tN = 78,\n\tO = 79,\n\tP = 80,\n\tQ = 81,\n\tR = 82,\n\tS = 83,\n\tT = 84,\n\tU = 85,\n\tV = 86,\n\tW = 87,\n\tX = 88,\n\tY = 89,\n\tZ = 90,\n\ta = 97,\n\tb = 98,\n\tc = 99,\n\td = 100,\n\te = 101,\n\tf = 102,\n\tg = 103,\n\th = 104,\n\ti = 105,\n\tj = 106,\n\tk = 107,\n\tl = 108,\n\tm = 109,\n\tn = 110,\n\to = 111,\n\tp = 112,\n\tq = 113,\n\tr = 114,\n\ts = 115,\n\tt = 116,\n\tu = 117,\n\tv = 118,\n\tw = 119,\n\tx = 120,\n\ty = 121,\n\tz = 122,\n}\n\n/**\n * Numbers that represent multiple ascii codes. These are precomputed at compile time to reduce\n * bundle and runtime overhead.\n */\nconst enum AsciiCodeCombo {\n\tfa = AsciiCode.a << 8 | AsciiCode.f,\n\tfg = AsciiCode.g << 8 | AsciiCode.f,\n\tfq = AsciiCode.q << 8 | AsciiCode.f,\n\tfr = AsciiCode.r << 8 | AsciiCode.f,\n\tft = AsciiCode.t << 8 | AsciiCode.f,\n\tfv = AsciiCode.v << 8 | AsciiCode.f,\n\tfx = AsciiCode.x << 8 | AsciiCode.f,\n\thk = AsciiCode.k << 8 | AsciiCode.h,\n\thl = AsciiCode.l << 8 | AsciiCode.h,\n\tho = AsciiCode.o << 8 | AsciiCode.h,\n\tml = AsciiCode.l << 8 | AsciiCode.m,\n\tnj = AsciiCode.j << 8 | AsciiCode.n,\n\tnl = AsciiCode.l << 8 | AsciiCode.n,\n\tnp = AsciiCode.p << 8 | AsciiCode.n,\n\tqt = AsciiCode.t << 8 | AsciiCode.q,\n\trt = AsciiCode.t << 8 | AsciiCode.r,\n\tsg = AsciiCode.g << 8 | AsciiCode.s,\n\tsw = AsciiCode.w << 8 | AsciiCode.s,\n}\n\n/**\n * Hangul Jamo - Modern consonants #1\n *\n * Range U+1100..U+1112\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+110x | ᄀ | ᄁ | ᄂ | ᄃ | ᄄ | ᄅ | ᄆ | ᄇ | ᄈ | ᄉ | ᄊ | ᄋ | ᄌ | ᄍ | ᄎ | ᄏ |\n * | U+111x | ᄐ | ᄑ | ᄒ |\n */\nconst modernConsonants = new Uint8Array([\n\tAsciiCode.r, // ㄱ\n\tAsciiCode.R, // ㄲ\n\tAsciiCode.s, // ㄴ\n\tAsciiCode.e, // ㄷ\n\tAsciiCode.E, // ㄸ\n\tAsciiCode.f, // ㄹ\n\tAsciiCode.a, // ㅁ\n\tAsciiCode.q, // ㅂ\n\tAsciiCode.Q, // ㅃ\n\tAsciiCode.t, // ㅅ\n\tAsciiCode.T, // ㅆ\n\tAsciiCode.d, // ㅇ\n\tAsciiCode.w, // ㅈ\n\tAsciiCode.W, // ㅉ\n\tAsciiCode.c, // ㅊ\n\tAsciiCode.z, // ㅋ\n\tAsciiCode.x, // ㅌ\n\tAsciiCode.v, // ㅍ\n\tAsciiCode.g, // ㅎ\n]);\n\n/**\n * Hangul Jamo - Modern Vowels\n *\n * Range U+1161..U+1175\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+116x |   | ᅡ | ᅢ | ᅣ | ᅤ | ᅥ | ᅦ | ᅧ | ᅨ | ᅩ | ᅪ | ᅫ | ᅬ | ᅭ | ᅮ | ᅯ |\n * | U+117x | ᅰ | ᅱ | ᅲ | ᅳ | ᅴ | ᅵ |\n */\nconst modernVowels = new Uint16Array([\n\tAsciiCode.k,       //  -> ㅏ\n\tAsciiCode.o,       //  -> ㅐ\n\tAsciiCode.i,       //  -> ㅑ\n\tAsciiCode.O,       //  -> ㅒ\n\tAsciiCode.j,       //  -> ㅓ\n\tAsciiCode.p,       //  -> ㅔ\n\tAsciiCode.u,       //  -> ㅕ\n\tAsciiCode.P,       //  -> ㅖ\n\tAsciiCode.h,       //  -> ㅗ\n\tAsciiCodeCombo.hk, //  -> ㅘ\n\tAsciiCodeCombo.ho, //  -> ㅙ\n\tAsciiCodeCombo.hl, //  -> ㅚ\n\tAsciiCode.y,       //  -> ㅛ\n\tAsciiCode.n,       //  -> ㅜ\n\tAsciiCodeCombo.nj, //  -> ㅝ\n\tAsciiCodeCombo.np, //  -> ㅞ\n\tAsciiCodeCombo.nl, //  -> ㅟ\n\tAsciiCode.b,       //  -> ㅠ\n\tAsciiCode.m,       //  -> ㅡ\n\tAsciiCodeCombo.ml, //  -> ㅢ\n\tAsciiCode.l,       //  -> ㅣ\n]);\n\n/**\n * Hangul Jamo - Modern Consonants #2\n *\n * Range U+11A8..U+11C2\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+11Ax |   |   |   |   |   |   |   |   | ᆨ | ᆩ | ᆪ | ᆫ | ᆬ | ᆭ | ᆮ | ᆯ |\n * | U+11Bx | ᆰ | ᆱ | ᆲ | ᆳ | ᆴ | ᆵ | ᆶ | ᆷ | ᆸ | ᆹ | ᆺ | ᆻ | ᆼ | ᆽ | ᆾ | ᆿ |\n * | U+11Cx | ᇀ | ᇁ | ᇂ |\n */\nconst modernFinalConsonants = new Uint16Array([\n\tAsciiCode.r,       // ㄱ\n\tAsciiCode.R,       // ㄲ\n\tAsciiCodeCombo.rt, // ㄳ\n\tAsciiCode.s,       // ㄴ\n\tAsciiCodeCombo.sw, // ㄵ\n\tAsciiCodeCombo.sg, // ㄶ\n\tAsciiCode.e,       // ㄷ\n\tAsciiCode.f,       // ㄹ\n\tAsciiCodeCombo.fr, // ㄺ\n\tAsciiCodeCombo.fa, // ㄻ\n\tAsciiCodeCombo.fq, // ㄼ\n\tAsciiCodeCombo.ft, // ㄽ\n\tAsciiCodeCombo.fx, // ㄾ\n\tAsciiCodeCombo.fv, // ㄿ\n\tAsciiCodeCombo.fg, // ㅀ\n\tAsciiCode.a,       // ㅁ\n\tAsciiCode.q,       // ㅂ\n\tAsciiCodeCombo.qt, // ㅄ\n\tAsciiCode.t,       // ㅅ\n\tAsciiCode.T,       // ㅆ\n\tAsciiCode.d,       // ㅇ\n\tAsciiCode.w,       // ㅈ\n\tAsciiCode.c,       // ㅊ\n\tAsciiCode.z,       // ㅋ\n\tAsciiCode.x,       // ㅌ\n\tAsciiCode.v,       // ㅍ\n\tAsciiCode.g,       // ㅎ\n]);\n\n/**\n * Hangul Compatibility Jamo\n *\n * Range U+3131..U+318F\n *\n * This includes range includes archaic jamo which we don't consider, these are\n * given the NUL character code in order to be ignored.\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+313x |   | ㄱ | ㄲ | ㄳ | ㄴ | ㄵ | ㄶ | ㄷ | ㄸ | ㄹ | ㄺ | ㄻ | ㄼ | ㄽ | ㄾ | ㄿ |\n * | U+314x | ㅀ | ㅁ | ㅂ | ㅃ | ㅄ | ㅅ | ㅆ | ㅇ | ㅈ | ㅉ | ㅊ | ㅋ | ㅌ | ㅍ | ㅎ | ㅏ |\n * | U+315x | ㅐ | ㅑ | ㅒ | ㅓ | ㅔ | ㅕ | ㅖ | ㅗ | ㅘ | ㅙ | ㅚ | ㅛ | ㅜ | ㅝ | ㅞ | ㅟ |\n * | U+316x | ㅠ | ㅡ | ㅢ | ㅣ | HF | ㅥ | ㅦ | ㅧ | ㅨ | ㅩ | ㅪ | ㅫ | ㅬ | ㅭ | ㅮ | ㅯ |\n * | U+317x | ㅰ | ㅱ | ㅲ | ㅳ | ㅴ | ㅵ | ㅶ | ㅷ | ㅸ | ㅹ | ㅺ | ㅻ | ㅼ | ㅽ | ㅾ | ㅿ |\n * | U+318x | ㆀ | ㆁ | ㆂ | ㆃ | ㆄ | ㆅ | ㆆ | ㆇ | ㆈ | ㆉ | ㆊ | ㆋ | ㆌ | ㆍ | ㆎ |\n */\nconst compatibilityJamo = new Uint16Array([\n\tAsciiCode.r,        // ㄱ\n\tAsciiCode.R,        // ㄲ\n\tAsciiCodeCombo.rt,  // ㄳ\n\tAsciiCode.s,        // ㄴ\n\tAsciiCodeCombo.sw,  // ㄵ\n\tAsciiCodeCombo.sg,  // ㄶ\n\tAsciiCode.e,        // ㄷ\n\tAsciiCode.E,        // ㄸ\n\tAsciiCode.f,        // ㄹ\n\tAsciiCodeCombo.fr,  // ㄺ\n\tAsciiCodeCombo.fa,  // ㄻ\n\tAsciiCodeCombo.fq,  // ㄼ\n\tAsciiCodeCombo.ft,  // ㄽ\n\tAsciiCodeCombo.fx,  // ㄾ\n\tAsciiCodeCombo.fv,  // ㄿ\n\tAsciiCodeCombo.fg,  // ㅀ\n\tAsciiCode.a,        // ㅁ\n\tAsciiCode.q,        // ㅂ\n\tAsciiCode.Q,        // ㅃ\n\tAsciiCodeCombo.qt,  // ㅄ\n\tAsciiCode.t,        // ㅅ\n\tAsciiCode.T,        // ㅆ\n\tAsciiCode.d,        // ㅇ\n\tAsciiCode.w,        // ㅈ\n\tAsciiCode.W,        // ㅉ\n\tAsciiCode.c,        // ㅊ\n\tAsciiCode.z,        // ㅋ\n\tAsciiCode.x,        // ㅌ\n\tAsciiCode.v,        // ㅍ\n\tAsciiCode.g,        // ㅎ\n\tAsciiCode.k,        // ㅏ\n\tAsciiCode.o,        // ㅐ\n\tAsciiCode.i,        // ㅑ\n\tAsciiCode.O,        // ㅒ\n\tAsciiCode.j,        // ㅓ\n\tAsciiCode.p,        // ㅔ\n\tAsciiCode.u,        // ㅕ\n\tAsciiCode.P,        // ㅖ\n\tAsciiCode.h,        // ㅗ\n\tAsciiCodeCombo.hk,  // ㅘ\n\tAsciiCodeCombo.ho,  // ㅙ\n\tAsciiCodeCombo.hl,  // ㅚ\n\tAsciiCode.y,        // ㅛ\n\tAsciiCode.n,        // ㅜ\n\tAsciiCodeCombo.nj,  // ㅝ\n\tAsciiCodeCombo.np,  // ㅞ\n\tAsciiCodeCombo.nl,  // ㅟ\n\tAsciiCode.b,        // ㅠ\n\tAsciiCode.m,        // ㅡ\n\tAsciiCodeCombo.ml,  // ㅢ\n\tAsciiCode.l,        // ㅣ\n\t// HF: Hangul Filler (everything after this is archaic)\n\t// ㅥ\n\t// ㅦ\n\t// ㅧ\n\t// ㅨ\n\t// ㅩ\n\t// ㅪ\n\t// ㅫ\n\t// ㅬ\n\t// ㅮ\n\t// ㅯ\n\t// ㅰ\n\t// ㅱ\n\t// ㅲ\n\t// ㅳ\n\t// ㅴ\n\t// ㅵ\n\t// ㅶ\n\t// ㅷ\n\t// ㅸ\n\t// ㅹ\n\t// ㅺ\n\t// ㅻ\n\t// ㅼ\n\t// ㅽ\n\t// ㅾ\n\t// ㅿ\n\t// ㆀ\n\t// ㆁ\n\t// ㆂ\n\t// ㆃ\n\t// ㆄ\n\t// ㆅ\n\t// ㆆ\n\t// ㆇ\n\t// ㆈ\n\t// ㆉ\n\t// ㆊ\n\t// ㆋ\n\t// ㆌ\n\t// ㆍ\n\t// ㆎ\n]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// allow-any-unicode-comment-file\n\n/**\n * Gets alternative Korean characters for the character code. This will return the ascii\n * character code(s) that a Hangul character may have been input with using a qwerty layout.\n *\n * This only aims to cover modern (not archaic) Hangul syllables.\n *\n * @param code The character code to get alternate characters for\n */\nexport function getKoreanAltChars(code: number): ArrayLike<number> | undefined {\n\tconst result = disassembleKorean(code);\n\tif (result && result.length > 0) {\n\t\treturn new Uint32Array(result);\n\t}\n\treturn undefined;\n}\n\nlet codeBufferLength = 0;\nconst codeBuffer = new Uint32Array(10);\nfunction disassembleKorean(code: number): Uint32Array | undefined {\n\tcodeBufferLength = 0;\n\n\t// Initial consonants (초성)\n\tgetCodesFromArray(code, modernConsonants, HangulRangeStartCode.InitialConsonant);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Vowels (중성)\n\tgetCodesFromArray(code, modernVowels, HangulRangeStartCode.Vowel);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Final consonants (종성)\n\tgetCodesFromArray(code, modernFinalConsonants, HangulRangeStartCode.FinalConsonant);\n\tif (codeBufferLength > 0) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Hangul Compatibility Jamo\n\tgetCodesFromArray(code, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\tif (codeBufferLength) {\n\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t}\n\n\t// Hangul Syllables\n\tif (code >= 0xAC00 && code <= 0xD7A3) {\n\t\tconst hangulIndex = code - 0xAC00;\n\t\tconst vowelAndFinalConsonantProduct = hangulIndex % 588;\n\n\t\t// 0-based starting at 0x1100\n\t\tconst initialConsonantIndex = Math.floor(hangulIndex / 588);\n\t\t// 0-based starting at 0x1161\n\t\tconst vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);\n\t\t// 0-based starting at 0x11A8\n\t\t// Subtract 1 as the standard algorithm uses the 0 index to represent no\n\t\t// final consonant\n\t\tconst finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;\n\n\t\tif (initialConsonantIndex < modernConsonants.length) {\n\t\t\tgetCodesFromArray(initialConsonantIndex, modernConsonants, 0);\n\t\t} else if (HangulRangeStartCode.InitialConsonant + initialConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\tgetCodesFromArray(HangulRangeStartCode.InitialConsonant + initialConsonantIndex, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t}\n\n\t\tif (vowelIndex < modernVowels.length) {\n\t\t\tgetCodesFromArray(vowelIndex, modernVowels, 0);\n\t\t} else if (HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\tgetCodesFromArray(HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t}\n\n\t\tif (finalConsonantIndex >= 0) {\n\t\t\tif (finalConsonantIndex < modernFinalConsonants.length) {\n\t\t\t\tgetCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);\n\t\t\t} else if (HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {\n\t\t\t\tgetCodesFromArray(HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);\n\t\t\t}\n\t\t}\n\n\t\tif (codeBufferLength > 0) {\n\t\t\treturn codeBuffer.subarray(0, codeBufferLength);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction getCodesFromArray(code: number, array: ArrayLike<number>, arrayStartIndex: number): void {\n\t// Verify the code is within the array's range\n\tif (code >= arrayStartIndex && code < arrayStartIndex + array.length) {\n\t\taddCodesToBuffer(array[code - arrayStartIndex]);\n\t}\n}\n\nfunction addCodesToBuffer(codes: number): void {\n\t// NUL is ignored, this is used for archaic characters to avoid using a Map\n\t// for the data\n\tif (codes === AsciiCode.NUL) {\n\t\treturn;\n\t}\n\t// Number stored in format: OptionalThirdCode << 16 | OptionalSecondCode << 8 | Code\n\tcodeBuffer[codeBufferLength++] = codes & 0xFF;\n\tif (codes >> 8) {\n\t\tcodeBuffer[codeBufferLength++] = (codes >> 8) & 0xFF;\n\t}\n\tif (codes >> 16) {\n\t\tcodeBuffer[codeBufferLength++] = (codes >> 16) & 0xFF;\n\t}\n}\n\nconst enum HangulRangeStartCode {\n\tInitialConsonant = 0x1100,\n\tVowel = 0x1161,\n\tFinalConsonant = 0x11A8,\n\tCompatibilityJamo = 0x3131,\n}\n\nconst enum AsciiCode {\n\tNUL = 0,\n\tA = 65,\n\tB = 66,\n\tC = 67,\n\tD = 68,\n\tE = 69,\n\tF = 70,\n\tG = 71,\n\tH = 72,\n\tI = 73,\n\tJ = 74,\n\tK = 75,\n\tL = 76,\n\tM = 77,\n\tN = 78,\n\tO = 79,\n\tP = 80,\n\tQ = 81,\n\tR = 82,\n\tS = 83,\n\tT = 84,\n\tU = 85,\n\tV = 86,\n\tW = 87,\n\tX = 88,\n\tY = 89,\n\tZ = 90,\n\ta = 97,\n\tb = 98,\n\tc = 99,\n\td = 100,\n\te = 101,\n\tf = 102,\n\tg = 103,\n\th = 104,\n\ti = 105,\n\tj = 106,\n\tk = 107,\n\tl = 108,\n\tm = 109,\n\tn = 110,\n\to = 111,\n\tp = 112,\n\tq = 113,\n\tr = 114,\n\ts = 115,\n\tt = 116,\n\tu = 117,\n\tv = 118,\n\tw = 119,\n\tx = 120,\n\ty = 121,\n\tz = 122,\n}\n\n/**\n * Numbers that represent multiple ascii codes. These are precomputed at compile time to reduce\n * bundle and runtime overhead.\n */\nconst enum AsciiCodeCombo {\n\tfa = AsciiCode.a << 8 | AsciiCode.f,\n\tfg = AsciiCode.g << 8 | AsciiCode.f,\n\tfq = AsciiCode.q << 8 | AsciiCode.f,\n\tfr = AsciiCode.r << 8 | AsciiCode.f,\n\tft = AsciiCode.t << 8 | AsciiCode.f,\n\tfv = AsciiCode.v << 8 | AsciiCode.f,\n\tfx = AsciiCode.x << 8 | AsciiCode.f,\n\thk = AsciiCode.k << 8 | AsciiCode.h,\n\thl = AsciiCode.l << 8 | AsciiCode.h,\n\tho = AsciiCode.o << 8 | AsciiCode.h,\n\tml = AsciiCode.l << 8 | AsciiCode.m,\n\tnj = AsciiCode.j << 8 | AsciiCode.n,\n\tnl = AsciiCode.l << 8 | AsciiCode.n,\n\tnp = AsciiCode.p << 8 | AsciiCode.n,\n\tqt = AsciiCode.t << 8 | AsciiCode.q,\n\trt = AsciiCode.t << 8 | AsciiCode.r,\n\tsg = AsciiCode.g << 8 | AsciiCode.s,\n\tsw = AsciiCode.w << 8 | AsciiCode.s,\n}\n\n/**\n * Hangul Jamo - Modern consonants #1\n *\n * Range U+1100..U+1112\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+110x | ᄀ | ᄁ | ᄂ | ᄃ | ᄄ | ᄅ | ᄆ | ᄇ | ᄈ | ᄉ | ᄊ | ᄋ | ᄌ | ᄍ | ᄎ | ᄏ |\n * | U+111x | ᄐ | ᄑ | ᄒ |\n */\nconst modernConsonants = new Uint8Array([\n\tAsciiCode.r, // ㄱ\n\tAsciiCode.R, // ㄲ\n\tAsciiCode.s, // ㄴ\n\tAsciiCode.e, // ㄷ\n\tAsciiCode.E, // ㄸ\n\tAsciiCode.f, // ㄹ\n\tAsciiCode.a, // ㅁ\n\tAsciiCode.q, // ㅂ\n\tAsciiCode.Q, // ㅃ\n\tAsciiCode.t, // ㅅ\n\tAsciiCode.T, // ㅆ\n\tAsciiCode.d, // ㅇ\n\tAsciiCode.w, // ㅈ\n\tAsciiCode.W, // ㅉ\n\tAsciiCode.c, // ㅊ\n\tAsciiCode.z, // ㅋ\n\tAsciiCode.x, // ㅌ\n\tAsciiCode.v, // ㅍ\n\tAsciiCode.g, // ㅎ\n]);\n\n/**\n * Hangul Jamo - Modern Vowels\n *\n * Range U+1161..U+1175\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+116x |   | ᅡ | ᅢ | ᅣ | ᅤ | ᅥ | ᅦ | ᅧ | ᅨ | ᅩ | ᅪ | ᅫ | ᅬ | ᅭ | ᅮ | ᅯ |\n * | U+117x | ᅰ | ᅱ | ᅲ | ᅳ | ᅴ | ᅵ |\n */\nconst modernVowels = new Uint16Array([\n\tAsciiCode.k,       //  -> ㅏ\n\tAsciiCode.o,       //  -> ㅐ\n\tAsciiCode.i,       //  -> ㅑ\n\tAsciiCode.O,       //  -> ㅒ\n\tAsciiCode.j,       //  -> ㅓ\n\tAsciiCode.p,       //  -> ㅔ\n\tAsciiCode.u,       //  -> ㅕ\n\tAsciiCode.P,       //  -> ㅖ\n\tAsciiCode.h,       //  -> ㅗ\n\tAsciiCodeCombo.hk, //  -> ㅘ\n\tAsciiCodeCombo.ho, //  -> ㅙ\n\tAsciiCodeCombo.hl, //  -> ㅚ\n\tAsciiCode.y,       //  -> ㅛ\n\tAsciiCode.n,       //  -> ㅜ\n\tAsciiCodeCombo.nj, //  -> ㅝ\n\tAsciiCodeCombo.np, //  -> ㅞ\n\tAsciiCodeCombo.nl, //  -> ㅟ\n\tAsciiCode.b,       //  -> ㅠ\n\tAsciiCode.m,       //  -> ㅡ\n\tAsciiCodeCombo.ml, //  -> ㅢ\n\tAsciiCode.l,       //  -> ㅣ\n]);\n\n/**\n * Hangul Jamo - Modern Consonants #2\n *\n * Range U+11A8..U+11C2\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+11Ax |   |   |   |   |   |   |   |   | ᆨ | ᆩ | ᆪ | ᆫ | ᆬ | ᆭ | ᆮ | ᆯ |\n * | U+11Bx | ᆰ | ᆱ | ᆲ | ᆳ | ᆴ | ᆵ | ᆶ | ᆷ | ᆸ | ᆹ | ᆺ | ᆻ | ᆼ | ᆽ | ᆾ | ᆿ |\n * | U+11Cx | ᇀ | ᇁ | ᇂ |\n */\nconst modernFinalConsonants = new Uint16Array([\n\tAsciiCode.r,       // ㄱ\n\tAsciiCode.R,       // ㄲ\n\tAsciiCodeCombo.rt, // ㄳ\n\tAsciiCode.s,       // ㄴ\n\tAsciiCodeCombo.sw, // ㄵ\n\tAsciiCodeCombo.sg, // ㄶ\n\tAsciiCode.e,       // ㄷ\n\tAsciiCode.f,       // ㄹ\n\tAsciiCodeCombo.fr, // ㄺ\n\tAsciiCodeCombo.fa, // ㄻ\n\tAsciiCodeCombo.fq, // ㄼ\n\tAsciiCodeCombo.ft, // ㄽ\n\tAsciiCodeCombo.fx, // ㄾ\n\tAsciiCodeCombo.fv, // ㄿ\n\tAsciiCodeCombo.fg, // ㅀ\n\tAsciiCode.a,       // ㅁ\n\tAsciiCode.q,       // ㅂ\n\tAsciiCodeCombo.qt, // ㅄ\n\tAsciiCode.t,       // ㅅ\n\tAsciiCode.T,       // ㅆ\n\tAsciiCode.d,       // ㅇ\n\tAsciiCode.w,       // ㅈ\n\tAsciiCode.c,       // ㅊ\n\tAsciiCode.z,       // ㅋ\n\tAsciiCode.x,       // ㅌ\n\tAsciiCode.v,       // ㅍ\n\tAsciiCode.g,       // ㅎ\n]);\n\n/**\n * Hangul Compatibility Jamo\n *\n * Range U+3131..U+318F\n *\n * This includes range includes archaic jamo which we don't consider, these are\n * given the NUL character code in order to be ignored.\n *\n * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |\n * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n * | U+313x |   | ㄱ | ㄲ | ㄳ | ㄴ | ㄵ | ㄶ | ㄷ | ㄸ | ㄹ | ㄺ | ㄻ | ㄼ | ㄽ | ㄾ | ㄿ |\n * | U+314x | ㅀ | ㅁ | ㅂ | ㅃ | ㅄ | ㅅ | ㅆ | ㅇ | ㅈ | ㅉ | ㅊ | ㅋ | ㅌ | ㅍ | ㅎ | ㅏ |\n * | U+315x | ㅐ | ㅑ | ㅒ | ㅓ | ㅔ | ㅕ | ㅖ | ㅗ | ㅘ | ㅙ | ㅚ | ㅛ | ㅜ | ㅝ | ㅞ | ㅟ |\n * | U+316x | ㅠ | ㅡ | ㅢ | ㅣ | HF | ㅥ | ㅦ | ㅧ | ㅨ | ㅩ | ㅪ | ㅫ | ㅬ | ㅭ | ㅮ | ㅯ |\n * | U+317x | ㅰ | ㅱ | ㅲ | ㅳ | ㅴ | ㅵ | ㅶ | ㅷ | ㅸ | ㅹ | ㅺ | ㅻ | ㅼ | ㅽ | ㅾ | ㅿ |\n * | U+318x | ㆀ | ㆁ | ㆂ | ㆃ | ㆄ | ㆅ | ㆆ | ㆇ | ㆈ | ㆉ | ㆊ | ㆋ | ㆌ | ㆍ | ㆎ |\n */\nconst compatibilityJamo = new Uint16Array([\n\tAsciiCode.r,        // ㄱ\n\tAsciiCode.R,        // ㄲ\n\tAsciiCodeCombo.rt,  // ㄳ\n\tAsciiCode.s,        // ㄴ\n\tAsciiCodeCombo.sw,  // ㄵ\n\tAsciiCodeCombo.sg,  // ㄶ\n\tAsciiCode.e,        // ㄷ\n\tAsciiCode.E,        // ㄸ\n\tAsciiCode.f,        // ㄹ\n\tAsciiCodeCombo.fr,  // ㄺ\n\tAsciiCodeCombo.fa,  // ㄻ\n\tAsciiCodeCombo.fq,  // ㄼ\n\tAsciiCodeCombo.ft,  // ㄽ\n\tAsciiCodeCombo.fx,  // ㄾ\n\tAsciiCodeCombo.fv,  // ㄿ\n\tAsciiCodeCombo.fg,  // ㅀ\n\tAsciiCode.a,        // ㅁ\n\tAsciiCode.q,        // ㅂ\n\tAsciiCode.Q,        // ㅃ\n\tAsciiCodeCombo.qt,  // ㅄ\n\tAsciiCode.t,        // ㅅ\n\tAsciiCode.T,        // ㅆ\n\tAsciiCode.d,        // ㅇ\n\tAsciiCode.w,        // ㅈ\n\tAsciiCode.W,        // ㅉ\n\tAsciiCode.c,        // ㅊ\n\tAsciiCode.z,        // ㅋ\n\tAsciiCode.x,        // ㅌ\n\tAsciiCode.v,        // ㅍ\n\tAsciiCode.g,        // ㅎ\n\tAsciiCode.k,        // ㅏ\n\tAsciiCode.o,        // ㅐ\n\tAsciiCode.i,        // ㅑ\n\tAsciiCode.O,        // ㅒ\n\tAsciiCode.j,        // ㅓ\n\tAsciiCode.p,        // ㅔ\n\tAsciiCode.u,        // ㅕ\n\tAsciiCode.P,        // ㅖ\n\tAsciiCode.h,        // ㅗ\n\tAsciiCodeCombo.hk,  // ㅘ\n\tAsciiCodeCombo.ho,  // ㅙ\n\tAsciiCodeCombo.hl,  // ㅚ\n\tAsciiCode.y,        // ㅛ\n\tAsciiCode.n,        // ㅜ\n\tAsciiCodeCombo.nj,  // ㅝ\n\tAsciiCodeCombo.np,  // ㅞ\n\tAsciiCodeCombo.nl,  // ㅟ\n\tAsciiCode.b,        // ㅠ\n\tAsciiCode.m,        // ㅡ\n\tAsciiCodeCombo.ml,  // ㅢ\n\tAsciiCode.l,        // ㅣ\n\t// HF: Hangul Filler (everything after this is archaic)\n\t// ㅥ\n\t// ㅦ\n\t// ㅧ\n\t// ㅨ\n\t// ㅩ\n\t// ㅪ\n\t// ㅫ\n\t// ㅬ\n\t// ㅮ\n\t// ㅯ\n\t// ㅰ\n\t// ㅱ\n\t// ㅲ\n\t// ㅳ\n\t// ㅴ\n\t// ㅵ\n\t// ㅶ\n\t// ㅷ\n\t// ㅸ\n\t// ㅹ\n\t// ㅺ\n\t// ㅻ\n\t// ㅼ\n\t// ㅽ\n\t// ㅾ\n\t// ㅿ\n\t// ㆀ\n\t// ㆁ\n\t// ㆂ\n\t// ㆃ\n\t// ㆄ\n\t// ㆅ\n\t// ㆆ\n\t// ㆇ\n\t// ㆈ\n\t// ㆉ\n\t// ㆊ\n\t// ㆋ\n\t// ㆌ\n\t// ㆍ\n\t// ㆎ\n]);\n"]}