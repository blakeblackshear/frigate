var e=e=>Object.prototype.toString.call(e),t=e=>ArrayBuffer.isView(e)&&!(e instanceof DataView),o=t=>"[object Date]"===e(t),n=t=>"[object RegExp]"===e(t),s=t=>"[object Error]"===e(t),r=t=>"[object Boolean]"===e(t),l=t=>"[object Number]"===e(t),c=t=>"[object String]"===e(t),i=Array.isArray,a=Object.getOwnPropertyDescriptor,u=Object.prototype.propertyIsEnumerable,f=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty;function h(e){const t=Object.keys(e),o=f(e);for(let n=0;n<o.length;n++)u.call(e,o[n])&&t.push(o[n]);return t}function d(e,t){return!a(e,t)?.writable}function b(e,a){if("object"==typeof e&&null!==e){let u;if(i(e))u=[];else if(o(e))u=new Date(e.getTime?e.getTime():e);else if(n(e))u=new RegExp(e);else if(s(e))u={message:e.message};else if(r(e)||l(e)||c(e))u=Object(e);else{if(t(e))return e.slice();u=Object.create(Object.getPrototypeOf(e))}const f=a.includeSymbols?h:Object.keys;for(const t of f(e))u[t]=e[t];return u}return e}var y={includeSymbols:!1,immutable:!1};function g(e,t,o=y){const n=[],s=[];let r=!0;const l=o.includeSymbols?h:Object.keys,c=!!o.immutable;return function e(a){const u=c?b(a,o):a,f={};let h=!0;const y={node:u,node_:a,path:[].concat(n),parent:s[s.length-1],parents:s,key:n[n.length-1],isRoot:0===n.length,level:n.length,circular:void 0,isLeaf:!1,notLeaf:!0,notRoot:!0,isFirst:!1,isLast:!1,update:function(e,t=!1){y.isRoot||(y.parent.node[y.key]=e),y.node=e,t&&(h=!1)},delete:function(e){delete y.parent.node[y.key],e&&(h=!1)},remove:function(e){i(y.parent.node)?y.parent.node.splice(y.key,1):delete y.parent.node[y.key],e&&(h=!1)},keys:null,before:function(e){f.before=e},after:function(e){f.after=e},pre:function(e){f.pre=e},post:function(e){f.post=e},stop:function(){r=!1},block:function(){h=!1}};if(!r)return y;function g(){if("object"==typeof y.node&&null!==y.node){y.keys&&y.node_===y.node||(y.keys=l(y.node)),y.isLeaf=0===y.keys.length;for(let e=0;e<s.length;e++)if(s[e].node_===a){y.circular=s[e];break}}else y.isLeaf=!0,y.keys=null;y.notLeaf=!y.isLeaf,y.notRoot=!y.isRoot}g();const m=t.call(y,y.node);if(void 0!==m&&y.update&&y.update(m),f.before&&f.before.call(y,y.node),!h)return y;if("object"==typeof y.node&&null!==y.node&&!y.circular){s.push(y),g();for(const[t,o]of Object.entries(y.keys??[])){n.push(o),f.pre&&f.pre.call(y,y.node[o],o);const s=e(y.node[o]);c&&p.call(y.node,o)&&!d(y.node,o)&&(y.node[o]=s.node),s.isLast=!!y.keys?.length&&+t==y.keys.length-1,s.isFirst=0==+t,f.post&&f.post.call(y,s),n.pop()}s.pop()}return f.after&&f.after.call(y,y.node),y}(e).node}var m=class{#e;#t;constructor(e,t=y){this.#e=e,this.#t=t}get(e){let t=this.#e;for(let o=0;t&&o<e.length;o++){const n=e[o];if(!p.call(t,n)||!this.#t.includeSymbols&&"symbol"==typeof n)return;t=t[n]}return t}has(e){let t=this.#e;for(let o=0;t&&o<e.length;o++){const n=e[o];if(!p.call(t,n)||!this.#t.includeSymbols&&"symbol"==typeof n)return!1;t=t[n]}return!0}set(e,t){let o=this.#e,n=0;for(n=0;n<e.length-1;n++){const t=e[n];p.call(o,t)||(o[t]={}),o=o[t]}return o[e[n]]=t,t}map(e){return g(this.#e,e,{immutable:!0,includeSymbols:!!this.#t.includeSymbols})}forEach(e){return this.#e=g(this.#e,e,this.#t),this.#e}reduce(e,t){const o=1===arguments.length;let n=o?this.#e:t;return this.forEach((function(t){this.isRoot&&o||(n=e.call(this,n,t))})),n}paths(){const e=[];return this.forEach((function(){e.push(this.path)})),e}nodes(){const e=[];return this.forEach((function(){e.push(this.node)})),e}clone(){const e=[],o=[],n=this.#t;return t(this.#e)?this.#e.slice():function t(s){for(let t=0;t<e.length;t++)if(e[t]===s)return o[t];if("object"==typeof s&&null!==s){const r=b(s,n);e.push(s),o.push(r);const l=n.includeSymbols?h:Object.keys;for(const e of l(s))r[e]=t(s[e]);return e.pop(),o.pop(),r}return s}(this.#e)}},j=(e,t)=>new m(e,t);j.get=(e,t,o)=>new m(e,o).get(t),j.set=(e,t,o,n)=>new m(e,n).set(t,o),j.has=(e,t,o)=>new m(e,o).has(t),j.map=(e,t,o)=>new m(e,o).map(t),j.forEach=(e,t,o)=>new m(e,o).forEach(t),j.reduce=(e,t,o,n)=>new m(e,n).reduce(t,o),j.paths=(e,t)=>new m(e,t).paths(),j.nodes=(e,t)=>new m(e,t).nodes(),j.clone=(e,t)=>new m(e,t).clone();var v=j;export{m as Traverse,v as default};