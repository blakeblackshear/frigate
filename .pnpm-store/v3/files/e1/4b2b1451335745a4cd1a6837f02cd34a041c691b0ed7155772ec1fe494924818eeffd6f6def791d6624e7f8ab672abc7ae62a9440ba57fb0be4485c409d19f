{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlas.ts","vs/editor/browser/gpu/atlas/textureAtlas.ts"],"names":[],"mappings":"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","file":"textureAtlas.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { MetadataConsts } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { IGlyphRasterizer } from '../raster/raster.js';\nimport { IdleTaskQueue, type ITaskQueue } from '../taskQueue.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { AllocatorType, TextureAtlasPage } from './textureAtlasPage.js';\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap?: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<ITaskQueue> = this._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The maximum number of texture atlas pages. This is currently a hard static cap that must not\n\t * be reached.\n\t */\n\tstatic readonly maximumPageCount = 16;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] { return this._pages; }\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new NKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? 'slab';\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\tif (this._colorMap) {\n\t\t\t\tthis.clear();\n\t\t\t}\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\tconst dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, '', 1, this._decorationStyleCache);\n\t\tfirstPage.getGlyph(nullRasterizer, '', 0, 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number, x: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\ttokenMetadata &= ~(MetadataConsts.LANGUAGEID_MASK | MetadataConsts.TOKEN_TYPE_MASK | MetadataConsts.BALANCED_BRACKETS_MASK);\n\n\t\t// Add x offset for sub-pixel rendering to the unused portion or tokenMetadata. This\n\t\t// converts the decimal part of the x to a range from 0 to 9, where 0 = 0.0px x offset,\n\t\t// 9 = 0.9px x offset\n\t\ttokenMetadata |= Math.floor((x % 1) * 10);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(this._glyphPageIndex.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? 0, rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _tryGetGlyph(pageIndex: number, rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(pageIndex, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t?? (pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t\t: undefined)\n\t\t\t?? this._getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tif (this._pages.length >= TextureAtlas.maximumPageCount) {\n\t\t\tthrow new Error(`Attempt to create a texture atlas page past the limit ${TextureAtlas.maximumPageCount}`);\n\t\t}\n\t\tthis._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n\t\tthis._glyphPageIndex.set(this._pages.length - 1, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)!;\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map(e => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tconst colorMap = this._colorMap;\n\t\tif (!colorMap) {\n\t\t\tthrow new BugIndicatingError('Cannot warm atlas without color map');\n\t\t}\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = this._warmUpTask.value = this._instantiationService.createInstance(IdleTaskQueue);\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (let code = CharCode.ExclamationMark; code <= CharCode.Tilde; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { MetadataConsts } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { IGlyphRasterizer } from '../raster/raster.js';\nimport { IdleTaskQueue, type ITaskQueue } from '../taskQueue.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { AllocatorType, TextureAtlasPage } from './textureAtlasPage.js';\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap?: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<ITaskQueue> = this._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The maximum number of texture atlas pages. This is currently a hard static cap that must not\n\t * be reached.\n\t */\n\tstatic readonly maximumPageCount = 16;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] { return this._pages; }\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new NKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? 'slab';\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\tif (this._colorMap) {\n\t\t\t\tthis.clear();\n\t\t\t}\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\tconst dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, '', 1, this._decorationStyleCache);\n\t\tfirstPage.getGlyph(nullRasterizer, '', 0, 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number, x: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\ttokenMetadata &= ~(MetadataConsts.LANGUAGEID_MASK | MetadataConsts.TOKEN_TYPE_MASK | MetadataConsts.BALANCED_BRACKETS_MASK);\n\n\t\t// Add x offset for sub-pixel rendering to the unused portion or tokenMetadata. This\n\t\t// converts the decimal part of the x to a range from 0 to 9, where 0 = 0.0px x offset,\n\t\t// 9 = 0.9px x offset\n\t\ttokenMetadata |= Math.floor((x % 1) * 10);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(this._glyphPageIndex.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? 0, rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _tryGetGlyph(pageIndex: number, rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(pageIndex, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t?? (pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t\t: undefined)\n\t\t\t?? this._getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tif (this._pages.length >= TextureAtlas.maximumPageCount) {\n\t\t\tthrow new Error(`Attempt to create a texture atlas page past the limit ${TextureAtlas.maximumPageCount}`);\n\t\t}\n\t\tthis._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n\t\tthis._glyphPageIndex.set(this._pages.length - 1, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)!;\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map(e => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tconst colorMap = this._colorMap;\n\t\tif (!colorMap) {\n\t\t\tthrow new BugIndicatingError('Cannot warm atlas without color map');\n\t\t}\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = this._warmUpTask.value = this._instantiationService.createInstance(IdleTaskQueue);\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (let code = CharCode.ExclamationMark; code <= CharCode.Tilde; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n"]}