{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/editorBrowser.ts","vs/editor/browser/editorBrowser.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAchG,OAAO,KAAK,YAAY,MAAM,2BAA2B,CAAC;AAsyC1D;;GAEG;AACH,MAAM,UAAU,YAAY,CAAC,KAAc;IAC1C,IAAI,KAAK,IAAI,OAAqB,KAAM,CAAC,aAAa,KAAK,UAAU,EAAE,CAAC;QACvE,OAAqB,KAAM,CAAC,aAAa,EAAE,KAAK,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC;IACrF,CAAC;SAAM,CAAC;QACP,OAAO,KAAK,CAAC;IACd,CAAC;AACF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,YAAY,CAAC,KAAc;IAC1C,IAAI,KAAK,IAAI,OAAqB,KAAM,CAAC,aAAa,KAAK,UAAU,EAAE,CAAC;QACvE,OAAqB,KAAM,CAAC,aAAa,EAAE,KAAK,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC;IACrF,CAAC;SAAM,CAAC;QACP,OAAO,KAAK,CAAC;IACd,CAAC;AACF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAc;IAC/C,OAAO,CAAC,CAAC,KAAK;WACV,OAAO,KAAK,KAAK,QAAQ;WACzB,OAA2C,KAAM,CAAC,uBAAuB,KAAK,UAAU,CAAC;AAE9F,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,KAAc;IAC3C,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;QACzB,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;QACzB,OAAO,KAAK,CAAC,iBAAiB,EAAE,CAAC;IAClC,CAAC;IAED,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,CAAC;QACtE,OAAO,KAAK,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,OAAO,IAAI,CAAC;AACb,CAAC","file":"editorBrowser.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IKeyboardEvent } from '../../base/browser/keyboardEvent.js';\nimport { IMouseEvent, IMouseWheelEvent } from '../../base/browser/mouseEvent.js';\nimport { Event } from '../../base/common/event.js';\nimport { IEditorConstructionOptions } from './config/editorConfiguration.js';\nimport { ConfigurationChangedEvent, EditorLayoutInfo, EditorOption, FindComputedEditorOptionValueById, IComputedEditorOptions, IDiffEditorOptions, IEditorOptions, OverviewRulerPosition } from '../common/config/editorOptions.js';\nimport { IDimension } from '../common/core/2d/dimension.js';\nimport { IPosition, Position } from '../common/core/position.js';\nimport { IRange, Range } from '../common/core/range.js';\nimport { Selection } from '../common/core/selection.js';\nimport { IWordAtPosition } from '../common/core/wordHelper.js';\nimport { ICursorPositionChangedEvent, ICursorSelectionChangedEvent } from '../common/cursorEvents.js';\nimport { ILineChange } from '../common/diff/legacyLinesDiffComputer.js';\nimport * as editorCommon from '../common/editorCommon.js';\nimport { GlyphMarginLane, ICursorStateComputer, IIdentifiedSingleEditOperation, IModelDecoration, IModelDeltaDecoration, ITextModel, PositionAffinity } from '../common/model.js';\nimport { InjectedText } from '../common/modelLineProjectionData.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, ModelFontChangedEvent, ModelLineHeightChangedEvent } from '../common/textModelEvents.js';\nimport { IViewModel } from '../common/viewModel.js';\nimport { OverviewRulerZone } from '../common/viewModel/overviewZoneManager.js';\nimport { MenuId } from '../../platform/actions/common/actions.js';\nimport { ServicesAccessor } from '../../platform/instantiation/common/instantiation.js';\nimport { TextEdit } from '../common/core/edits/textEdit.js';\nimport { TextModelEditSource } from '../common/textModelEditSource.js';\n\n/**\n * A view zone is a full horizontal rectangle that 'pushes' text down.\n * The editor reserves space for view zones when rendering.\n */\nexport interface IViewZone {\n\t/**\n\t * The line number after which this zone should appear.\n\t * Use 0 to place a view zone before the first line number.\n\t */\n\tafterLineNumber: number;\n\t/**\n\t * The column after which this zone should appear.\n\t * If not set, the maxLineColumn of `afterLineNumber` will be used.\n\t * This is relevant for wrapped lines.\n\t */\n\tafterColumn?: number;\n\t/**\n\t * If the `afterColumn` has multiple view columns, the affinity specifies which one to use. Defaults to `none`.\n\t*/\n\tafterColumnAffinity?: PositionAffinity;\n\t/**\n\t * Render the zone even when its line is hidden.\n\t */\n\tshowInHiddenAreas?: boolean;\n\t/**\n\t * Tiebreaker that is used when multiple view zones want to be after the same line.\n\t * Defaults to `afterColumn` otherwise 10000;\n\t */\n\tordinal?: number;\n\t/**\n\t * Suppress mouse down events.\n\t * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.\n\t * Defaults to false\n\t */\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * The height in lines of the view zone.\n\t * If specified, `heightInPx` will be used instead of this.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInLines?: number;\n\t/**\n\t * The height in px of the view zone.\n\t * If this is set, the editor will give preference to it rather than `heightInLines` above.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInPx?: number;\n\t/**\n\t * The minimum width in px of the view zone.\n\t * If this is set, the editor will ensure that the scroll width is >= than this value.\n\t */\n\tminWidthInPx?: number;\n\t/**\n\t * The dom node of the view zone\n\t */\n\tdomNode: HTMLElement;\n\t/**\n\t * An optional dom node for the view zone that will be placed in the margin area.\n\t */\n\tmarginDomNode?: HTMLElement | null;\n\t/**\n\t * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).\n\t */\n\tonDomNodeTop?: (top: number) => void;\n\t/**\n\t * Callback which gives the height in pixels of the view zone.\n\t */\n\tonComputedHeight?: (height: number) => void;\n}\n/**\n * An accessor that allows for zones to be added or removed.\n */\nexport interface IViewZoneChangeAccessor {\n\t/**\n\t * Create a new view zone.\n\t * @param zone Zone to create\n\t * @return A unique identifier to the view zone.\n\t */\n\taddZone(zone: IViewZone): string;\n\t/**\n\t * Remove a zone\n\t * @param id A unique identifier to the view zone, as returned by the `addZone` call.\n\t */\n\tremoveZone(id: string): void;\n\t/**\n\t * Change a zone's position.\n\t * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.\n\t */\n\tlayoutZone(id: string): void;\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport const enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW\n}\n/**\n * A position for rendering content widgets.\n */\nexport interface IContentWidgetPosition {\n\t/**\n\t * Desired position which serves as an anchor for placing the content widget.\n\t * The widget will be placed above, at, or below the specified position, based on the\n\t * provided preference. The widget will always touch this position.\n\t *\n\t * Given sufficient horizontal space, the widget will be placed to the right of the\n\t * passed in position. This can be tweaked by providing a `secondaryPosition`.\n\t *\n\t * @see preference\n\t * @see secondaryPosition\n\t */\n\tposition: IPosition | null;\n\t/**\n\t * Optionally, a secondary position can be provided to further define the placing of\n\t * the content widget. The secondary position must have the same line number as the\n\t * primary position. If possible, the widget will be placed such that it also touches\n\t * the secondary position.\n\t */\n\tsecondaryPosition?: IPosition | null;\n\t/**\n\t * Placement preference for position, in order of preference.\n\t */\n\tpreference: ContentWidgetPositionPreference[];\n\n\t/**\n\t * Placement preference when multiple view positions refer to the same (model) position.\n\t * This plays a role when injected text is involved.\n\t*/\n\tpositionAffinity?: PositionAffinity;\n}\n/**\n * A content widget renders inline with the text and can be easily placed 'near' an editor position.\n */\nexport interface IContentWidget {\n\t/**\n\t * Render this content widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\t/**\n\t * Call preventDefault() on mousedown events that target the content widget.\n\t */\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * Get a unique identifier of the content widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the content widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the content widget.\n\t * If null is returned, the content widget will be placed off screen.\n\t */\n\tgetPosition(): IContentWidgetPosition | null;\n\t/**\n\t * Optional function that is invoked before rendering\n\t * the content widget. If a dimension is returned the editor will\n\t * attempt to use it.\n\t */\n\tbeforeRender?(): IDimension | null;\n\t/**\n\t * Optional function that is invoked after rendering the content\n\t * widget. Is being invoked with the selected position preference\n\t * or `null` if not rendered.\n\t */\n\tafterRender?(position: ContentWidgetPositionPreference | null, coordinate: IContentWidgetRenderedCoordinate | null): void;\n}\n\n/**\n * Coordinatees passed in {@link IContentWidget.afterRender}\n */\nexport interface IContentWidgetRenderedCoordinate {\n\t/**\n\t * Top position relative to the editor content.\n\t */\n\treadonly top: number;\n\n\t/**\n\t * Left position relative to the editor content.\n\t */\n\treadonly left: number;\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport const enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER\n}\n\n\n/**\n * Represents editor-relative coordinates of an overlay widget.\n */\nexport interface IOverlayWidgetPositionCoordinates {\n\t/**\n\t * The top position for the overlay widget, relative to the editor.\n\t */\n\ttop: number;\n\t/**\n\t * The left position for the overlay widget, relative to the editor.\n\t */\n\tleft: number;\n}\n\n/**\n * A position for rendering overlay widgets.\n */\nexport interface IOverlayWidgetPosition {\n\t/**\n\t * The position preference for the overlay widget.\n\t */\n\tpreference: OverlayWidgetPositionPreference | IOverlayWidgetPositionCoordinates | null;\n\n\t/**\n\t * When set, stacks with other overlay widgets with the same preference,\n\t * in an order determined by the ordinal value.\n\t */\n\tstackOridinal?: number;\n}\n/**\n * An overlay widgets renders on top of the text.\n */\nexport interface IOverlayWidget {\n\t/**\n\t * Event fired when the widget layout changes.\n\t */\n\tonDidLayout?: Event<void>;\n\t/**\n\t * Render this overlay widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\t/**\n\t * Get a unique identifier of the overlay widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the overlay widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the overlay widget.\n\t * If null is returned, the overlay widget is responsible to place itself.\n\t */\n\tgetPosition(): IOverlayWidgetPosition | null;\n\t/**\n\t * The editor will ensure that the scroll width is >= than this value.\n\t */\n\tgetMinContentWidthInPx?(): number;\n}\n\n/**\n * A glyph margin widget renders in the editor glyph margin.\n */\nexport interface IGlyphMarginWidget {\n\t/**\n\t * Get a unique identifier of the glyph widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the glyph widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the glyph widget.\n\t */\n\tgetPosition(): IGlyphMarginWidgetPosition;\n}\n\n/**\n * A position for rendering glyph margin widgets.\n */\nexport interface IGlyphMarginWidgetPosition {\n\t/**\n\t * The glyph margin lane where the widget should be shown.\n\t */\n\tlane: GlyphMarginLane;\n\t/**\n\t * The priority order of the widget, used for determining which widget\n\t * to render when there are multiple.\n\t */\n\tzIndex: number;\n\t/**\n\t * The editor range that this widget applies to.\n\t */\n\trange: IRange;\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport const enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET,\n\t/**\n\t * Mouse is outside of the editor.\n\t */\n\tOUTSIDE_EDITOR,\n}\nexport interface IBaseMouseTarget {\n\t/**\n\t * The target element\n\t */\n\treadonly element: HTMLElement | null;\n\t/**\n\t * The 'approximate' editor position\n\t */\n\treadonly position: Position | null;\n\t/**\n\t * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\n\t */\n\treadonly mouseColumn: number;\n\t/**\n\t * The 'approximate' editor range\n\t */\n\treadonly range: Range | null;\n}\nexport interface IMouseTargetUnknown extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.UNKNOWN;\n}\nexport interface IMouseTargetTextarea extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.TEXTAREA;\n\treadonly position: null;\n\treadonly range: null;\n}\nexport interface IMouseTargetMarginData {\n\treadonly isAfterLines: boolean;\n\treadonly glyphMarginLeft: number;\n\treadonly glyphMarginWidth: number;\n\treadonly glyphMarginLane?: GlyphMarginLane;\n\treadonly lineNumbersWidth: number;\n\treadonly offsetX: number;\n}\nexport interface IMouseTargetMargin extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.GUTTER_GLYPH_MARGIN | MouseTargetType.GUTTER_LINE_NUMBERS | MouseTargetType.GUTTER_LINE_DECORATIONS;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetMarginData;\n}\nexport interface IMouseTargetViewZoneData {\n\treadonly viewZoneId: string;\n\treadonly positionBefore: Position | null;\n\treadonly positionAfter: Position | null;\n\treadonly position: Position;\n\treadonly afterLineNumber: number;\n}\nexport interface IMouseTargetViewZone extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.GUTTER_VIEW_ZONE | MouseTargetType.CONTENT_VIEW_ZONE;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetViewZoneData;\n}\nexport interface IMouseTargetContentTextData {\n\treadonly mightBeForeignElement: boolean;\n\t/**\n\t * @internal\n\t */\n\treadonly injectedText: InjectedText | null;\n}\nexport interface IMouseTargetContentText extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_TEXT;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetContentTextData;\n}\nexport interface IMouseTargetContentEmptyData {\n\treadonly isAfterLines: boolean;\n\treadonly horizontalDistanceToText?: number;\n}\nexport interface IMouseTargetContentEmpty extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_EMPTY;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetContentEmptyData;\n}\nexport interface IMouseTargetContentWidget extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_WIDGET;\n\treadonly position: null;\n\treadonly range: null;\n\treadonly detail: string;\n}\nexport interface IMouseTargetOverlayWidget extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OVERLAY_WIDGET;\n\treadonly position: null;\n\treadonly range: null;\n\treadonly detail: string;\n}\nexport interface IMouseTargetScrollbar extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.SCROLLBAR;\n\treadonly position: Position;\n\treadonly range: Range;\n}\nexport interface IMouseTargetOverviewRuler extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OVERVIEW_RULER;\n}\nexport interface IMouseTargetOutsideEditor extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OUTSIDE_EDITOR;\n\treadonly outsidePosition: 'above' | 'below' | 'left' | 'right';\n\treadonly outsideDistance: number;\n}\n/**\n * Target hit with the mouse in the editor.\n */\nexport type IMouseTarget = (\n\tIMouseTargetUnknown\n\t| IMouseTargetTextarea\n\t| IMouseTargetMargin\n\t| IMouseTargetViewZone\n\t| IMouseTargetContentText\n\t| IMouseTargetContentEmpty\n\t| IMouseTargetContentWidget\n\t| IMouseTargetOverlayWidget\n\t| IMouseTargetScrollbar\n\t| IMouseTargetOverviewRuler\n\t| IMouseTargetOutsideEditor\n);\n/**\n * A mouse event originating from the editor.\n */\nexport interface IEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget;\n}\nexport interface IPartialEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget | null;\n}\n\n/**\n * A paste event originating from the editor.\n */\nexport interface IPasteEvent {\n\treadonly range: Range;\n\treadonly languageId: string | null;\n\treadonly clipboardEvent?: ClipboardEvent;\n}\n\n/**\n * @internal\n */\nexport interface PastePayload {\n\ttext: string;\n\tpasteOnNewLine: boolean;\n\tmulticursorText: string[] | null;\n\tmode: string | null;\n\tclipboardEvent?: ClipboardEvent;\n}\n\n/**\n * An overview ruler\n * @internal\n */\nexport interface IOverviewRuler {\n\tgetDomNode(): HTMLElement;\n\tdispose(): void;\n\tsetZones(zones: OverviewRulerZone[]): void;\n\tsetLayout(position: OverviewRulerPosition): void;\n}\n\n/**\n * Editor aria options.\n * @internal\n */\nexport interface IEditorAriaOptions {\n\tactiveDescendant: string | undefined;\n\trole?: string;\n}\n\nexport interface IDiffEditorConstructionOptions extends IDiffEditorOptions, IEditorConstructionOptions {\n\t/**\n\t * Place overflow widgets inside an external DOM node.\n\t * Defaults to an internal DOM node.\n\t */\n\toverflowWidgetsDomNode?: HTMLElement;\n\n\t/**\n\t * Aria label for original editor.\n\t */\n\toriginalAriaLabel?: string;\n\n\t/**\n\t * Aria label for modified editor.\n\t */\n\tmodifiedAriaLabel?: string;\n}\n\n/**\n * A rich code editor.\n */\nexport interface ICodeEditor extends editorCommon.IEditor {\n\t/**\n\t * This editor is used as an alternative to an <input> box, i.e. as a simple widget.\n\t * @internal\n\t */\n\treadonly isSimpleWidget: boolean;\n\t/**\n\t * The context menu ID that should be used to lookup context menu actions.\n\t * @internal\n\t */\n\treadonly contextMenuId: MenuId;\n\t/**\n\t * An event emitted when the content of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelContent: Event<IModelContentChangedEvent>;\n\t/**\n\t * An event emitted when the language of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the options of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)\n\t * @event\n\t */\n\treadonly onDidChangeConfiguration: Event<ConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the cursor position has changed.\n\t * @event\n\t */\n\treadonly onDidChangeCursorPosition: Event<ICursorPositionChangedEvent>;\n\t/**\n\t * An event emitted when the cursor selection has changed.\n\t * @event\n\t */\n\treadonly onDidChangeCursorSelection: Event<ICursorSelectionChangedEvent>;\n\t/**\n\t * An event emitted when the model of this editor is about to change (e.g. from `editor.setModel()`).\n\t * @event\n\t */\n\treadonly onWillChangeModel: Event<editorCommon.IModelChangedEvent>;\n\t/**\n\t * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).\n\t * @event\n\t */\n\treadonly onDidChangeModel: Event<editorCommon.IModelChangedEvent>;\n\t/**\n\t * An event emitted when the decorations of the current model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when the tokens of the current model have changed.\n\t * @internal\n\t */\n\treadonly onDidChangeModelTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).\n\t * @event\n\t */\n\treadonly onDidFocusEditorText: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).\n\t * @event\n\t */\n\treadonly onDidBlurEditorText: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget gained focus.\n\t * @event\n\t */\n\treadonly onDidFocusEditorWidget: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget lost focus.\n\t * @event\n\t */\n\treadonly onDidBlurEditorWidget: Event<void>;\n\t/**\n\t * An event emitted before interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\treadonly onWillType: Event<string>;\n\t/**\n\t * An event emitted after interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidType: Event<string>;\n\t/**\n\t * Boolean indicating whether input is in composition\n\t */\n\treadonly inComposition: boolean;\n\t/**\n\t * An event emitted after composition has started.\n\t */\n\treadonly onDidCompositionStart: Event<void>;\n\t/**\n\t * An event emitted after composition has ended.\n\t */\n\treadonly onDidCompositionEnd: Event<void>;\n\t/**\n\t * An event emitted when editing failed because the editor is read-only.\n\t * @event\n\t */\n\treadonly onDidAttemptReadOnlyEdit: Event<void>;\n\t/**\n\t * An event emitted when users paste text in the editor.\n\t * @event\n\t */\n\treadonly onDidPaste: Event<IPasteEvent>;\n\t/**\n\t * An event emitted on a \"mouseup\".\n\t * @event\n\t */\n\treadonly onMouseUp: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedown\".\n\t * @event\n\t */\n\treadonly onMouseDown: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedrag\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDrag: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedrop\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDrop: Event<IPartialEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedropcanceled\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDropCanceled: Event<void>;\n\t/**\n\t * An event emitted when content is dropped into the editor.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDropIntoEditor: Event<{ readonly position: IPosition; readonly event: DragEvent }>;\n\t/**\n\t * An event emitted on a \"contextmenu\".\n\t * @event\n\t */\n\treadonly onContextMenu: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousemove\".\n\t * @event\n\t */\n\treadonly onMouseMove: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mouseleave\".\n\t * @event\n\t */\n\treadonly onMouseLeave: Event<IPartialEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousewheel\"\n\t * @event\n\t * @internal\n\t */\n\treadonly onMouseWheel: Event<IMouseWheelEvent>;\n\t/**\n\t * An event emitted on a \"keyup\".\n\t * @event\n\t */\n\treadonly onKeyUp: Event<IKeyboardEvent>;\n\t/**\n\t * An event emitted on a \"keydown\".\n\t * @event\n\t */\n\treadonly onKeyDown: Event<IKeyboardEvent>;\n\t/**\n\t * An event emitted when the layout of the editor has changed.\n\t * @event\n\t */\n\treadonly onDidLayoutChange: Event<EditorLayoutInfo>;\n\t/**\n\t * An event emitted when the content width or content height in the editor has changed.\n\t * @event\n\t */\n\treadonly onDidContentSizeChange: Event<editorCommon.IContentSizeChangedEvent>;\n\t/**\n\t * An event emitted when the scroll in the editor has changed.\n\t * @event\n\t */\n\treadonly onDidScrollChange: Event<editorCommon.IScrollEvent>;\n\n\t/**\n\t * An event emitted when hidden areas change in the editor (e.g. due to folding).\n\t * @event\n\t */\n\treadonly onDidChangeHiddenAreas: Event<void>;\n\n\t/**\n\t * Some editor operations fire multiple events at once.\n\t * To allow users to react to multiple events fired by a single operation,\n\t * the editor fires a begin update before the operation and an end update after the operation.\n\t * Whenever the editor fires `onBeginUpdate`, it will also fire `onEndUpdate` once the operation finishes.\n\t * Note that not all operations are bracketed by `onBeginUpdate` and `onEndUpdate`.\n\t*/\n\treadonly onBeginUpdate: Event<void>;\n\n\t/**\n\t * Fires after the editor completes the operation it fired `onBeginUpdate` for.\n\t*/\n\treadonly onEndUpdate: Event<void>;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.ICodeEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.ICodeEditorViewState | null): void;\n\n\t/**\n\t * Returns true if the text inside this editor or an editor widget has focus.\n\t */\n\thasWidgetFocus(): boolean;\n\n\t/**\n\t * Get a contribution of this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The contribution or null if contribution not found.\n\t */\n\tgetContribution<T extends editorCommon.IEditorContribution>(id: string): T | null;\n\n\t/**\n\t * Execute `fn` with the editor's services.\n\t * @internal\n\t */\n\tinvokeWithinContext<T>(fn: (accessor: ServicesAccessor) => T): T;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel | null;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: ITextModel | null): void;\n\n\t/**\n\t * Gets all the editor computed options.\n\t */\n\tgetOptions(): IComputedEditorOptions;\n\n\t/**\n\t * Gets a specific editor option.\n\t */\n\tgetOption<T extends EditorOption>(id: T): FindComputedEditorOptionValueById<T>;\n\n\t/**\n\t * Returns the editor's configuration (without any validation or defaults).\n\t */\n\tgetRawOptions(): IEditorOptions;\n\n\t/**\n\t * @internal\n\t */\n\tgetOverflowWidgetsDomNode(): HTMLElement | undefined;\n\n\t/**\n\t * @internal\n\t */\n\tgetConfiguredWordAtPosition(position: Position): IWordAtPosition | null;\n\n\t/**\n\t * An event emitted when line heights from decorations change\n\t * @internal\n\t * @event\n\t */\n\tonDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\n\t/**\n\t * An event emitted when the font of the editor has changed.\n\t * @internal\n\t * @event\n\t */\n\tonDidChangeFont: Event<ModelFontChangedEvent>;\n\n\t/**\n\t * Get value of the current model attached to this editor.\n\t * @see {@link ITextModel.getValue}\n\t */\n\tgetValue(options?: { preserveBOM: boolean; lineEnding: string }): string;\n\n\t/**\n\t * Set the value of the current model attached to this editor.\n\t * @see {@link ITextModel.setValue}\n\t */\n\tsetValue(newValue: string): void;\n\n\t/**\n\t * Get the width of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollWidth = Math.max(contentWidth, width)`\n\t */\n\tgetContentWidth(): number;\n\t/**\n\t * Get the scrollWidth of the editor's viewport.\n\t */\n\tgetScrollWidth(): number;\n\t/**\n\t * Get the scrollLeft of the editor's viewport.\n\t */\n\tgetScrollLeft(): number;\n\n\t/**\n\t * Get the height of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollHeight = Math.max(contentHeight, height)`\n\t */\n\tgetContentHeight(): number;\n\t/**\n\t * Get the scrollHeight of the editor's viewport.\n\t */\n\tgetScrollHeight(): number;\n\t/**\n\t * Get the scrollTop of the editor's viewport.\n\t */\n\tgetScrollTop(): number;\n\n\t/**\n\t * Change the scrollLeft of the editor's viewport.\n\t */\n\tsetScrollLeft(newScrollLeft: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scrollTop of the editor's viewport.\n\t */\n\tsetScrollTop(newScrollTop: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scroll position of the editor's viewport.\n\t */\n\tsetScrollPosition(position: editorCommon.INewScrollPosition, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Check if the editor is currently scrolling towards a different scroll position.\n\t */\n\thasPendingScrollAnimation(): boolean;\n\n\t/**\n\t * Get an action that is a contribution to this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The action or null if action not found.\n\t */\n\tgetAction(id: string): editorCommon.IEditorAction | null;\n\n\t/**\n\t * Execute a command on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param command The command to execute\n\t */\n\texecuteCommand(source: string | null | undefined, command: editorCommon.ICommand): void;\n\n\t/**\n\t * Create an \"undo stop\" in the undo-redo stack.\n\t */\n\tpushUndoStop(): boolean;\n\n\t/**\n\t * Remove the \"undo stop\" in the undo-redo stack.\n\t */\n\tpopUndoStop(): boolean;\n\n\t/**\n\t * Execute edits on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param edits The edits to execute.\n\t * @param endCursorState Cursor state after the edits were applied.\n\t */\n\texecuteEdits(source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;\n\t/** @internal */\n\texecuteEdits(source: TextModelEditSource | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;\n\n\t/**\n\t * @internal\n\t*/\n\tedit(edit: TextEdit, reason: TextModelEditSource): void;\n\n\t/**\n\t * Execute multiple (concomitant) commands on the editor.\n\t * @param source The source of the call.\n\t * @param command The commands to execute\n\t */\n\texecuteCommands(source: string | null | undefined, commands: (editorCommon.ICommand | null)[]): void;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel | null;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[] | null;\n\n\t/**\n\t * Get all the decorations for a range (filtering out decorations from other editors).\n\t */\n\tgetDecorationsInRange(range: Range): IModelDecoration[] | null;\n\n\t/**\n\t * Get the font size at a given position\n\t * @param position the position for which to fetch the font size\n\t */\n\tgetFontSizeAtPosition(position: IPosition): string | null;\n\n\t/**\n\t * All decorations added through this call will get the ownerId of this editor.\n\t * @deprecated Use `createDecorationsCollection`\n\t * @see createDecorationsCollection\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];\n\n\t/**\n\t * Remove previously added decorations.\n\t */\n\tremoveDecorations(decorationIds: string[]): void;\n\n\t/**\n\t * @internal\n\t */\n\tremoveDecorationsByType(decorationTypeKey: string): void;\n\n\t/**\n\t * Get the layout info for the editor.\n\t */\n\tgetLayoutInfo(): EditorLayoutInfo;\n\n\t/**\n\t * Returns the ranges that are currently visible.\n\t * Does not account for horizontal scrolling.\n\t */\n\tgetVisibleRanges(): Range[];\n\n\t/**\n\t * @internal\n\t */\n\tgetVisibleRangesPlusViewportAboveBelow(): Range[];\n\n\t/**\n\t * Get the vertical position (top offset) for the line's top w.r.t. to the first line.\n\t */\n\tgetTopForLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the line's bottom w.r.t. to the first line.\n\t */\n\tgetBottomForLineNumber(lineNumber: number): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the position w.r.t. to the first line.\n\t */\n\tgetTopForPosition(lineNumber: number, column: number): number;\n\n\t/**\n\t * Get the line height for a model position.\n\t */\n\tgetLineHeightForPosition(position: IPosition): number;\n\n\t/**\n\t * Set the model ranges that will be hidden in the view.\n\t * Hidden areas are stored per source.\n\t * @internal\n\t */\n\tsetHiddenAreas(ranges: IRange[], source?: unknown): void;\n\n\t/**\n\t * Sets the editor aria options, primarily the active descendent.\n\t * @internal\n\t */\n\tsetAriaOptions(options: IEditorAriaOptions): void;\n\n\t/**\n\t * Write the screen reader content to be the current selection\n\t */\n\twriteScreenReaderContent(reason: string): void;\n\n\t/**\n\t * Returns the editor's container dom node\n\t */\n\tgetContainerDomNode(): HTMLElement;\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement | null;\n\n\t/**\n\t * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Remove a content widget.\n\t */\n\tremoveContentWidget(widget: IContentWidget): void;\n\n\t/**\n\t * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Remove an overlay widget.\n\t */\n\tremoveOverlayWidget(widget: IOverlayWidget): void;\n\n\t/**\n\t * Add a glyph margin widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\t/**\n\t * Layout/Reposition a glyph margin widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\t/**\n\t * Remove a glyph margin widget.\n\t */\n\tremoveGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\n\t/**\n\t * Change the view zones. View zones are lost when a new model is attached to the editor.\n\t */\n\tchangeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;\n\n\t/**\n\t * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.\n\t * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).\n\t * Use this method with caution.\n\t */\n\tgetOffsetForColumn(lineNumber: number, column: number): number;\n\n\t/**\n\t * Force an editor render now.\n\t */\n\trender(forceRedraw?: boolean): void;\n\n\t/**\n\t * Get the hit test target at coordinates `clientX` and `clientY`.\n\t * The coordinates are relative to the top-left of the viewport.\n\t *\n\t * @returns Hit test target or null if the coordinates fall outside the editor or the editor has no model.\n\t */\n\tgetTargetAtClientPoint(clientX: number, clientY: number): IMouseTarget | null;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number } | null;\n\n\t/**\n\t * Apply the same font settings as the editor to `target`.\n\t */\n\tapplyFontInfo(target: HTMLElement): void;\n\n\t/**\n\t * Check if the current instance has a model attached.\n\t * @internal\n\t */\n\thasModel(): this is IActiveCodeEditor;\n\n\tsetBanner(bannerDomNode: HTMLElement | null, height: number): void;\n\n\t/**\n\t * Is called when the model has been set, view state was restored and options are updated.\n\t * This is the best place to compute data for the viewport (such as tokens).\n\t */\n\thandleInitialized?(): void;\n}\n\n/**\n * @internal\n */\nexport interface IActiveCodeEditor extends ICodeEditor {\n\t/**\n\t * Returns the primary position of the cursor.\n\t */\n\tgetPosition(): Position;\n\n\t/**\n\t * Returns the primary selection of the editor.\n\t */\n\tgetSelection(): Selection;\n\n\t/**\n\t * Returns all the selections of the editor.\n\t */\n\tgetSelections(): Selection[];\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[];\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number };\n}\n\n/**\n * A rich diff editor.\n */\nexport interface IDiffEditor extends editorCommon.IEditor {\n\n\t/**\n\t * @see {@link ICodeEditor.getContainerDomNode}\n\t */\n\tgetContainerDomNode(): HTMLElement;\n\n\t/**\n\t * An event emitted when the diff information computed by this diff editor has been updated.\n\t * @event\n\t */\n\treadonly onDidUpdateDiff: Event<void>;\n\n\t/**\n\t * An event emitted when the diff model is changed (i.e. the diff editor shows new content).\n\t * @event\n\t */\n\treadonly onDidChangeModel: Event<void>;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.IDiffEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.IDiffEditorViewState | null): void;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): editorCommon.IDiffEditorModel | null;\n\n\tcreateViewModel(model: editorCommon.IDiffEditorModel): editorCommon.IDiffEditorViewModel;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: editorCommon.IDiffEditorModel | editorCommon.IDiffEditorViewModel | null): void;\n\n\t/**\n\t * Get the `original` editor.\n\t */\n\tgetOriginalEditor(): ICodeEditor;\n\n\t/**\n\t * Get the `modified` editor.\n\t */\n\tgetModifiedEditor(): ICodeEditor;\n\n\t/**\n\t * Get the computed diff information.\n\t */\n\tgetLineChanges(): ILineChange[] | null;\n\n\t/**\n\t * Update the editor's options after the editor has been created.\n\t */\n\tupdateOptions(newOptions: IDiffEditorOptions): void;\n\n\t/**\n\t * Jumps to the next or previous diff.\n\t */\n\tgoToDiff(target: 'next' | 'previous'): void;\n\n\t/**\n\t * Scrolls to the first diff.\n\t * (Waits until the diff computation finished.)\n\t */\n\trevealFirstDiff(): unknown;\n\n\taccessibleDiffViewerNext(): void;\n\n\taccessibleDiffViewerPrev(): void;\n\n\thandleInitialized(): void;\n}\n\n/**\n *@internal\n */\nexport function isCodeEditor(thing: unknown): thing is ICodeEditor {\n\tif (thing && typeof (<ICodeEditor>thing).getEditorType === 'function') {\n\t\treturn (<ICodeEditor>thing).getEditorType() === editorCommon.EditorType.ICodeEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isDiffEditor(thing: unknown): thing is IDiffEditor {\n\tif (thing && typeof (<IDiffEditor>thing).getEditorType === 'function') {\n\t\treturn (<IDiffEditor>thing).getEditorType() === editorCommon.EditorType.IDiffEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isCompositeEditor(thing: unknown): thing is editorCommon.ICompositeCodeEditor {\n\treturn !!thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof (<editorCommon.ICompositeCodeEditor>thing).onDidChangeActiveEditor === 'function';\n\n}\n\n/**\n *@internal\n */\nexport function getCodeEditor(thing: unknown): ICodeEditor | null {\n\tif (isCodeEditor(thing)) {\n\t\treturn thing;\n\t}\n\n\tif (isDiffEditor(thing)) {\n\t\treturn thing.getModifiedEditor();\n\t}\n\n\tif (isCompositeEditor(thing) && isCodeEditor(thing.activeCodeEditor)) {\n\t\treturn thing.activeCodeEditor;\n\t}\n\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IKeyboardEvent } from '../../base/browser/keyboardEvent.js';\nimport { IMouseEvent, IMouseWheelEvent } from '../../base/browser/mouseEvent.js';\nimport { Event } from '../../base/common/event.js';\nimport { IEditorConstructionOptions } from './config/editorConfiguration.js';\nimport { ConfigurationChangedEvent, EditorLayoutInfo, EditorOption, FindComputedEditorOptionValueById, IComputedEditorOptions, IDiffEditorOptions, IEditorOptions, OverviewRulerPosition } from '../common/config/editorOptions.js';\nimport { IDimension } from '../common/core/2d/dimension.js';\nimport { IPosition, Position } from '../common/core/position.js';\nimport { IRange, Range } from '../common/core/range.js';\nimport { Selection } from '../common/core/selection.js';\nimport { IWordAtPosition } from '../common/core/wordHelper.js';\nimport { ICursorPositionChangedEvent, ICursorSelectionChangedEvent } from '../common/cursorEvents.js';\nimport { ILineChange } from '../common/diff/legacyLinesDiffComputer.js';\nimport * as editorCommon from '../common/editorCommon.js';\nimport { GlyphMarginLane, ICursorStateComputer, IIdentifiedSingleEditOperation, IModelDecoration, IModelDeltaDecoration, ITextModel, PositionAffinity } from '../common/model.js';\nimport { InjectedText } from '../common/modelLineProjectionData.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, ModelFontChangedEvent, ModelLineHeightChangedEvent } from '../common/textModelEvents.js';\nimport { IViewModel } from '../common/viewModel.js';\nimport { OverviewRulerZone } from '../common/viewModel/overviewZoneManager.js';\nimport { MenuId } from '../../platform/actions/common/actions.js';\nimport { ServicesAccessor } from '../../platform/instantiation/common/instantiation.js';\nimport { TextEdit } from '../common/core/edits/textEdit.js';\nimport { TextModelEditSource } from '../common/textModelEditSource.js';\n\n/**\n * A view zone is a full horizontal rectangle that 'pushes' text down.\n * The editor reserves space for view zones when rendering.\n */\nexport interface IViewZone {\n\t/**\n\t * The line number after which this zone should appear.\n\t * Use 0 to place a view zone before the first line number.\n\t */\n\tafterLineNumber: number;\n\t/**\n\t * The column after which this zone should appear.\n\t * If not set, the maxLineColumn of `afterLineNumber` will be used.\n\t * This is relevant for wrapped lines.\n\t */\n\tafterColumn?: number;\n\t/**\n\t * If the `afterColumn` has multiple view columns, the affinity specifies which one to use. Defaults to `none`.\n\t*/\n\tafterColumnAffinity?: PositionAffinity;\n\t/**\n\t * Render the zone even when its line is hidden.\n\t */\n\tshowInHiddenAreas?: boolean;\n\t/**\n\t * Tiebreaker that is used when multiple view zones want to be after the same line.\n\t * Defaults to `afterColumn` otherwise 10000;\n\t */\n\tordinal?: number;\n\t/**\n\t * Suppress mouse down events.\n\t * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.\n\t * Defaults to false\n\t */\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * The height in lines of the view zone.\n\t * If specified, `heightInPx` will be used instead of this.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInLines?: number;\n\t/**\n\t * The height in px of the view zone.\n\t * If this is set, the editor will give preference to it rather than `heightInLines` above.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInPx?: number;\n\t/**\n\t * The minimum width in px of the view zone.\n\t * If this is set, the editor will ensure that the scroll width is >= than this value.\n\t */\n\tminWidthInPx?: number;\n\t/**\n\t * The dom node of the view zone\n\t */\n\tdomNode: HTMLElement;\n\t/**\n\t * An optional dom node for the view zone that will be placed in the margin area.\n\t */\n\tmarginDomNode?: HTMLElement | null;\n\t/**\n\t * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).\n\t */\n\tonDomNodeTop?: (top: number) => void;\n\t/**\n\t * Callback which gives the height in pixels of the view zone.\n\t */\n\tonComputedHeight?: (height: number) => void;\n}\n/**\n * An accessor that allows for zones to be added or removed.\n */\nexport interface IViewZoneChangeAccessor {\n\t/**\n\t * Create a new view zone.\n\t * @param zone Zone to create\n\t * @return A unique identifier to the view zone.\n\t */\n\taddZone(zone: IViewZone): string;\n\t/**\n\t * Remove a zone\n\t * @param id A unique identifier to the view zone, as returned by the `addZone` call.\n\t */\n\tremoveZone(id: string): void;\n\t/**\n\t * Change a zone's position.\n\t * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.\n\t */\n\tlayoutZone(id: string): void;\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport const enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW\n}\n/**\n * A position for rendering content widgets.\n */\nexport interface IContentWidgetPosition {\n\t/**\n\t * Desired position which serves as an anchor for placing the content widget.\n\t * The widget will be placed above, at, or below the specified position, based on the\n\t * provided preference. The widget will always touch this position.\n\t *\n\t * Given sufficient horizontal space, the widget will be placed to the right of the\n\t * passed in position. This can be tweaked by providing a `secondaryPosition`.\n\t *\n\t * @see preference\n\t * @see secondaryPosition\n\t */\n\tposition: IPosition | null;\n\t/**\n\t * Optionally, a secondary position can be provided to further define the placing of\n\t * the content widget. The secondary position must have the same line number as the\n\t * primary position. If possible, the widget will be placed such that it also touches\n\t * the secondary position.\n\t */\n\tsecondaryPosition?: IPosition | null;\n\t/**\n\t * Placement preference for position, in order of preference.\n\t */\n\tpreference: ContentWidgetPositionPreference[];\n\n\t/**\n\t * Placement preference when multiple view positions refer to the same (model) position.\n\t * This plays a role when injected text is involved.\n\t*/\n\tpositionAffinity?: PositionAffinity;\n}\n/**\n * A content widget renders inline with the text and can be easily placed 'near' an editor position.\n */\nexport interface IContentWidget {\n\t/**\n\t * Render this content widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\t/**\n\t * Call preventDefault() on mousedown events that target the content widget.\n\t */\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * Get a unique identifier of the content widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the content widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the content widget.\n\t * If null is returned, the content widget will be placed off screen.\n\t */\n\tgetPosition(): IContentWidgetPosition | null;\n\t/**\n\t * Optional function that is invoked before rendering\n\t * the content widget. If a dimension is returned the editor will\n\t * attempt to use it.\n\t */\n\tbeforeRender?(): IDimension | null;\n\t/**\n\t * Optional function that is invoked after rendering the content\n\t * widget. Is being invoked with the selected position preference\n\t * or `null` if not rendered.\n\t */\n\tafterRender?(position: ContentWidgetPositionPreference | null, coordinate: IContentWidgetRenderedCoordinate | null): void;\n}\n\n/**\n * Coordinatees passed in {@link IContentWidget.afterRender}\n */\nexport interface IContentWidgetRenderedCoordinate {\n\t/**\n\t * Top position relative to the editor content.\n\t */\n\treadonly top: number;\n\n\t/**\n\t * Left position relative to the editor content.\n\t */\n\treadonly left: number;\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport const enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER\n}\n\n\n/**\n * Represents editor-relative coordinates of an overlay widget.\n */\nexport interface IOverlayWidgetPositionCoordinates {\n\t/**\n\t * The top position for the overlay widget, relative to the editor.\n\t */\n\ttop: number;\n\t/**\n\t * The left position for the overlay widget, relative to the editor.\n\t */\n\tleft: number;\n}\n\n/**\n * A position for rendering overlay widgets.\n */\nexport interface IOverlayWidgetPosition {\n\t/**\n\t * The position preference for the overlay widget.\n\t */\n\tpreference: OverlayWidgetPositionPreference | IOverlayWidgetPositionCoordinates | null;\n\n\t/**\n\t * When set, stacks with other overlay widgets with the same preference,\n\t * in an order determined by the ordinal value.\n\t */\n\tstackOridinal?: number;\n}\n/**\n * An overlay widgets renders on top of the text.\n */\nexport interface IOverlayWidget {\n\t/**\n\t * Event fired when the widget layout changes.\n\t */\n\tonDidLayout?: Event<void>;\n\t/**\n\t * Render this overlay widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\t/**\n\t * Get a unique identifier of the overlay widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the overlay widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the overlay widget.\n\t * If null is returned, the overlay widget is responsible to place itself.\n\t */\n\tgetPosition(): IOverlayWidgetPosition | null;\n\t/**\n\t * The editor will ensure that the scroll width is >= than this value.\n\t */\n\tgetMinContentWidthInPx?(): number;\n}\n\n/**\n * A glyph margin widget renders in the editor glyph margin.\n */\nexport interface IGlyphMarginWidget {\n\t/**\n\t * Get a unique identifier of the glyph widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the glyph widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the glyph widget.\n\t */\n\tgetPosition(): IGlyphMarginWidgetPosition;\n}\n\n/**\n * A position for rendering glyph margin widgets.\n */\nexport interface IGlyphMarginWidgetPosition {\n\t/**\n\t * The glyph margin lane where the widget should be shown.\n\t */\n\tlane: GlyphMarginLane;\n\t/**\n\t * The priority order of the widget, used for determining which widget\n\t * to render when there are multiple.\n\t */\n\tzIndex: number;\n\t/**\n\t * The editor range that this widget applies to.\n\t */\n\trange: IRange;\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport const enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET,\n\t/**\n\t * Mouse is outside of the editor.\n\t */\n\tOUTSIDE_EDITOR,\n}\nexport interface IBaseMouseTarget {\n\t/**\n\t * The target element\n\t */\n\treadonly element: HTMLElement | null;\n\t/**\n\t * The 'approximate' editor position\n\t */\n\treadonly position: Position | null;\n\t/**\n\t * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\n\t */\n\treadonly mouseColumn: number;\n\t/**\n\t * The 'approximate' editor range\n\t */\n\treadonly range: Range | null;\n}\nexport interface IMouseTargetUnknown extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.UNKNOWN;\n}\nexport interface IMouseTargetTextarea extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.TEXTAREA;\n\treadonly position: null;\n\treadonly range: null;\n}\nexport interface IMouseTargetMarginData {\n\treadonly isAfterLines: boolean;\n\treadonly glyphMarginLeft: number;\n\treadonly glyphMarginWidth: number;\n\treadonly glyphMarginLane?: GlyphMarginLane;\n\treadonly lineNumbersWidth: number;\n\treadonly offsetX: number;\n}\nexport interface IMouseTargetMargin extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.GUTTER_GLYPH_MARGIN | MouseTargetType.GUTTER_LINE_NUMBERS | MouseTargetType.GUTTER_LINE_DECORATIONS;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetMarginData;\n}\nexport interface IMouseTargetViewZoneData {\n\treadonly viewZoneId: string;\n\treadonly positionBefore: Position | null;\n\treadonly positionAfter: Position | null;\n\treadonly position: Position;\n\treadonly afterLineNumber: number;\n}\nexport interface IMouseTargetViewZone extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.GUTTER_VIEW_ZONE | MouseTargetType.CONTENT_VIEW_ZONE;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetViewZoneData;\n}\nexport interface IMouseTargetContentTextData {\n\treadonly mightBeForeignElement: boolean;\n\t/**\n\t * @internal\n\t */\n\treadonly injectedText: InjectedText | null;\n}\nexport interface IMouseTargetContentText extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_TEXT;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetContentTextData;\n}\nexport interface IMouseTargetContentEmptyData {\n\treadonly isAfterLines: boolean;\n\treadonly horizontalDistanceToText?: number;\n}\nexport interface IMouseTargetContentEmpty extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_EMPTY;\n\treadonly position: Position;\n\treadonly range: Range;\n\treadonly detail: IMouseTargetContentEmptyData;\n}\nexport interface IMouseTargetContentWidget extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.CONTENT_WIDGET;\n\treadonly position: null;\n\treadonly range: null;\n\treadonly detail: string;\n}\nexport interface IMouseTargetOverlayWidget extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OVERLAY_WIDGET;\n\treadonly position: null;\n\treadonly range: null;\n\treadonly detail: string;\n}\nexport interface IMouseTargetScrollbar extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.SCROLLBAR;\n\treadonly position: Position;\n\treadonly range: Range;\n}\nexport interface IMouseTargetOverviewRuler extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OVERVIEW_RULER;\n}\nexport interface IMouseTargetOutsideEditor extends IBaseMouseTarget {\n\treadonly type: MouseTargetType.OUTSIDE_EDITOR;\n\treadonly outsidePosition: 'above' | 'below' | 'left' | 'right';\n\treadonly outsideDistance: number;\n}\n/**\n * Target hit with the mouse in the editor.\n */\nexport type IMouseTarget = (\n\tIMouseTargetUnknown\n\t| IMouseTargetTextarea\n\t| IMouseTargetMargin\n\t| IMouseTargetViewZone\n\t| IMouseTargetContentText\n\t| IMouseTargetContentEmpty\n\t| IMouseTargetContentWidget\n\t| IMouseTargetOverlayWidget\n\t| IMouseTargetScrollbar\n\t| IMouseTargetOverviewRuler\n\t| IMouseTargetOutsideEditor\n);\n/**\n * A mouse event originating from the editor.\n */\nexport interface IEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget;\n}\nexport interface IPartialEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget | null;\n}\n\n/**\n * A paste event originating from the editor.\n */\nexport interface IPasteEvent {\n\treadonly range: Range;\n\treadonly languageId: string | null;\n\treadonly clipboardEvent?: ClipboardEvent;\n}\n\n/**\n * @internal\n */\nexport interface PastePayload {\n\ttext: string;\n\tpasteOnNewLine: boolean;\n\tmulticursorText: string[] | null;\n\tmode: string | null;\n\tclipboardEvent?: ClipboardEvent;\n}\n\n/**\n * An overview ruler\n * @internal\n */\nexport interface IOverviewRuler {\n\tgetDomNode(): HTMLElement;\n\tdispose(): void;\n\tsetZones(zones: OverviewRulerZone[]): void;\n\tsetLayout(position: OverviewRulerPosition): void;\n}\n\n/**\n * Editor aria options.\n * @internal\n */\nexport interface IEditorAriaOptions {\n\tactiveDescendant: string | undefined;\n\trole?: string;\n}\n\nexport interface IDiffEditorConstructionOptions extends IDiffEditorOptions, IEditorConstructionOptions {\n\t/**\n\t * Place overflow widgets inside an external DOM node.\n\t * Defaults to an internal DOM node.\n\t */\n\toverflowWidgetsDomNode?: HTMLElement;\n\n\t/**\n\t * Aria label for original editor.\n\t */\n\toriginalAriaLabel?: string;\n\n\t/**\n\t * Aria label for modified editor.\n\t */\n\tmodifiedAriaLabel?: string;\n}\n\n/**\n * A rich code editor.\n */\nexport interface ICodeEditor extends editorCommon.IEditor {\n\t/**\n\t * This editor is used as an alternative to an <input> box, i.e. as a simple widget.\n\t * @internal\n\t */\n\treadonly isSimpleWidget: boolean;\n\t/**\n\t * The context menu ID that should be used to lookup context menu actions.\n\t * @internal\n\t */\n\treadonly contextMenuId: MenuId;\n\t/**\n\t * An event emitted when the content of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelContent: Event<IModelContentChangedEvent>;\n\t/**\n\t * An event emitted when the language of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the options of the current model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)\n\t * @event\n\t */\n\treadonly onDidChangeConfiguration: Event<ConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the cursor position has changed.\n\t * @event\n\t */\n\treadonly onDidChangeCursorPosition: Event<ICursorPositionChangedEvent>;\n\t/**\n\t * An event emitted when the cursor selection has changed.\n\t * @event\n\t */\n\treadonly onDidChangeCursorSelection: Event<ICursorSelectionChangedEvent>;\n\t/**\n\t * An event emitted when the model of this editor is about to change (e.g. from `editor.setModel()`).\n\t * @event\n\t */\n\treadonly onWillChangeModel: Event<editorCommon.IModelChangedEvent>;\n\t/**\n\t * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).\n\t * @event\n\t */\n\treadonly onDidChangeModel: Event<editorCommon.IModelChangedEvent>;\n\t/**\n\t * An event emitted when the decorations of the current model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeModelDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when the tokens of the current model have changed.\n\t * @internal\n\t */\n\treadonly onDidChangeModelTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).\n\t * @event\n\t */\n\treadonly onDidFocusEditorText: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).\n\t * @event\n\t */\n\treadonly onDidBlurEditorText: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget gained focus.\n\t * @event\n\t */\n\treadonly onDidFocusEditorWidget: Event<void>;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget lost focus.\n\t * @event\n\t */\n\treadonly onDidBlurEditorWidget: Event<void>;\n\t/**\n\t * An event emitted before interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\treadonly onWillType: Event<string>;\n\t/**\n\t * An event emitted after interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidType: Event<string>;\n\t/**\n\t * Boolean indicating whether input is in composition\n\t */\n\treadonly inComposition: boolean;\n\t/**\n\t * An event emitted after composition has started.\n\t */\n\treadonly onDidCompositionStart: Event<void>;\n\t/**\n\t * An event emitted after composition has ended.\n\t */\n\treadonly onDidCompositionEnd: Event<void>;\n\t/**\n\t * An event emitted when editing failed because the editor is read-only.\n\t * @event\n\t */\n\treadonly onDidAttemptReadOnlyEdit: Event<void>;\n\t/**\n\t * An event emitted when users paste text in the editor.\n\t * @event\n\t */\n\treadonly onDidPaste: Event<IPasteEvent>;\n\t/**\n\t * An event emitted on a \"mouseup\".\n\t * @event\n\t */\n\treadonly onMouseUp: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedown\".\n\t * @event\n\t */\n\treadonly onMouseDown: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedrag\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDrag: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedrop\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDrop: Event<IPartialEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousedropcanceled\".\n\t * @internal\n\t * @event\n\t */\n\treadonly onMouseDropCanceled: Event<void>;\n\t/**\n\t * An event emitted when content is dropped into the editor.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDropIntoEditor: Event<{ readonly position: IPosition; readonly event: DragEvent }>;\n\t/**\n\t * An event emitted on a \"contextmenu\".\n\t * @event\n\t */\n\treadonly onContextMenu: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousemove\".\n\t * @event\n\t */\n\treadonly onMouseMove: Event<IEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mouseleave\".\n\t * @event\n\t */\n\treadonly onMouseLeave: Event<IPartialEditorMouseEvent>;\n\t/**\n\t * An event emitted on a \"mousewheel\"\n\t * @event\n\t * @internal\n\t */\n\treadonly onMouseWheel: Event<IMouseWheelEvent>;\n\t/**\n\t * An event emitted on a \"keyup\".\n\t * @event\n\t */\n\treadonly onKeyUp: Event<IKeyboardEvent>;\n\t/**\n\t * An event emitted on a \"keydown\".\n\t * @event\n\t */\n\treadonly onKeyDown: Event<IKeyboardEvent>;\n\t/**\n\t * An event emitted when the layout of the editor has changed.\n\t * @event\n\t */\n\treadonly onDidLayoutChange: Event<EditorLayoutInfo>;\n\t/**\n\t * An event emitted when the content width or content height in the editor has changed.\n\t * @event\n\t */\n\treadonly onDidContentSizeChange: Event<editorCommon.IContentSizeChangedEvent>;\n\t/**\n\t * An event emitted when the scroll in the editor has changed.\n\t * @event\n\t */\n\treadonly onDidScrollChange: Event<editorCommon.IScrollEvent>;\n\n\t/**\n\t * An event emitted when hidden areas change in the editor (e.g. due to folding).\n\t * @event\n\t */\n\treadonly onDidChangeHiddenAreas: Event<void>;\n\n\t/**\n\t * Some editor operations fire multiple events at once.\n\t * To allow users to react to multiple events fired by a single operation,\n\t * the editor fires a begin update before the operation and an end update after the operation.\n\t * Whenever the editor fires `onBeginUpdate`, it will also fire `onEndUpdate` once the operation finishes.\n\t * Note that not all operations are bracketed by `onBeginUpdate` and `onEndUpdate`.\n\t*/\n\treadonly onBeginUpdate: Event<void>;\n\n\t/**\n\t * Fires after the editor completes the operation it fired `onBeginUpdate` for.\n\t*/\n\treadonly onEndUpdate: Event<void>;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.ICodeEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.ICodeEditorViewState | null): void;\n\n\t/**\n\t * Returns true if the text inside this editor or an editor widget has focus.\n\t */\n\thasWidgetFocus(): boolean;\n\n\t/**\n\t * Get a contribution of this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The contribution or null if contribution not found.\n\t */\n\tgetContribution<T extends editorCommon.IEditorContribution>(id: string): T | null;\n\n\t/**\n\t * Execute `fn` with the editor's services.\n\t * @internal\n\t */\n\tinvokeWithinContext<T>(fn: (accessor: ServicesAccessor) => T): T;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel | null;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: ITextModel | null): void;\n\n\t/**\n\t * Gets all the editor computed options.\n\t */\n\tgetOptions(): IComputedEditorOptions;\n\n\t/**\n\t * Gets a specific editor option.\n\t */\n\tgetOption<T extends EditorOption>(id: T): FindComputedEditorOptionValueById<T>;\n\n\t/**\n\t * Returns the editor's configuration (without any validation or defaults).\n\t */\n\tgetRawOptions(): IEditorOptions;\n\n\t/**\n\t * @internal\n\t */\n\tgetOverflowWidgetsDomNode(): HTMLElement | undefined;\n\n\t/**\n\t * @internal\n\t */\n\tgetConfiguredWordAtPosition(position: Position): IWordAtPosition | null;\n\n\t/**\n\t * An event emitted when line heights from decorations change\n\t * @internal\n\t * @event\n\t */\n\tonDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\n\t/**\n\t * An event emitted when the font of the editor has changed.\n\t * @internal\n\t * @event\n\t */\n\tonDidChangeFont: Event<ModelFontChangedEvent>;\n\n\t/**\n\t * Get value of the current model attached to this editor.\n\t * @see {@link ITextModel.getValue}\n\t */\n\tgetValue(options?: { preserveBOM: boolean; lineEnding: string }): string;\n\n\t/**\n\t * Set the value of the current model attached to this editor.\n\t * @see {@link ITextModel.setValue}\n\t */\n\tsetValue(newValue: string): void;\n\n\t/**\n\t * Get the width of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollWidth = Math.max(contentWidth, width)`\n\t */\n\tgetContentWidth(): number;\n\t/**\n\t * Get the scrollWidth of the editor's viewport.\n\t */\n\tgetScrollWidth(): number;\n\t/**\n\t * Get the scrollLeft of the editor's viewport.\n\t */\n\tgetScrollLeft(): number;\n\n\t/**\n\t * Get the height of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollHeight = Math.max(contentHeight, height)`\n\t */\n\tgetContentHeight(): number;\n\t/**\n\t * Get the scrollHeight of the editor's viewport.\n\t */\n\tgetScrollHeight(): number;\n\t/**\n\t * Get the scrollTop of the editor's viewport.\n\t */\n\tgetScrollTop(): number;\n\n\t/**\n\t * Change the scrollLeft of the editor's viewport.\n\t */\n\tsetScrollLeft(newScrollLeft: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scrollTop of the editor's viewport.\n\t */\n\tsetScrollTop(newScrollTop: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scroll position of the editor's viewport.\n\t */\n\tsetScrollPosition(position: editorCommon.INewScrollPosition, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Check if the editor is currently scrolling towards a different scroll position.\n\t */\n\thasPendingScrollAnimation(): boolean;\n\n\t/**\n\t * Get an action that is a contribution to this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The action or null if action not found.\n\t */\n\tgetAction(id: string): editorCommon.IEditorAction | null;\n\n\t/**\n\t * Execute a command on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param command The command to execute\n\t */\n\texecuteCommand(source: string | null | undefined, command: editorCommon.ICommand): void;\n\n\t/**\n\t * Create an \"undo stop\" in the undo-redo stack.\n\t */\n\tpushUndoStop(): boolean;\n\n\t/**\n\t * Remove the \"undo stop\" in the undo-redo stack.\n\t */\n\tpopUndoStop(): boolean;\n\n\t/**\n\t * Execute edits on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param edits The edits to execute.\n\t * @param endCursorState Cursor state after the edits were applied.\n\t */\n\texecuteEdits(source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;\n\t/** @internal */\n\texecuteEdits(source: TextModelEditSource | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;\n\n\t/**\n\t * @internal\n\t*/\n\tedit(edit: TextEdit, reason: TextModelEditSource): void;\n\n\t/**\n\t * Execute multiple (concomitant) commands on the editor.\n\t * @param source The source of the call.\n\t * @param command The commands to execute\n\t */\n\texecuteCommands(source: string | null | undefined, commands: (editorCommon.ICommand | null)[]): void;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel | null;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[] | null;\n\n\t/**\n\t * Get all the decorations for a range (filtering out decorations from other editors).\n\t */\n\tgetDecorationsInRange(range: Range): IModelDecoration[] | null;\n\n\t/**\n\t * Get the font size at a given position\n\t * @param position the position for which to fetch the font size\n\t */\n\tgetFontSizeAtPosition(position: IPosition): string | null;\n\n\t/**\n\t * All decorations added through this call will get the ownerId of this editor.\n\t * @deprecated Use `createDecorationsCollection`\n\t * @see createDecorationsCollection\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];\n\n\t/**\n\t * Remove previously added decorations.\n\t */\n\tremoveDecorations(decorationIds: string[]): void;\n\n\t/**\n\t * @internal\n\t */\n\tremoveDecorationsByType(decorationTypeKey: string): void;\n\n\t/**\n\t * Get the layout info for the editor.\n\t */\n\tgetLayoutInfo(): EditorLayoutInfo;\n\n\t/**\n\t * Returns the ranges that are currently visible.\n\t * Does not account for horizontal scrolling.\n\t */\n\tgetVisibleRanges(): Range[];\n\n\t/**\n\t * @internal\n\t */\n\tgetVisibleRangesPlusViewportAboveBelow(): Range[];\n\n\t/**\n\t * Get the vertical position (top offset) for the line's top w.r.t. to the first line.\n\t */\n\tgetTopForLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the line's bottom w.r.t. to the first line.\n\t */\n\tgetBottomForLineNumber(lineNumber: number): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the position w.r.t. to the first line.\n\t */\n\tgetTopForPosition(lineNumber: number, column: number): number;\n\n\t/**\n\t * Get the line height for a model position.\n\t */\n\tgetLineHeightForPosition(position: IPosition): number;\n\n\t/**\n\t * Set the model ranges that will be hidden in the view.\n\t * Hidden areas are stored per source.\n\t * @internal\n\t */\n\tsetHiddenAreas(ranges: IRange[], source?: unknown): void;\n\n\t/**\n\t * Sets the editor aria options, primarily the active descendent.\n\t * @internal\n\t */\n\tsetAriaOptions(options: IEditorAriaOptions): void;\n\n\t/**\n\t * Write the screen reader content to be the current selection\n\t */\n\twriteScreenReaderContent(reason: string): void;\n\n\t/**\n\t * Returns the editor's container dom node\n\t */\n\tgetContainerDomNode(): HTMLElement;\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement | null;\n\n\t/**\n\t * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Remove a content widget.\n\t */\n\tremoveContentWidget(widget: IContentWidget): void;\n\n\t/**\n\t * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Remove an overlay widget.\n\t */\n\tremoveOverlayWidget(widget: IOverlayWidget): void;\n\n\t/**\n\t * Add a glyph margin widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\t/**\n\t * Layout/Reposition a glyph margin widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\t/**\n\t * Remove a glyph margin widget.\n\t */\n\tremoveGlyphMarginWidget(widget: IGlyphMarginWidget): void;\n\n\t/**\n\t * Change the view zones. View zones are lost when a new model is attached to the editor.\n\t */\n\tchangeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;\n\n\t/**\n\t * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.\n\t * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).\n\t * Use this method with caution.\n\t */\n\tgetOffsetForColumn(lineNumber: number, column: number): number;\n\n\t/**\n\t * Force an editor render now.\n\t */\n\trender(forceRedraw?: boolean): void;\n\n\t/**\n\t * Get the hit test target at coordinates `clientX` and `clientY`.\n\t * The coordinates are relative to the top-left of the viewport.\n\t *\n\t * @returns Hit test target or null if the coordinates fall outside the editor or the editor has no model.\n\t */\n\tgetTargetAtClientPoint(clientX: number, clientY: number): IMouseTarget | null;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number } | null;\n\n\t/**\n\t * Apply the same font settings as the editor to `target`.\n\t */\n\tapplyFontInfo(target: HTMLElement): void;\n\n\t/**\n\t * Check if the current instance has a model attached.\n\t * @internal\n\t */\n\thasModel(): this is IActiveCodeEditor;\n\n\tsetBanner(bannerDomNode: HTMLElement | null, height: number): void;\n\n\t/**\n\t * Is called when the model has been set, view state was restored and options are updated.\n\t * This is the best place to compute data for the viewport (such as tokens).\n\t */\n\thandleInitialized?(): void;\n}\n\n/**\n * @internal\n */\nexport interface IActiveCodeEditor extends ICodeEditor {\n\t/**\n\t * Returns the primary position of the cursor.\n\t */\n\tgetPosition(): Position;\n\n\t/**\n\t * Returns the primary selection of the editor.\n\t */\n\tgetSelection(): Selection;\n\n\t/**\n\t * Returns all the selections of the editor.\n\t */\n\tgetSelections(): Selection[];\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[];\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number };\n}\n\n/**\n * A rich diff editor.\n */\nexport interface IDiffEditor extends editorCommon.IEditor {\n\n\t/**\n\t * @see {@link ICodeEditor.getContainerDomNode}\n\t */\n\tgetContainerDomNode(): HTMLElement;\n\n\t/**\n\t * An event emitted when the diff information computed by this diff editor has been updated.\n\t * @event\n\t */\n\treadonly onDidUpdateDiff: Event<void>;\n\n\t/**\n\t * An event emitted when the diff model is changed (i.e. the diff editor shows new content).\n\t * @event\n\t */\n\treadonly onDidChangeModel: Event<void>;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.IDiffEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.IDiffEditorViewState | null): void;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): editorCommon.IDiffEditorModel | null;\n\n\tcreateViewModel(model: editorCommon.IDiffEditorModel): editorCommon.IDiffEditorViewModel;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: editorCommon.IDiffEditorModel | editorCommon.IDiffEditorViewModel | null): void;\n\n\t/**\n\t * Get the `original` editor.\n\t */\n\tgetOriginalEditor(): ICodeEditor;\n\n\t/**\n\t * Get the `modified` editor.\n\t */\n\tgetModifiedEditor(): ICodeEditor;\n\n\t/**\n\t * Get the computed diff information.\n\t */\n\tgetLineChanges(): ILineChange[] | null;\n\n\t/**\n\t * Update the editor's options after the editor has been created.\n\t */\n\tupdateOptions(newOptions: IDiffEditorOptions): void;\n\n\t/**\n\t * Jumps to the next or previous diff.\n\t */\n\tgoToDiff(target: 'next' | 'previous'): void;\n\n\t/**\n\t * Scrolls to the first diff.\n\t * (Waits until the diff computation finished.)\n\t */\n\trevealFirstDiff(): unknown;\n\n\taccessibleDiffViewerNext(): void;\n\n\taccessibleDiffViewerPrev(): void;\n\n\thandleInitialized(): void;\n}\n\n/**\n *@internal\n */\nexport function isCodeEditor(thing: unknown): thing is ICodeEditor {\n\tif (thing && typeof (<ICodeEditor>thing).getEditorType === 'function') {\n\t\treturn (<ICodeEditor>thing).getEditorType() === editorCommon.EditorType.ICodeEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isDiffEditor(thing: unknown): thing is IDiffEditor {\n\tif (thing && typeof (<IDiffEditor>thing).getEditorType === 'function') {\n\t\treturn (<IDiffEditor>thing).getEditorType() === editorCommon.EditorType.IDiffEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isCompositeEditor(thing: unknown): thing is editorCommon.ICompositeCodeEditor {\n\treturn !!thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof (<editorCommon.ICompositeCodeEditor>thing).onDidChangeActiveEditor === 'function';\n\n}\n\n/**\n *@internal\n */\nexport function getCodeEditor(thing: unknown): ICodeEditor | null {\n\tif (isCodeEditor(thing)) {\n\t\treturn thing;\n\t}\n\n\tif (isDiffEditor(thing)) {\n\t\treturn thing.getModifiedEditor();\n\t}\n\n\tif (isCompositeEditor(thing) && isCodeEditor(thing.activeCodeEditor)) {\n\t\treturn thing.activeCodeEditor;\n\t}\n\n\treturn null;\n}\n"]}