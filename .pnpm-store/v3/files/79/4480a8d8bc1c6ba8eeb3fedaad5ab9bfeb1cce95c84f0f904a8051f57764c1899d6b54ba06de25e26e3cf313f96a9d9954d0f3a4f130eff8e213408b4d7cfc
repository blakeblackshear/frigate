{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.ts","vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,eAAe,EAAE,MAAM,iCAAiC,CAAC;AAClE,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AACzD,OAAO,EAAE,kBAAkB,EAAE,MAAM,mCAAmC,CAAC;AACvE,OAAO,EAAE,OAAO,EAAE,MAAM,kCAAkC,CAAC;AAC3D,OAAO,EAAE,aAAa,EAAE,MAAM,uCAAuC,CAAC;AAStE,OAAO,EAAE,sBAAsB,EAA0B,MAAM,wBAAwB,CAAC;AAExF,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AACnD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAE9C,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;AACtD,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAC7D,OAAO,EAAE,0BAA0B,EAAE,MAAM,kCAAkC,CAAC;AAmB9E;;GAEG;AACH,MAAM,OAAO,sBAAuB,SAAQ,kBAAkB;IAC7D;;OAEG;aACa,wBAAmB,GAAG,IAAH,AAAO,CAAC;IAqB3C,IAAI,gBAAgB;QACnB,OAAO;YACN,EAAE,OAAO,yBAAiB,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE,EAAE;YACxE,EAAE,OAAO,gCAAwB,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,uBAAuB,EAAE,EAAE;SACvF,CAAC;IACH,CAAC;IAKD,YACC,OAAoB,EACpB,cAA8B,EAC9B,MAAiB,EACjB,eAA2C;QAE3C,KAAK,CAAC,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE,eAAe,CAAC,CAAC;QAnChD,SAAI,GAAG,UAAU,CAAC;QAClB,SAAI,GAAW,0BAA0B,CAAC;QAE3C,gCAA2B,oDAA2C;QAQtE,6BAAwB,GAAU,CAAC,CAAC;QAEpC,wBAAmB,GAAW,CAAC,CAAC;QAIhC,uBAAkB,GAAY,KAAK,CAAC;QAS3B,iCAA4B,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,OAAO,EAAQ,CAAC,CAAC;QAC3E,gCAA2B,GAAG,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC;QAU9E,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAC;QAE1D,MAAM,sBAAsB,GAAG,CAAC,CAAC;QACjC,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE;YACrF,KAAK,EAAE,6BAA6B;YACpC,IAAI,EAAE,sBAAsB,GAAG,YAAY,CAAC,iBAAiB;YAC7D,KAAK,EAAE,cAAc,CAAC,OAAO,GAAG,cAAc,CAAC,QAAQ;SACvD,CAAC,CAAC,CAAC,MAAM,CAAC;QACX,IAAI,CAAC,wBAAwB,GAAG,IAAI,YAAY,CAAC,sBAAsB,CAAC,CAAC;IAC1E,CAAC;IAEO,kBAAkB,CAAC,SAAiB;QAC3C,IAAI,CAAC,eAAe,EAAE,OAAO,EAAE,CAAC;QAEhC,4FAA4F;QAC5F,MAAM,sBAAsB,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,qDAA4C,CAAC,GAAG,CAAC,CAAC,qDAA4C,CAAC;QAEnJ,MAAM,UAAU,GAAG,sBAAsB,GAAG,sBAAsB,CAAC,mBAAmB,mCAA2B,GAAG,YAAY,CAAC,iBAAiB,CAAC;QACnJ,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE;YAC7E,KAAK,EAAE,8BAA8B;YACrC,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,cAAc,CAAC,OAAO,GAAG,cAAc,CAAC,QAAQ;SACvD,CAAC,CAAC,CAAC,MAAM,CAAC;QACX,IAAI,CAAC,iBAAiB,GAAG;YACxB,IAAI,WAAW,CAAC,UAAU,CAAC;YAC3B,IAAI,WAAW,CAAC,UAAU,CAAC;SAC3B,CAAC;QACF,IAAI,CAAC,2BAA2B,GAAG,sBAAsB,CAAC;QAE1D,IAAI,CAAC,4BAA4B,CAAC,IAAI,EAAE,CAAC;IAC1C,CAAC;IAED,yBAAyB;IAEzB,2CAA2C;IAC3C,4FAA4F;IAC5F,iCAAiC;IACjC,8FAA8F;IAC9F,6FAA6F;IAC7F,wFAAwF;IACxF,sCAAsC;IAEtB,sBAAsB,CAAC,CAAgC;QACtE,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,oBAAoB,CAAC,CAA8B;QAClE,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,eAAe,CAAC,CAAyB;QACxD,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,cAAc,CAAC,CAAwB;QACtD,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,eAAe,CAAC,CAAyB;QACxD,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,cAAc,CAAC,CAAwB;QACtD,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,eAAe,CAAC,CAA0B;QACzD,MAAM,GAAG,GAAG,eAAe,EAAE,CAAC,gBAAgB,CAAC;QAC/C,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,oBAAoB,EAAE,CAAC,GAAG,GAAG,CAAC;QAC5G,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,mBAAmB,EAAE,CAAC,GAAG,GAAG,CAAC;QAC1G,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,EAAE,IAAI,CAAC,wBAAqD,CAAC,CAAC;QAC5H,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,cAAc,CAAC,CAAwB;QACtD,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,oBAAoB,CAAC,CAA8B;QAClE,OAAO,IAAI,CAAC;IACb,CAAC;IAEe,cAAc,CAAC,CAAwB;QACtD,OAAO,IAAI,CAAC;IACb,CAAC;IAED,aAAa;IAEb,KAAK;QACJ,KAAK,MAAM,WAAW,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;YAClC,yEAAyE;YACzE,MAAM,MAAM,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC,CAAC;YACrE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;QAC9F,CAAC;IACF,CAAC;IAED,MAAM,CAAC,YAA0B,EAAE,eAAgC;QAClE,uFAAuF;QACvF,2FAA2F;QAC3F,2FAA2F;QAC3F,kBAAkB;QAElB,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,IAAI,OAA2B,CAAC;QAChC,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,KAAuC,CAAC;QAC5C,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,aAAa,GAAG,CAAC,CAAC;QAEtB,IAAI,sBAA2C,CAAC;QAChD,IAAI,uBAA2C,CAAC;QAChD,IAAI,yBAA6C,CAAC;QAElD,IAAI,QAA+B,CAAC;QACpC,IAAI,UAA4B,CAAC;QACjC,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,YAAY,GAAG,CAAC,CAAC;QAErB,IAAI,MAAuB,CAAC;QAE5B,MAAM,GAAG,GAAG,eAAe,EAAE,CAAC,gBAAgB,CAAC;QAC/C,IAAI,gBAAmC,CAAC;QAExC,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC9B,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAChC,CAAC;QAED,4CAA4C;QAC5C,IAAI,IAAI,CAAC,2BAA2B,GAAG,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,eAAe,GAAG,CAAC,EAAE,CAAC;YACtG,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;QACxF,CAAC;QACD,MAAM,UAAU,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC;QAC3F,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAEnB,MAAM,cAAc,GAAG,sBAAsB,CAAC,mBAAmB,mCAA2B,CAAC;QAE7F,KAAK,CAAC,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC,IAAI,YAAY,CAAC,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;YAE7E,gEAAgE;YAChE,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,eAAe,EAAE,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC;gBACvE,SAAS;YACV,CAAC;YAED,QAAQ,GAAG,YAAY,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC;YACpD,UAAU,GAAG,CAAC,CAAC;YAEf,gBAAgB,GAAG,sBAAsB,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;YACrE,SAAS,GAAG,eAAe,CAAC,UAAU,GAAG,GAAG,CAAC;YAC7C,eAAe,GAAG,CAAC,CAAC;YAEpB,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YACzB,eAAe,GAAG,QAAQ,CAAC,SAAS,GAAG,CAAC,CAAC;YACzC,aAAa,GAAG,CAAC,CAAC;YAClB,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,SAAS,GAAG,MAAM,CAAC,QAAQ,EAAE,EAAE,UAAU,GAAG,SAAS,EAAE,UAAU,EAAE,EAAE,CAAC;gBAC9F,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAChD,IAAI,aAAa,IAAI,eAAe,EAAE,CAAC;oBACtC,6DAA6D;oBAC7D,SAAS;gBACV,CAAC;gBAED,aAAa,GAAG,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;gBAE/C,KAAK,CAAC,GAAG,eAAe,EAAE,CAAC,GAAG,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;oBAClD,uDAAuD;oBACvD,IAAI,CAAC,GAAG,sBAAsB,CAAC,mBAAmB,EAAE,CAAC;wBACpD,MAAM;oBACP,CAAC;oBACD,OAAO,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;oBAChD,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;wBAC3B,SAAS;oBACV,CAAC;oBACD,KAAK,GAAG,OAAO,CAAC;oBAEhB,IAAI,CAAC,CAAC,QAAQ,CAAC,YAAY,IAAI,eAAe,CAAC,yBAAyB,CAAC,EAAE,CAAC;wBAC3E,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC;oBAC9D,CAAC;oBAED,uBAAuB,GAAG,SAAS,CAAC;oBACpC,sBAAsB,GAAG,SAAS,CAAC;oBACnC,yBAAyB,GAAG,SAAS,CAAC;oBAEtC,gEAAgE;oBAChE,KAAK,UAAU,IAAI,QAAQ,CAAC,iBAAiB,EAAE,CAAC;wBAC/C,0EAA0E;wBAC1E,uCAAuC;wBACvC,IACC,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,eAAe,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,aAAa,CAAC;4BAC5E,CAAC,CAAC,KAAK,UAAU,CAAC,KAAK,CAAC,eAAe,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC;4BAChF,CAAC,CAAC,KAAK,UAAU,CAAC,KAAK,CAAC,aAAa,IAAI,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,EAC5E,CAAC;4BACF,SAAS;wBACV,CAAC;wBAED,MAAM,KAAK,GAAG,cAAc,CAAC,0BAA0B,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,eAAe,CAAC,CAAC;wBACvI,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;4BAC1B,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gCAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;gCACrD,QAAQ,CAAC,EAAE,CAAC;oCACX,KAAK,OAAO,CAAC,CAAC,CAAC;wCACd,+EAA+E;wCAC/E,qBAAqB;wCACrB,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wCAClD,IAAI,CAAC,WAAW,EAAE,CAAC;4CAClB,MAAM,IAAI,kBAAkB,CAAC,uBAAuB,GAAG,KAAK,CAAC,CAAC;wCAC/D,CAAC;wCACD,uBAAuB,GAAG,WAAW,CAAC,aAAa,EAAE,CAAC;wCACtD,MAAM;oCACP,CAAC;oCACD,KAAK,aAAa,CAAC,CAAC,CAAC;wCACpB,MAAM,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;wCAC9C,IAAI,WAAW,IAAI,GAAG,EAAE,CAAC;4CACxB,sBAAsB,GAAG,IAAI,CAAC;4CAC9B,qEAAqE;wCACtE,CAAC;6CAAM,CAAC;4CACP,sBAAsB,GAAG,KAAK,CAAC;4CAC/B,uEAAuE;wCACxE,CAAC;wCACD,MAAM;oCACP,CAAC;oCACD,KAAK,SAAS,CAAC,CAAC,CAAC;wCAChB,MAAM,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;wCAC3C,yBAAyB,GAAG,WAAW,CAAC;wCACxC,MAAM;oCACP,CAAC;oCACD,OAAO,CAAC,CAAC,MAAM,IAAI,kBAAkB,CAAC,oCAAoC,CAAC,CAAC;gCAC7E,CAAC;4BACF,CAAC;wBACF,CAAC;oBACF,CAAC;oBAED,IAAI,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;wBACrC,mDAAmD;wBACnD,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,sBAAsB,CAAC,mBAAmB,GAAG,CAAC,CAAC,mCAA2B,CAAC;wBAClG,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,wCAAgC,CAAC,CAAC;wBACzE,+BAA+B;wBAC/B,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;4BACpB,2EAA2E;4BAC3E,MAAM,YAAY,GAAG,CAAC,GAAG,UAAU,CAAC;4BACpC,UAAU,GAAG,aAAa,CAAC,iBAAiB,CAAC,CAAC,GAAG,UAAU,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;4BAC/E,eAAe,IAAI,SAAS,GAAG,CAAC,UAAU,GAAG,YAAY,CAAC,CAAC;4BAC3D,+DAA+D;4BAC/D,UAAU,IAAI,CAAC,GAAG,CAAC,CAAC;wBACrB,CAAC;6BAAM,CAAC;4BACP,eAAe,IAAI,SAAS,CAAC;wBAC9B,CAAC;wBACD,SAAS;oBACV,CAAC;oBAED,MAAM,oBAAoB,GAAG,cAAc,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,uBAAuB,EAAE,sBAAsB,EAAE,yBAAyB,CAAC,CAAC;oBAC9J,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE,KAAK,EAAE,aAAa,EAAE,oBAAoB,EAAE,eAAe,CAAC,CAAC;oBAE/H,eAAe,GAAG,IAAI,CAAC,KAAK;oBAC3B,2CAA2C;oBAC3C,YAAY,CAAC,sBAAsB,CAAC,CAAC,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,GAAG;wBAE3E,gGAAgG;wBAChG,IAAI,CAAC,KAAK,CAAC,CAAC,YAAY,CAAC,UAAU,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,qBAAqB,GAAG,KAAK,CAAC,sBAAsB,CAAC,CAAC,GAAG,CAAC,CAAC;wBAE9G,+FAA+F;wBAC/F,mGAAmG;wBACnG,YAAY;wBACZ,KAAK,CAAC,qBAAqB,CAC3B,CAAC;oBAEF,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,sBAAsB,CAAC,mBAAmB,GAAG,CAAC,CAAC,mCAA2B,CAAC;oBAC7H,UAAU,CAAC,SAAS,kCAA0B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;oBAC9E,UAAU,CAAC,SAAS,kCAA0B,CAAC,GAAG,eAAe,CAAC;oBAClE,UAAU,CAAC,SAAS,oCAA4B,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC;oBACrE,UAAU,CAAC,SAAS,sCAA8B,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;oBAEtE,mDAAmD;oBACnD,eAAe,IAAI,SAAS,CAAC;gBAC9B,CAAC;gBAED,eAAe,GAAG,aAAa,CAAC;YACjC,CAAC;YAED,uBAAuB;YACvB,cAAc,GAAG,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,sBAAsB,CAAC,mBAAmB,GAAG,aAAa,CAAC,mCAA2B,CAAC;YAC9I,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,sBAAsB,CAAC,mBAAmB,CAAC,mCAA2B,CAAC;YAC5H,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;QAClD,CAAC;QAED,MAAM,kBAAkB,GAAG,CAAC,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,eAAe,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC;QAE5G,yDAAyD;QACzD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAC7B,IAAI,CAAC,eAAe,EACpB,CAAC,EACD,UAAU,CAAC,MAAM,EACjB,CAAC,EACD,CAAC,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,cAAc,GAAG,YAAY,CAAC,iBAAiB,CAC7G,CAAC;QAEF,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtE,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;QAE9C,OAAO,kBAAkB,CAAC;IAC3B,CAAC;IAED,IAAI,CAAC,IAA0B,EAAE,YAA0B;QAC1D,IAAI,IAAI,CAAC,mBAAmB,IAAI,CAAC,EAAE,CAAC;YACnC,MAAM,IAAI,kBAAkB,CAAC,2BAA2B,CAAC,CAAC;QAC3D,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;IAC9D,CAAC;;AAGF,SAAS,kBAAkB,CAAC,KAAa;IACxC,QAAQ,KAAK,EAAE,CAAC;QACf,KAAK,SAAS,CAAC;QACf,KAAK,QAAQ,CAAC,CAAC,OAAO,GAAG,CAAC;QAC1B,KAAK,QAAQ,CAAC;QACd,KAAK,MAAM,CAAC,CAAC,OAAO,GAAG,CAAC;IACzB,CAAC;IACD,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAED,SAAS,eAAe,CAAC,KAAa;IACrC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;QACzB,OAAO,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;IAC/D,CAAC;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE,CAAC;QAClC,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IACD,OAAO,CAAC,CAAC;AACV,CAAC","file":"viewportRenderStrategy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n\tCellBindBufferCapacityIncrement = 32,\n\tCellBindBufferInitialCapacity = 63, // Will be rounded up to nearest increment\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\n/**\n * A render strategy that uploads the content of the entire viewport every frame.\n */\nexport class ViewportRenderStrategy extends BaseRenderStrategy {\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 2000;\n\n\treadonly type = 'viewport';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBufferLineCapacity = Constants.CellBindBufferInitialCapacity;\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate _visibleObjectCount: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tprivate readonly _onDidChangeBindGroupEntries = this._register(new Emitter<void>());\n\treadonly onDidChangeBindGroupEntries = this._onDidChangeBindGroupEntries.event;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tthis._rebuildCellBuffer(this._cellBindBufferLineCapacity);\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\tprivate _rebuildCellBuffer(lineCount: number) {\n\t\tthis._cellBindBuffer?.destroy();\n\n\t\t// Increase in chunks so resizing a window by hand doesn't keep allocating and throwing away\n\t\tconst lineCountWithIncrement = (Math.floor(lineCount / Constants.CellBindBufferCapacityIncrement) + 1) * Constants.CellBindBufferCapacityIncrement;\n\n\t\tconst bufferSize = lineCountWithIncrement * ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\t\tthis._cellBindBufferLineCapacity = lineCountWithIncrement;\n\n\t\tthis._onDidChangeBindGroupEntries.fire();\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\treset() {\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Zero out cell buffer or rebuild if needed\n\t\tif (this._cellBindBufferLineCapacity < viewportData.endLineNumber - viewportData.startLineNumber + 1) {\n\t\t\tthis._rebuildCellBuffer(viewportData.endLineNumber - viewportData.startLineNumber + 1);\n\t\t}\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tcellBuffer.fill(0);\n\n\t\tconst lineIndexCount = ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > ViewportRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// This render strategy always uploads the whole viewport\n\t\tthis._device.queue.writeBuffer(\n\t\t\tthis._cellBindBuffer,\n\t\t\t0,\n\t\t\tcellBuffer.buffer,\n\t\t\t0,\n\t\t\t(viewportData.endLineNumber - viewportData.startLineNumber) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(quadVertices.length / 2, this._visibleObjectCount);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n\tCellBindBufferCapacityIncrement = 32,\n\tCellBindBufferInitialCapacity = 63, // Will be rounded up to nearest increment\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\n/**\n * A render strategy that uploads the content of the entire viewport every frame.\n */\nexport class ViewportRenderStrategy extends BaseRenderStrategy {\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 2000;\n\n\treadonly type = 'viewport';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBufferLineCapacity = Constants.CellBindBufferInitialCapacity;\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate _visibleObjectCount: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tprivate readonly _onDidChangeBindGroupEntries = this._register(new Emitter<void>());\n\treadonly onDidChangeBindGroupEntries = this._onDidChangeBindGroupEntries.event;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tthis._rebuildCellBuffer(this._cellBindBufferLineCapacity);\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\tprivate _rebuildCellBuffer(lineCount: number) {\n\t\tthis._cellBindBuffer?.destroy();\n\n\t\t// Increase in chunks so resizing a window by hand doesn't keep allocating and throwing away\n\t\tconst lineCountWithIncrement = (Math.floor(lineCount / Constants.CellBindBufferCapacityIncrement) + 1) * Constants.CellBindBufferCapacityIncrement;\n\n\t\tconst bufferSize = lineCountWithIncrement * ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\t\tthis._cellBindBufferLineCapacity = lineCountWithIncrement;\n\n\t\tthis._onDidChangeBindGroupEntries.fire();\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\treset() {\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Zero out cell buffer or rebuild if needed\n\t\tif (this._cellBindBufferLineCapacity < viewportData.endLineNumber - viewportData.startLineNumber + 1) {\n\t\t\tthis._rebuildCellBuffer(viewportData.endLineNumber - viewportData.startLineNumber + 1);\n\t\t}\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tcellBuffer.fill(0);\n\n\t\tconst lineIndexCount = ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > ViewportRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// This render strategy always uploads the whole viewport\n\t\tthis._device.queue.writeBuffer(\n\t\t\tthis._cellBindBuffer,\n\t\t\t0,\n\t\t\tcellBuffer.buffer,\n\t\t\t0,\n\t\t\t(viewportData.endLineNumber - viewportData.startLineNumber) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(quadVertices.length / 2, this._visibleObjectCount);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n"]}