{"version":3,"sources":["../src/index.ts","../src/createFetchRequester.ts"],"sourcesContent":["export * from './createFetchRequester';\n","import type { Response as AlgoliaResponse, EndRequest, Requester } from '@algolia/client-common';\n\nfunction isAbortError(error: unknown): boolean {\n  return error instanceof Error && error.name === 'AbortError';\n}\n\nfunction getErrorMessage(error: unknown, abortContent: string): string {\n  if (isAbortError(error)) {\n    return abortContent;\n  }\n  return error instanceof Error ? error.message : 'Network request failed';\n}\n\nexport type FetchRequesterOptions = {\n  readonly requesterOptions?: RequestInit | undefined;\n};\n\nexport function createFetchRequester({ requesterOptions = {} }: FetchRequesterOptions = {}): Requester {\n  async function send(request: EndRequest): Promise<AlgoliaResponse> {\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n\n    const createTimeout = (timeout: number): NodeJS.Timeout => {\n      return setTimeout(() => {\n        abortController.abort();\n      }, timeout);\n    };\n\n    const connectTimeout = createTimeout(request.connectTimeout);\n\n    let fetchRes: Response;\n    try {\n      fetchRes = await fetch(request.url, {\n        method: request.method,\n        body: request.data || null,\n        redirect: 'manual',\n        signal,\n        ...requesterOptions,\n        headers: {\n          ...requesterOptions.headers,\n          ...request.headers,\n        },\n      });\n    } catch (error) {\n      return {\n        status: 0,\n        content: getErrorMessage(error, 'Connection timeout'),\n        isTimedOut: isAbortError(error),\n      };\n    }\n\n    clearTimeout(connectTimeout);\n\n    createTimeout(request.responseTimeout);\n\n    try {\n      const content = await fetchRes.text();\n\n      return {\n        content,\n        isTimedOut: false,\n        status: fetchRes.status,\n      };\n    } catch (error) {\n      return {\n        status: 0,\n        content: getErrorMessage(error, 'Socket timeout'),\n        isTimedOut: isAbortError(error),\n      };\n    }\n  }\n\n  return { send };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,SAAS,aAAa,OAAyB;AAC7C,SAAO,iBAAiB,SAAS,MAAM,SAAS;AAClD;AAEA,SAAS,gBAAgB,OAAgB,cAA8B;AACrE,MAAI,aAAa,KAAK,GAAG;AACvB,WAAO;AAAA,EACT;AACA,SAAO,iBAAiB,QAAQ,MAAM,UAAU;AAClD;AAMO,SAAS,qBAAqB,EAAE,mBAAmB,CAAC,EAAE,IAA2B,CAAC,GAAc;AACrG,iBAAe,KAAK,SAA+C;AACjE,UAAM,kBAAkB,IAAI,gBAAgB;AAC5C,UAAM,SAAS,gBAAgB;AAE/B,UAAM,gBAAgB,CAAC,YAAoC;AACzD,aAAO,WAAW,MAAM;AACtB,wBAAgB,MAAM;AAAA,MACxB,GAAG,OAAO;AAAA,IACZ;AAEA,UAAM,iBAAiB,cAAc,QAAQ,cAAc;AAE3D,QAAI;AACJ,QAAI;AACF,iBAAW,MAAM,MAAM,QAAQ,KAAK;AAAA,QAClC,QAAQ,QAAQ;AAAA,QAChB,MAAM,QAAQ,QAAQ;AAAA,QACtB,UAAU;AAAA,QACV;AAAA,QACA,GAAG;AAAA,QACH,SAAS;AAAA,UACP,GAAG,iBAAiB;AAAA,UACpB,GAAG,QAAQ;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS,gBAAgB,OAAO,oBAAoB;AAAA,QACpD,YAAY,aAAa,KAAK;AAAA,MAChC;AAAA,IACF;AAEA,iBAAa,cAAc;AAE3B,kBAAc,QAAQ,eAAe;AAErC,QAAI;AACF,YAAM,UAAU,MAAM,SAAS,KAAK;AAEpC,aAAO;AAAA,QACL;AAAA,QACA,YAAY;AAAA,QACZ,QAAQ,SAAS;AAAA,MACnB;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS,gBAAgB,OAAO,gBAAgB;AAAA,QAChD,YAAY,aAAa,KAAK;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,KAAK;AAChB;","names":[]}