{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/undoRedo/common/undoRedo.ts","vs/platform/undoRedo/common/undoRedo.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAIhG,OAAO,EAAE,eAAe,EAAE,MAAM,6CAA6C,CAAC;AAE9E,MAAM,CAAC,MAAM,gBAAgB,GAAG,eAAe,CAAmB,iBAAiB,CAAC,CAAC;AAkErF,MAAM,OAAO,yBAAyB;IACrC,YACiB,QAAa,EACb,QAAkB;QADlB,aAAQ,GAAR,QAAQ,CAAK;QACb,aAAQ,GAAR,QAAQ,CAAU;IAC/B,CAAC;CACL;AAED,MAAM,OAAO,aAAa;aACV,QAAG,GAAG,CAAC,CAAC;IAKvB;QACC,IAAI,CAAC,EAAE,GAAG,aAAa,CAAC,GAAG,EAAE,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IAChB,CAAC;IAEM,SAAS;QACf,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC;YACnB,OAAO,CAAC,CAAC;QACV,CAAC;QACD,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC;aAEa,SAAI,GAAG,IAAI,aAAa,EAAE,CAAC;;AAG1C,MAAM,OAAO,cAAc;aACX,QAAG,GAAG,CAAC,CAAC;IAKvB;QACC,IAAI,CAAC,EAAE,GAAG,cAAc,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IAChB,CAAC;IAEM,SAAS;QACf,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC;YACnB,OAAO,CAAC,CAAC;QACV,CAAC;QACD,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC;aAEa,SAAI,GAAG,IAAI,cAAc,EAAE,CAAC","file":"undoRedo.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport const IUndoRedoService = createDecorator<IUndoRedoService>('undoRedoService');\n\nexport const enum UndoRedoElementType {\n\tResource,\n\tWorkspace\n}\n\nexport interface IResourceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Resource;\n\t/**\n\t * The resource impacted by this element.\n\t */\n\treadonly resource: URI;\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n}\n\nexport interface IWorkspaceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Workspace;\n\t/**\n\t * The resources impacted by this element.\n\t */\n\treadonly resources: readonly URI[];\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n\n\t/**\n\t * If implemented, indicates that this undo/redo element can be split into multiple per resource elements.\n\t */\n\tsplit?(): IResourceUndoRedoElement[];\n\n\t/**\n\t * If implemented, will be invoked before calling `undo()` or `redo()`.\n\t * This is a good place to prepare everything such that the calls to `undo()` or `redo()` are synchronous.\n\t * If a disposable is returned, it will be invoked to clean things up.\n\t */\n\tprepareUndoRedo?(): Promise<IDisposable> | IDisposable | void;\n}\n\nexport type IUndoRedoElement = IResourceUndoRedoElement | IWorkspaceUndoRedoElement;\n\nexport interface IPastFutureElements {\n\tpast: IUndoRedoElement[];\n\tfuture: IUndoRedoElement[];\n}\n\nexport interface UriComparisonKeyComputer {\n\tgetComparisonKey(uri: URI): string;\n}\n\nexport class ResourceEditStackSnapshot {\n\tconstructor(\n\t\tpublic readonly resource: URI,\n\t\tpublic readonly elements: number[]\n\t) { }\n}\n\nexport class UndoRedoGroup {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoGroup._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoGroup();\n}\n\nexport class UndoRedoSource {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoSource._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoSource();\n}\n\nexport interface IUndoRedoService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Get the hash used internally for a certain URI.\n\t * This uses any registered `UriComparisonKeyComputer`.\n\t */\n\tgetUriComparisonKey(resource: URI): string;\n\n\t/**\n\t * Add a new element to the `undo` stack.\n\t * This will destroy the `redo` stack.\n\t */\n\tpushElement(element: IUndoRedoElement, group?: UndoRedoGroup, source?: UndoRedoSource): void;\n\n\t/**\n\t * Get the last pushed element for a resource.\n\t * If the last pushed element has been undone, returns null.\n\t */\n\tgetLastElement(resource: URI): IUndoRedoElement | null;\n\n\t/**\n\t * Get all the elements associated with a resource.\n\t * This includes the past and the future.\n\t */\n\tgetElements(resource: URI): IPastFutureElements;\n\n\t/**\n\t * Validate or invalidate stack elements associated with a resource.\n\t */\n\tsetElementsValidFlag(resource: URI, isValid: boolean, filter: (element: IUndoRedoElement) => boolean): void;\n\n\t/**\n\t * Remove elements that target `resource`.\n\t */\n\tremoveElements(resource: URI): void;\n\n\t/**\n\t * Create a snapshot of the current elements on the undo-redo stack for a resource.\n\t */\n\tcreateSnapshot(resource: URI): ResourceEditStackSnapshot;\n\t/**\n\t * Attempt (as best as possible) to restore a certain snapshot previously created with `createSnapshot` for a resource.\n\t */\n\trestoreSnapshot(snapshot: ResourceEditStackSnapshot): void;\n\n\tcanUndo(resource: URI | UndoRedoSource): boolean;\n\tundo(resource: URI | UndoRedoSource): Promise<void> | void;\n\n\tcanRedo(resource: URI | UndoRedoSource): boolean;\n\tredo(resource: URI | UndoRedoSource): Promise<void> | void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport const IUndoRedoService = createDecorator<IUndoRedoService>('undoRedoService');\n\nexport const enum UndoRedoElementType {\n\tResource,\n\tWorkspace\n}\n\nexport interface IResourceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Resource;\n\t/**\n\t * The resource impacted by this element.\n\t */\n\treadonly resource: URI;\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n}\n\nexport interface IWorkspaceUndoRedoElement {\n\treadonly type: UndoRedoElementType.Workspace;\n\t/**\n\t * The resources impacted by this element.\n\t */\n\treadonly resources: readonly URI[];\n\t/**\n\t * A user presentable label. May be localized.\n\t */\n\treadonly label: string;\n\t/**\n\t * Show a message to the user confirming when trying to undo this element\n\t */\n\treadonly confirmBeforeUndo?: boolean;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n\n\t/**\n\t * If implemented, indicates that this undo/redo element can be split into multiple per resource elements.\n\t */\n\tsplit?(): IResourceUndoRedoElement[];\n\n\t/**\n\t * If implemented, will be invoked before calling `undo()` or `redo()`.\n\t * This is a good place to prepare everything such that the calls to `undo()` or `redo()` are synchronous.\n\t * If a disposable is returned, it will be invoked to clean things up.\n\t */\n\tprepareUndoRedo?(): Promise<IDisposable> | IDisposable | void;\n}\n\nexport type IUndoRedoElement = IResourceUndoRedoElement | IWorkspaceUndoRedoElement;\n\nexport interface IPastFutureElements {\n\tpast: IUndoRedoElement[];\n\tfuture: IUndoRedoElement[];\n}\n\nexport interface UriComparisonKeyComputer {\n\tgetComparisonKey(uri: URI): string;\n}\n\nexport class ResourceEditStackSnapshot {\n\tconstructor(\n\t\tpublic readonly resource: URI,\n\t\tpublic readonly elements: number[]\n\t) { }\n}\n\nexport class UndoRedoGroup {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoGroup._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoGroup();\n}\n\nexport class UndoRedoSource {\n\tprivate static _ID = 0;\n\n\tpublic readonly id: number;\n\tprivate order: number;\n\n\tconstructor() {\n\t\tthis.id = UndoRedoSource._ID++;\n\t\tthis.order = 1;\n\t}\n\n\tpublic nextOrder(): number {\n\t\tif (this.id === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.order++;\n\t}\n\n\tpublic static None = new UndoRedoSource();\n}\n\nexport interface IUndoRedoService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Get the hash used internally for a certain URI.\n\t * This uses any registered `UriComparisonKeyComputer`.\n\t */\n\tgetUriComparisonKey(resource: URI): string;\n\n\t/**\n\t * Add a new element to the `undo` stack.\n\t * This will destroy the `redo` stack.\n\t */\n\tpushElement(element: IUndoRedoElement, group?: UndoRedoGroup, source?: UndoRedoSource): void;\n\n\t/**\n\t * Get the last pushed element for a resource.\n\t * If the last pushed element has been undone, returns null.\n\t */\n\tgetLastElement(resource: URI): IUndoRedoElement | null;\n\n\t/**\n\t * Get all the elements associated with a resource.\n\t * This includes the past and the future.\n\t */\n\tgetElements(resource: URI): IPastFutureElements;\n\n\t/**\n\t * Validate or invalidate stack elements associated with a resource.\n\t */\n\tsetElementsValidFlag(resource: URI, isValid: boolean, filter: (element: IUndoRedoElement) => boolean): void;\n\n\t/**\n\t * Remove elements that target `resource`.\n\t */\n\tremoveElements(resource: URI): void;\n\n\t/**\n\t * Create a snapshot of the current elements on the undo-redo stack for a resource.\n\t */\n\tcreateSnapshot(resource: URI): ResourceEditStackSnapshot;\n\t/**\n\t * Attempt (as best as possible) to restore a certain snapshot previously created with `createSnapshot` for a resource.\n\t */\n\trestoreSnapshot(snapshot: ResourceEditStackSnapshot): void;\n\n\tcanUndo(resource: URI | UndoRedoSource): boolean;\n\tundo(resource: URI | UndoRedoSource): Promise<void> | void;\n\n\tcanRedo(resource: URI | UndoRedoSource): boolean;\n\tredo(resource: URI | UndoRedoSource): Promise<void> | void;\n}\n"]}