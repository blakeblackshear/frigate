{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/iframe.ts","vs/base/browser/iframe.ts"],"names":[],"mappings":"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","file":"iframe.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a window in a possible chain of iframes\n */\ninterface IWindowChainElement {\n\t/**\n\t * The window object for it\n\t */\n\treadonly window: WeakRef<Window>;\n\t/**\n\t * The iframe element inside the window.parent corresponding to window\n\t */\n\treadonly iframeElement: Element | null;\n}\n\nconst sameOriginWindowChainCache = new WeakMap<Window, IWindowChainElement[] | null>();\n\nfunction getParentWindowIfSameOrigin(w: Window): Window | null {\n\tif (!w.parent || w.parent === w) {\n\t\treturn null;\n\t}\n\n\t// Cannot really tell if we have access to the parent window unless we try to access something in it\n\ttry {\n\t\tconst location = w.location;\n\t\tconst parentLocation = w.parent.location;\n\t\tif (location.origin !== 'null' && parentLocation.origin !== 'null' && location.origin !== parentLocation.origin) {\n\t\t\treturn null;\n\t\t}\n\t} catch (e) {\n\t\treturn null;\n\t}\n\n\treturn w.parent;\n}\n\nexport class IframeUtils {\n\n\t/**\n\t * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\n\t * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\n\t */\n\tprivate static getSameOriginWindowChain(targetWindow: Window): IWindowChainElement[] {\n\t\tlet windowChainCache = sameOriginWindowChainCache.get(targetWindow);\n\t\tif (!windowChainCache) {\n\t\t\twindowChainCache = [];\n\t\t\tsameOriginWindowChainCache.set(targetWindow, windowChainCache);\n\t\t\tlet w: Window | null = targetWindow;\n\t\t\tlet parent: Window | null;\n\t\t\tdo {\n\t\t\t\tparent = getParentWindowIfSameOrigin(w);\n\t\t\t\tif (parent) {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: w.frameElement || null\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tw = parent;\n\t\t\t} while (w);\n\t\t}\n\t\treturn windowChainCache.slice(0);\n\t}\n\n\t/**\n\t * Returns the position of `childWindow` relative to `ancestorWindow`\n\t */\n\tpublic static getPositionOfChildWindowRelativeToAncestorWindow(childWindow: Window, ancestorWindow: Window | null) {\n\n\t\tif (!ancestorWindow || childWindow === ancestorWindow) {\n\t\t\treturn {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t};\n\t\t}\n\n\t\tlet top = 0, left = 0;\n\n\t\tconst windowChain = this.getSameOriginWindowChain(childWindow);\n\n\t\tfor (const windowChainEl of windowChain) {\n\t\t\tconst windowInChain = windowChainEl.window.deref();\n\t\t\ttop += windowInChain?.scrollY ?? 0;\n\t\t\tleft += windowInChain?.scrollX ?? 0;\n\n\t\t\tif (windowInChain === ancestorWindow) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!windowChainEl.iframeElement) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n\t\t\ttop += boundingRect.top;\n\t\t\tleft += boundingRect.left;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a window in a possible chain of iframes\n */\ninterface IWindowChainElement {\n\t/**\n\t * The window object for it\n\t */\n\treadonly window: WeakRef<Window>;\n\t/**\n\t * The iframe element inside the window.parent corresponding to window\n\t */\n\treadonly iframeElement: Element | null;\n}\n\nconst sameOriginWindowChainCache = new WeakMap<Window, IWindowChainElement[] | null>();\n\nfunction getParentWindowIfSameOrigin(w: Window): Window | null {\n\tif (!w.parent || w.parent === w) {\n\t\treturn null;\n\t}\n\n\t// Cannot really tell if we have access to the parent window unless we try to access something in it\n\ttry {\n\t\tconst location = w.location;\n\t\tconst parentLocation = w.parent.location;\n\t\tif (location.origin !== 'null' && parentLocation.origin !== 'null' && location.origin !== parentLocation.origin) {\n\t\t\treturn null;\n\t\t}\n\t} catch (e) {\n\t\treturn null;\n\t}\n\n\treturn w.parent;\n}\n\nexport class IframeUtils {\n\n\t/**\n\t * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\n\t * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\n\t */\n\tprivate static getSameOriginWindowChain(targetWindow: Window): IWindowChainElement[] {\n\t\tlet windowChainCache = sameOriginWindowChainCache.get(targetWindow);\n\t\tif (!windowChainCache) {\n\t\t\twindowChainCache = [];\n\t\t\tsameOriginWindowChainCache.set(targetWindow, windowChainCache);\n\t\t\tlet w: Window | null = targetWindow;\n\t\t\tlet parent: Window | null;\n\t\t\tdo {\n\t\t\t\tparent = getParentWindowIfSameOrigin(w);\n\t\t\t\tif (parent) {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: w.frameElement || null\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tw = parent;\n\t\t\t} while (w);\n\t\t}\n\t\treturn windowChainCache.slice(0);\n\t}\n\n\t/**\n\t * Returns the position of `childWindow` relative to `ancestorWindow`\n\t */\n\tpublic static getPositionOfChildWindowRelativeToAncestorWindow(childWindow: Window, ancestorWindow: Window | null) {\n\n\t\tif (!ancestorWindow || childWindow === ancestorWindow) {\n\t\t\treturn {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t};\n\t\t}\n\n\t\tlet top = 0, left = 0;\n\n\t\tconst windowChain = this.getSameOriginWindowChain(childWindow);\n\n\t\tfor (const windowChainEl of windowChain) {\n\t\t\tconst windowInChain = windowChainEl.window.deref();\n\t\t\ttop += windowInChain?.scrollY ?? 0;\n\t\t\tleft += windowInChain?.scrollX ?? 0;\n\n\t\t\tif (windowInChain === ancestorWindow) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!windowChainEl.iframeElement) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n\t\t\ttop += boundingRect.top;\n\t\t\tleft += boundingRect.left;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left\n\t\t};\n\t}\n}\n"]}