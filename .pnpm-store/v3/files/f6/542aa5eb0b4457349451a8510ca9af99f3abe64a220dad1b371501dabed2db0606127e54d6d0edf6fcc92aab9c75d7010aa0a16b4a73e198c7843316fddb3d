{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/model/computeGhostText.ts","vs/editor/contrib/inlineCompletions/browser/model/computeGhostText.ts"],"names":[],"mappings":"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","file":"computeGhostText.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from '../../../../../base/common/diff/diff.js';\nimport { getLeadingWhitespace } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(\n\tedit: TextReplacement,\n\tmodel: ITextModel,\n\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\tcursorPosition?: Position,\n\tpreviewSuffixLength = 0\n): GhostText | undefined {\n\tlet e = singleTextRemoveCommonPrefix(edit, model);\n\n\tif (e.range.endLineNumber !== e.range.startLineNumber) {\n\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\treturn undefined;\n\t}\n\n\tconst sourceLine = model.getLineContent(e.range.startLineNumber);\n\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\tconst suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n\tif (suggestionTouchesIndentation) {\n\t\t// source:      ··········[······abc]\n\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\t\t// inlineCompletion.text: '··foo'\n\t\t//                         ^^ suggestionAddedIndentationLength\n\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n\n\t\tconst replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n\n\t\tconst [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n\t\tconst newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t: endPosition;\n\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\tconst suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t? e.text.substring(replacedIndentation.length)\n\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t: e.text.substring(suggestionAddedIndentationLength);\n\n\t\te = new TextReplacement(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t}\n\n\t// This is a single line string\n\tconst valueToBeReplaced = model.getValueInRange(e.range);\n\n\tconst changes = cachingDiff(valueToBeReplaced, e.text);\n\n\tif (!changes) {\n\t\t// No ghost text in case the diff would be too slow to compute\n\t\treturn undefined;\n\t}\n\n\tconst lineNumber = e.range.startLineNumber;\n\n\tconst parts = new Array<GhostTextPart>();\n\n\tif (mode === 'prefix') {\n\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t// Prefixes only have a single change.\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconst previewStartInCompletionText = e.text.length - previewSuffixLength;\n\n\tfor (const c of changes) {\n\t\tconst insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n\n\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t// No ghost text before cursor\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.originalLength > 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.modifiedLength === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\tconst nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\tconst italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\tif (nonPreviewText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t}\n\t\tif (italicText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t}\n\t}\n\n\treturn new GhostText(lineNumber, parts);\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nexport function smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from '../../../../../base/common/diff/diff.js';\nimport { getLeadingWhitespace } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nimport { singleTextRemoveCommonPrefix } from './singleTextEditHelpers.js';\n\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(\n\tedit: TextReplacement,\n\tmodel: ITextModel,\n\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\tcursorPosition?: Position,\n\tpreviewSuffixLength = 0\n): GhostText | undefined {\n\tlet e = singleTextRemoveCommonPrefix(edit, model);\n\n\tif (e.range.endLineNumber !== e.range.startLineNumber) {\n\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\treturn undefined;\n\t}\n\n\tconst sourceLine = model.getLineContent(e.range.startLineNumber);\n\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\tconst suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n\tif (suggestionTouchesIndentation) {\n\t\t// source:      ··········[······abc]\n\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\t\t// inlineCompletion.text: '··foo'\n\t\t//                         ^^ suggestionAddedIndentationLength\n\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n\n\t\tconst replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n\n\t\tconst [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n\t\tconst newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t: endPosition;\n\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\tconst suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t? e.text.substring(replacedIndentation.length)\n\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t: e.text.substring(suggestionAddedIndentationLength);\n\n\t\te = new TextReplacement(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t}\n\n\t// This is a single line string\n\tconst valueToBeReplaced = model.getValueInRange(e.range);\n\n\tconst changes = cachingDiff(valueToBeReplaced, e.text);\n\n\tif (!changes) {\n\t\t// No ghost text in case the diff would be too slow to compute\n\t\treturn undefined;\n\t}\n\n\tconst lineNumber = e.range.startLineNumber;\n\n\tconst parts = new Array<GhostTextPart>();\n\n\tif (mode === 'prefix') {\n\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t// Prefixes only have a single change.\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconst previewStartInCompletionText = e.text.length - previewSuffixLength;\n\n\tfor (const c of changes) {\n\t\tconst insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n\n\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t// No ghost text before cursor\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.originalLength > 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (c.modifiedLength === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\tconst nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\tconst italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\tif (nonPreviewText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t}\n\t\tif (italicText.length > 0) {\n\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t}\n\t}\n\n\treturn new GhostText(lineNumber, parts);\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nexport function smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"]}