{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/errors.ts","vs/base/common/errors.ts"],"names":[],"mappings":"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","file":"errors.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n"]}