{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/legacyLinesDiffComputer.ts","vs/editor/common/diff/legacyLinesDiffComputer.ts"],"names":[],"mappings":"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","file":"legacyLinesDiffComputer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n"]}