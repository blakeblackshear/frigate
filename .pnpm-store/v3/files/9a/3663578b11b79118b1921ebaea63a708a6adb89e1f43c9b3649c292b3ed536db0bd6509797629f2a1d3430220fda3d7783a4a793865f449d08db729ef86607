{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/extensions/common/extensions.ts","vs/platform/extensions/common/extensions.ts"],"names":[],"mappings":"AAEA;;;;;;;;;;;;;;;GAeG;AACH,MAAM,OAAO,mBAAmB;IAS/B,YAAY,KAAa;QACxB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC;IACnC,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAC,EAAgC;QACnD,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE,CAAC;YAC5B,OAAO,EAAE,CAAC,WAAW,EAAE,CAAC;QACzB,CAAC;QACD,OAAO,EAAE,CAAC,MAAM,CAAC;IAClB,CAAC;CACD;AAED,MAAM,OAAO,sBAAsB;IAIlC,YAAY,QAAiD;QAF5C,SAAI,GAAG,IAAI,GAAG,EAAU,CAAC;QAGzC,IAAI,QAAQ,EAAE,CAAC;YACd,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE,CAAC;gBAC9B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACjB,CAAC;QACF,CAAC;IACF,CAAC;IAEM,GAAG,CAAC,EAAgC;QAC1C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;IAC9C,CAAC;IAEM,GAAG,CAAC,EAAgC;QAC1C,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;IACrD,CAAC;CACD","file":"extensions.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["\n\n/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nexport class ExtensionIdentifier {\n\tpublic readonly value: string;\n\n\t/**\n\t * Do not use directly. This is public to avoid mangling and thus\n\t * allow compatibility between running from source and a built version.\n\t */\n\treadonly _lower: string;\n\n\tconstructor(value: string) {\n\t\tthis.value = value;\n\t\tthis._lower = value.toLowerCase();\n\t}\n\n\t/**\n\t * Gives the value by which to index (for equality).\n\t */\n\tpublic static toKey(id: ExtensionIdentifier | string): string {\n\t\tif (typeof id === 'string') {\n\t\t\treturn id.toLowerCase();\n\t\t}\n\t\treturn id._lower;\n\t}\n}\n\nexport class ExtensionIdentifierSet {\n\n\tprivate readonly _set = new Set<string>();\n\n\tconstructor(iterable?: Iterable<ExtensionIdentifier | string>) {\n\t\tif (iterable) {\n\t\t\tfor (const value of iterable) {\n\t\t\t\tthis.add(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic add(id: ExtensionIdentifier | string): void {\n\t\tthis._set.add(ExtensionIdentifier.toKey(id));\n\t}\n\n\tpublic has(id: ExtensionIdentifier | string): boolean {\n\t\treturn this._set.has(ExtensionIdentifier.toKey(id));\n\t}\n}\n","\n\n/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nexport class ExtensionIdentifier {\n\tpublic readonly value: string;\n\n\t/**\n\t * Do not use directly. This is public to avoid mangling and thus\n\t * allow compatibility between running from source and a built version.\n\t */\n\treadonly _lower: string;\n\n\tconstructor(value: string) {\n\t\tthis.value = value;\n\t\tthis._lower = value.toLowerCase();\n\t}\n\n\t/**\n\t * Gives the value by which to index (for equality).\n\t */\n\tpublic static toKey(id: ExtensionIdentifier | string): string {\n\t\tif (typeof id === 'string') {\n\t\t\treturn id.toLowerCase();\n\t\t}\n\t\treturn id._lower;\n\t}\n}\n\nexport class ExtensionIdentifierSet {\n\n\tprivate readonly _set = new Set<string>();\n\n\tconstructor(iterable?: Iterable<ExtensionIdentifier | string>) {\n\t\tif (iterable) {\n\t\t\tfor (const value of iterable) {\n\t\t\t\tthis.add(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic add(id: ExtensionIdentifier | string): void {\n\t\tthis._set.add(ExtensionIdentifier.toKey(id));\n\t}\n\n\tpublic has(id: ExtensionIdentifier | string): boolean {\n\t\treturn this._set.has(ExtensionIdentifier.toKey(id));\n\t}\n}\n"]}