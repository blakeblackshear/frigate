{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/utils.ts","vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["\nimport { numberComparator } from '../../../../../../../base/common/arrays.js';\nimport { findFirstMin } from '../../../../../../../base/common/arraysFind.js';\nimport { derived, derivedObservableWithCache, derivedOpts, IObservable, IReader } from '../../../../../../../base/common/observable.js';\nimport { splitLines } from '../../../../../../../base/common/strings.js';\nimport { ICodeEditor } from '../../../../../../browser/editorBrowser.js';\nimport { ObservableCodeEditor } from '../../../../../../browser/observableCodeEditor.js';\nimport { Point } from '../../../../../../common/core/2d/point.js';\nimport { Rect } from '../../../../../../common/core/2d/rect.js';\nimport { EditorOption } from '../../../../../../common/config/editorOptions.js';\nimport { LineRange } from '../../../../../../common/core/ranges/lineRange.js';\nimport { OffsetRange } from '../../../../../../common/core/ranges/offsetRange.js';\nimport { Position } from '../../../../../../common/core/position.js';\nimport { Range } from '../../../../../../common/core/range.js';\nimport { TextReplacement, TextEdit } from '../../../../../../common/core/edits/textEdit.js';\nimport { RangeMapping } from '../../../../../../common/diff/rangeMapping.js';\nimport { ITextModel } from '../../../../../../common/model.js';\nimport { indentOfLine } from '../../../../../../common/model/textModel.js';\nimport { CharCode } from '../../../../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../../../../base/common/errors.js';\n\nexport function maxContentWidthInRange(editor: ObservableCodeEditor, range: LineRange, reader: IReader | undefined): number {\n\teditor.layoutInfo.read(reader);\n\teditor.value.read(reader);\n\n\tconst model = editor.model.read(reader);\n\tif (!model) { return 0; }\n\tlet maxContentWidth = 0;\n\n\teditor.scrollTop.read(reader);\n\tfor (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {\n\t\tconst column = model.getLineMaxColumn(i);\n\t\tlet lineContentWidth = editor.editor.getOffsetForColumn(i, column);\n\t\tif (lineContentWidth === -1) {\n\t\t\t// approximation\n\t\t\tconst typicalHalfwidthCharacterWidth = editor.editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;\n\t\t\tconst approximation = column * typicalHalfwidthCharacterWidth;\n\t\t\tlineContentWidth = approximation;\n\t\t}\n\t\tmaxContentWidth = Math.max(maxContentWidth, lineContentWidth);\n\t}\n\tconst lines = range.mapToLineArray(l => model.getLineContent(l));\n\n\tif (maxContentWidth < 5 && lines.some(l => l.length > 0) && model.uri.scheme !== 'file') {\n\t\tconsole.error('unexpected width');\n\t}\n\treturn maxContentWidth;\n}\n\nexport function getOffsetForPos(editor: ObservableCodeEditor, pos: Position, reader: IReader): number {\n\teditor.layoutInfo.read(reader);\n\teditor.value.read(reader);\n\n\tconst model = editor.model.read(reader);\n\tif (!model) { return 0; }\n\n\teditor.scrollTop.read(reader);\n\tconst lineContentWidth = editor.editor.getOffsetForColumn(pos.lineNumber, pos.column);\n\n\treturn lineContentWidth;\n}\n\nexport function getPrefixTrim(diffRanges: Range[], originalLinesRange: LineRange, modifiedLines: string[], editor: ICodeEditor): { prefixTrim: number; prefixLeftOffset: number } {\n\tconst textModel = editor.getModel();\n\tif (!textModel) {\n\t\treturn { prefixTrim: 0, prefixLeftOffset: 0 };\n\t}\n\n\tconst replacementStart = diffRanges.map(r => r.isSingleLine() ? r.startColumn - 1 : 0);\n\tconst originalIndents = originalLinesRange.mapToLineArray(line => indentOfLine(textModel.getLineContent(line)));\n\tconst modifiedIndents = modifiedLines.filter(line => line !== '').map(line => indentOfLine(line));\n\tconst prefixTrim = Math.min(...replacementStart, ...originalIndents, ...modifiedIndents);\n\n\tlet prefixLeftOffset;\n\tconst startLineIndent = textModel.getLineIndentColumn(originalLinesRange.startLineNumber);\n\tif (startLineIndent >= prefixTrim + 1) {\n\t\t// We can use the editor to get the offset\n\t\tprefixLeftOffset = editor.getOffsetForColumn(originalLinesRange.startLineNumber, prefixTrim + 1);\n\t} else if (modifiedLines.length > 0) {\n\t\t// Content is not in the editor, we can use the content width to calculate the offset\n\t\tprefixLeftOffset = getContentRenderWidth(modifiedLines[0].slice(0, prefixTrim), editor, textModel);\n\t} else {\n\t\t// unable to approximate the offset\n\t\treturn { prefixTrim: 0, prefixLeftOffset: 0 };\n\t}\n\n\treturn { prefixTrim, prefixLeftOffset };\n}\n\nexport function getContentRenderWidth(content: string, editor: ICodeEditor, textModel: ITextModel) {\n\tconst w = editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;\n\tconst tabSize = textModel.getOptions().tabSize * w;\n\n\tconst numTabs = content.split('\\t').length - 1;\n\tconst numNoneTabs = content.length - numTabs;\n\treturn numNoneTabs * w + numTabs * tabSize;\n}\n\nexport function getEditorValidOverlayRect(editor: ObservableCodeEditor): IObservable<Rect> {\n\tconst contentLeft = editor.layoutInfoContentLeft;\n\n\tconst width = derived({ name: 'editor.validOverlay.width' }, r => {\n\t\tconst hasMinimapOnTheRight = editor.layoutInfoMinimap.read(r).minimapLeft !== 0;\n\t\tconst editorWidth = editor.layoutInfoWidth.read(r) - contentLeft.read(r);\n\n\t\tif (hasMinimapOnTheRight) {\n\t\t\tconst minimapAndScrollbarWidth = editor.layoutInfoMinimap.read(r).minimapWidth + editor.layoutInfoVerticalScrollbarWidth.read(r);\n\t\t\treturn editorWidth - minimapAndScrollbarWidth;\n\t\t}\n\n\t\treturn editorWidth;\n\t});\n\n\tconst height = derived({ name: 'editor.validOverlay.height' }, r => editor.layoutInfoHeight.read(r) + editor.contentHeight.read(r));\n\n\treturn derived({ name: 'editor.validOverlay' }, r => Rect.fromLeftTopWidthHeight(contentLeft.read(r), 0, width.read(r), height.read(r)));\n}\nexport function applyEditToModifiedRangeMappings(rangeMapping: RangeMapping[], edit: TextEdit): RangeMapping[] {\n\tconst updatedMappings: RangeMapping[] = [];\n\tfor (const m of rangeMapping) {\n\t\tconst updatedRange = edit.mapRange(m.modifiedRange);\n\t\tupdatedMappings.push(new RangeMapping(m.originalRange, updatedRange));\n\t}\n\treturn updatedMappings;\n}\n\n\nexport function classNames(...classes: (string | false | undefined | null)[]) {\n\treturn classes.filter(c => typeof c === 'string').join(' ');\n}\n\nfunction offsetRangeToRange(columnOffsetRange: OffsetRange, startPos: Position): Range {\n\treturn new Range(\n\t\tstartPos.lineNumber,\n\t\tstartPos.column + columnOffsetRange.start,\n\t\tstartPos.lineNumber,\n\t\tstartPos.column + columnOffsetRange.endExclusive,\n\t);\n}\n\n/**\n * Calculates the indentation size (in spaces) of a given line,\n * interpreting tabs as the specified tab size.\n */\nfunction getIndentationSize(line: string, tabSize: number): number {\n\tlet currentSize = 0;\n\tloop: for (let i = 0, len = line.length; i < len; i++) {\n\t\tswitch (line.charCodeAt(i)) {\n\t\t\tcase CharCode.Tab: currentSize += tabSize; break;\n\t\t\tcase CharCode.Space: currentSize++; break;\n\t\t\tdefault: break loop;\n\t\t}\n\t}\n\t// if currentSize % tabSize !== 0,\n\t// then there are spaces which are not part of the indentation\n\treturn currentSize - (currentSize % tabSize);\n}\n\n/**\n * Calculates the number of characters at the start of a line that correspond to a given indentation size,\n * taking into account both tabs and spaces.\n */\nfunction indentSizeToIndentLength(line: string, indentSize: number, tabSize: number): number {\n\tlet remainingSize = indentSize - (indentSize % tabSize);\n\tlet i = 0;\n\tfor (; i < line.length; i++) {\n\t\tif (remainingSize === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (line.charCodeAt(i)) {\n\t\t\tcase CharCode.Tab: remainingSize -= tabSize; break;\n\t\t\tcase CharCode.Space: remainingSize--; break;\n\t\t\tdefault: throw new BugIndicatingError('Unexpected character found while calculating indent length');\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function createReindentEdit(text: string, range: LineRange, tabSize: number): TextEdit {\n\tconst newLines = splitLines(text);\n\tconst edits: TextReplacement[] = [];\n\tconst minIndentSize = findFirstMin(range.mapToLineArray(l => getIndentationSize(newLines[l - 1], tabSize)), numberComparator)!;\n\trange.forEach(lineNumber => {\n\t\tconst indentLength = indentSizeToIndentLength(newLines[lineNumber - 1], minIndentSize, tabSize);\n\t\tedits.push(new TextReplacement(offsetRangeToRange(new OffsetRange(0, indentLength), new Position(lineNumber, 1)), ''));\n\t});\n\treturn new TextEdit(edits);\n}\n\nexport class PathBuilder {\n\tprivate _data: string = '';\n\n\tpublic moveTo(point: Point): this {\n\t\tthis._data += `M ${point.x} ${point.y} `;\n\t\treturn this;\n\t}\n\n\tpublic lineTo(point: Point): this {\n\t\tthis._data += `L ${point.x} ${point.y} `;\n\t\treturn this;\n\t}\n\n\tpublic build(): string {\n\t\treturn this._data;\n\t}\n}\n\ntype RemoveFalsy<T> = T extends false | undefined | null ? never : T;\ntype Falsy<T> = T extends false | undefined | null ? T : never;\n\nexport function mapOutFalsy<T>(obs: IObservable<T>): IObservable<IObservable<RemoveFalsy<T>> | Falsy<T>> {\n\tconst nonUndefinedObs = derivedObservableWithCache<T | undefined | null | false>(undefined, (reader, lastValue) => obs.read(reader) || lastValue);\n\n\treturn derivedOpts({\n\t\tdebugName: () => `${obs.debugName}.mapOutFalsy`\n\t}, reader => {\n\t\tnonUndefinedObs.read(reader);\n\t\tconst val = obs.read(reader);\n\t\tif (!val) {\n\t\t\treturn undefined as Falsy<T>;\n\t\t}\n\n\t\treturn nonUndefinedObs as IObservable<RemoveFalsy<T>>;\n\t});\n}\n\nexport function rectToProps(fn: (reader: IReader) => Rect) {\n\treturn {\n\t\tleft: derived({ name: 'editor.validOverlay.left' }, reader => /** @description left */ fn(reader).left),\n\t\ttop: derived({ name: 'editor.validOverlay.top' }, reader => /** @description top */ fn(reader).top),\n\t\twidth: derived({ name: 'editor.validOverlay.width' }, reader => /** @description width */ fn(reader).right - fn(reader).left),\n\t\theight: derived({ name: 'editor.validOverlay.height' }, reader => /** @description height */ fn(reader).bottom - fn(reader).top),\n\t};\n}\n\nexport type FirstFnArg<T> = T extends (arg: infer U) => any ? U : never;\n","\nimport { numberComparator } from '../../../../../../../base/common/arrays.js';\nimport { findFirstMin } from '../../../../../../../base/common/arraysFind.js';\nimport { derived, derivedObservableWithCache, derivedOpts, IObservable, IReader } from '../../../../../../../base/common/observable.js';\nimport { splitLines } from '../../../../../../../base/common/strings.js';\nimport { ICodeEditor } from '../../../../../../browser/editorBrowser.js';\nimport { ObservableCodeEditor } from '../../../../../../browser/observableCodeEditor.js';\nimport { Point } from '../../../../../../common/core/2d/point.js';\nimport { Rect } from '../../../../../../common/core/2d/rect.js';\nimport { EditorOption } from '../../../../../../common/config/editorOptions.js';\nimport { LineRange } from '../../../../../../common/core/ranges/lineRange.js';\nimport { OffsetRange } from '../../../../../../common/core/ranges/offsetRange.js';\nimport { Position } from '../../../../../../common/core/position.js';\nimport { Range } from '../../../../../../common/core/range.js';\nimport { TextReplacement, TextEdit } from '../../../../../../common/core/edits/textEdit.js';\nimport { RangeMapping } from '../../../../../../common/diff/rangeMapping.js';\nimport { ITextModel } from '../../../../../../common/model.js';\nimport { indentOfLine } from '../../../../../../common/model/textModel.js';\nimport { CharCode } from '../../../../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../../../../base/common/errors.js';\n\nexport function maxContentWidthInRange(editor: ObservableCodeEditor, range: LineRange, reader: IReader | undefined): number {\n\teditor.layoutInfo.read(reader);\n\teditor.value.read(reader);\n\n\tconst model = editor.model.read(reader);\n\tif (!model) { return 0; }\n\tlet maxContentWidth = 0;\n\n\teditor.scrollTop.read(reader);\n\tfor (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {\n\t\tconst column = model.getLineMaxColumn(i);\n\t\tlet lineContentWidth = editor.editor.getOffsetForColumn(i, column);\n\t\tif (lineContentWidth === -1) {\n\t\t\t// approximation\n\t\t\tconst typicalHalfwidthCharacterWidth = editor.editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;\n\t\t\tconst approximation = column * typicalHalfwidthCharacterWidth;\n\t\t\tlineContentWidth = approximation;\n\t\t}\n\t\tmaxContentWidth = Math.max(maxContentWidth, lineContentWidth);\n\t}\n\tconst lines = range.mapToLineArray(l => model.getLineContent(l));\n\n\tif (maxContentWidth < 5 && lines.some(l => l.length > 0) && model.uri.scheme !== 'file') {\n\t\tconsole.error('unexpected width');\n\t}\n\treturn maxContentWidth;\n}\n\nexport function getOffsetForPos(editor: ObservableCodeEditor, pos: Position, reader: IReader): number {\n\teditor.layoutInfo.read(reader);\n\teditor.value.read(reader);\n\n\tconst model = editor.model.read(reader);\n\tif (!model) { return 0; }\n\n\teditor.scrollTop.read(reader);\n\tconst lineContentWidth = editor.editor.getOffsetForColumn(pos.lineNumber, pos.column);\n\n\treturn lineContentWidth;\n}\n\nexport function getPrefixTrim(diffRanges: Range[], originalLinesRange: LineRange, modifiedLines: string[], editor: ICodeEditor): { prefixTrim: number; prefixLeftOffset: number } {\n\tconst textModel = editor.getModel();\n\tif (!textModel) {\n\t\treturn { prefixTrim: 0, prefixLeftOffset: 0 };\n\t}\n\n\tconst replacementStart = diffRanges.map(r => r.isSingleLine() ? r.startColumn - 1 : 0);\n\tconst originalIndents = originalLinesRange.mapToLineArray(line => indentOfLine(textModel.getLineContent(line)));\n\tconst modifiedIndents = modifiedLines.filter(line => line !== '').map(line => indentOfLine(line));\n\tconst prefixTrim = Math.min(...replacementStart, ...originalIndents, ...modifiedIndents);\n\n\tlet prefixLeftOffset;\n\tconst startLineIndent = textModel.getLineIndentColumn(originalLinesRange.startLineNumber);\n\tif (startLineIndent >= prefixTrim + 1) {\n\t\t// We can use the editor to get the offset\n\t\tprefixLeftOffset = editor.getOffsetForColumn(originalLinesRange.startLineNumber, prefixTrim + 1);\n\t} else if (modifiedLines.length > 0) {\n\t\t// Content is not in the editor, we can use the content width to calculate the offset\n\t\tprefixLeftOffset = getContentRenderWidth(modifiedLines[0].slice(0, prefixTrim), editor, textModel);\n\t} else {\n\t\t// unable to approximate the offset\n\t\treturn { prefixTrim: 0, prefixLeftOffset: 0 };\n\t}\n\n\treturn { prefixTrim, prefixLeftOffset };\n}\n\nexport function getContentRenderWidth(content: string, editor: ICodeEditor, textModel: ITextModel) {\n\tconst w = editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;\n\tconst tabSize = textModel.getOptions().tabSize * w;\n\n\tconst numTabs = content.split('\\t').length - 1;\n\tconst numNoneTabs = content.length - numTabs;\n\treturn numNoneTabs * w + numTabs * tabSize;\n}\n\nexport function getEditorValidOverlayRect(editor: ObservableCodeEditor): IObservable<Rect> {\n\tconst contentLeft = editor.layoutInfoContentLeft;\n\n\tconst width = derived({ name: 'editor.validOverlay.width' }, r => {\n\t\tconst hasMinimapOnTheRight = editor.layoutInfoMinimap.read(r).minimapLeft !== 0;\n\t\tconst editorWidth = editor.layoutInfoWidth.read(r) - contentLeft.read(r);\n\n\t\tif (hasMinimapOnTheRight) {\n\t\t\tconst minimapAndScrollbarWidth = editor.layoutInfoMinimap.read(r).minimapWidth + editor.layoutInfoVerticalScrollbarWidth.read(r);\n\t\t\treturn editorWidth - minimapAndScrollbarWidth;\n\t\t}\n\n\t\treturn editorWidth;\n\t});\n\n\tconst height = derived({ name: 'editor.validOverlay.height' }, r => editor.layoutInfoHeight.read(r) + editor.contentHeight.read(r));\n\n\treturn derived({ name: 'editor.validOverlay' }, r => Rect.fromLeftTopWidthHeight(contentLeft.read(r), 0, width.read(r), height.read(r)));\n}\nexport function applyEditToModifiedRangeMappings(rangeMapping: RangeMapping[], edit: TextEdit): RangeMapping[] {\n\tconst updatedMappings: RangeMapping[] = [];\n\tfor (const m of rangeMapping) {\n\t\tconst updatedRange = edit.mapRange(m.modifiedRange);\n\t\tupdatedMappings.push(new RangeMapping(m.originalRange, updatedRange));\n\t}\n\treturn updatedMappings;\n}\n\n\nexport function classNames(...classes: (string | false | undefined | null)[]) {\n\treturn classes.filter(c => typeof c === 'string').join(' ');\n}\n\nfunction offsetRangeToRange(columnOffsetRange: OffsetRange, startPos: Position): Range {\n\treturn new Range(\n\t\tstartPos.lineNumber,\n\t\tstartPos.column + columnOffsetRange.start,\n\t\tstartPos.lineNumber,\n\t\tstartPos.column + columnOffsetRange.endExclusive,\n\t);\n}\n\n/**\n * Calculates the indentation size (in spaces) of a given line,\n * interpreting tabs as the specified tab size.\n */\nfunction getIndentationSize(line: string, tabSize: number): number {\n\tlet currentSize = 0;\n\tloop: for (let i = 0, len = line.length; i < len; i++) {\n\t\tswitch (line.charCodeAt(i)) {\n\t\t\tcase CharCode.Tab: currentSize += tabSize; break;\n\t\t\tcase CharCode.Space: currentSize++; break;\n\t\t\tdefault: break loop;\n\t\t}\n\t}\n\t// if currentSize % tabSize !== 0,\n\t// then there are spaces which are not part of the indentation\n\treturn currentSize - (currentSize % tabSize);\n}\n\n/**\n * Calculates the number of characters at the start of a line that correspond to a given indentation size,\n * taking into account both tabs and spaces.\n */\nfunction indentSizeToIndentLength(line: string, indentSize: number, tabSize: number): number {\n\tlet remainingSize = indentSize - (indentSize % tabSize);\n\tlet i = 0;\n\tfor (; i < line.length; i++) {\n\t\tif (remainingSize === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (line.charCodeAt(i)) {\n\t\t\tcase CharCode.Tab: remainingSize -= tabSize; break;\n\t\t\tcase CharCode.Space: remainingSize--; break;\n\t\t\tdefault: throw new BugIndicatingError('Unexpected character found while calculating indent length');\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function createReindentEdit(text: string, range: LineRange, tabSize: number): TextEdit {\n\tconst newLines = splitLines(text);\n\tconst edits: TextReplacement[] = [];\n\tconst minIndentSize = findFirstMin(range.mapToLineArray(l => getIndentationSize(newLines[l - 1], tabSize)), numberComparator)!;\n\trange.forEach(lineNumber => {\n\t\tconst indentLength = indentSizeToIndentLength(newLines[lineNumber - 1], minIndentSize, tabSize);\n\t\tedits.push(new TextReplacement(offsetRangeToRange(new OffsetRange(0, indentLength), new Position(lineNumber, 1)), ''));\n\t});\n\treturn new TextEdit(edits);\n}\n\nexport class PathBuilder {\n\tprivate _data: string = '';\n\n\tpublic moveTo(point: Point): this {\n\t\tthis._data += `M ${point.x} ${point.y} `;\n\t\treturn this;\n\t}\n\n\tpublic lineTo(point: Point): this {\n\t\tthis._data += `L ${point.x} ${point.y} `;\n\t\treturn this;\n\t}\n\n\tpublic build(): string {\n\t\treturn this._data;\n\t}\n}\n\ntype RemoveFalsy<T> = T extends false | undefined | null ? never : T;\ntype Falsy<T> = T extends false | undefined | null ? T : never;\n\nexport function mapOutFalsy<T>(obs: IObservable<T>): IObservable<IObservable<RemoveFalsy<T>> | Falsy<T>> {\n\tconst nonUndefinedObs = derivedObservableWithCache<T | undefined | null | false>(undefined, (reader, lastValue) => obs.read(reader) || lastValue);\n\n\treturn derivedOpts({\n\t\tdebugName: () => `${obs.debugName}.mapOutFalsy`\n\t}, reader => {\n\t\tnonUndefinedObs.read(reader);\n\t\tconst val = obs.read(reader);\n\t\tif (!val) {\n\t\t\treturn undefined as Falsy<T>;\n\t\t}\n\n\t\treturn nonUndefinedObs as IObservable<RemoveFalsy<T>>;\n\t});\n}\n\nexport function rectToProps(fn: (reader: IReader) => Rect) {\n\treturn {\n\t\tleft: derived({ name: 'editor.validOverlay.left' }, reader => /** @description left */ fn(reader).left),\n\t\ttop: derived({ name: 'editor.validOverlay.top' }, reader => /** @description top */ fn(reader).top),\n\t\twidth: derived({ name: 'editor.validOverlay.width' }, reader => /** @description width */ fn(reader).right - fn(reader).left),\n\t\theight: derived({ name: 'editor.validOverlay.height' }, reader => /** @description height */ fn(reader).bottom - fn(reader).top),\n\t};\n}\n\nexport type FirstFnArg<T> = T extends (arg: infer U) => any ? U : never;\n"]}