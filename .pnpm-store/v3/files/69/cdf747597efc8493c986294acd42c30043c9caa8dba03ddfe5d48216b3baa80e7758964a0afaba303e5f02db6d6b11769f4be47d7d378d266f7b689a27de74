{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts"],"names":[],"mappings":"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","file":"concat23Trees.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, ListAstNode } from './ast.js';\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t*/\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(items: AstNode[], createImmutableLists: boolean = false): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t}\n\telse if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild()!, nodeToAppendOfCorrectHeight, null, false);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild()!, null, false);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, ListAstNode } from './ast.js';\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t*/\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(items: AstNode[], createImmutableLists: boolean = false): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t}\n\telse if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild()!, nodeToAppendOfCorrectHeight, null, false);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild()!, null, false);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n"]}