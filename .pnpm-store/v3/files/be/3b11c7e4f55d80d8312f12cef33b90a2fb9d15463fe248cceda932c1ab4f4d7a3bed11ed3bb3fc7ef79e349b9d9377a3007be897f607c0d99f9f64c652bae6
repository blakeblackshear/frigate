/*!
 * json-crawl v0.5.3
 * Copyright (C) 2012-2024 Damir Yusipov
 * Date: Sat, 06 Jan 2024 08:16:05 GMT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).JsonCrawl={})}(this,(function(e){"use strict";function t(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n}function n(e,t,n,o){return new(n||(n=Promise))((function(s,a){function r(e){try{i(o.next(e))}catch(e){a(e)}}function l(e){try{i(o.throw(e))}catch(e){a(e)}}function i(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,l)}i((o=o.apply(e,t||[])).next())}))}const o=(e={},t,n,o)=>{const s=`/${t}`,a="function"==typeof e["/**"]?e["/**"]({key:t,path:n,value:o}):e["/**"],r="function"==typeof e["/*"]?e["/*"]({key:t,path:n,value:o}):e["/*"];let l={};if(s in e)l=e[s];else if(!a&&!r)return;return l="function"==typeof l?l({key:t,path:n,value:o}):l,r&&(l=Object.assign(Object.assign({},r),l)),a?Object.assign(Object.assign({"/**":e["/**"]},a),l):l},s=e=>{const t={},n=e.reduce(((e,t)=>(Object.keys(t).forEach((t=>e.add(t))),e)),new Set);for(const o of n.keys()){const n=e.filter((e=>o in e));if(1!==n.length){if("/"!==o.charAt(0))throw new Error(`Cannot merge rules. Duplicate key: ${o}. Rules should not have same Rule key`);t[o]=(e,t)=>{const a=n.map((n=>"function"==typeof n[o]?n[o](e,t):n[o]));return s(a)}}else t[o]=n[0][o]}return t},a=e=>"object"==typeof e&&null!==e,r=e=>Array.isArray(e),l=(e,l,i={})=>n(void 0,void 0,void 0,(function*(){var n,u;l=r(l)?l:[l];const c=r(i.rules)?s(i.rules):i.rules,d=[{data:e,state:i.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const e=d[d.length-1];if(e.keyIndex>=e.keys.length){for(;null===(n=e.hooks)||void 0===n?void 0:n.length;)e.hooks.pop()();d.pop();continue}const s=e.keys[e.keyIndex++],[i,f,y]=d.length>1?[e.data[s],[...e.path,s],o(e.rules,s,[...e.path,s],e.data[s])]:[e.data,e.path,c];let p={value:i,path:f,key:s,state:e.state,rules:y};const v=[];for(const e of l){if(!e||"function"!=typeof e)continue;const n=null!==(u=yield e(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=t(n,["terminate","done","exitHook"]);if(o)return;if(p=Object.assign(Object.assign({},p),r),a&&v.push(a),s){p=null;break}}if(p&&a(p.value)){const e=r(p.value)?[...p.value.keys()]:Object.keys(p.value);d.push({hooks:v,state:p.state,data:p.value,path:f,keys:e,keyIndex:0,rules:p.rules})}else for(;v.length;)v.pop()()}})),i=(e,n,l={})=>{var i,u;n=r(n)?n:[n];const c=r(l.rules)?s(l.rules):l.rules,d=[{data:e,state:l.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const e=d[d.length-1];if(e.keyIndex>=e.keys.length){for(;null===(i=e.hooks)||void 0===i?void 0:i.length;)e.hooks.pop()();d.pop();continue}const s=e.keys[e.keyIndex++],[l,f,y]=d.length>1?[e.data[s],[...e.path,s],o(e.rules,s,[...e.path,s],e.data[s])]:[e.data,e.path,c];let p={value:l,path:f,key:s,state:e.state,rules:y};const v=[];for(const e of n){if(!e||"function"!=typeof e)continue;const n=null!==(u=e(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=t(n,["terminate","done","exitHook"]);if(o)return;if(a&&v.push(a),p=Object.assign(Object.assign({},p),r),s){p=null;break}}if(p&&a(p.value)){const e=r(p.value)?[...p.value.keys()]:Object.keys(p.value);d.push({hooks:v,state:p.state,data:p.value,path:f,keys:e,keyIndex:0,rules:p.rules})}else for(;v.length;)v.pop()()}},u=()=>{const e=new WeakMap;let t;return[({value:e})=>{t=e},({value:n,path:o,key:s,state:r})=>{if(s=o.length?s:"#",a(t)&&a(n)){if(e.has(t))return r.node[s]=e.get(t),{done:!0};const o=Array.isArray(n)?[]:{};r.node[s]=o,e.set(t,o)}else r.node[s]=n;return{value:n,state:Object.assign(Object.assign({},r),{node:r.node[s]})}}]};e.clone=(e,t=[],o={})=>n(void 0,void 0,void 0,(function*(){var n;t=Array.isArray(t)?t:[t];const s={"#":void 0},a=Object.assign({state:Object.assign(Object.assign({},null!==(n=o.state)&&void 0!==n?n:{}),{root:s,node:s})},o.rules?{rules:o.rules}:{}),[r,i]=u();return yield l(e,[r,...t,i],a),s["#"]})),e.crawl=l,e.equal=(e,t)=>{if(e===t)return!0;let n=!0;return i(e,(({value:e,key:t,state:o})=>{const s=void 0===t?o.value:o.value[t],a={state:{value:s}};if(e===s)return a;if(n=!1,typeof e!=typeof s)return{done:!0};if(r(e)&&e.length!==s.length)return{terminate:!0};if("object"==typeof e&&null!==e){const t=Object.keys(e),n=Object.keys(s);if(t.length!==n.length||!t.every((e=>n.includes(e))))return{terminate:!0}}else if(e!==s)return{terminate:!0};return n=!0,a}),{state:{value:t}}),n},e.getNodeRules=o,e.isArray=r,e.isObject=a,e.mergeRules=s,e.syncClone=(e,t=[],n={})=>{var o;t=Array.isArray(t)?t:[t];const s={"#":void 0},a=Object.assign({state:Object.assign(Object.assign({},null!==(o=n.state)&&void 0!==o?o:{}),{root:s,node:s})},n.rules?{rules:n.rules}:{}),[r,l]=u();return i(e,[r,...t,l],a),s["#"]},e.syncCrawl=i,e.transform=(e,t=[],o={})=>n(void 0,void 0,void 0,(function*(){var s;t=r(t)?t:[t];const i={"#":e},u=Object.assign({state:Object.assign(Object.assign({},null!==(s=o.state)&&void 0!==s?s:{}),{root:i,node:i})},o.rules?{rules:o.rules}:{});return yield l(e,[...t,({value:e,path:t,key:o,state:s})=>n(void 0,void 0,void 0,(function*(){return o=t.length?o:"#",void 0===e?r(s.node)&&"number"==typeof o?s.node.splice(o,1):a(s.node)&&o in s.node&&delete s.node[o]:a(s.node)&&(s.node[o]=e),{value:e,state:s}}))],u),i["#"]})),Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.cjs.map
