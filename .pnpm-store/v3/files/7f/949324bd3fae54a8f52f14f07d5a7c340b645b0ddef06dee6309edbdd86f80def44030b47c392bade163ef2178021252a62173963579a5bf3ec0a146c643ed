{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/languages/textToHtmlTokenizer.ts","vs/editor/common/languages/textToHtmlTokenizer.ts"],"names":[],"mappings":"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","file":"textToHtmlTokenizer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IViewLineTokens, LineTokens } from '../tokens/lineTokens.js';\nimport { ILanguageIdCodec, IState, ITokenizationSupport, TokenizationRegistry } from '../languages.js';\nimport { LanguageId } from '../encodedTokenAttributes.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nimport { ILanguageService } from './language.js';\n\nexport type IReducedTokenizationSupport = Omit<ITokenizationSupport, 'tokenize'>;\n\nconst fallback: IReducedTokenizationSupport = {\n\tgetInitialState: () => NullState,\n\ttokenizeEncoded: (buffer: string, hasEOL: boolean, state: IState) => nullTokenizeEncoded(LanguageId.Null, state)\n};\n\nexport async function tokenizeToString(languageService: ILanguageService, text: string, languageId: string | null): Promise<string> {\n\tif (!languageId) {\n\t\treturn _tokenizeToString(text, languageService.languageIdCodec, fallback);\n\t}\n\tconst tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n\treturn _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\n\nexport function tokenizeLineToHTML(text: string, viewLineTokens: IViewLineTokens, colorMap: string[], startOffset: number, endOffset: number, tabSize: number, useNbsp: boolean): string {\n\tlet result = `<div>`;\n\tlet charIndex = startOffset;\n\tlet tabsCharDelta = 0;\n\n\tlet prevIsSpace = true;\n\n\tfor (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n\t\tconst tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n\t\tif (tokenEndIndex <= startOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet partContent = '';\n\n\t\tfor (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n\t\t\tconst charCode = text.charCodeAt(charIndex);\n\n\t\t\tswitch (charCode) {\n\t\t\t\tcase CharCode.Tab: {\n\t\t\t\t\tlet insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\t\tpartContent += '&#160;';\n\t\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpartContent += ' ';\n\t\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\tpartContent += '&lt;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\tpartContent += '&gt;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tpartContent += '&amp;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Null:\n\t\t\t\t\tpartContent += '&#00;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\t\tpartContent += '\\ufffd';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\t\t// zero width space, because carriage return would introduce a line break\n\t\t\t\t\tpartContent += '&#8203';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\tpartContent += '&#160;';\n\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartContent += ' ';\n\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tpartContent += String.fromCharCode(charCode);\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t}\n\t\t}\n\n\t\tresult += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n\t\tif (tokenEndIndex > endOffset || charIndex >= endOffset) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n\nexport function _tokenizeToString(text: string, languageIdCodec: ILanguageIdCodec, tokenizationSupport: IReducedTokenizationSupport): string {\n\tlet result = `<div class=\"monaco-tokenized-source\">`;\n\tconst lines = strings.splitLines(text);\n\tlet currentState = tokenizationSupport.getInitialState();\n\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\tconst line = lines[i];\n\n\t\tif (i > 0) {\n\t\t\tresult += `<br/>`;\n\t\t}\n\n\t\tconst tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n\t\tLineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n\t\tconst lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n\t\tconst viewLineTokens = lineTokens.inflate();\n\n\t\tlet startOffset = 0;\n\t\tfor (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n\t\t\tconst type = viewLineTokens.getClassName(j);\n\t\t\tconst endIndex = viewLineTokens.getEndOffset(j);\n\t\t\tresult += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n\t\t\tstartOffset = endIndex;\n\t\t}\n\n\t\tcurrentState = tokenizationResult.endState;\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IViewLineTokens, LineTokens } from '../tokens/lineTokens.js';\nimport { ILanguageIdCodec, IState, ITokenizationSupport, TokenizationRegistry } from '../languages.js';\nimport { LanguageId } from '../encodedTokenAttributes.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nimport { ILanguageService } from './language.js';\n\nexport type IReducedTokenizationSupport = Omit<ITokenizationSupport, 'tokenize'>;\n\nconst fallback: IReducedTokenizationSupport = {\n\tgetInitialState: () => NullState,\n\ttokenizeEncoded: (buffer: string, hasEOL: boolean, state: IState) => nullTokenizeEncoded(LanguageId.Null, state)\n};\n\nexport async function tokenizeToString(languageService: ILanguageService, text: string, languageId: string | null): Promise<string> {\n\tif (!languageId) {\n\t\treturn _tokenizeToString(text, languageService.languageIdCodec, fallback);\n\t}\n\tconst tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n\treturn _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\n\nexport function tokenizeLineToHTML(text: string, viewLineTokens: IViewLineTokens, colorMap: string[], startOffset: number, endOffset: number, tabSize: number, useNbsp: boolean): string {\n\tlet result = `<div>`;\n\tlet charIndex = startOffset;\n\tlet tabsCharDelta = 0;\n\n\tlet prevIsSpace = true;\n\n\tfor (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n\t\tconst tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n\t\tif (tokenEndIndex <= startOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet partContent = '';\n\n\t\tfor (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n\t\t\tconst charCode = text.charCodeAt(charIndex);\n\n\t\t\tswitch (charCode) {\n\t\t\t\tcase CharCode.Tab: {\n\t\t\t\t\tlet insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\t\tpartContent += '&#160;';\n\t\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpartContent += ' ';\n\t\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\tpartContent += '&lt;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\tpartContent += '&gt;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tpartContent += '&amp;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Null:\n\t\t\t\t\tpartContent += '&#00;';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\t\tpartContent += '\\ufffd';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\t\t// zero width space, because carriage return would introduce a line break\n\t\t\t\t\tpartContent += '&#8203';\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tif (useNbsp && prevIsSpace) {\n\t\t\t\t\t\tpartContent += '&#160;';\n\t\t\t\t\t\tprevIsSpace = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartContent += ' ';\n\t\t\t\t\t\tprevIsSpace = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tpartContent += String.fromCharCode(charCode);\n\t\t\t\t\tprevIsSpace = false;\n\t\t\t}\n\t\t}\n\n\t\tresult += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n\t\tif (tokenEndIndex > endOffset || charIndex >= endOffset) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n\nexport function _tokenizeToString(text: string, languageIdCodec: ILanguageIdCodec, tokenizationSupport: IReducedTokenizationSupport): string {\n\tlet result = `<div class=\"monaco-tokenized-source\">`;\n\tconst lines = strings.splitLines(text);\n\tlet currentState = tokenizationSupport.getInitialState();\n\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\tconst line = lines[i];\n\n\t\tif (i > 0) {\n\t\t\tresult += `<br/>`;\n\t\t}\n\n\t\tconst tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n\t\tLineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n\t\tconst lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n\t\tconst viewLineTokens = lineTokens.inflate();\n\n\t\tlet startOffset = 0;\n\t\tfor (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n\t\t\tconst type = viewLineTokens.getClassName(j);\n\t\t\tconst endIndex = viewLineTokens.getEndOffset(j);\n\t\t\tresult += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n\t\t\tstartOffset = endIndex;\n\t\t}\n\n\t\tcurrentState = tokenizationResult.endState;\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n"]}