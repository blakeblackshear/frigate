{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/parts/storage/common/storage.ts","vs/base/parts/storage/common/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue = string | boolean | number | undefined | null | object;\n\nexport interface IStorage extends IDisposable {\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new PauseableEmitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY));\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach(key => this.acceptExternal(key, undefined));\n\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined | object, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (\n\t\t\tthis.state === StorageState.Closed || \t// Return early if we are already closed\n\t\t\tthis.pendingClose \t\t\t\t\t\t// return early if nothing to do\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach(key => this.items.delete(key));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable, IDisposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST,\n\n\t// A hint to the storage that the storage\n\t// is backed by an in-memory storage.\n\tSTORAGE_IN_MEMORY\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n}\n\nexport interface IStorageChangeEvent {\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport type StorageValue = string | boolean | number | undefined | null | object;\n\nexport interface IStorage extends IDisposable {\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tset(key: string, value: StorageValue, external?: boolean): Promise<void>;\n\tdelete(key: string, external?: boolean): Promise<void>;\n\n\tflush(delay?: number): Promise<void>;\n\twhenFlushed(): Promise<void>;\n}\n\nexport enum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new PauseableEmitter<IStorageChangeEvent>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = this._register(new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY));\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\tthis._onDidChangeStorage.pause();\n\n\t\ttry {\n\t\t\t// items that change external require us to update our\n\t\t\t// caches with the values. we just accept the value and\n\t\t\t// emit an event if there is a change.\n\n\t\t\te.changed?.forEach((value, key) => this.acceptExternal(key, value));\n\t\t\te.deleted?.forEach(key => this.acceptExternal(key, undefined));\n\n\t\t} finally {\n\t\t\tthis._onDidChangeStorage.resume();\n\t\t}\n\t}\n\n\tprivate acceptExternal(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire({ key, external: true });\n\t\t}\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined | object, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key, external);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tasync delete(key: string, external = false): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire({ key, external });\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.doFlush();\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync flush(delay?: number): Promise<void> {\n\t\tif (\n\t\t\tthis.state === StorageState.Closed || \t// Return early if we are already closed\n\t\t\tthis.pendingClose \t\t\t\t\t\t// return early if nothing to do\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doFlush(delay);\n\t}\n\n\tprivate async doFlush(delay?: number): Promise<void> {\n\t\tif (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n\t\t\treturn this.flushPending(); // return early if in-memory\n\t\t}\n\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), delay);\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\trequest.insert?.forEach((value, key) => this.items.set(key, value));\n\n\t\trequest.delete?.forEach(key => this.items.delete(key));\n\t}\n}\n"]}