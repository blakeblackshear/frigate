{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/log/common/log.ts","vs/platform/log/common/log.ts"],"names":[],"mappings":"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","file":"log.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { Mutable, isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport const ILogService = createDecorator<ILogService>('logService');\nexport const ILoggerService = createDecorator<ILoggerService>('loggerService');\n\nexport enum LogLevel {\n\tOff,\n\tTrace,\n\tDebug,\n\tInfo,\n\tWarning,\n\tError\n}\n\nexport const DEFAULT_LOG_LEVEL: LogLevel = LogLevel.Info;\n\nexport interface ILogger extends IDisposable {\n\tonDidChangeLogLevel: Event<LogLevel>;\n\tgetLevel(): LogLevel;\n\tsetLevel(level: LogLevel): void;\n\n\ttrace(message: string, ...args: any[]): void;\n\tdebug(message: string, ...args: any[]): void;\n\tinfo(message: string, ...args: any[]): void;\n\twarn(message: string, ...args: any[]): void;\n\terror(message: string | Error, ...args: any[]): void;\n}\n\nexport function canLog(loggerLevel: LogLevel, messageLevel: LogLevel): boolean {\n\treturn loggerLevel !== LogLevel.Off && loggerLevel <= messageLevel;\n}\n\nexport type LoggerGroup = {\n\treadonly id: string;\n\treadonly name: string;\n};\n\nexport interface ILogService extends ILogger {\n\treadonly _serviceBrand: undefined;\n}\n\nexport interface ILoggerOptions {\n\n\t/**\n\t * Id of the logger.\n\t */\n\tid?: string;\n\n\t/**\n\t * Name of the logger.\n\t */\n\tname?: string;\n\n\t/**\n\t * When to log. Set to `always` to log always.\n\t */\n\tlogLevel?: 'always' | LogLevel;\n\n\t/**\n\t * Whether the log should be hidden from the user.\n\t */\n\thidden?: boolean;\n\n\t/**\n\t * Condition which must be true to show this logger\n\t */\n\twhen?: string;\n\n\t/**\n\t * Id of the extension that created this logger.\n\t */\n\textensionId?: string;\n\n\t/**\n\t * Group of the logger.\n\t */\n\tgroup?: LoggerGroup;\n}\n\nexport interface ILoggerResource {\n\treadonly resource: URI;\n\treadonly id: string;\n\treadonly name?: string;\n\treadonly logLevel?: LogLevel;\n\treadonly hidden?: boolean;\n\treadonly when?: string;\n\treadonly extensionId?: string;\n\treadonly group?: LoggerGroup;\n}\n\nexport interface ILoggerService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Creates a logger for the given resource, or gets one if it already exists.\n\t *\n\t * This will also register the logger with the logger service.\n\t */\n\tcreateLogger(resource: URI, options?: ILoggerOptions): ILogger;\n\n\t/**\n\t * Creates a logger with the given id in the logs folder, or gets one if it already exists.\n\t *\n\t * This will also register the logger with the logger service.\n\t */\n\tcreateLogger(id: string, options?: Omit<ILoggerOptions, 'id'>): ILogger;\n}\n\nexport abstract class AbstractLogger extends Disposable implements ILogger {\n\n\tprivate level: LogLevel = DEFAULT_LOG_LEVEL;\n\tprivate readonly _onDidChangeLogLevel: Emitter<LogLevel> = this._register(new Emitter<LogLevel>());\n\tget onDidChangeLogLevel(): Event<LogLevel> { return this._onDidChangeLogLevel.event; }\n\n\tsetLevel(level: LogLevel): void {\n\t\tif (this.level !== level) {\n\t\t\tthis.level = level;\n\t\t\tthis._onDidChangeLogLevel.fire(this.level);\n\t\t}\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.level;\n\t}\n\n\tprotected checkLogLevel(level: LogLevel): boolean {\n\t\treturn canLog(this.level, level);\n\t}\n\n\tprotected canLog(level: LogLevel): boolean {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.checkLogLevel(level);\n\t}\n\n\tabstract trace(message: string, ...args: any[]): void;\n\tabstract debug(message: string, ...args: any[]): void;\n\tabstract info(message: string, ...args: any[]): void;\n\tabstract warn(message: string, ...args: any[]): void;\n\tabstract error(message: string | Error, ...args: any[]): void;\n}\n\nexport class ConsoleLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL, private readonly useColors: boolean = true) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Trace)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%cTRACE', 'color: #888', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Debug)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Info)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%c INFO', 'color: #33f', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Warning)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.warn('%c WARN', 'color: #993', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Error)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error('%c  ERR', 'color: #f33', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class MultiplexLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(private readonly loggers: ReadonlyArray<ILogger>) {\n\t\tsuper();\n\t\tif (loggers.length) {\n\t\t\tthis.setLevel(loggers[0].getLevel());\n\t\t}\n\t}\n\n\toverride setLevel(level: LogLevel): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.setLevel(level);\n\t\t}\n\t\tsuper.setLevel(level);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.trace(message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.debug(message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.info(message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.warn(message, ...args);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.error(message, ...args);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.dispose();\n\t\t}\n\t\tsuper.dispose();\n\t}\n}\n\ntype LoggerEntry = { logger: ILogger | undefined; info: Mutable<ILoggerResource> };\n\nexport abstract class AbstractLoggerService extends Disposable implements ILoggerService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _loggers = new ResourceMap<LoggerEntry>();\n\n\tprivate _onDidChangeLoggers = this._register(new Emitter<{ added: ILoggerResource[]; removed: ILoggerResource[] }>);\n\n\tprivate _onDidChangeVisibility = this._register(new Emitter<[URI, boolean]>);\n\n\tconstructor(\n\t\tprotected logLevel: LogLevel,\n\t\tprivate readonly logsHome: URI,\n\t\tloggerResources?: Iterable<ILoggerResource>,\n\t) {\n\t\tsuper();\n\t\tif (loggerResources) {\n\t\t\tfor (const loggerResource of loggerResources) {\n\t\t\t\tthis._loggers.set(loggerResource.resource, { logger: undefined, info: loggerResource });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLoggerEntry(resourceOrId: URI | string): LoggerEntry | undefined {\n\t\tif (isString(resourceOrId)) {\n\t\t\treturn [...this._loggers.values()].find(logger => logger.info.id === resourceOrId);\n\t\t}\n\t\treturn this._loggers.get(resourceOrId);\n\t}\n\n\tcreateLogger(idOrResource: URI | string, options?: ILoggerOptions): ILogger {\n\t\tconst resource = this.toResource(idOrResource);\n\t\tconst id = isString(idOrResource) ? idOrResource : (options?.id ?? hash(resource.toString()).toString(16));\n\t\tlet logger = this._loggers.get(resource)?.logger;\n\t\tconst logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;\n\t\tif (!logger) {\n\t\t\tlogger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, { ...options, id });\n\t\t}\n\t\tconst loggerEntry: LoggerEntry = {\n\t\t\tlogger,\n\t\t\tinfo: {\n\t\t\t\tresource,\n\t\t\t\tid,\n\t\t\t\tlogLevel,\n\t\t\t\tname: options?.name,\n\t\t\t\thidden: options?.hidden,\n\t\t\t\tgroup: options?.group,\n\t\t\t\textensionId: options?.extensionId,\n\t\t\t\twhen: options?.when\n\t\t\t}\n\t\t};\n\t\tthis.registerLogger(loggerEntry.info);\n\t\t// TODO: @sandy081 Remove this once registerLogger can take ILogger\n\t\tthis._loggers.set(resource, loggerEntry);\n\t\treturn logger;\n\t}\n\n\tprotected toResource(idOrResource: string | URI): URI {\n\t\treturn isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;\n\t}\n\n\tsetVisibility(resourceOrId: URI | string, visibility: boolean): void {\n\t\tconst logger = this.getLoggerEntry(resourceOrId);\n\t\tif (logger && visibility !== !logger.info.hidden) {\n\t\t\tlogger.info.hidden = !visibility;\n\t\t\tthis._loggers.set(logger.info.resource, logger);\n\t\t\tthis._onDidChangeVisibility.fire([logger.info.resource, visibility]);\n\t\t}\n\t}\n\n\tgetLogLevel(resource?: URI): LogLevel {\n\t\tlet logLevel;\n\t\tif (resource) {\n\t\t\tlogLevel = this._loggers.get(resource)?.info.logLevel;\n\t\t}\n\t\treturn logLevel ?? this.logLevel;\n\t}\n\n\tregisterLogger(resource: ILoggerResource): void {\n\t\tconst existing = this._loggers.get(resource.resource);\n\t\tif (existing) {\n\t\t\tif (existing.info.hidden !== resource.hidden) {\n\t\t\t\tthis.setVisibility(resource.resource, !resource.hidden);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._loggers.set(resource.resource, { info: resource, logger: undefined });\n\t\t\tthis._onDidChangeLoggers.fire({ added: [resource], removed: [] });\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis._loggers.forEach(logger => logger.logger?.dispose());\n\t\tthis._loggers.clear();\n\t\tsuper.dispose();\n\t}\n\n\tprotected abstract doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger;\n}\n\nexport class NullLogger implements ILogger {\n\treadonly onDidChangeLogLevel: Event<LogLevel> = new Emitter<LogLevel>().event;\n\tsetLevel(level: LogLevel): void { }\n\tgetLevel(): LogLevel { return LogLevel.Info; }\n\ttrace(message: string, ...args: any[]): void { }\n\tdebug(message: string, ...args: any[]): void { }\n\tinfo(message: string, ...args: any[]): void { }\n\twarn(message: string, ...args: any[]): void { }\n\terror(message: string | Error, ...args: any[]): void { }\n\tdispose(): void { }\n}\n\nexport class NullLoggerService extends AbstractLoggerService {\n\tconstructor() {\n\t\tsuper(LogLevel.Off, URI.parse('log:///log'));\n\t}\n\tprotected override doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger {\n\t\treturn new NullLogger();\n\t}\n}\n\nexport function LogLevelToString(logLevel: LogLevel): string {\n\tswitch (logLevel) {\n\t\tcase LogLevel.Trace: return 'trace';\n\t\tcase LogLevel.Debug: return 'debug';\n\t\tcase LogLevel.Info: return 'info';\n\t\tcase LogLevel.Warning: return 'warn';\n\t\tcase LogLevel.Error: return 'error';\n\t\tcase LogLevel.Off: return 'off';\n\t}\n}\n\n// Contexts\nexport const CONTEXT_LOG_LEVEL = new RawContextKey<string>('logLevel', LogLevelToString(LogLevel.Info));\n","\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { Mutable, isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nexport const ILogService = createDecorator<ILogService>('logService');\nexport const ILoggerService = createDecorator<ILoggerService>('loggerService');\n\nexport enum LogLevel {\n\tOff,\n\tTrace,\n\tDebug,\n\tInfo,\n\tWarning,\n\tError\n}\n\nexport const DEFAULT_LOG_LEVEL: LogLevel = LogLevel.Info;\n\nexport interface ILogger extends IDisposable {\n\tonDidChangeLogLevel: Event<LogLevel>;\n\tgetLevel(): LogLevel;\n\tsetLevel(level: LogLevel): void;\n\n\ttrace(message: string, ...args: any[]): void;\n\tdebug(message: string, ...args: any[]): void;\n\tinfo(message: string, ...args: any[]): void;\n\twarn(message: string, ...args: any[]): void;\n\terror(message: string | Error, ...args: any[]): void;\n}\n\nexport function canLog(loggerLevel: LogLevel, messageLevel: LogLevel): boolean {\n\treturn loggerLevel !== LogLevel.Off && loggerLevel <= messageLevel;\n}\n\nexport type LoggerGroup = {\n\treadonly id: string;\n\treadonly name: string;\n};\n\nexport interface ILogService extends ILogger {\n\treadonly _serviceBrand: undefined;\n}\n\nexport interface ILoggerOptions {\n\n\t/**\n\t * Id of the logger.\n\t */\n\tid?: string;\n\n\t/**\n\t * Name of the logger.\n\t */\n\tname?: string;\n\n\t/**\n\t * When to log. Set to `always` to log always.\n\t */\n\tlogLevel?: 'always' | LogLevel;\n\n\t/**\n\t * Whether the log should be hidden from the user.\n\t */\n\thidden?: boolean;\n\n\t/**\n\t * Condition which must be true to show this logger\n\t */\n\twhen?: string;\n\n\t/**\n\t * Id of the extension that created this logger.\n\t */\n\textensionId?: string;\n\n\t/**\n\t * Group of the logger.\n\t */\n\tgroup?: LoggerGroup;\n}\n\nexport interface ILoggerResource {\n\treadonly resource: URI;\n\treadonly id: string;\n\treadonly name?: string;\n\treadonly logLevel?: LogLevel;\n\treadonly hidden?: boolean;\n\treadonly when?: string;\n\treadonly extensionId?: string;\n\treadonly group?: LoggerGroup;\n}\n\nexport interface ILoggerService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Creates a logger for the given resource, or gets one if it already exists.\n\t *\n\t * This will also register the logger with the logger service.\n\t */\n\tcreateLogger(resource: URI, options?: ILoggerOptions): ILogger;\n\n\t/**\n\t * Creates a logger with the given id in the logs folder, or gets one if it already exists.\n\t *\n\t * This will also register the logger with the logger service.\n\t */\n\tcreateLogger(id: string, options?: Omit<ILoggerOptions, 'id'>): ILogger;\n}\n\nexport abstract class AbstractLogger extends Disposable implements ILogger {\n\n\tprivate level: LogLevel = DEFAULT_LOG_LEVEL;\n\tprivate readonly _onDidChangeLogLevel: Emitter<LogLevel> = this._register(new Emitter<LogLevel>());\n\tget onDidChangeLogLevel(): Event<LogLevel> { return this._onDidChangeLogLevel.event; }\n\n\tsetLevel(level: LogLevel): void {\n\t\tif (this.level !== level) {\n\t\t\tthis.level = level;\n\t\t\tthis._onDidChangeLogLevel.fire(this.level);\n\t\t}\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.level;\n\t}\n\n\tprotected checkLogLevel(level: LogLevel): boolean {\n\t\treturn canLog(this.level, level);\n\t}\n\n\tprotected canLog(level: LogLevel): boolean {\n\t\tif (this._store.isDisposed) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.checkLogLevel(level);\n\t}\n\n\tabstract trace(message: string, ...args: any[]): void;\n\tabstract debug(message: string, ...args: any[]): void;\n\tabstract info(message: string, ...args: any[]): void;\n\tabstract warn(message: string, ...args: any[]): void;\n\tabstract error(message: string | Error, ...args: any[]): void;\n}\n\nexport class ConsoleLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL, private readonly useColors: boolean = true) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Trace)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%cTRACE', 'color: #888', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Debug)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Info)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log('%c INFO', 'color: #33f', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Warning)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.warn('%c WARN', 'color: #993', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.canLog(LogLevel.Error)) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error('%c  ERR', 'color: #f33', message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(message, ...args);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class MultiplexLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(private readonly loggers: ReadonlyArray<ILogger>) {\n\t\tsuper();\n\t\tif (loggers.length) {\n\t\t\tthis.setLevel(loggers[0].getLevel());\n\t\t}\n\t}\n\n\toverride setLevel(level: LogLevel): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.setLevel(level);\n\t\t}\n\t\tsuper.setLevel(level);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.trace(message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.debug(message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.info(message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.warn(message, ...args);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.error(message, ...args);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.dispose();\n\t\t}\n\t\tsuper.dispose();\n\t}\n}\n\ntype LoggerEntry = { logger: ILogger | undefined; info: Mutable<ILoggerResource> };\n\nexport abstract class AbstractLoggerService extends Disposable implements ILoggerService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _loggers = new ResourceMap<LoggerEntry>();\n\n\tprivate _onDidChangeLoggers = this._register(new Emitter<{ added: ILoggerResource[]; removed: ILoggerResource[] }>);\n\n\tprivate _onDidChangeVisibility = this._register(new Emitter<[URI, boolean]>);\n\n\tconstructor(\n\t\tprotected logLevel: LogLevel,\n\t\tprivate readonly logsHome: URI,\n\t\tloggerResources?: Iterable<ILoggerResource>,\n\t) {\n\t\tsuper();\n\t\tif (loggerResources) {\n\t\t\tfor (const loggerResource of loggerResources) {\n\t\t\t\tthis._loggers.set(loggerResource.resource, { logger: undefined, info: loggerResource });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLoggerEntry(resourceOrId: URI | string): LoggerEntry | undefined {\n\t\tif (isString(resourceOrId)) {\n\t\t\treturn [...this._loggers.values()].find(logger => logger.info.id === resourceOrId);\n\t\t}\n\t\treturn this._loggers.get(resourceOrId);\n\t}\n\n\tcreateLogger(idOrResource: URI | string, options?: ILoggerOptions): ILogger {\n\t\tconst resource = this.toResource(idOrResource);\n\t\tconst id = isString(idOrResource) ? idOrResource : (options?.id ?? hash(resource.toString()).toString(16));\n\t\tlet logger = this._loggers.get(resource)?.logger;\n\t\tconst logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;\n\t\tif (!logger) {\n\t\t\tlogger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, { ...options, id });\n\t\t}\n\t\tconst loggerEntry: LoggerEntry = {\n\t\t\tlogger,\n\t\t\tinfo: {\n\t\t\t\tresource,\n\t\t\t\tid,\n\t\t\t\tlogLevel,\n\t\t\t\tname: options?.name,\n\t\t\t\thidden: options?.hidden,\n\t\t\t\tgroup: options?.group,\n\t\t\t\textensionId: options?.extensionId,\n\t\t\t\twhen: options?.when\n\t\t\t}\n\t\t};\n\t\tthis.registerLogger(loggerEntry.info);\n\t\t// TODO: @sandy081 Remove this once registerLogger can take ILogger\n\t\tthis._loggers.set(resource, loggerEntry);\n\t\treturn logger;\n\t}\n\n\tprotected toResource(idOrResource: string | URI): URI {\n\t\treturn isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;\n\t}\n\n\tsetVisibility(resourceOrId: URI | string, visibility: boolean): void {\n\t\tconst logger = this.getLoggerEntry(resourceOrId);\n\t\tif (logger && visibility !== !logger.info.hidden) {\n\t\t\tlogger.info.hidden = !visibility;\n\t\t\tthis._loggers.set(logger.info.resource, logger);\n\t\t\tthis._onDidChangeVisibility.fire([logger.info.resource, visibility]);\n\t\t}\n\t}\n\n\tgetLogLevel(resource?: URI): LogLevel {\n\t\tlet logLevel;\n\t\tif (resource) {\n\t\t\tlogLevel = this._loggers.get(resource)?.info.logLevel;\n\t\t}\n\t\treturn logLevel ?? this.logLevel;\n\t}\n\n\tregisterLogger(resource: ILoggerResource): void {\n\t\tconst existing = this._loggers.get(resource.resource);\n\t\tif (existing) {\n\t\t\tif (existing.info.hidden !== resource.hidden) {\n\t\t\t\tthis.setVisibility(resource.resource, !resource.hidden);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._loggers.set(resource.resource, { info: resource, logger: undefined });\n\t\t\tthis._onDidChangeLoggers.fire({ added: [resource], removed: [] });\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis._loggers.forEach(logger => logger.logger?.dispose());\n\t\tthis._loggers.clear();\n\t\tsuper.dispose();\n\t}\n\n\tprotected abstract doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger;\n}\n\nexport class NullLogger implements ILogger {\n\treadonly onDidChangeLogLevel: Event<LogLevel> = new Emitter<LogLevel>().event;\n\tsetLevel(level: LogLevel): void { }\n\tgetLevel(): LogLevel { return LogLevel.Info; }\n\ttrace(message: string, ...args: any[]): void { }\n\tdebug(message: string, ...args: any[]): void { }\n\tinfo(message: string, ...args: any[]): void { }\n\twarn(message: string, ...args: any[]): void { }\n\terror(message: string | Error, ...args: any[]): void { }\n\tdispose(): void { }\n}\n\nexport class NullLoggerService extends AbstractLoggerService {\n\tconstructor() {\n\t\tsuper(LogLevel.Off, URI.parse('log:///log'));\n\t}\n\tprotected override doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger {\n\t\treturn new NullLogger();\n\t}\n}\n\nexport function LogLevelToString(logLevel: LogLevel): string {\n\tswitch (logLevel) {\n\t\tcase LogLevel.Trace: return 'trace';\n\t\tcase LogLevel.Debug: return 'debug';\n\t\tcase LogLevel.Info: return 'info';\n\t\tcase LogLevel.Warning: return 'warn';\n\t\tcase LogLevel.Error: return 'error';\n\t\tcase LogLevel.Off: return 'off';\n\t}\n}\n\n// Contexts\nexport const CONTEXT_LOG_LEVEL = new RawContextKey<string>('logLevel', LogLevelToString(LogLevel.Info));\n"]}