{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/formattedTextRenderer.ts","vs/base/browser/formattedTextRenderer.ts"],"names":[],"mappings":"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","file":"formattedTextRenderer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from './dom.js';\nimport { IKeyboardEvent } from './keyboardEvent.js';\nimport { IMouseEvent } from './mouseEvent.js';\nimport { DisposableStore } from '../common/lifecycle.js';\n\nexport interface IContentActionHandler {\n\treadonly callback: (content: string, event: IMouseEvent | IKeyboardEvent) => void;\n\treadonly disposables: DisposableStore;\n}\n\nexport interface FormattedTextRenderOptions {\n\treadonly actionHandler?: IContentActionHandler;\n\treadonly renderCodeSegments?: boolean;\n}\n\nexport function renderText(text: string, _options?: FormattedTextRenderOptions, target?: HTMLElement): HTMLElement {\n\tconst element = target ?? document.createElement('div');\n\telement.textContent = text;\n\treturn element;\n}\n\nexport function renderFormattedText(formattedText: string, options?: FormattedTextRenderOptions, target?: HTMLElement): HTMLElement {\n\tconst element = target ?? document.createElement('div');\n\telement.textContent = '';\n\t_renderFormattedText(element, parseFormattedText(formattedText, !!options?.renderCodeSegments), options?.actionHandler, options?.renderCodeSegments);\n\treturn element;\n}\n\nclass StringStream {\n\tprivate source: string;\n\tprivate index: number;\n\n\tconstructor(source: string) {\n\t\tthis.source = source;\n\t\tthis.index = 0;\n\t}\n\n\tpublic eos(): boolean {\n\t\treturn this.index >= this.source.length;\n\t}\n\n\tpublic next(): string {\n\t\tconst next = this.peek();\n\t\tthis.advance();\n\t\treturn next;\n\t}\n\n\tpublic peek(): string {\n\t\treturn this.source[this.index];\n\t}\n\n\tpublic advance(): void {\n\t\tthis.index++;\n\t}\n}\n\nconst enum FormatType {\n\tInvalid,\n\tRoot,\n\tText,\n\tBold,\n\tItalics,\n\tAction,\n\tActionClose,\n\tCode,\n\tNewLine\n}\n\ninterface IFormatParseTree {\n\ttype: FormatType;\n\tcontent?: string;\n\tindex?: number;\n\tchildren?: IFormatParseTree[];\n}\n\nfunction _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler, renderCodeSegments?: boolean) {\n\tlet child: Node | undefined;\n\n\tif (treeNode.type === FormatType.Text) {\n\t\tchild = document.createTextNode(treeNode.content || '');\n\t} else if (treeNode.type === FormatType.Bold) {\n\t\tchild = document.createElement('b');\n\t} else if (treeNode.type === FormatType.Italics) {\n\t\tchild = document.createElement('i');\n\t} else if (treeNode.type === FormatType.Code && renderCodeSegments) {\n\t\tchild = document.createElement('code');\n\t} else if (treeNode.type === FormatType.Action && actionHandler) {\n\t\tconst a = document.createElement('a');\n\t\tactionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n\t\t\tactionHandler.callback(String(treeNode.index), event);\n\t\t}));\n\n\t\tchild = a;\n\t} else if (treeNode.type === FormatType.NewLine) {\n\t\tchild = document.createElement('br');\n\t} else if (treeNode.type === FormatType.Root) {\n\t\tchild = element;\n\t}\n\n\tif (child && element !== child) {\n\t\telement.appendChild(child);\n\t}\n\n\tif (child && Array.isArray(treeNode.children)) {\n\t\ttreeNode.children.forEach((nodeChild) => {\n\t\t\t_renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n\t\t});\n\t}\n}\n\nfunction parseFormattedText(content: string, parseCodeSegments: boolean): IFormatParseTree {\n\n\tconst root: IFormatParseTree = {\n\t\ttype: FormatType.Root,\n\t\tchildren: []\n\t};\n\n\tlet actionViewItemIndex = 0;\n\tlet current = root;\n\tconst stack: IFormatParseTree[] = [];\n\tconst stream = new StringStream(content);\n\n\twhile (!stream.eos()) {\n\t\tlet next = stream.next();\n\n\t\tconst isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== FormatType.Invalid);\n\t\tif (isEscapedFormatType) {\n\t\t\tnext = stream.next(); // unread the backslash if it escapes a format tag type\n\t\t}\n\n\t\tif (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n\t\t\tstream.advance();\n\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tconst type = formatTagType(next, parseCodeSegments);\n\t\t\tif (current.type === type || (current.type === FormatType.Action && type === FormatType.ActionClose)) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t} else {\n\t\t\t\tconst newCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\n\t\t\t\tif (type === FormatType.Action) {\n\t\t\t\t\tnewCurrent.index = actionViewItemIndex;\n\t\t\t\t\tactionViewItemIndex++;\n\t\t\t\t}\n\n\t\t\t\tcurrent.children!.push(newCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = newCurrent;\n\t\t\t}\n\t\t} else if (next === '\\n') {\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tcurrent.children!.push({\n\t\t\t\ttype: FormatType.NewLine\n\t\t\t});\n\n\t\t} else {\n\t\t\tif (current.type !== FormatType.Text) {\n\t\t\t\tconst textCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: FormatType.Text,\n\t\t\t\t\tcontent: next\n\t\t\t\t};\n\t\t\t\tcurrent.children!.push(textCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = textCurrent;\n\n\t\t\t} else {\n\t\t\t\tcurrent.content += next;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (current.type === FormatType.Text) {\n\t\tcurrent = stack.pop()!;\n\t}\n\n\tif (stack.length) {\n\t\t// incorrectly formatted string literal\n\t}\n\n\treturn root;\n}\n\nfunction isFormatTag(char: string, supportCodeSegments: boolean): boolean {\n\treturn formatTagType(char, supportCodeSegments) !== FormatType.Invalid;\n}\n\nfunction formatTagType(char: string, supportCodeSegments: boolean): FormatType {\n\tswitch (char) {\n\t\tcase '*':\n\t\t\treturn FormatType.Bold;\n\t\tcase '_':\n\t\t\treturn FormatType.Italics;\n\t\tcase '[':\n\t\t\treturn FormatType.Action;\n\t\tcase ']':\n\t\t\treturn FormatType.ActionClose;\n\t\tcase '`':\n\t\t\treturn supportCodeSegments ? FormatType.Code : FormatType.Invalid;\n\t\tdefault:\n\t\t\treturn FormatType.Invalid;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from './dom.js';\nimport { IKeyboardEvent } from './keyboardEvent.js';\nimport { IMouseEvent } from './mouseEvent.js';\nimport { DisposableStore } from '../common/lifecycle.js';\n\nexport interface IContentActionHandler {\n\treadonly callback: (content: string, event: IMouseEvent | IKeyboardEvent) => void;\n\treadonly disposables: DisposableStore;\n}\n\nexport interface FormattedTextRenderOptions {\n\treadonly actionHandler?: IContentActionHandler;\n\treadonly renderCodeSegments?: boolean;\n}\n\nexport function renderText(text: string, _options?: FormattedTextRenderOptions, target?: HTMLElement): HTMLElement {\n\tconst element = target ?? document.createElement('div');\n\telement.textContent = text;\n\treturn element;\n}\n\nexport function renderFormattedText(formattedText: string, options?: FormattedTextRenderOptions, target?: HTMLElement): HTMLElement {\n\tconst element = target ?? document.createElement('div');\n\telement.textContent = '';\n\t_renderFormattedText(element, parseFormattedText(formattedText, !!options?.renderCodeSegments), options?.actionHandler, options?.renderCodeSegments);\n\treturn element;\n}\n\nclass StringStream {\n\tprivate source: string;\n\tprivate index: number;\n\n\tconstructor(source: string) {\n\t\tthis.source = source;\n\t\tthis.index = 0;\n\t}\n\n\tpublic eos(): boolean {\n\t\treturn this.index >= this.source.length;\n\t}\n\n\tpublic next(): string {\n\t\tconst next = this.peek();\n\t\tthis.advance();\n\t\treturn next;\n\t}\n\n\tpublic peek(): string {\n\t\treturn this.source[this.index];\n\t}\n\n\tpublic advance(): void {\n\t\tthis.index++;\n\t}\n}\n\nconst enum FormatType {\n\tInvalid,\n\tRoot,\n\tText,\n\tBold,\n\tItalics,\n\tAction,\n\tActionClose,\n\tCode,\n\tNewLine\n}\n\ninterface IFormatParseTree {\n\ttype: FormatType;\n\tcontent?: string;\n\tindex?: number;\n\tchildren?: IFormatParseTree[];\n}\n\nfunction _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler, renderCodeSegments?: boolean) {\n\tlet child: Node | undefined;\n\n\tif (treeNode.type === FormatType.Text) {\n\t\tchild = document.createTextNode(treeNode.content || '');\n\t} else if (treeNode.type === FormatType.Bold) {\n\t\tchild = document.createElement('b');\n\t} else if (treeNode.type === FormatType.Italics) {\n\t\tchild = document.createElement('i');\n\t} else if (treeNode.type === FormatType.Code && renderCodeSegments) {\n\t\tchild = document.createElement('code');\n\t} else if (treeNode.type === FormatType.Action && actionHandler) {\n\t\tconst a = document.createElement('a');\n\t\tactionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n\t\t\tactionHandler.callback(String(treeNode.index), event);\n\t\t}));\n\n\t\tchild = a;\n\t} else if (treeNode.type === FormatType.NewLine) {\n\t\tchild = document.createElement('br');\n\t} else if (treeNode.type === FormatType.Root) {\n\t\tchild = element;\n\t}\n\n\tif (child && element !== child) {\n\t\telement.appendChild(child);\n\t}\n\n\tif (child && Array.isArray(treeNode.children)) {\n\t\ttreeNode.children.forEach((nodeChild) => {\n\t\t\t_renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n\t\t});\n\t}\n}\n\nfunction parseFormattedText(content: string, parseCodeSegments: boolean): IFormatParseTree {\n\n\tconst root: IFormatParseTree = {\n\t\ttype: FormatType.Root,\n\t\tchildren: []\n\t};\n\n\tlet actionViewItemIndex = 0;\n\tlet current = root;\n\tconst stack: IFormatParseTree[] = [];\n\tconst stream = new StringStream(content);\n\n\twhile (!stream.eos()) {\n\t\tlet next = stream.next();\n\n\t\tconst isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== FormatType.Invalid);\n\t\tif (isEscapedFormatType) {\n\t\t\tnext = stream.next(); // unread the backslash if it escapes a format tag type\n\t\t}\n\n\t\tif (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n\t\t\tstream.advance();\n\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tconst type = formatTagType(next, parseCodeSegments);\n\t\t\tif (current.type === type || (current.type === FormatType.Action && type === FormatType.ActionClose)) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t} else {\n\t\t\t\tconst newCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\n\t\t\t\tif (type === FormatType.Action) {\n\t\t\t\t\tnewCurrent.index = actionViewItemIndex;\n\t\t\t\t\tactionViewItemIndex++;\n\t\t\t\t}\n\n\t\t\t\tcurrent.children!.push(newCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = newCurrent;\n\t\t\t}\n\t\t} else if (next === '\\n') {\n\t\t\tif (current.type === FormatType.Text) {\n\t\t\t\tcurrent = stack.pop()!;\n\t\t\t}\n\n\t\t\tcurrent.children!.push({\n\t\t\t\ttype: FormatType.NewLine\n\t\t\t});\n\n\t\t} else {\n\t\t\tif (current.type !== FormatType.Text) {\n\t\t\t\tconst textCurrent: IFormatParseTree = {\n\t\t\t\t\ttype: FormatType.Text,\n\t\t\t\t\tcontent: next\n\t\t\t\t};\n\t\t\t\tcurrent.children!.push(textCurrent);\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = textCurrent;\n\n\t\t\t} else {\n\t\t\t\tcurrent.content += next;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (current.type === FormatType.Text) {\n\t\tcurrent = stack.pop()!;\n\t}\n\n\tif (stack.length) {\n\t\t// incorrectly formatted string literal\n\t}\n\n\treturn root;\n}\n\nfunction isFormatTag(char: string, supportCodeSegments: boolean): boolean {\n\treturn formatTagType(char, supportCodeSegments) !== FormatType.Invalid;\n}\n\nfunction formatTagType(char: string, supportCodeSegments: boolean): FormatType {\n\tswitch (char) {\n\t\tcase '*':\n\t\t\treturn FormatType.Bold;\n\t\tcase '_':\n\t\t\treturn FormatType.Italics;\n\t\tcase '[':\n\t\t\treturn FormatType.Action;\n\t\tcase ']':\n\t\t\treturn FormatType.ActionClose;\n\t\tcase '`':\n\t\t\treturn supportCodeSegments ? FormatType.Code : FormatType.Invalid;\n\t\tdefault:\n\t\t\treturn FormatType.Invalid;\n\t}\n}\n"]}