{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/reactions/autorun.ts","vs/base/common/observableInternal/reactions/autorun.ts"],"names":[],"mappings":"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","file":"autorun.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReaderWithStore, IReader, IObservable } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { AutorunObserver } from './autorunImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `changeTracker.createChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `changeTracker.handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\tdebugLocation = DebugLocation.ofCaller()\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.changeTracker,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tchangeTracker: options.changeTracker,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n *\n * @deprecated Use `autorun(reader => { reader.store.add(...) })` instead!\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReaderWithStore, IReader, IObservable } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { AutorunObserver } from './autorunImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `changeTracker.createChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `changeTracker.handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\tdebugLocation = DebugLocation.ofCaller()\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.changeTracker,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tchangeTracker: options.changeTracker,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n *\n * @deprecated Use `autorun(reader => { reader.store.add(...) })` instead!\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n"]}