{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/async.ts","vs/base/common/async.ts"],"names":[],"mappings":"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","file":"async.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable, isDisposable, toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable, isDisposable, toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n"]}