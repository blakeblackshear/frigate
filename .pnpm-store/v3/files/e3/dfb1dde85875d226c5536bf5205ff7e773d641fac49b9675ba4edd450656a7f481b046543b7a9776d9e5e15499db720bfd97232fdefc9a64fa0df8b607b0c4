{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/tokens/sparseTokensStore.ts","vs/editor/common/tokens/sparseTokensStore.ts"],"names":[],"mappings":"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","file":"sparseTokensStore.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IRange, Range } from '../core/range.js';\nimport { LineTokens } from './lineTokens.js';\nimport { SparseMultilineTokens } from './sparseMultilineTokens.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { MetadataConsts } from '../encodedTokenAttributes.js';\nimport { ITextModel } from '../model.js';\n\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n\n\tprivate _pieces: SparseMultilineTokens[];\n\tprivate _isComplete: boolean;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._pieces.length === 0);\n\t}\n\n\tpublic set(pieces: SparseMultilineTokens[] | null, isComplete: boolean, textModel: ITextModel | undefined = undefined): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\n\t\tif (textModel) {\n\t\t\tfor (const p of this._pieces) {\n\t\t\t\tp.reportIfInvalid(textModel);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic setPartial(_range: Range, pieces: SparseMultilineTokens[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSparseTokens(lineNumber: number, aTokens: LineTokens): LineTokens {\n\t\tif (aTokens.getTextLength() === 0) {\n\t\t\t// Don't do anything for empty lines\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tconst result: number[] = [];\n\t\tlet resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\t// bTokens is not validated yet, but aTokens is. We want to make sure that the LineTokens we return\n\t\t\t// are valid, so we clamp the ranges to ensure that.\n\t\t\tconst bStartCharacter = Math.min(bTokens.getStartCharacter(bIndex), aTokens.getTextLength());\n\t\t\tconst bEndCharacter = Math.min(bTokens.getEndCharacter(bIndex), aTokens.getTextLength());\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask = (\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC) ? MetadataConsts.ITALIC_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BOLD) ? MetadataConsts.BOLD_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE) ? MetadataConsts.UNDERLINE_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_STRIKETHROUGH) ? MetadataConsts.STRIKETHROUGH_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND) ? MetadataConsts.FOREGROUND_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND) ? MetadataConsts.BACKGROUND_MASK : 0)\n\t\t\t) >>> 0;\n\t\t\tconst aMask = (~bMask) >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n\t}\n\n\tprivate static _findFirstPieceWithLine(pieces: SparseMultilineTokens[], lineNumber: number): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IRange, Range } from '../core/range.js';\nimport { LineTokens } from './lineTokens.js';\nimport { SparseMultilineTokens } from './sparseMultilineTokens.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { MetadataConsts } from '../encodedTokenAttributes.js';\nimport { ITextModel } from '../model.js';\n\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n\n\tprivate _pieces: SparseMultilineTokens[];\n\tprivate _isComplete: boolean;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tconstructor(languageIdCodec: ILanguageIdCodec) {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t\tthis._languageIdCodec = languageIdCodec;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._pieces.length === 0);\n\t}\n\n\tpublic set(pieces: SparseMultilineTokens[] | null, isComplete: boolean, textModel: ITextModel | undefined = undefined): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\n\t\tif (textModel) {\n\t\t\tfor (const p of this._pieces) {\n\t\t\t\tp.reportIfInvalid(textModel);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic setPartial(_range: Range, pieces: SparseMultilineTokens[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSparseTokens(lineNumber: number, aTokens: LineTokens): LineTokens {\n\t\tif (aTokens.getTextLength() === 0) {\n\t\t\t// Don't do anything for empty lines\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tconst result: number[] = [];\n\t\tlet resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\t// bTokens is not validated yet, but aTokens is. We want to make sure that the LineTokens we return\n\t\t\t// are valid, so we clamp the ranges to ensure that.\n\t\t\tconst bStartCharacter = Math.min(bTokens.getStartCharacter(bIndex), aTokens.getTextLength());\n\t\t\tconst bEndCharacter = Math.min(bTokens.getEndCharacter(bIndex), aTokens.getTextLength());\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask = (\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC) ? MetadataConsts.ITALIC_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BOLD) ? MetadataConsts.BOLD_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE) ? MetadataConsts.UNDERLINE_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_STRIKETHROUGH) ? MetadataConsts.STRIKETHROUGH_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND) ? MetadataConsts.FOREGROUND_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND) ? MetadataConsts.BACKGROUND_MASK : 0)\n\t\t\t) >>> 0;\n\t\t\tconst aMask = (~bMask) >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n\t}\n\n\tprivate static _findFirstPieceWithLine(pieces: SparseMultilineTokens[], lineNumber: number): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\t}\n\t}\n}\n"]}