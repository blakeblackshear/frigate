{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.ts"],"names":[],"mappings":"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","file":"ast.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { ITextModel } from '../../../model.js';\nimport { Length, lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId } from './tokenizer.js';\n\nexport const enum AstNodeKind {\n\tText = 0,\n\tBracket = 1,\n\tPair = 2,\n\tUnexpectedClosingBracket = 3,\n\tList = 4,\n}\n\nexport type AstNode = PairAstNode | ListAstNode | BracketAstNode | InvalidBracketAstNode | TextAstNode;\n\n/**\n * The base implementation for all AST nodes.\n*/\nabstract class BaseAstNode {\n\tpublic abstract readonly kind: AstNodeKind;\n\n\tpublic abstract readonly childrenLength: number;\n\n\t/**\n\t * Might return null even if {@link idx} is smaller than {@link BaseAstNode.childrenLength}.\n\t*/\n\tpublic abstract getChild(idx: number): AstNode | null;\n\n\t/**\n\t * Try to avoid using this property, as implementations might need to allocate the resulting array.\n\t*/\n\tpublic abstract readonly children: readonly AstNode[];\n\n\t/**\n\t * Represents the set of all (potentially) missing opening bracket ids in this node.\n\t * E.g. in `{ ] ) }` that set is {`[`, `(` }.\n\t*/\n\tpublic abstract readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\t/**\n\t * In case of a list, determines the height of the (2,3) tree.\n\t*/\n\tpublic abstract readonly listHeight: number;\n\n\tprotected _length: Length;\n\n\t/**\n\t * The length of the entire node, which should equal the sum of lengths of all children.\n\t*/\n\tpublic get length(): Length {\n\t\treturn this._length;\n\t}\n\n\tpublic constructor(length: Length) {\n\t\tthis._length = length;\n\t}\n\n\t/**\n\t * @param openBracketIds The set of all opening brackets that have not yet been closed.\n\t */\n\tpublic abstract canBeReused(\n\t\topenBracketIds: SmallImmutableSet<OpeningBracketId>\n\t): boolean;\n\n\t/**\n\t * Creates a deep clone.\n\t */\n\tpublic abstract deepClone(): AstNode;\n\n\tpublic abstract computeMinIndentation(offset: Length, textModel: ITextModel): number;\n}\n\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n\tpublic static create(\n\t\topeningBracket: BracketAstNode,\n\t\tchild: AstNode | null,\n\t\tclosingBracket: BracketAstNode | null\n\t) {\n\t\tlet length = openingBracket.length;\n\t\tif (child) {\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t}\n\t\tif (closingBracket) {\n\t\t\tlength = lengthAdd(length, closingBracket.length);\n\t\t}\n\t\treturn new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.Pair {\n\t\treturn AstNodeKind.Pair;\n\t}\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 3;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this.openingBracket;\n\t\t\tcase 1: return this.child;\n\t\t\tcase 2: return this.closingBracket;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\t/**\n\t * Avoid using this property, it allocates an array!\n\t*/\n\tpublic get children() {\n\t\tconst result: AstNode[] = [];\n\t\tresult.push(this.openingBracket);\n\t\tif (this.child) {\n\t\t\tresult.push(this.child);\n\t\t}\n\t\tif (this.closingBracket) {\n\t\t\tresult.push(this.closingBracket);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly openingBracket: BracketAstNode,\n\t\tpublic readonly child: AstNode | null,\n\t\tpublic readonly closingBracket: BracketAstNode | null,\n\t\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\tif (this.closingBracket === null) {\n\t\t\t// Unclosed pair ast nodes only\n\t\t\t// end at the end of the document\n\t\t\t// or when a parent node is closed.\n\n\t\t\t// This could be improved:\n\t\t\t// Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic deepClone(): PairAstNode {\n\t\treturn new PairAstNode(\n\t\t\tthis.length,\n\t\t\tthis.openingBracket.deepClone(),\n\t\t\tthis.child && this.child.deepClone(),\n\t\t\tthis.closingBracket && this.closingBracket.deepClone(),\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport abstract class ListAstNode extends BaseAstNode {\n\t/**\n\t * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n\t*/\n\tpublic static create23(item1: AstNode, item2: AstNode, item3: AstNode | null, immutable: boolean = false): ListAstNode {\n\t\tlet length = item1.length;\n\t\tlet missingBracketIds = item1.missingOpeningBracketIds;\n\n\t\tif (item1.listHeight !== item2.listHeight) {\n\t\t\tthrow new Error('Invalid list heights');\n\t\t}\n\n\t\tlength = lengthAdd(length, item2.length);\n\t\tmissingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n\n\t\tif (item3) {\n\t\t\tif (item1.listHeight !== item3.listHeight) {\n\t\t\t\tthrow new Error('Invalid list heights');\n\t\t\t}\n\t\t\tlength = lengthAdd(length, item3.length);\n\t\t\tmissingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n\t\t}\n\t\treturn immutable\n\t\t\t? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n\t\t\t: new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n\t}\n\n\tpublic static getEmpty() {\n\t\treturn new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.List {\n\t\treturn AstNodeKind.List;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn this._missingOpeningBracketIds;\n\t}\n\n\tprivate cachedMinIndentation: number = -1;\n\n\t/**\n\t * Use ListAstNode.create.\n\t*/\n\tconstructor(\n\t\tlength: Length,\n\t\tpublic readonly listHeight: number,\n\t\tprivate _missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tprotected throwIfImmutable(): void {\n\t\t// NOOP\n\t}\n\n\tprotected abstract setChild(idx: number, child: AstNode): void;\n\n\tpublic makeLastElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lastChild = this.getChild(childCount - 1)!;\n\t\tconst mutable = lastChild.kind === AstNodeKind.List ? lastChild.toMutable() : lastChild;\n\t\tif (lastChild !== mutable) {\n\t\t\tthis.setChild(childCount - 1, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic makeFirstElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst firstChild = this.getChild(0)!;\n\t\tconst mutable = firstChild.kind === AstNodeKind.List ? firstChild.toMutable() : firstChild;\n\t\tif (firstChild !== mutable) {\n\t\t\tthis.setChild(0, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean {\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.childrenLength === 0) {\n\t\t\t// Don't reuse empty lists.\n\t\t\treturn false;\n\t\t}\n\n\t\tlet lastChild: ListAstNode = this;\n\t\twhile (lastChild.kind === AstNodeKind.List) {\n\t\t\tconst lastLength = lastChild.childrenLength;\n\t\t\tif (lastLength === 0) {\n\t\t\t\t// Empty lists should never be contained in other lists.\n\t\t\t\tthrow new BugIndicatingError();\n\t\t\t}\n\t\t\tlastChild = lastChild.getChild(lastLength - 1) as ListAstNode;\n\t\t}\n\n\t\treturn lastChild.canBeReused(openBracketIds);\n\t}\n\n\tpublic handleChildrenChanged(): void {\n\t\tthis.throwIfImmutable();\n\n\t\tconst count = this.childrenLength;\n\n\t\tlet length = this.getChild(0)!.length;\n\t\tlet unopenedBrackets = this.getChild(0)!.missingOpeningBracketIds;\n\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tconst child = this.getChild(i)!;\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t\tunopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n\t\t}\n\n\t\tthis._length = length;\n\t\tthis._missingOpeningBracketIds = unopenedBrackets;\n\t\tthis.cachedMinIndentation = -1;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tif (this.cachedMinIndentation !== -1) {\n\t\t\treturn this.cachedMinIndentation;\n\t\t}\n\n\t\tlet minIndentation = Number.MAX_SAFE_INTEGER;\n\t\tlet childOffset = offset;\n\t\tfor (let i = 0; i < this.childrenLength; i++) {\n\t\t\tconst child = this.getChild(i);\n\t\t\tif (child) {\n\t\t\t\tminIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n\t\t\t\tchildOffset = lengthAdd(childOffset, child.length);\n\t\t\t}\n\t\t}\n\n\t\tthis.cachedMinIndentation = minIndentation;\n\t\treturn minIndentation;\n\t}\n\n\t/**\n\t * Creates a shallow clone that is mutable, or itself if it is already mutable.\n\t */\n\tpublic abstract toMutable(): ListAstNode;\n\n\tpublic abstract appendChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unappendChild(): AstNode | undefined;\n\tpublic abstract prependChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unprependChild(): AstNode | undefined;\n}\n\nclass TwoThreeListAstNode extends ListAstNode {\n\tpublic get childrenLength(): number {\n\t\treturn this._item3 !== null ? 3 : 2;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this._item1;\n\t\t\tcase 1: return this._item2;\n\t\t\tcase 2: return this._item3;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\tprotected setChild(idx: number, node: AstNode): void {\n\t\tswitch (idx) {\n\t\t\tcase 0: this._item1 = node; return;\n\t\t\tcase 1: this._item2 = node; return;\n\t\t\tcase 2: this._item3 = node; return;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\tpublic get children(): readonly AstNode[] {\n\t\treturn this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n\t}\n\n\tpublic get item1(): AstNode {\n\t\treturn this._item1;\n\t}\n\tpublic get item2(): AstNode {\n\t\treturn this._item2;\n\t}\n\tpublic get item3(): AstNode | null {\n\t\treturn this._item3;\n\t}\n\n\tpublic constructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate _item1: AstNode,\n\t\tprivate _item2: AstNode,\n\t\tprivate _item3: AstNode | null,\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tpublic deepClone(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(\n\t\t\tthis.length,\n\t\t\tthis.listHeight,\n\t\t\tthis._item1.deepClone(),\n\t\t\tthis._item2.deepClone(),\n\t\t\tthis._item3 ? this._item3.deepClone() : null,\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot append to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item3;\n\t\tthis._item3 = null;\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot prepend to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = this._item2;\n\t\tthis._item2 = this._item1;\n\t\tthis._item1 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item1;\n\t\tthis._item1 = this._item2;\n\t\tthis._item2 = this._item3;\n\t\tthis._item3 = null;\n\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\toverride toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n\tget childrenLength(): number {\n\t\treturn this._children.length;\n\t}\n\tgetChild(idx: number): AstNode | null {\n\t\treturn this._children[idx];\n\t}\n\tprotected setChild(idx: number, child: AstNode): void {\n\t\tthis._children[idx] = child;\n\t}\n\tget children(): readonly AstNode[] {\n\t\treturn this._children;\n\t}\n\n\tconstructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate readonly _children: AstNode[],\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tdeepClone(): ListAstNode {\n\t\tconst children = new Array<AstNode>(this._children.length);\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tchildren[i] = this._children[i].deepClone();\n\t\t}\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.push(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.pop();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.unshift(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.shift();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic override toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\nconst emptyArray: readonly AstNode[] = [];\n\nabstract class ImmutableLeafAstNode extends BaseAstNode {\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 0;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\treturn null;\n\t}\n\tpublic get children(): readonly AstNode[] {\n\t\treturn emptyArray;\n\t}\n\tpublic deepClone(): this & AstNode {\n\t\treturn this as this & AstNode;\n\t}\n}\n\nexport class TextAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.Text {\n\t\treturn AstNodeKind.Text;\n\t}\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn true;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tconst start = lengthToObj(offset);\n\t\t// Text ast nodes don't have partial indentation (ensured by the tokenizer).\n\t\t// Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n\t\tconst startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n\t\tconst endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n\n\t\tlet result = Number.MAX_SAFE_INTEGER;\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\t\tconst lineContent = textModel.getLineContent(lineNumber);\n\t\t\tif (firstNonWsColumn === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize)!;\n\t\t\tresult = Math.min(result, visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport class BracketAstNode extends ImmutableLeafAstNode {\n\tpublic static create(\n\t\tlength: Length,\n\t\tbracketInfo: BracketKind,\n\t\tbracketIds: SmallImmutableSet<OpeningBracketId>\n\t): BracketAstNode {\n\t\tconst node = new BracketAstNode(length, bracketInfo, bracketIds);\n\t\treturn node;\n\t}\n\n\tpublic get kind(): AstNodeKind.Bracket {\n\t\treturn AstNodeKind.Bracket;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly bracketInfo: BracketKind,\n\t\t/**\n\t\t * In case of a opening bracket, this is the id of the opening bracket.\n\t\t * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n\t\t*/\n\t\tpublic readonly bracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic get text() {\n\t\treturn this.bracketInfo.bracketText;\n\t}\n\n\tpublic get languageId() {\n\t\treturn this.bracketInfo.languageId;\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\t// These nodes could be reused,\n\t\t// but not in a general way.\n\t\t// Their parent may be reused.\n\t\treturn false;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.UnexpectedClosingBracket {\n\t\treturn AstNodeKind.UnexpectedClosingBracket;\n\t}\n\n\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\tpublic constructor(closingBrackets: SmallImmutableSet<OpeningBracketId>, length: Length) {\n\t\tsuper(length);\n\t\tthis.missingOpeningBracketIds = closingBrackets;\n\t}\n\n\tpublic canBeReused(openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn !openedBracketIds.intersects(this.missingOpeningBracketIds);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { ITextModel } from '../../../model.js';\nimport { Length, lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId } from './tokenizer.js';\n\nexport const enum AstNodeKind {\n\tText = 0,\n\tBracket = 1,\n\tPair = 2,\n\tUnexpectedClosingBracket = 3,\n\tList = 4,\n}\n\nexport type AstNode = PairAstNode | ListAstNode | BracketAstNode | InvalidBracketAstNode | TextAstNode;\n\n/**\n * The base implementation for all AST nodes.\n*/\nabstract class BaseAstNode {\n\tpublic abstract readonly kind: AstNodeKind;\n\n\tpublic abstract readonly childrenLength: number;\n\n\t/**\n\t * Might return null even if {@link idx} is smaller than {@link BaseAstNode.childrenLength}.\n\t*/\n\tpublic abstract getChild(idx: number): AstNode | null;\n\n\t/**\n\t * Try to avoid using this property, as implementations might need to allocate the resulting array.\n\t*/\n\tpublic abstract readonly children: readonly AstNode[];\n\n\t/**\n\t * Represents the set of all (potentially) missing opening bracket ids in this node.\n\t * E.g. in `{ ] ) }` that set is {`[`, `(` }.\n\t*/\n\tpublic abstract readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\t/**\n\t * In case of a list, determines the height of the (2,3) tree.\n\t*/\n\tpublic abstract readonly listHeight: number;\n\n\tprotected _length: Length;\n\n\t/**\n\t * The length of the entire node, which should equal the sum of lengths of all children.\n\t*/\n\tpublic get length(): Length {\n\t\treturn this._length;\n\t}\n\n\tpublic constructor(length: Length) {\n\t\tthis._length = length;\n\t}\n\n\t/**\n\t * @param openBracketIds The set of all opening brackets that have not yet been closed.\n\t */\n\tpublic abstract canBeReused(\n\t\topenBracketIds: SmallImmutableSet<OpeningBracketId>\n\t): boolean;\n\n\t/**\n\t * Creates a deep clone.\n\t */\n\tpublic abstract deepClone(): AstNode;\n\n\tpublic abstract computeMinIndentation(offset: Length, textModel: ITextModel): number;\n}\n\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n\tpublic static create(\n\t\topeningBracket: BracketAstNode,\n\t\tchild: AstNode | null,\n\t\tclosingBracket: BracketAstNode | null\n\t) {\n\t\tlet length = openingBracket.length;\n\t\tif (child) {\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t}\n\t\tif (closingBracket) {\n\t\t\tlength = lengthAdd(length, closingBracket.length);\n\t\t}\n\t\treturn new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.Pair {\n\t\treturn AstNodeKind.Pair;\n\t}\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 3;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this.openingBracket;\n\t\t\tcase 1: return this.child;\n\t\t\tcase 2: return this.closingBracket;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\t/**\n\t * Avoid using this property, it allocates an array!\n\t*/\n\tpublic get children() {\n\t\tconst result: AstNode[] = [];\n\t\tresult.push(this.openingBracket);\n\t\tif (this.child) {\n\t\t\tresult.push(this.child);\n\t\t}\n\t\tif (this.closingBracket) {\n\t\t\tresult.push(this.closingBracket);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly openingBracket: BracketAstNode,\n\t\tpublic readonly child: AstNode | null,\n\t\tpublic readonly closingBracket: BracketAstNode | null,\n\t\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\tif (this.closingBracket === null) {\n\t\t\t// Unclosed pair ast nodes only\n\t\t\t// end at the end of the document\n\t\t\t// or when a parent node is closed.\n\n\t\t\t// This could be improved:\n\t\t\t// Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic deepClone(): PairAstNode {\n\t\treturn new PairAstNode(\n\t\t\tthis.length,\n\t\t\tthis.openingBracket.deepClone(),\n\t\t\tthis.child && this.child.deepClone(),\n\t\t\tthis.closingBracket && this.closingBracket.deepClone(),\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport abstract class ListAstNode extends BaseAstNode {\n\t/**\n\t * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n\t*/\n\tpublic static create23(item1: AstNode, item2: AstNode, item3: AstNode | null, immutable: boolean = false): ListAstNode {\n\t\tlet length = item1.length;\n\t\tlet missingBracketIds = item1.missingOpeningBracketIds;\n\n\t\tif (item1.listHeight !== item2.listHeight) {\n\t\t\tthrow new Error('Invalid list heights');\n\t\t}\n\n\t\tlength = lengthAdd(length, item2.length);\n\t\tmissingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n\n\t\tif (item3) {\n\t\t\tif (item1.listHeight !== item3.listHeight) {\n\t\t\t\tthrow new Error('Invalid list heights');\n\t\t\t}\n\t\t\tlength = lengthAdd(length, item3.length);\n\t\t\tmissingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n\t\t}\n\t\treturn immutable\n\t\t\t? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n\t\t\t: new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n\t}\n\n\tpublic static getEmpty() {\n\t\treturn new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.List {\n\t\treturn AstNodeKind.List;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn this._missingOpeningBracketIds;\n\t}\n\n\tprivate cachedMinIndentation: number = -1;\n\n\t/**\n\t * Use ListAstNode.create.\n\t*/\n\tconstructor(\n\t\tlength: Length,\n\t\tpublic readonly listHeight: number,\n\t\tprivate _missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tprotected throwIfImmutable(): void {\n\t\t// NOOP\n\t}\n\n\tprotected abstract setChild(idx: number, child: AstNode): void;\n\n\tpublic makeLastElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lastChild = this.getChild(childCount - 1)!;\n\t\tconst mutable = lastChild.kind === AstNodeKind.List ? lastChild.toMutable() : lastChild;\n\t\tif (lastChild !== mutable) {\n\t\t\tthis.setChild(childCount - 1, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic makeFirstElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst firstChild = this.getChild(0)!;\n\t\tconst mutable = firstChild.kind === AstNodeKind.List ? firstChild.toMutable() : firstChild;\n\t\tif (firstChild !== mutable) {\n\t\t\tthis.setChild(0, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean {\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.childrenLength === 0) {\n\t\t\t// Don't reuse empty lists.\n\t\t\treturn false;\n\t\t}\n\n\t\tlet lastChild: ListAstNode = this;\n\t\twhile (lastChild.kind === AstNodeKind.List) {\n\t\t\tconst lastLength = lastChild.childrenLength;\n\t\t\tif (lastLength === 0) {\n\t\t\t\t// Empty lists should never be contained in other lists.\n\t\t\t\tthrow new BugIndicatingError();\n\t\t\t}\n\t\t\tlastChild = lastChild.getChild(lastLength - 1) as ListAstNode;\n\t\t}\n\n\t\treturn lastChild.canBeReused(openBracketIds);\n\t}\n\n\tpublic handleChildrenChanged(): void {\n\t\tthis.throwIfImmutable();\n\n\t\tconst count = this.childrenLength;\n\n\t\tlet length = this.getChild(0)!.length;\n\t\tlet unopenedBrackets = this.getChild(0)!.missingOpeningBracketIds;\n\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tconst child = this.getChild(i)!;\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t\tunopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n\t\t}\n\n\t\tthis._length = length;\n\t\tthis._missingOpeningBracketIds = unopenedBrackets;\n\t\tthis.cachedMinIndentation = -1;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tif (this.cachedMinIndentation !== -1) {\n\t\t\treturn this.cachedMinIndentation;\n\t\t}\n\n\t\tlet minIndentation = Number.MAX_SAFE_INTEGER;\n\t\tlet childOffset = offset;\n\t\tfor (let i = 0; i < this.childrenLength; i++) {\n\t\t\tconst child = this.getChild(i);\n\t\t\tif (child) {\n\t\t\t\tminIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n\t\t\t\tchildOffset = lengthAdd(childOffset, child.length);\n\t\t\t}\n\t\t}\n\n\t\tthis.cachedMinIndentation = minIndentation;\n\t\treturn minIndentation;\n\t}\n\n\t/**\n\t * Creates a shallow clone that is mutable, or itself if it is already mutable.\n\t */\n\tpublic abstract toMutable(): ListAstNode;\n\n\tpublic abstract appendChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unappendChild(): AstNode | undefined;\n\tpublic abstract prependChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unprependChild(): AstNode | undefined;\n}\n\nclass TwoThreeListAstNode extends ListAstNode {\n\tpublic get childrenLength(): number {\n\t\treturn this._item3 !== null ? 3 : 2;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this._item1;\n\t\t\tcase 1: return this._item2;\n\t\t\tcase 2: return this._item3;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\tprotected setChild(idx: number, node: AstNode): void {\n\t\tswitch (idx) {\n\t\t\tcase 0: this._item1 = node; return;\n\t\t\tcase 1: this._item2 = node; return;\n\t\t\tcase 2: this._item3 = node; return;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\tpublic get children(): readonly AstNode[] {\n\t\treturn this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n\t}\n\n\tpublic get item1(): AstNode {\n\t\treturn this._item1;\n\t}\n\tpublic get item2(): AstNode {\n\t\treturn this._item2;\n\t}\n\tpublic get item3(): AstNode | null {\n\t\treturn this._item3;\n\t}\n\n\tpublic constructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate _item1: AstNode,\n\t\tprivate _item2: AstNode,\n\t\tprivate _item3: AstNode | null,\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tpublic deepClone(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(\n\t\t\tthis.length,\n\t\t\tthis.listHeight,\n\t\t\tthis._item1.deepClone(),\n\t\t\tthis._item2.deepClone(),\n\t\t\tthis._item3 ? this._item3.deepClone() : null,\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot append to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item3;\n\t\tthis._item3 = null;\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot prepend to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = this._item2;\n\t\tthis._item2 = this._item1;\n\t\tthis._item1 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item1;\n\t\tthis._item1 = this._item2;\n\t\tthis._item2 = this._item3;\n\t\tthis._item3 = null;\n\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\toverride toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n\tget childrenLength(): number {\n\t\treturn this._children.length;\n\t}\n\tgetChild(idx: number): AstNode | null {\n\t\treturn this._children[idx];\n\t}\n\tprotected setChild(idx: number, child: AstNode): void {\n\t\tthis._children[idx] = child;\n\t}\n\tget children(): readonly AstNode[] {\n\t\treturn this._children;\n\t}\n\n\tconstructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate readonly _children: AstNode[],\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tdeepClone(): ListAstNode {\n\t\tconst children = new Array<AstNode>(this._children.length);\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tchildren[i] = this._children[i].deepClone();\n\t\t}\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.push(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.pop();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.unshift(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.shift();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic override toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\nconst emptyArray: readonly AstNode[] = [];\n\nabstract class ImmutableLeafAstNode extends BaseAstNode {\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 0;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\treturn null;\n\t}\n\tpublic get children(): readonly AstNode[] {\n\t\treturn emptyArray;\n\t}\n\tpublic deepClone(): this & AstNode {\n\t\treturn this as this & AstNode;\n\t}\n}\n\nexport class TextAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.Text {\n\t\treturn AstNodeKind.Text;\n\t}\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn true;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tconst start = lengthToObj(offset);\n\t\t// Text ast nodes don't have partial indentation (ensured by the tokenizer).\n\t\t// Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n\t\tconst startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n\t\tconst endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n\n\t\tlet result = Number.MAX_SAFE_INTEGER;\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\t\tconst lineContent = textModel.getLineContent(lineNumber);\n\t\t\tif (firstNonWsColumn === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize)!;\n\t\t\tresult = Math.min(result, visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport class BracketAstNode extends ImmutableLeafAstNode {\n\tpublic static create(\n\t\tlength: Length,\n\t\tbracketInfo: BracketKind,\n\t\tbracketIds: SmallImmutableSet<OpeningBracketId>\n\t): BracketAstNode {\n\t\tconst node = new BracketAstNode(length, bracketInfo, bracketIds);\n\t\treturn node;\n\t}\n\n\tpublic get kind(): AstNodeKind.Bracket {\n\t\treturn AstNodeKind.Bracket;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly bracketInfo: BracketKind,\n\t\t/**\n\t\t * In case of a opening bracket, this is the id of the opening bracket.\n\t\t * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n\t\t*/\n\t\tpublic readonly bracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic get text() {\n\t\treturn this.bracketInfo.bracketText;\n\t}\n\n\tpublic get languageId() {\n\t\treturn this.bracketInfo.languageId;\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\t// These nodes could be reused,\n\t\t// but not in a general way.\n\t\t// Their parent may be reused.\n\t\treturn false;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.UnexpectedClosingBracket {\n\t\treturn AstNodeKind.UnexpectedClosingBracket;\n\t}\n\n\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\tpublic constructor(closingBrackets: SmallImmutableSet<OpeningBracketId>, length: Length) {\n\t\tsuper(length);\n\t\tthis.missingOpeningBracketIds = closingBrackets;\n\t}\n\n\tpublic canBeReused(openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn !openedBracketIds.intersects(this.missingOpeningBracketIds);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n"]}