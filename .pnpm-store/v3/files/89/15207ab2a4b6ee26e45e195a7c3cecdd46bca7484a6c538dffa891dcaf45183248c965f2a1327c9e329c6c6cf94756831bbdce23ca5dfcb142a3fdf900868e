{"version":3,"file":"index.jsx","sources":["../../src/src/core/utils.ts","../../src/src/core/cache.ts","../../src/src/core/environment.ts","../../src/src/core/store.ts","../../src/src/core/scroller.ts","../../src/src/core/resizer.ts","../../src/src/solid/ListItem.tsx","../../src/src/solid/utils.ts","../../src/src/solid/Virtualizer.tsx","../../src/src/solid/VList.tsx","../../src/src/solid/WindowVirtualizer.tsx","../../src/src/solid/index.ts"],"sourcesContent":["/** @internal */\nexport const NULL = null;\n\n/** @internal */\nexport const { min, max, abs, floor } = Math;\n\n/**\n * @internal\n */\nexport const clamp = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => min(maxValue, max(minValue, value));\n\n/**\n * @internal\n */\nexport const sort = <T extends number>(arr: readonly T[]): T[] => {\n  return [...arr].sort((a, b) => a - b);\n};\n\n/**\n * @internal\n */\nexport const microtask: (fn: () => void) => void =\n  typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : (fn) => {\n        Promise.resolve().then(fn);\n      };\n\n/**\n * @internal\n */\nexport const once = <T>(fn: () => T): (() => T) => {\n  let cache: T;\n\n  return () => {\n    if (fn) {\n      cache = fn();\n      fn = undefined!;\n    }\n    return cache;\n  };\n};\n","import { type InternalCacheSnapshot, type ItemsRange } from \"./types\";\nimport { clamp, floor, max, min, sort } from \"./utils\";\n\ntype Writeable<T> = {\n  -readonly [key in keyof T]: Writeable<T[key]>;\n};\n\n/** @internal */\nexport const UNCACHED = -1;\n\n/**\n * @internal\n */\nexport type Cache = {\n  readonly _length: number;\n  // sizes\n  readonly _sizes: number[];\n  readonly _defaultItemSize: number;\n  // offsets\n  readonly _computedOffsetIndex: number;\n  readonly _offsets: number[];\n};\n\nconst fill = (array: number[], length: number, prepend?: boolean): number[] => {\n  const key = prepend ? \"unshift\" : \"push\";\n  for (let i = 0; i < length; i++) {\n    array[key](UNCACHED);\n  }\n  return array;\n};\n\n/**\n * @internal\n */\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\n/**\n * @internal\n */\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._computedOffsetIndex = min(index, cache._computedOffsetIndex);\n  return isInitialMeasurement;\n};\n\n/**\n * @internal\n */\nexport const computeOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  if (!cache._length) return 0;\n  if (cache._computedOffsetIndex >= index) {\n    return cache._offsets[index]!;\n  }\n\n  if (cache._computedOffsetIndex < 0) {\n    // first offset must be 0 to avoid returning NaN, which can cause infinite rerender.\n    // https://github.com/inokawa/virtua/pull/160\n    cache._offsets[0] = 0;\n    cache._computedOffsetIndex = 0;\n  }\n  let i = cache._computedOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i < index) {\n    top += getItemSize(cache, i);\n    cache._offsets[++i] = top;\n  }\n  // mark as measured\n  cache._computedOffsetIndex = index;\n  return top;\n};\n\n/**\n * @internal\n */\nexport const computeTotalSize = (cache: Cache): number => {\n  if (!cache._length) return 0;\n  return (\n    computeOffset(cache, cache._length - 1) +\n    getItemSize(cache, cache._length - 1)\n  );\n};\n\n/**\n * Finds the index of an item in the cache whose computed offset is closest to the specified offset.\n *\n * @internal\n */\nexport const findIndex = (\n  cache: Cache,\n  offset: number,\n  low: number = 0,\n  high: number = cache._length - 1\n): number => {\n  // Find with binary search\n  while (low <= high) {\n    const mid = floor((low + high) / 2);\n    const itemOffset = computeOffset(cache, mid);\n    if (itemOffset <= offset) {\n      if (itemOffset + getItemSize(cache, mid) > offset) {\n        return mid;\n      }\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return clamp(low, 0, cache._length - 1);\n};\n\n/**\n * @internal\n */\nexport const computeRange = (\n  cache: Cache,\n  scrollOffset: number,\n  viewportSize: number,\n  prevStartIndex: number\n): ItemsRange => {\n  // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\n  prevStartIndex = min(prevStartIndex, cache._length - 1);\n\n  if (computeOffset(cache, prevStartIndex) <= scrollOffset) {\n    // search forward\n    // start <= end, prevStartIndex <= start\n    const end = findIndex(cache, scrollOffset + viewportSize, prevStartIndex);\n    return [findIndex(cache, scrollOffset, prevStartIndex, end), end];\n  } else {\n    // search backward\n    // start <= end, start <= prevStartIndex\n    const start = findIndex(cache, scrollOffset, undefined, prevStartIndex);\n    return [start, findIndex(cache, scrollOffset + viewportSize, start)];\n  }\n};\n\n/**\n * @internal\n */\nexport const estimateDefaultItemSize = (\n  cache: Writeable<Cache>,\n  startIndex: number\n): number => {\n  let measuredCountBeforeStart = 0;\n  // This function will be called after measurement so measured size array must be longer than 0\n  const measuredSizes: number[] = [];\n  cache._sizes.forEach((s, i) => {\n    if (s !== UNCACHED) {\n      measuredSizes.push(s);\n      if (i < startIndex) {\n        measuredCountBeforeStart++;\n      }\n    }\n  });\n\n  // Discard cache for now\n  cache._computedOffsetIndex = -1;\n\n  // Calculate median\n  const sorted = sort(measuredSizes);\n  const len = sorted.length;\n  const mid = (len / 2) | 0;\n  const median =\n    len % 2 === 0 ? (sorted[mid - 1]! + sorted[mid]!) / 2 : sorted[mid]!;\n\n  const prevDefaultItemSize = cache._defaultItemSize;\n\n  // Calculate diff of unmeasured items before start\n  return (\n    ((cache._defaultItemSize = median) - prevDefaultItemSize) *\n    max(startIndex - measuredCountBeforeStart, 0)\n  );\n};\n\n/**\n * @internal\n */\nexport const initCache = (\n  length: number,\n  itemSize: number,\n  snapshot?: InternalCacheSnapshot\n): Cache => {\n  return {\n    _defaultItemSize: snapshot ? snapshot[1] : itemSize,\n    _sizes:\n      snapshot && snapshot[0]\n        ? // https://github.com/inokawa/virtua/issues/441\n          fill(\n            snapshot[0].slice(0, min(length, snapshot[0].length)),\n            max(0, length - snapshot[0].length)\n          )\n        : fill([], length),\n    _length: length,\n    _computedOffsetIndex: -1,\n    _offsets: fill([], length),\n  };\n};\n\n/**\n * @internal\n */\nexport const takeCacheSnapshot = (cache: Cache): InternalCacheSnapshot => {\n  return [cache._sizes.slice(), cache._defaultItemSize];\n};\n\n/**\n * @internal\n */\nexport const updateCacheLength = (\n  cache: Writeable<Cache>,\n  length: number,\n  isShift?: boolean\n): number => {\n  const diff = length - cache._length;\n\n  cache._computedOffsetIndex = isShift\n    ? // Discard cache for now\n      -1\n    : min(length - 1, cache._computedOffsetIndex);\n  cache._length = length;\n\n  if (diff > 0) {\n    // Added\n    fill(cache._offsets, diff);\n    fill(cache._sizes, diff, isShift);\n    return cache._defaultItemSize * diff;\n  } else {\n    // Removed\n    cache._offsets.splice(diff);\n    return (\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\n    ).reduce(\n      (acc, removed) =>\n        acc - (removed === UNCACHED ? cache._defaultItemSize : removed),\n      0\n    );\n  }\n};\n","import { once } from \"./utils\";\n\n/**\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nconst getDocumentElement = () => document.documentElement;\n\n/**\n * @internal\n */\nexport const getCurrentDocument = (node: HTMLElement): Document =>\n  node.ownerDocument;\n\n/**\n * @internal\n */\nexport const getCurrentWindow = (doc: Document) => doc.defaultView!;\n\n/**\n * @internal\n */\nexport const isRTLDocument = /*#__PURE__*/ once((): boolean => {\n  // TODO support SSR in rtl\n  return isBrowser\n    ? getComputedStyle(getDocumentElement()).direction === \"rtl\"\n    : false;\n});\n\n/**\n * Currently, all browsers on iOS/iPadOS are WebKit, including WebView.\n * @internal\n */\nexport const isIOSWebKit = /*#__PURE__*/ once((): boolean => {\n  return /iP(hone|od|ad)/.test(navigator.userAgent);\n});\n\n/**\n * @internal\n */\nexport const isSmoothScrollSupported = /*#__PURE__*/ once((): boolean => {\n  return \"scrollBehavior\" in getDocumentElement().style;\n});\n","import {\n  initCache,\n  getItemSize as _getItemSize,\n  computeTotalSize,\n  computeOffset as computeStartOffset,\n  UNCACHED,\n  setItemSize,\n  estimateDefaultItemSize,\n  updateCacheLength,\n  computeRange,\n  takeCacheSnapshot,\n  findIndex,\n} from \"./cache\";\nimport { isIOSWebKit } from \"./environment\";\nimport type {\n  CacheSnapshot,\n  InternalCacheSnapshot,\n  ItemResize,\n  ItemsRange,\n} from \"./types\";\nimport { abs, max, min, NULL } from \"./utils\";\n\nconst MAX_INT_32 = 0x7fffffff;\n\nconst SCROLL_IDLE = 0;\nconst SCROLL_DOWN = 1;\nconst SCROLL_UP = 2;\ntype ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP;\n\nconst SCROLL_BY_NATIVE = 0;\nconst SCROLL_BY_MANUAL_SCROLL = 1;\nconst SCROLL_BY_SHIFT = 2;\ntype ScrollMode =\n  | typeof SCROLL_BY_NATIVE\n  | typeof SCROLL_BY_MANUAL_SCROLL\n  | typeof SCROLL_BY_SHIFT;\n\n/** @internal */\nexport const ACTION_SCROLL = 1;\n/** @internal */\nexport const ACTION_SCROLL_END = 2;\n/** @internal */\nexport const ACTION_ITEM_RESIZE = 3;\n/** @internal */\nexport const ACTION_VIEWPORT_RESIZE = 4;\n/** @internal */\nexport const ACTION_ITEMS_LENGTH_CHANGE = 5;\n/** @internal */\nexport const ACTION_START_OFFSET_CHANGE = 6;\n/** @internal */\nexport const ACTION_MANUAL_SCROLL = 7;\n/** @internal */\nexport const ACTION_BEFORE_MANUAL_SMOOTH_SCROLL = 8;\n\ntype Actions =\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: number]\n  | [\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\n      arg: [length: number, isShift?: boolean | undefined],\n    ]\n  | [type: typeof ACTION_START_OFFSET_CHANGE, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void]\n  | [type: typeof ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, offset: number];\n\n/** @internal */\nexport const UPDATE_VIRTUAL_STATE = 0b0001;\n/** @internal */\nexport const UPDATE_SIZE_EVENT = 0b0010;\n/** @internal */\nexport const UPDATE_SCROLL_EVENT = 0b0100;\n/** @internal */\nexport const UPDATE_SCROLL_END_EVENT = 0b1000;\n\n/**\n * @internal\n */\nexport const getScrollSize = (store: VirtualStore): number => {\n  return max(store.$getTotalSize(), store.$getViewportSize());\n};\n\n/**\n * @internal\n */\nexport const isInitialMeasurementDone = (store: VirtualStore): boolean => {\n  return !!store.$getViewportSize();\n};\n\ntype Subscriber = (sync?: boolean) => void;\n\n/** @internal */\nexport type StateVersion =\n  number & {} /* hack for typescript to pretend as not falsy */;\n\n/**\n * @internal\n */\nexport type VirtualStore = {\n  $getStateVersion(): StateVersion;\n  $getCacheSnapshot(): CacheSnapshot;\n  $getRange(): ItemsRange;\n  $findStartIndex(): number;\n  $findEndIndex(): number;\n  $isUnmeasuredItem(index: number): boolean;\n  $getItemOffset(index: number): number;\n  $getItemSize(index: number): number;\n  $getItemsLength(): number;\n  $getScrollOffset(): number;\n  $isScrolling(): boolean;\n  $getViewportSize(): number;\n  $getStartSpacerSize(): number;\n  $getTotalSize(): number;\n  _flushJump(): [number, boolean];\n  $subscribe(target: number, cb: Subscriber): () => void;\n  $update(...action: Actions): void;\n  _hasUnmeasuredItemsInFrozenRange(): boolean;\n};\n\n/**\n * @internal\n */\nexport const createVirtualStore = (\n  elementsCount: number,\n  itemSize: number = 40,\n  overscan: number = 4,\n  ssrCount: number = 0,\n  cacheSnapshot?: CacheSnapshot | undefined,\n  shouldAutoEstimateItemSize: boolean = false\n): VirtualStore => {\n  let isSSR = !!ssrCount;\n  let stateVersion: StateVersion = 1;\n  let viewportSize = 0;\n  let startSpacerSize = 0;\n  let scrollOffset = 0;\n  let jump = 0;\n  let pendingJump = 0;\n  let _flushedJump = 0;\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _scrollMode: ScrollMode = SCROLL_BY_NATIVE;\n  let _frozenRange: ItemsRange | null = isSSR\n    ? [0, max(ssrCount - 1, 0)]\n    : NULL;\n  let _prevRange: ItemsRange = [0, 0];\n  let _totalMeasuredSize = 0;\n\n  const cache = initCache(\n    elementsCount,\n    itemSize,\n    cacheSnapshot as unknown as InternalCacheSnapshot | undefined\n  );\n  const subscribers = new Set<[number, Subscriber]>();\n  const getRelativeScrollOffset = () => scrollOffset - startSpacerSize;\n  const getVisibleOffset = () => getRelativeScrollOffset() + pendingJump + jump;\n  const getRange = (offset: number) => {\n    return computeRange(cache, offset, viewportSize, _prevRange[0]);\n  };\n  const getTotalSize = (): number => computeTotalSize(cache);\n  const getItemOffset = (index: number): number => {\n    return computeStartOffset(cache, index) - pendingJump;\n  };\n  const getItemSize = (index: number): number => {\n    return _getItemSize(cache, index);\n  };\n\n  const applyJump = (j: number) => {\n    if (j) {\n      // In iOS WebKit browsers, updating scroll position will stop scrolling so it have to be deferred during scrolling.\n      if (isIOSWebKit() && _scrollDirection !== SCROLL_IDLE) {\n        pendingJump += j;\n      } else {\n        jump += j;\n      }\n    }\n  };\n\n  return {\n    $getStateVersion: () => stateVersion,\n    $getCacheSnapshot: () => {\n      return takeCacheSnapshot(cache) as unknown as CacheSnapshot;\n    },\n    $getRange: () => {\n      let startIndex: number;\n      let endIndex: number;\n      if (_flushedJump) {\n        // Return previous range for consistent render until next scroll event comes in.\n        // And it must be clamped. https://github.com/inokawa/virtua/issues/597\n        [startIndex, endIndex] = _prevRange;\n      } else {\n        [startIndex, endIndex] = _prevRange = getRange(\n          max(0, getVisibleOffset())\n        );\n        if (_frozenRange) {\n          startIndex = min(startIndex, _frozenRange[0]);\n          endIndex = max(endIndex, _frozenRange[1]);\n        }\n      }\n\n      if (_scrollDirection !== SCROLL_DOWN) {\n        startIndex -= max(0, overscan);\n      }\n      if (_scrollDirection !== SCROLL_UP) {\n        endIndex += max(0, overscan);\n      }\n      return [max(startIndex, 0), min(endIndex, cache._length - 1)];\n    },\n    $findStartIndex: () => findIndex(cache, getVisibleOffset()),\n    $findEndIndex: () => findIndex(cache, getVisibleOffset() + viewportSize),\n    $isUnmeasuredItem: (index) => cache._sizes[index] === UNCACHED,\n    _hasUnmeasuredItemsInFrozenRange: () => {\n      if (!_frozenRange) return false;\n      return cache._sizes\n        .slice(\n          max(0, _frozenRange[0] - 1),\n          min(cache._length - 1, _frozenRange[1] + 1) + 1\n        )\n        .includes(UNCACHED);\n    },\n    $getItemOffset: getItemOffset,\n    $getItemSize: getItemSize,\n    $getItemsLength: () => cache._length,\n    $getScrollOffset: () => scrollOffset,\n    $isScrolling: () => _scrollDirection !== SCROLL_IDLE,\n    $getViewportSize: () => viewportSize,\n    $getStartSpacerSize: () => startSpacerSize,\n    $getTotalSize: getTotalSize,\n    _flushJump: () => {\n      _flushedJump = jump;\n      jump = 0;\n      return [\n        _flushedJump,\n        // Use absolute position not to exceed scrollable bounds\n        _scrollMode === SCROLL_BY_SHIFT ||\n          // https://github.com/inokawa/virtua/discussions/475\n          getRelativeScrollOffset() + viewportSize >= getTotalSize(),\n      ];\n    },\n    $subscribe: (target, cb) => {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    $update: (type, payload): void => {\n      let shouldFlushPendingJump: boolean | undefined;\n      let shouldSync: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_SCROLL: {\n          const flushedJump = _flushedJump;\n          _flushedJump = 0;\n\n          const delta = payload - scrollOffset;\n          const distance = abs(delta);\n\n          // Scroll event after jump compensation is not reliable because it may result in the opposite direction.\n          // The delta of artificial scroll may not be equal with the jump because it may be batched with other scrolls.\n          // And at least in latest Chrome/Firefox/Safari in 2023, setting value to scrollTop/scrollLeft can lose subpixel because its integer (sometimes float probably depending on dpr).\n          const isJustJumped = flushedJump && distance < abs(flushedJump) + 1;\n\n          // Scroll events are dispatched enough so it's ok to skip some of them.\n          if (\n            !isJustJumped &&\n            // Ignore until manual scrolling\n            _scrollMode === SCROLL_BY_NATIVE\n          ) {\n            _scrollDirection = delta < 0 ? SCROLL_UP : SCROLL_DOWN;\n          }\n\n          // TODO This will cause glitch in reverse infinite scrolling. Disable this until better solution is found.\n          // if (\n          //   pendingJump &&\n          //   ((_scrollDirection === SCROLL_UP &&\n          //     payload - max(pendingJump, 0) <= 0) ||\n          //     (_scrollDirection === SCROLL_DOWN &&\n          //       payload - min(pendingJump, 0) >= getScrollOffsetMax()))\n          // ) {\n          //   // Flush if almost reached to start or end\n          //   shouldFlushPendingJump = true;\n          // }\n\n          if (isSSR) {\n            _frozenRange = NULL;\n            isSSR = false;\n          }\n\n          scrollOffset = payload;\n          mutated = UPDATE_SCROLL_EVENT;\n\n          // Skip if offset is not changed\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n          const relativeOffset = getRelativeScrollOffset();\n          if (\n            relativeOffset >= -viewportSize &&\n            relativeOffset <= getTotalSize()\n          ) {\n            mutated += UPDATE_VIRTUAL_STATE;\n\n            // Update synchronously if scrolled a lot\n            shouldSync = distance > viewportSize;\n          }\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          mutated = UPDATE_SCROLL_END_EVENT;\n          if (_scrollDirection !== SCROLL_IDLE) {\n            shouldFlushPendingJump = true;\n            mutated += UPDATE_VIRTUAL_STATE;\n          }\n          _scrollDirection = SCROLL_IDLE;\n          _scrollMode = SCROLL_BY_NATIVE;\n          _frozenRange = NULL;\n          break;\n        }\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          // Calculate jump by resize to minimize junks in appearance\n          applyJump(\n            updated.reduce((acc, [index, size]) => {\n              if (\n                // Keep distance from end during shifting\n                _scrollMode === SCROLL_BY_SHIFT ||\n                (_frozenRange\n                  ? // https://github.com/inokawa/virtua/issues/380\n                    // https://github.com/inokawa/virtua/issues/590\n                    !isSSR && index < _frozenRange[0]\n                  : // Otherwise we should maintain visible position\n                    getItemOffset(index) +\n                      // https://github.com/inokawa/virtua/issues/385\n                      (_scrollDirection === SCROLL_IDLE &&\n                      _scrollMode === SCROLL_BY_NATIVE\n                        ? getItemSize(index)\n                        : 0) <\n                    getRelativeScrollOffset())\n              ) {\n                acc += size - getItemSize(index);\n              }\n              return acc;\n            }, 0)\n          );\n\n          // Update item sizes\n          for (const [index, size] of updated) {\n            const prevSize = getItemSize(index);\n            const isInitialMeasurement = setItemSize(cache, index, size);\n\n            if (shouldAutoEstimateItemSize) {\n              _totalMeasuredSize += isInitialMeasurement\n                ? size\n                : size - prevSize;\n            }\n          }\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            viewportSize &&\n            // If the total size is lower than the viewport, the item may be a empty state\n            _totalMeasuredSize > viewportSize\n          ) {\n            applyJump(\n              estimateDefaultItemSize(\n                cache,\n                findIndex(cache, getVisibleOffset())\n              )\n            );\n            shouldAutoEstimateItemSize = false;\n          }\n\n          mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n\n          // Synchronous update is necessary in current design to minimize visible glitch in concurrent rendering.\n          // However this seems to be the main cause of the errors from ResizeObserver.\n          // https://github.com/inokawa/virtua/issues/470\n          //\n          // And in React, synchronous update with flushSync after asynchronous update will overtake the asynchronous one.\n          // If items resize happens just after scroll, race condition can occur depending on implementation.\n          shouldSync = true;\n          break;\n        }\n        case ACTION_VIEWPORT_RESIZE: {\n          if (viewportSize !== payload) {\n            viewportSize = payload;\n            mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n          }\n          break;\n        }\n        case ACTION_ITEMS_LENGTH_CHANGE: {\n          if (payload[1]) {\n            applyJump(updateCacheLength(cache, payload[0], true));\n            _scrollMode = SCROLL_BY_SHIFT;\n            mutated = UPDATE_VIRTUAL_STATE;\n          } else {\n            updateCacheLength(cache, payload[0]);\n            // https://github.com/inokawa/virtua/issues/552\n            // https://github.com/inokawa/virtua/issues/557\n            mutated = UPDATE_VIRTUAL_STATE;\n          }\n          break;\n        }\n        case ACTION_START_OFFSET_CHANGE: {\n          startSpacerSize = payload;\n          break;\n        }\n        case ACTION_MANUAL_SCROLL: {\n          _scrollMode = SCROLL_BY_MANUAL_SCROLL;\n          break;\n        }\n        case ACTION_BEFORE_MANUAL_SMOOTH_SCROLL: {\n          _frozenRange = getRange(payload);\n          mutated = UPDATE_VIRTUAL_STATE;\n          break;\n        }\n      }\n\n      if (mutated) {\n        stateVersion = (stateVersion & MAX_INT_32) + 1;\n\n        if (shouldFlushPendingJump && pendingJump) {\n          jump += pendingJump;\n          pendingJump = 0;\n        }\n\n        subscribers.forEach(([target, cb]) => {\n          // Early return to skip React's computation\n          if (!(mutated & target)) {\n            return;\n          }\n          // https://github.com/facebook/react/issues/25191\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\n          cb(shouldSync);\n        });\n      }\n    },\n  };\n};\n","import {\n  getCurrentDocument,\n  getCurrentWindow,\n  isIOSWebKit,\n  isRTLDocument,\n  isSmoothScrollSupported,\n} from \"./environment\";\nimport {\n  ACTION_SCROLL,\n  type VirtualStore,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE_EVENT,\n  ACTION_MANUAL_SCROLL,\n  ACTION_BEFORE_MANUAL_SMOOTH_SCROLL,\n  ACTION_START_OFFSET_CHANGE,\n  isInitialMeasurementDone,\n} from \"./store\";\nimport { type ScrollToIndexOpts } from \"./types\";\nimport { clamp, microtask, NULL } from \"./utils\";\n\nconst timeout = setTimeout;\n\nconst debounce = <T extends () => void>(fn: T, ms: number) => {\n  let id: ReturnType<typeof setTimeout> | undefined | null;\n\n  const cancel = () => {\n    if (id != NULL) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = NULL;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\n/**\n * scrollLeft is negative value in rtl direction.\n *\n * left  right\n * 0     100    spec compliant (ltr)\n * -100  0      spec compliant (rtl)\n * https://github.com/othree/jquery.rtl-scroll-type\n */\nconst normalizeOffset = (offset: number, isHorizontal: boolean): number => {\n  if (isHorizontal && isRTLDocument()) {\n    return -offset;\n  } else {\n    return offset;\n  }\n};\n\nconst createScrollObserver = (\n  store: VirtualStore,\n  viewport: HTMLElement | Window,\n  isHorizontal: boolean,\n  getScrollOffset: () => number,\n  updateScrollOffset: (\n    value: number,\n    shift: boolean,\n    isMomentumScrolling: boolean\n  ) => void,\n  getStartOffset?: () => number\n) => {\n  const now = Date.now;\n\n  let lastScrollTime = 0;\n  let wheeling = false;\n  let touching = false;\n  let justTouchEnded = false;\n  let stillMomentumScrolling = false;\n\n  const onScrollEnd = debounce(() => {\n    if (wheeling || touching) {\n      wheeling = false;\n\n      // Wait while wheeling or touching\n      onScrollEnd();\n      return;\n    }\n\n    justTouchEnded = false;\n\n    store.$update(ACTION_SCROLL_END);\n  }, 150);\n\n  const onScroll = () => {\n    lastScrollTime = now();\n\n    if (justTouchEnded) {\n      stillMomentumScrolling = true;\n    }\n\n    if (getStartOffset) {\n      store.$update(ACTION_START_OFFSET_CHANGE, getStartOffset());\n    }\n    store.$update(ACTION_SCROLL, getScrollOffset());\n\n    onScrollEnd();\n  };\n\n  // Infer scroll state also from wheel events\n  // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n  const onWheel = ((e: WheelEvent) => {\n    if (\n      wheeling ||\n      // Scroll start should be detected with scroll event\n      !store.$isScrolling() ||\n      // Probably a pinch-to-zoom gesture\n      e.ctrlKey\n    ) {\n      return;\n    }\n\n    const timeDelta = now() - lastScrollTime;\n    if (\n      // Check if wheel event occurs some time after scrolling\n      150 > timeDelta &&\n      50 < timeDelta &&\n      // Get delta before checking deltaMode for firefox behavior\n      // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n      (isHorizontal ? e.deltaX : e.deltaY)\n    ) {\n      wheeling = true;\n    }\n  }) as (e: Event) => void; // FIXME type error. why only here?\n\n  const onTouchStart = () => {\n    touching = true;\n    justTouchEnded = stillMomentumScrolling = false;\n  };\n  const onTouchEnd = () => {\n    touching = false;\n    if (isIOSWebKit()) {\n      justTouchEnded = true;\n    }\n  };\n\n  viewport.addEventListener(\"scroll\", onScroll);\n  viewport.addEventListener(\"wheel\", onWheel, { passive: true });\n  viewport.addEventListener(\"touchstart\", onTouchStart, { passive: true });\n  viewport.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n\n  return {\n    _dispose: () => {\n      viewport.removeEventListener(\"scroll\", onScroll);\n      viewport.removeEventListener(\"wheel\", onWheel);\n      viewport.removeEventListener(\"touchstart\", onTouchStart);\n      viewport.removeEventListener(\"touchend\", onTouchEnd);\n      onScrollEnd._cancel();\n    },\n    _fixScrollJump: () => {\n      const [jump, shift] = store._flushJump();\n      if (!jump) return;\n      updateScrollOffset(\n        normalizeOffset(jump, isHorizontal),\n        shift,\n        stillMomentumScrolling\n      );\n      stillMomentumScrolling = false;\n\n      if (shift && store.$getViewportSize() > store.$getTotalSize()) {\n        // In this case applying jump may not cause scroll.\n        // Current logic expects scroll event occurs after applying jump so we dispatch it manually.\n        store.$update(ACTION_SCROLL, getScrollOffset());\n      }\n    },\n  };\n};\n\ntype ScrollObserver = ReturnType<typeof createScrollObserver>;\n\n/**\n * @internal\n */\nexport type Scroller = {\n  $observe: (viewportElement: HTMLElement) => void;\n  $dispose(): void;\n  $scrollTo: (offset: number) => void;\n  $scrollBy: (offset: number) => void;\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): Scroller => {\n  let viewportElement: HTMLElement | undefined;\n  let scrollObserver: ScrollObserver | undefined;\n  let cancelScroll: (() => void) | undefined;\n  const scrollOffsetKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n  const overflowKey = isHorizontal ? \"overflowX\" : \"overflowY\";\n\n  // The given offset will be clamped by browser\n  // https://drafts.csswg.org/cssom-view/#dom-element-scrolltop\n  const scheduleImperativeScroll = async (\n    getTargetOffset: () => number,\n    smooth?: boolean\n  ) => {\n    if (!viewportElement) {\n      // Wait for element assign. The element may be undefined if scrollRef prop is used and scroll is scheduled on mount.\n      microtask(() => scheduleImperativeScroll(getTargetOffset, smooth));\n      return;\n    }\n\n    if (cancelScroll) {\n      // Cancel waiting scrollTo\n      cancelScroll();\n    }\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      // Wait for the scroll destination items to be measured.\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          cancelScroll = reject;\n\n          // Resize event may not happen when the window/tab is not visible, or during browser back in Safari.\n          // We have to wait for the initial measurement to avoid failing imperative scroll on mount.\n          // https://github.com/inokawa/virtua/issues/450\n          if (isInitialMeasurementDone(store)) {\n            // Reject when items around scroll destination completely measured\n            timeout(reject, 150);\n          }\n        }),\n        store.$subscribe(UPDATE_SIZE_EVENT, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store.$update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInFrozenRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          // canceled\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      viewportElement.scrollTo({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n          getTargetOffset(),\n          isHorizontal\n        ),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          viewportElement[scrollOffsetKey] = normalizeOffset(\n            getTargetOffset(),\n            isHorizontal\n          );\n          store.$update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          // canceled or finished\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    $observe(viewport) {\n      viewportElement = viewport;\n\n      scrollObserver = createScrollObserver(\n        store,\n        viewport,\n        isHorizontal,\n        () => normalizeOffset(viewport[scrollOffsetKey], isHorizontal),\n        (jump, shift, isMomentumScrolling) => {\n          // If we update scroll position while touching on iOS, the position will be reverted.\n          // However iOS WebKit fires touch events only once at the beginning of momentum scrolling.\n          // That means we have no reliable way to confirm still touched or not if user touches more than once during momentum scrolling...\n          // This is a hack for the suspectable situations, inspired by https://github.com/prud/ios-overflow-scroll-to-top\n          if (isMomentumScrolling) {\n            const style = viewport.style;\n            const prev = style[overflowKey];\n            style[overflowKey] = \"hidden\";\n            timeout(() => {\n              style[overflowKey] = prev;\n            });\n          }\n\n          if (shift) {\n            viewport[scrollOffsetKey] = store.$getScrollOffset() + jump;\n            // https://github.com/inokawa/virtua/issues/357\n            cancelScroll && cancelScroll();\n          } else {\n            viewport[scrollOffsetKey] += jump;\n          }\n        }\n      );\n    },\n    $dispose() {\n      scrollObserver && scrollObserver._dispose();\n    },\n    $scrollTo(offset) {\n      scheduleImperativeScroll(() => offset);\n    },\n    $scrollBy(offset) {\n      offset += store.$getScrollOffset();\n      scheduleImperativeScroll(() => offset);\n    },\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\n      index = clamp(index, 0, store.$getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store.$getItemOffset(index);\n        const scrollOffset = store.$getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store.$getItemSize(index) >\n          scrollOffset + store.$getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          // already completely visible\n          return;\n        }\n      }\n\n      scheduleImperativeScroll(() => {\n        return (\n          offset +\n          store.$getStartSpacerSize() +\n          store.$getItemOffset(index) +\n          (align === \"end\"\n            ? store.$getItemSize(index) - store.$getViewportSize()\n            : align === \"center\"\n              ? (store.$getItemSize(index) - store.$getViewportSize()) / 2\n              : 0)\n        );\n      }, smooth);\n    },\n    $fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type WindowScroller = {\n  $observe(containerElement: HTMLElement): void;\n  $dispose(): void;\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  let containerElement: HTMLElement | undefined;\n  let scrollObserver: ScrollObserver | undefined;\n  let cancelScroll: (() => void) | undefined;\n\n  const calcOffsetToViewport = (\n    node: HTMLElement,\n    viewport: HTMLElement,\n    window: Window,\n    isHorizontal: boolean,\n    offset: number = 0\n  ): number => {\n    // TODO calc offset only when it changes (maybe impossible)\n    const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n    const offsetSum =\n      offset +\n      (isHorizontal && isRTLDocument()\n        ? window.innerWidth - node[offsetKey] - node.offsetWidth\n        : node[offsetKey]);\n\n    const parent = node.offsetParent;\n    if (node === viewport || !parent) {\n      return offsetSum;\n    }\n\n    return calcOffsetToViewport(\n      parent as HTMLElement,\n      viewport,\n      window,\n      isHorizontal,\n      offsetSum\n    );\n  };\n\n  const scheduleImperativeScroll = async (\n    getTargetOffset: () => number,\n    smooth?: boolean\n  ) => {\n    if (!containerElement) {\n      // Wait for element assign\n      microtask(() => scheduleImperativeScroll(getTargetOffset, smooth));\n      return;\n    }\n\n    if (cancelScroll) {\n      cancelScroll();\n    }\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          cancelScroll = reject;\n\n          if (isInitialMeasurementDone(store)) {\n            timeout(reject, 150);\n          }\n        }),\n        store.$subscribe(UPDATE_SIZE_EVENT, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    const window = getCurrentWindow(getCurrentDocument(containerElement));\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store.$update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInFrozenRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      window.scroll({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n          getTargetOffset(),\n          isHorizontal\n        ),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          window.scroll({\n            [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n              getTargetOffset(),\n              isHorizontal\n            ),\n          });\n          store.$update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    $observe(container) {\n      containerElement = container;\n      const scrollOffsetKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n\n      const document = getCurrentDocument(container);\n      const window = getCurrentWindow(document);\n      const documentBody = document.body;\n\n      scrollObserver = createScrollObserver(\n        store,\n        window,\n        isHorizontal,\n        () => normalizeOffset(window[scrollOffsetKey], isHorizontal),\n        (jump, shift) => {\n          // TODO support case two window scrollers exist in the same view\n          if (shift) {\n            window.scroll({\n              [isHorizontal ? \"left\" : \"top\"]: store.$getScrollOffset() + jump,\n            });\n          } else {\n            window.scrollBy(isHorizontal ? jump : 0, isHorizontal ? 0 : jump);\n          }\n        },\n        () =>\n          calcOffsetToViewport(container, documentBody, window, isHorizontal)\n      );\n    },\n    $dispose() {\n      scrollObserver && scrollObserver._dispose();\n      containerElement = undefined;\n    },\n    $fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\n      if (!containerElement) return;\n\n      index = clamp(index, 0, store.$getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store.$getItemOffset(index);\n        const scrollOffset = store.$getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store.$getItemSize(index) >\n          scrollOffset + store.$getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          return;\n        }\n      }\n\n      const document = getCurrentDocument(containerElement);\n      const window = getCurrentWindow(document);\n      const html = document.documentElement;\n      const getScrollbarSize = () =>\n        store.$getViewportSize() -\n        (isHorizontal ? html.clientWidth : html.clientHeight);\n\n      scheduleImperativeScroll(() => {\n        return (\n          offset +\n          // Calculate target scroll position including container's offset from document\n          calcOffsetToViewport(\n            containerElement!,\n            document.body,\n            window,\n            isHorizontal\n          ) +\n          // store._getStartSpacerSize() +\n          store.$getItemOffset(index) +\n          (align === \"end\"\n            ? store.$getItemSize(index) -\n              (store.$getViewportSize() - getScrollbarSize())\n            : align === \"center\"\n              ? (store.$getItemSize(index) -\n                  (store.$getViewportSize() - getScrollbarSize())) /\n                2\n              : 0)\n        );\n      }, smooth);\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type GridScroller = {\n  $observe: (viewportElement: HTMLElement) => void;\n  $dispose(): void;\n  $scrollTo: (offsetX: number, offsetY: number) => void;\n  $scrollBy: (offsetX: number, offsetY: number) => void;\n  $scrollToIndex: (indexX: number, indexY: number) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createGridScroller = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n): GridScroller => {\n  const vScroller = createScroller(vStore, false);\n  const hScroller = createScroller(hStore, true);\n  return {\n    $observe(viewportElement) {\n      vScroller.$observe(viewportElement);\n      hScroller.$observe(viewportElement);\n    },\n    $dispose() {\n      vScroller.$dispose();\n      hScroller.$dispose();\n    },\n    $scrollTo(offsetX, offsetY) {\n      vScroller.$scrollTo(offsetY);\n      hScroller.$scrollTo(offsetX);\n    },\n    $scrollBy(offsetX, offsetY) {\n      vScroller.$scrollBy(offsetY);\n      hScroller.$scrollBy(offsetX);\n    },\n    $scrollToIndex(indexX, indexY) {\n      vScroller.$scrollToIndex(indexY);\n      hScroller.$scrollToIndex(indexX);\n    },\n    $fixScrollJump() {\n      vScroller.$fixScrollJump();\n      hScroller.$fixScrollJump();\n    },\n  };\n};\n","import { getCurrentDocument, getCurrentWindow } from \"./environment\";\nimport {\n  ACTION_ITEM_RESIZE,\n  ACTION_VIEWPORT_RESIZE,\n  type VirtualStore,\n} from \"./store\";\nimport { type ItemResize } from \"./types\";\nimport { max, NULL } from \"./utils\";\n\nconst createResizeObserver = (cb: ResizeObserverCallback) => {\n  let ro: ResizeObserver | undefined;\n\n  return {\n    _observe(e: HTMLElement) {\n      // Initialize ResizeObserver lazily for SSR\n      // https://www.w3.org/TR/resize-observer/#intro\n      (\n        ro ||\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1491739\n        (ro = new (getCurrentWindow(getCurrentDocument(e)).ResizeObserver)(cb))\n      ).observe(e);\n    },\n    _unobserve(e: HTMLElement) {\n      ro!.unobserve(e);\n    },\n    _dispose() {\n      ro && ro.disconnect();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type ItemResizeObserver = (el: HTMLElement, i: number) => () => void;\n\ninterface ListResizer {\n  $observeRoot(viewportElement: HTMLElement): void;\n  $observeItem: ItemResizeObserver;\n  $dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let viewportElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        store.$update(ACTION_VIEWPORT_RESIZE, contentRect[sizeKey]);\n      } else {\n        const index = mountedIndexes.get(target);\n        if (index != NULL) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n    }\n\n    if (resizes.length) {\n      store.$update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  return {\n    $observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    $observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose: resizeObserver._dispose,\n  };\n};\n\ninterface WindowListResizer {\n  $observeRoot(container: HTMLElement): void;\n  $observeItem: ItemResizeObserver;\n  $dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      const index = mountedIndexes.get(target);\n      if (index != NULL) {\n        resizes.push([index, contentRect[sizeKey]]);\n      }\n    }\n\n    if (resizes.length) {\n      store.$update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  let cleanupOnWindowResize: (() => void) | undefined;\n\n  return {\n    $observeRoot(container) {\n      const window = getCurrentWindow(getCurrentDocument(container));\n      const onWindowResize = () => {\n        store.$update(ACTION_VIEWPORT_RESIZE, window[windowSizeKey]);\n      };\n      window.addEventListener(\"resize\", onWindowResize);\n      onWindowResize();\n\n      cleanupOnWindowResize = () => {\n        window.removeEventListener(\"resize\", onWindowResize);\n      };\n    },\n    $observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose() {\n      cleanupOnWindowResize && cleanupOnWindowResize();\n      resizeObserver._dispose();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let viewportElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizedRows = new Set<number>();\n    const resizedCols = new Set<number>();\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        vStore.$update(ACTION_VIEWPORT_RESIZE, contentRect[heightKey]);\n        hStore.$update(ACTION_VIEWPORT_RESIZE, contentRect[widthKey]);\n      } else {\n        const cell = mountedIndexes.get(target);\n        if (cell) {\n          const [rowIndex, colIndex] = cell;\n          const key = getKey(rowIndex, colIndex);\n          const prevSize = sizeCache.get(key);\n          const size: CellSize = [\n            contentRect[heightKey],\n            contentRect[widthKey],\n          ];\n          let rowResized: boolean | undefined;\n          let colResized: boolean | undefined;\n          if (!prevSize) {\n            rowResized = colResized = true;\n          } else {\n            if (prevSize[0] !== size[0]) {\n              rowResized = true;\n            }\n            if (prevSize[1] !== size[1]) {\n              colResized = true;\n            }\n          }\n          if (rowResized) {\n            resizedRows.add(rowIndex);\n          }\n          if (colResized) {\n            resizedCols.add(colIndex);\n          }\n          if (rowResized || colResized) {\n            sizeCache.set(key, size);\n          }\n        }\n      }\n    }\n\n    if (resizedRows.size) {\n      const heightResizes: ItemResize[] = [];\n      resizedRows.forEach((rowIndex) => {\n        let maxHeight = 0;\n        maybeCachedColIndexes.forEach((colIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxHeight = max(maxHeight, size[0]);\n          }\n        });\n        if (maxHeight) {\n          heightResizes.push([rowIndex, maxHeight]);\n        }\n      });\n      vStore.$update(ACTION_ITEM_RESIZE, heightResizes);\n    }\n    if (resizedCols.size) {\n      const widthResizes: ItemResize[] = [];\n      resizedCols.forEach((colIndex) => {\n        let maxWidth = 0;\n        maybeCachedRowIndexes.forEach((rowIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxWidth = max(maxWidth, size[1]);\n          }\n        });\n        if (maxWidth) {\n          widthResizes.push([colIndex, maxWidth]);\n        }\n      });\n      hStore.$update(ACTION_ITEM_RESIZE, widthResizes);\n    }\n  });\n\n  return {\n    $observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    $observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose: resizeObserver._dispose,\n  };\n};\n\n/**\n * @internal\n */\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","/**\n * @jsxImportSource solid-js\n */\nimport { ItemResizeObserver, isRTLDocument } from \"../core\";\nimport {\n  Component,\n  JSX,\n  createEffect,\n  createMemo,\n  mergeProps,\n  onCleanup,\n  type ValidComponent,\n} from \"solid-js\";\nimport { Dynamic } from \"solid-js/web\";\n\ninterface ListItemProps {\n  _children: JSX.Element;\n  _resizer: ItemResizeObserver;\n  _index: number;\n  _offset: number;\n  _hide: boolean;\n  _isHorizontal: boolean;\n  _as?: ValidComponent;\n}\n\n/**\n * @internal\n */\nexport const ListItem: Component<ListItemProps> = (props) => {\n  let elementRef: HTMLDivElement | undefined;\n  props = mergeProps<[Partial<ListItemProps>, ListItemProps]>(\n    { _as: \"div\" },\n    props\n  );\n\n  // The index may be changed if elements are inserted to or removed from the start of props.children\n  createEffect(() => {\n    if (!elementRef) return;\n    onCleanup(props._resizer(elementRef, props._index));\n  });\n\n  const style = createMemo(() => {\n    const isHorizontal = props._isHorizontal;\n    const style: JSX.CSSProperties = {\n      position: \"absolute\",\n      [isHorizontal ? \"height\" : \"width\"]: \"100%\",\n      [isHorizontal ? \"top\" : \"left\"]: \"0px\",\n      [isHorizontal ? (isRTLDocument() ? \"right\" : \"left\") : \"top\"]:\n        props._offset + \"px\",\n      visibility: props._hide ? \"hidden\" : \"visible\",\n    };\n    if (isHorizontal) {\n      style.display = \"flex\";\n    }\n    return style;\n  });\n\n  return (\n    <Dynamic component={props._as} index={props._index} ref={elementRef} style={style()}>\n      {props._children}\n    </Dynamic>\n  );\n};\n","import { ItemsRange } from \"../core\";\n\n/**\n * @internal\n */\nexport const isSameRange = (prev: ItemsRange, next: ItemsRange): boolean => {\n  return prev[0] === next[0] && prev[1] === next[1];\n};\n","/**\n * @jsxImportSource solid-js\n */\nimport {\n  onMount,\n  onCleanup,\n  createEffect,\n  createSignal,\n  createMemo,\n  JSX,\n  on,\n  createComputed,\n  type ValidComponent,\n  mergeProps,\n  For,\n  Accessor,\n  untrack,\n} from \"solid-js\";\nimport { Dynamic } from \"solid-js/web\";\nimport {\n  UPDATE_SCROLL_EVENT,\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  getScrollSize,\n  ACTION_START_OFFSET_CHANGE,\n  createResizer,\n  createScroller,\n  ItemsRange,\n  ScrollToIndexOpts,\n  CacheSnapshot,\n  sort,\n} from \"../core\";\nimport { ListItem } from \"./ListItem\";\nimport { isSameRange } from \"./utils\";\n\n/**\n * Methods of {@link Virtualizer}.\n */\nexport interface VirtualizerHandle {\n  /**\n   * Get current {@link CacheSnapshot}.\n   */\n  readonly cache: CacheSnapshot;\n  /**\n   * Get current scrollTop, or scrollLeft if horizontal: true.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight, or scrollWidth if horizontal: true.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight, or offsetWidth if horizontal: true.\n   */\n  readonly viewportSize: number;\n  /**\n   * Find the start index of visible range of items.\n   */\n  findStartIndex: () => number;\n  /**\n   * Find the end index of visible range of items.\n   */\n  findEndIndex: () => number;\n  /**\n   * Get item offset from start.\n   * @param index index of item\n   */\n  getItemOffset(index: number): number;\n  /**\n   * Get item size.\n   * @param index index of item\n   */\n  getItemSize(index: number): number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param opts options\n   */\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\n/**\n * Props of {@link Virtualizer}.\n */\nexport interface VirtualizerProps<T> {\n  /**\n   * Get reference to {@link VirtualizerHandle}.\n   */\n  ref?: (handle?: VirtualizerHandle) => void;\n  /**\n   * The data items rendered by this component.\n   */\n  data: T[];\n  /**\n   * The elements renderer function.\n   */\n  children: (data: T, index: Accessor<number>) => JSX.Element;\n  /**\n   * Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * Component or element type for container element.\n   * @defaultValue \"div\"\n   */\n  as?: ValidComponent;\n  /**\n   * Component or element type for item element.\n   * @defaultValue \"div\"\n   */\n  item?: ValidComponent;\n  /**\n   * Reference to the scrollable element. The default will get the direct parent element of virtualizer.\n   */\n  scrollRef?: HTMLElement;\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize?: number;\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift?: boolean;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * List of indexes that should be always mounted, even when off screen.\n   */\n  keepMounted?: number[];\n  /**\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.\n   *\n   * **The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**\n   */\n  cache?: CacheSnapshot;\n  /**\n   * If you put an element before virtualizer, you have to define its height with this prop.\n   */\n  startMargin?: number;\n  /**\n   * Callback invoked whenever scroll offset changes.\n   * @param offset Current scrollTop, or scrollLeft if horizontal: true.\n   */\n  onScroll?: (offset: number) => void;\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollEnd?: () => void;\n}\n\n/**\n * Customizable list virtualizer for advanced usage. See {@link VirtualizerProps} and {@link VirtualizerHandle}.\n */\nexport const Virtualizer = <T,>(props: VirtualizerProps<T>): JSX.Element => {\n  let containerRef: HTMLDivElement | undefined;\n  const { itemSize, horizontal = false, overscan, cache } = props;\n  props = mergeProps<[Partial<VirtualizerProps<T>>, VirtualizerProps<T>]>(\n    { as: \"div\" },\n    props\n  );\n\n  const store = createVirtualStore(\n    props.data.length,\n    itemSize,\n    overscan,\n    undefined,\n    cache,\n    !itemSize\n  );\n  const resizer = createResizer(store, horizontal);\n  const scroller = createScroller(store, horizontal);\n\n  const [stateVersion, setRerender] = createSignal(store.$getStateVersion());\n\n  const unsubscribeStore = store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\n    setRerender(store.$getStateVersion());\n  });\n\n  const unsubscribeOnScroll = store.$subscribe(UPDATE_SCROLL_EVENT, () => {\n    props.onScroll?.(store.$getScrollOffset());\n  });\n  const unsubscribeOnScrollEnd = store.$subscribe(\n    UPDATE_SCROLL_END_EVENT,\n    () => {\n      props.onScrollEnd?.();\n    }\n  );\n\n  const range = createMemo<ItemsRange>((prev) => {\n    stateVersion();\n    const next = store.$getRange();\n    if (prev && isSameRange(prev, next)) {\n      return prev;\n    }\n    return next;\n  });\n  const isScrolling = createMemo(() => stateVersion() && store.$isScrolling());\n  const totalSize = createMemo(() => stateVersion() && store.$getTotalSize());\n\n  onMount(() => {\n    if (props.ref) {\n      props.ref({\n        get cache() {\n          return store.$getCacheSnapshot();\n        },\n        get scrollOffset() {\n          return store.$getScrollOffset();\n        },\n        get scrollSize() {\n          return getScrollSize(store);\n        },\n        get viewportSize() {\n          return store.$getViewportSize();\n        },\n        findStartIndex: store.$findStartIndex,\n        findEndIndex: store.$findEndIndex,\n        getItemOffset: store.$getItemOffset,\n        getItemSize: store.$getItemSize,\n        scrollToIndex: scroller.$scrollToIndex,\n        scrollTo: scroller.$scrollTo,\n        scrollBy: scroller.$scrollBy,\n      });\n    }\n\n    const scrollable = props.scrollRef || containerRef!.parentElement!;\n    resizer.$observeRoot(scrollable);\n    scroller.$observe(scrollable);\n\n    onCleanup(() => {\n      if (props.ref) {\n        props.ref();\n      }\n\n      unsubscribeStore();\n      unsubscribeOnScroll();\n      unsubscribeOnScrollEnd();\n      resizer.$dispose();\n      scroller.$dispose();\n    });\n  });\n\n  createComputed(\n    on(\n      () => props.startMargin || 0,\n      (value) => {\n        if (value !== store.$getStartSpacerSize()) {\n          store.$update(ACTION_START_OFFSET_CHANGE, value);\n        }\n      }\n    )\n  );\n\n  createEffect(\n    on(stateVersion, () => {\n      scroller.$fixScrollJump();\n    })\n  );\n\n  const dataSlice = createMemo(() => {\n    const count = props.data.length;\n    untrack(() => {\n      if (count !== store.$getItemsLength()) {\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    });\n    const [start, end] = range();\n    const items = end >= 0 ? props.data.slice(start, end + 1) : [];\n    const indexes = items.map((_, index) => start + index);\n\n    if (props.keepMounted) {\n      const startItems: T[] = [];\n      const startIndexes: number[] = [];\n      const endItems: T[] = [];\n      const endIndexes: number[] = [];\n      sort(props.keepMounted).forEach((index) => {\n        if (index < 0 || index >= props.data.length) return;\n        if (index < start) {\n          startItems.push(props.data[index]!);\n          startIndexes.push(index);\n        }\n        if (index > end) {\n          endItems.push(props.data[index]!);\n          endIndexes.push(index);\n        }\n      });\n      items.unshift(...startItems);\n      indexes.unshift(...startIndexes);\n      items.push(...endItems);\n      indexes.push(...endIndexes);\n    }\n\n    return { _items: items, _indexes: indexes };\n  });\n\n  const renderItem = (data: T, index: Accessor<number>) => {\n    const offset = createMemo(() => {\n      stateVersion();\n      return store.$getItemOffset(index());\n    });\n    const hide = createMemo(() => {\n      stateVersion();\n      return store.$isUnmeasuredItem(index());\n    });\n    const children = createMemo(() => {\n      return untrack(() => props.children(data, index));\n    });\n\n    return (\n      <ListItem\n        _as={props.item}\n        _index={index()}\n        _resizer={resizer.$observeItem}\n        _offset={offset()}\n        _hide={hide()}\n        _children={children()}\n        _isHorizontal={horizontal}\n      />\n    );\n  };\n\n  return (\n    <Dynamic\n      component={props.as}\n      ref={containerRef}\n      style={{\n        // contain: \"content\",\n        \"overflow-anchor\": \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n        flex: \"none\", // flex style can break layout\n        position: \"relative\",\n        visibility: \"hidden\", // TODO replace with other optimization methods\n        width: horizontal ? totalSize() + \"px\" : \"100%\",\n        height: horizontal ? \"100%\" : totalSize() + \"px\",\n        \"pointer-events\": isScrolling() ? \"none\" : undefined,\n      }}\n    >\n      <For each={dataSlice()._items}>\n        {(data, index) => {\n          const itemIndex = createMemo(() => dataSlice()._indexes[index()]!);\n          // eslint-disable-next-line solid/reactivity\n          return renderItem(data, itemIndex);\n        }}\n      </For>\n    </Dynamic>\n  );\n};\n","/**\n * @jsxImportSource solid-js\n */\nimport { JSX, splitProps } from \"solid-js\";\nimport { ViewportComponentAttributes } from \"./types\";\nimport {\n  Virtualizer,\n  VirtualizerHandle,\n  VirtualizerProps,\n} from \"./Virtualizer\";\n\n/**\n * Methods of {@link VList}.\n */\nexport interface VListHandle extends VirtualizerHandle {}\n\n/**\n * Props of {@link VList}.\n */\nexport interface VListProps<T>\n  extends Pick<\n      VirtualizerProps<T>,\n      | \"ref\"\n      | \"data\"\n      | \"children\"\n      | \"overscan\"\n      | \"itemSize\"\n      | \"shift\"\n      | \"horizontal\"\n      | \"cache\"\n      | \"item\"\n      | \"onScroll\"\n      | \"onScrollEnd\"\n      | \"keepMounted\"\n    >,\n    ViewportComponentAttributes {}\n\n/**\n * Virtualized list component. See {@link VListProps} and {@link VListHandle}.\n */\nexport const VList = <T,>(props: VListProps<T>): JSX.Element => {\n  const [local, others] = splitProps(props, [\n    \"ref\",\n    \"data\",\n    \"children\",\n    \"overscan\",\n    \"itemSize\",\n    \"shift\",\n    \"horizontal\",\n    \"keepMounted\",\n    \"cache\",\n    \"item\",\n    \"onScroll\",\n    \"onScrollEnd\",\n    \"style\",\n  ]);\n\n  return (\n    <div\n      {...others}\n      style={{\n        display: local.horizontal ? \"inline-block\" : \"block\",\n        [local.horizontal ? \"overflow-x\" : \"overflow-y\"]: \"auto\",\n        contain: \"strict\",\n        width: \"100%\",\n        height: \"100%\",\n        ...local.style,\n      }}\n    >\n      <Virtualizer\n        ref={local.ref}\n        data={local.data}\n        overscan={local.overscan}\n        itemSize={local.itemSize}\n        shift={local.shift}\n        horizontal={local.horizontal}\n        keepMounted={local.keepMounted}\n        cache={local.cache}\n        item={local.item}\n        onScroll={local.onScroll}\n        onScrollEnd={local.onScrollEnd}\n      >\n        {local.children}\n      </Virtualizer>\n    </div>\n  );\n};\n","/**\n * @jsxImportSource solid-js\n */\nimport {\n  onMount,\n  onCleanup,\n  createEffect,\n  createSignal,\n  createMemo,\n  JSX,\n  Accessor,\n  on,\n  For,\n  untrack,\n} from \"solid-js\";\nimport {\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  UPDATE_SCROLL_EVENT,\n  createWindowResizer,\n  createWindowScroller,\n  ItemsRange,\n  ScrollToIndexOpts,\n  CacheSnapshot,\n} from \"../core\";\nimport { ListItem } from \"./ListItem\";\nimport { isSameRange } from \"./utils\";\n\n/**\n * Methods of {@link WindowVirtualizer}.\n */\nexport interface WindowVirtualizerHandle {\n  /**\n   * Get current {@link CacheSnapshot}.\n   */\n  readonly cache: CacheSnapshot;\n  /**\n   * Find the start index of visible range of items.\n   */\n  findStartIndex: () => number;\n  /**\n   * Find the end index of visible range of items.\n   */\n  findEndIndex: () => number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param opts options\n   */\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\n}\n\n/**\n * Props of {@link WindowVirtualizer}.\n */\nexport interface WindowVirtualizerProps<T> {\n  /**\n   * Get reference to {@link WindowVirtualizerHandle}.\n   */\n  ref?: (handle?: WindowVirtualizerHandle) => void;\n  /**\n   * The data items rendered by this component.\n   */\n  data: T[];\n  /**\n   * The elements renderer function.\n   */\n  children: (data: T, index: Accessor<number>) => JSX.Element;\n  /**\n   * Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize?: number;\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift?: boolean;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link WindowVirtualizerHandle.cache}.\n   *\n   * **The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**\n   */\n  cache?: CacheSnapshot;\n  /**\n   * Callback invoked whenever scroll offset changes.\n   */\n  onScroll?: () => void;\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollEnd?: () => void;\n}\n\n/**\n * {@link Virtualizer} controlled by the window scrolling. See {@link WindowVirtualizerProps} and {@link WindowVirtualizerHandle}.\n */\nexport const WindowVirtualizer = <T,>(\n  props: WindowVirtualizerProps<T>\n): JSX.Element => {\n  let containerRef: HTMLDivElement | undefined;\n\n  const {\n    ref: _ref,\n    data: _data,\n    children: _children,\n    overscan,\n    itemSize,\n    shift: _shift,\n    horizontal = false,\n    cache,\n    onScrollEnd: _onScrollEnd,\n  } = props;\n\n  const store = createVirtualStore(\n    props.data.length,\n    itemSize,\n    overscan,\n    undefined,\n    cache,\n    !itemSize\n  );\n  const resizer = createWindowResizer(store, horizontal);\n  const scroller = createWindowScroller(store, horizontal);\n\n  const [stateVersion, setRerender] = createSignal(store.$getStateVersion());\n\n  const unsubscribeStore = store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\n    setRerender(store.$getStateVersion());\n  });\n\n  const unsubscribeOnScroll = store.$subscribe(UPDATE_SCROLL_EVENT, () => {\n    // https://github.com/inokawa/virtua/discussions/580\n    props.onScroll?.();\n  });\n  const unsubscribeOnScrollEnd = store.$subscribe(\n    UPDATE_SCROLL_END_EVENT,\n    () => {\n      props.onScrollEnd?.();\n    }\n  );\n\n  const range = createMemo<ItemsRange>((prev) => {\n    stateVersion();\n    const next = store.$getRange();\n    if (prev && isSameRange(prev, next)) {\n      return prev;\n    }\n    return next;\n  });\n  const isScrolling = createMemo(() => stateVersion() && store.$isScrolling());\n  const totalSize = createMemo(() => stateVersion() && store.$getTotalSize());\n\n  onMount(() => {\n    if (props.ref) {\n      props.ref({\n        get cache() {\n          return store.$getCacheSnapshot();\n        },\n        findStartIndex: store.$findStartIndex,\n        findEndIndex: store.$findEndIndex,\n        scrollToIndex: scroller.$scrollToIndex,\n      });\n    }\n\n    resizer.$observeRoot(containerRef!);\n    scroller.$observe(containerRef!);\n\n    onCleanup(() => {\n      if (props.ref) {\n        props.ref();\n      }\n\n      unsubscribeStore();\n      unsubscribeOnScroll();\n      unsubscribeOnScrollEnd();\n      resizer.$dispose();\n      scroller.$dispose();\n    });\n  });\n\n  createEffect(\n    on(stateVersion, () => {\n      scroller.$fixScrollJump();\n    })\n  );\n\n  const dataSlice = createMemo<T[]>(() => {\n    const count = props.data.length;\n    untrack(() => {\n      if (count !== store.$getItemsLength()) {\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    });\n    const [start, end] = range();\n    return end >= 0 ? props.data.slice(start, end + 1) : [];\n  });\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        // contain: \"content\",\n        \"overflow-anchor\": \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n        flex: \"none\", // flex style can break layout\n        position: \"relative\",\n        visibility: \"hidden\", // TODO replace with other optimization methods\n        width: horizontal ? totalSize() + \"px\" : \"100%\",\n        height: horizontal ? \"100%\" : totalSize() + \"px\",\n        \"pointer-events\": isScrolling() ? \"none\" : undefined,\n      }}\n    >\n      <For each={dataSlice()}>\n        {(data, index) => {\n          const itemIndex = createMemo(() => range()[0] + index());\n          const offset = createMemo(() => {\n            stateVersion();\n            return store.$getItemOffset(itemIndex());\n          });\n          const hide = createMemo(() => {\n            stateVersion();\n            return store.$isUnmeasuredItem(itemIndex());\n          });\n          const children = createMemo(() => {\n            return untrack(() => props.children(data, itemIndex));\n          });\n\n          return (\n            <ListItem\n              _index={itemIndex()}\n              _resizer={resizer.$observeItem}\n              _offset={offset()}\n              _hide={hide()}\n              _children={children()}\n              _isHorizontal={horizontal}\n            />\n          );\n        }}\n      </For>\n    </div>\n  );\n};\n","/**\n * @module solid\n */\nexport { VList } from \"./VList\";\nexport type { VListProps, VListHandle } from \"./VList\";\nexport { Virtualizer } from \"./Virtualizer\";\nexport type { VirtualizerProps, VirtualizerHandle } from \"./Virtualizer\";\nexport { WindowVirtualizer } from \"./WindowVirtualizer\";\nexport type {\n  WindowVirtualizerProps,\n  WindowVirtualizerHandle,\n} from \"./WindowVirtualizer\";\nexport type * from \"./types\";\n"],"names":["computeStartOffset","getItemSize","_getItemSize"],"mappings":"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"}