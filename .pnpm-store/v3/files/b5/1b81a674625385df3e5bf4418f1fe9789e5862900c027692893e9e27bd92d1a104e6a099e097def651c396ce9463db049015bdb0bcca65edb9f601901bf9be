{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/stringEdit.ts","vs/editor/common/core/edits/stringEdit.ts"],"names":[],"mappings":"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","file":"stringEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n"]}