{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/instantiation/common/instantiationService.ts","vs/platform/instantiation/common/instantiationService.ts"],"names":[],"mappings":"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","file":"instantiationService.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { DisposableStore, dispose, IDisposable, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor, SyncDescriptor0 } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { GetLeadingNonServiceArgs, IInstantiationService, ServiceIdentifier, ServicesAccessor, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\n// TRACING\nconst _enableAllTracing = false\n\t// || \"TRUE\" // DO NOT CHECK IN!\n\t;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly _globalGraph?: Graph<string>;\n\tprivate _globalGraphImplicitDependency?: string;\n\n\tprivate _isDisposed = false;\n\tprivate readonly _servicesToMaybeDispose = new Set<any>();\n\tprivate readonly _children = new Set<InstantiationService>();\n\n\tconstructor(\n\t\tprivate readonly _services: ServiceCollection = new ServiceCollection(),\n\t\tprivate readonly _strict: boolean = false,\n\t\tprivate readonly _parent?: InstantiationService,\n\t\tprivate readonly _enableTracing: boolean = _enableAllTracing\n\t) {\n\n\t\tthis._services.set(IInstantiationService, this);\n\t\tthis._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n\t}\n\n\tdispose(): void {\n\t\tif (!this._isDisposed) {\n\t\t\tthis._isDisposed = true;\n\t\t\t// dispose all child services\n\t\t\tdispose(this._children);\n\t\t\tthis._children.clear();\n\n\t\t\t// dispose all services created by this service\n\t\t\tfor (const candidate of this._servicesToMaybeDispose) {\n\t\t\t\tif (isDisposable(candidate)) {\n\t\t\t\t\tcandidate.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._servicesToMaybeDispose.clear();\n\t\t}\n\t}\n\n\tprivate _throwIfDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('InstantiationService has been disposed');\n\t\t}\n\t}\n\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService {\n\t\tthis._throwIfDisposed();\n\n\t\tconst that = this;\n\t\tconst result = new class extends InstantiationService {\n\t\t\toverride dispose(): void {\n\t\t\t\tthat._children.delete(result);\n\t\t\t\tsuper.dispose();\n\t\t\t}\n\t\t}(services, this._strict, this, this._enableTracing);\n\t\tthis._children.add(result);\n\n\t\tstore?.add(result);\n\t\treturn result;\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tthis._throwIfDisposed();\n\n\t\tconst _trace = Trace.traceInvocation(this._enableTracing, fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tgetIfExists: <T>(id: ServiceIdentifier<T>) => {\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance<T>(descriptor: SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): unknown {\n\t\tthis._throwIfDisposed();\n\n\t\tlet _trace: Trace;\n\t\tlet result: unknown;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tconst serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tconst serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tconst service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service) {\n\t\t\t\tthis._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tconst firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tconst delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn Reflect.construct<any, T>(ctor, args.concat(serviceArgs));\n\t}\n\n\tprivate _setCreatedServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setCreatedServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tconst instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprotected _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tif (this._globalGraph && this._globalGraphImplicitDependency) {\n\t\t\tthis._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n\t\t}\n\t\tconst thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>; desc: SyncDescriptor<any>; _trace: Trace };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\tconst seen = new Set<string>();\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\n\t\t\tif (seen.has(String(item.id))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(String(item.id));\n\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc) {\n\t\t\t\t\tthis._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n\t\t\t\t}\n\n\t\t\t\t// take note of all service dependencies\n\t\t\t\tthis._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setCreatedServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace, disposeBucket: Set<any>): T {\n\t\tif (!supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\tconst result = this._createInstance<T>(ctor, args, _trace);\n\t\t\tdisposeBucket.add(result);\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tconst child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n\t\t\tchild._globalGraphImplicitDependency = String(id);\n\n\t\t\ttype EaryListenerData = {\n\t\t\t\tlistener: Parameters<Event<any>>;\n\t\t\t\tdisposable?: IDisposable;\n\t\t\t};\n\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\n\t\t\t// return \"empty events\" when the service isn't instantiated yet\n\t\t\tconst earlyListeners = new Map<string, LinkedList<EaryListenerData>>();\n\n\t\t\tconst idle = new GlobalIdleValue<any>(() => {\n\t\t\t\tconst result = child._createInstance<T>(ctor, args, _trace);\n\n\t\t\t\t// early listeners that we kept are now being subscribed to\n\t\t\t\t// the real service\n\t\t\t\tfor (const [key, values] of earlyListeners) {\n\t\t\t\t\tconst candidate = <Event<any>>(<any>result)[key];\n\t\t\t\t\tif (typeof candidate === 'function') {\n\t\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\t\tvalue.disposable = candidate.apply(result, value.listener);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tearlyListeners.clear();\n\t\t\t\tdisposeBucket.add(result);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): unknown {\n\n\t\t\t\t\tif (!idle.isInitialized) {\n\t\t\t\t\t\t// looks like an event\n\t\t\t\t\t\tif (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n\t\t\t\t\t\t\tlet list = earlyListeners.get(key);\n\t\t\t\t\t\t\tif (!list) {\n\t\t\t\t\t\t\t\tlist = new LinkedList();\n\t\t\t\t\t\t\t\tearlyListeners.set(key, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst event: Event<any> = (callback, thisArg, disposables) => {\n\t\t\t\t\t\t\t\tif (idle.isInitialized) {\n\t\t\t\t\t\t\t\t\treturn idle.value[key](callback, thisArg, disposables);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst entry: EaryListenerData = { listener: [callback, thisArg, disposables], disposable: undefined };\n\t\t\t\t\t\t\t\t\tconst rm = list.push(entry);\n\t\t\t\t\t\t\t\t\tconst result = toDisposable(() => {\n\t\t\t\t\t\t\t\t\t\trm();\n\t\t\t\t\t\t\t\t\t\tentry.disposable?.dispose();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn event;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// value already exists\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\n\t\t\t\t\t// create value\n\t\t\t\t\tconst obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetPrototypeOf(_target: T) {\n\t\t\t\t\treturn ctor.prototype;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _throwIfStrict(msg: string, printWarning: boolean): void {\n\t\tif (printWarning) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t\tif (this._strict) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tNone = 0,\n\tCreation = 1,\n\tInvocation = 2,\n\tBranch = 3,\n}\n\nexport class Trace {\n\n\tstatic all = new Set<string>();\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(TraceType.None, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || new Error().stack!.split('\\n').slice(3, 4).join('\\n'));\n\t}\n\n\tstatic traceCreation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tconst child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tconst dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tconst res: string[] = [];\n\t\t\tconst prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tconst nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tconst lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tTrace.all.add(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { DisposableStore, dispose, IDisposable, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor, SyncDescriptor0 } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { GetLeadingNonServiceArgs, IInstantiationService, ServiceIdentifier, ServicesAccessor, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\n// TRACING\nconst _enableAllTracing = false\n\t// || \"TRUE\" // DO NOT CHECK IN!\n\t;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly _globalGraph?: Graph<string>;\n\tprivate _globalGraphImplicitDependency?: string;\n\n\tprivate _isDisposed = false;\n\tprivate readonly _servicesToMaybeDispose = new Set<any>();\n\tprivate readonly _children = new Set<InstantiationService>();\n\n\tconstructor(\n\t\tprivate readonly _services: ServiceCollection = new ServiceCollection(),\n\t\tprivate readonly _strict: boolean = false,\n\t\tprivate readonly _parent?: InstantiationService,\n\t\tprivate readonly _enableTracing: boolean = _enableAllTracing\n\t) {\n\n\t\tthis._services.set(IInstantiationService, this);\n\t\tthis._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n\t}\n\n\tdispose(): void {\n\t\tif (!this._isDisposed) {\n\t\t\tthis._isDisposed = true;\n\t\t\t// dispose all child services\n\t\t\tdispose(this._children);\n\t\t\tthis._children.clear();\n\n\t\t\t// dispose all services created by this service\n\t\t\tfor (const candidate of this._servicesToMaybeDispose) {\n\t\t\t\tif (isDisposable(candidate)) {\n\t\t\t\t\tcandidate.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._servicesToMaybeDispose.clear();\n\t\t}\n\t}\n\n\tprivate _throwIfDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('InstantiationService has been disposed');\n\t\t}\n\t}\n\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService {\n\t\tthis._throwIfDisposed();\n\n\t\tconst that = this;\n\t\tconst result = new class extends InstantiationService {\n\t\t\toverride dispose(): void {\n\t\t\t\tthat._children.delete(result);\n\t\t\t\tsuper.dispose();\n\t\t\t}\n\t\t}(services, this._strict, this, this._enableTracing);\n\t\tthis._children.add(result);\n\n\t\tstore?.add(result);\n\t\treturn result;\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tthis._throwIfDisposed();\n\n\t\tconst _trace = Trace.traceInvocation(this._enableTracing, fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tgetIfExists: <T>(id: ServiceIdentifier<T>) => {\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance<T>(descriptor: SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): unknown {\n\t\tthis._throwIfDisposed();\n\n\t\tlet _trace: Trace;\n\t\tlet result: unknown;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tconst serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tconst serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tconst service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service) {\n\t\t\t\tthis._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tconst firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tconst delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn Reflect.construct<any, T>(ctor, args.concat(serviceArgs));\n\t}\n\n\tprivate _setCreatedServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setCreatedServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tconst instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprotected _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tif (this._globalGraph && this._globalGraphImplicitDependency) {\n\t\t\tthis._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n\t\t}\n\t\tconst thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>; desc: SyncDescriptor<any>; _trace: Trace };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\tconst seen = new Set<string>();\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\n\t\t\tif (seen.has(String(item.id))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(String(item.id));\n\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc) {\n\t\t\t\t\tthis._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n\t\t\t\t}\n\n\t\t\t\t// take note of all service dependencies\n\t\t\t\tthis._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setCreatedServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace, disposeBucket: Set<any>): T {\n\t\tif (!supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\tconst result = this._createInstance<T>(ctor, args, _trace);\n\t\t\tdisposeBucket.add(result);\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tconst child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n\t\t\tchild._globalGraphImplicitDependency = String(id);\n\n\t\t\ttype EaryListenerData = {\n\t\t\t\tlistener: Parameters<Event<any>>;\n\t\t\t\tdisposable?: IDisposable;\n\t\t\t};\n\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\n\t\t\t// return \"empty events\" when the service isn't instantiated yet\n\t\t\tconst earlyListeners = new Map<string, LinkedList<EaryListenerData>>();\n\n\t\t\tconst idle = new GlobalIdleValue<any>(() => {\n\t\t\t\tconst result = child._createInstance<T>(ctor, args, _trace);\n\n\t\t\t\t// early listeners that we kept are now being subscribed to\n\t\t\t\t// the real service\n\t\t\t\tfor (const [key, values] of earlyListeners) {\n\t\t\t\t\tconst candidate = <Event<any>>(<any>result)[key];\n\t\t\t\t\tif (typeof candidate === 'function') {\n\t\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\t\tvalue.disposable = candidate.apply(result, value.listener);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tearlyListeners.clear();\n\t\t\t\tdisposeBucket.add(result);\n\t\t\t\treturn result;\n\t\t\t});\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): unknown {\n\n\t\t\t\t\tif (!idle.isInitialized) {\n\t\t\t\t\t\t// looks like an event\n\t\t\t\t\t\tif (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n\t\t\t\t\t\t\tlet list = earlyListeners.get(key);\n\t\t\t\t\t\t\tif (!list) {\n\t\t\t\t\t\t\t\tlist = new LinkedList();\n\t\t\t\t\t\t\t\tearlyListeners.set(key, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst event: Event<any> = (callback, thisArg, disposables) => {\n\t\t\t\t\t\t\t\tif (idle.isInitialized) {\n\t\t\t\t\t\t\t\t\treturn idle.value[key](callback, thisArg, disposables);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst entry: EaryListenerData = { listener: [callback, thisArg, disposables], disposable: undefined };\n\t\t\t\t\t\t\t\t\tconst rm = list.push(entry);\n\t\t\t\t\t\t\t\t\tconst result = toDisposable(() => {\n\t\t\t\t\t\t\t\t\t\trm();\n\t\t\t\t\t\t\t\t\t\tentry.disposable?.dispose();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn event;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// value already exists\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\n\t\t\t\t\t// create value\n\t\t\t\t\tconst obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetPrototypeOf(_target: T) {\n\t\t\t\t\treturn ctor.prototype;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _throwIfStrict(msg: string, printWarning: boolean): void {\n\t\tif (printWarning) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t\tif (this._strict) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tNone = 0,\n\tCreation = 1,\n\tInvocation = 2,\n\tBranch = 3,\n}\n\nexport class Trace {\n\n\tstatic all = new Set<string>();\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(TraceType.None, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || new Error().stack!.split('\\n').slice(3, 4).join('\\n'));\n\t}\n\n\tstatic traceCreation(_enableTracing: boolean, ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tconst child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tconst dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tconst res: string[] = [];\n\t\t\tconst prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tconst nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tconst lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tTrace.all.add(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n"]}