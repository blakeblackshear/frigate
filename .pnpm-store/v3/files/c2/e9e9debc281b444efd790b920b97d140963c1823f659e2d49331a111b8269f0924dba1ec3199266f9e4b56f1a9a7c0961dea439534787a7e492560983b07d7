{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer.js';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer.js';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n"]}