{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/runOnChange.ts","vs/base/common/observableInternal/utils/runOnChange.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAqB,eAAe,EAAE,MAAM,iCAAiC,CAAC;AACrF,OAAO,EAAE,eAAe,EAAe,MAAM,yBAAyB,CAAC;AACvE,OAAO,EAAE,6BAA6B,EAAE,MAAM,yBAAyB,CAAC;AAIxE,MAAM,UAAU,WAAW,CAAa,UAA6C,EAAE,EAA4E;IAClK,IAAI,cAA6B,CAAC;IAClC,IAAI,SAAS,GAAG,IAAI,CAAC;IACrB,OAAO,6BAA6B,CAAC;QACpC,aAAa,EAAE;YACd,mBAAmB,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,MAAM,EAAE,EAAgC,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;YAC3F,YAAY,EAAE,CAAC,OAAO,EAAE,aAAa,EAAE,EAAE;gBACxC,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;oBACnC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;oBACzB,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;wBACrB,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAA6B,CAAC,CAAC;oBAC1D,CAAC;oBACD,aAAa,CAAC,SAAS,GAAG,IAAI,CAAC;gBAChC,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;SACD;KACD,EAAE,CAAC,MAAM,EAAE,aAAa,EAAE,EAAE;QAC5B,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtC,MAAM,aAAa,GAAG,cAAc,CAAC;QACrC,IAAI,aAAa,CAAC,SAAS,EAAE,CAAC;YAC7B,cAAc,GAAG,KAAK,CAAC;YACvB,wFAAwF;YACxF,EAAE,CAAC,KAAK,EAAE,aAAc,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;QACjD,CAAC;QACD,IAAI,SAAS,EAAE,CAAC;YACf,SAAS,GAAG,KAAK,CAAC;YAClB,cAAc,GAAG,KAAK,CAAC;QACxB,CAAC;IACF,CAAC,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAa,UAA6C,EAAE,EAAoG;IACnM,MAAM,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;IACpC,MAAM,UAAU,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,aAAgB,EAAE,MAAM,EAAE,EAAE;QAC9E,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;IACH,OAAO;QACN,OAAO;YACN,UAAU,CAAC,OAAO,EAAE,CAAC;YACrB,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;KACD,CAAC;AACH,CAAC;AAED,MAAM,UAAU,gCAAgC,CAAa,UAA6C,EAAE,EAA+G;IAC1N,OAAO,oBAAoB,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE;QAC/E,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;AACJ,CAAC","file":"runOnChange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange } from '../base.js';\nimport { CancellationToken, cancelOnDispose } from '../commonFacade/cancellation.js';\nimport { DisposableStore, IDisposable } from '../commonFacade/deps.js';\nimport { autorunWithStoreHandleChanges } from '../reactions/autorun.js';\n\nexport type RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\tlet _firstRun = true;\n\treturn autorunWithStoreHandleChanges({\n\t\tchangeTracker: {\n\t\t\tcreateChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\t\thandleChange: (context, changeSummary) => {\n\t\t\t\tif (context.didChange(observable)) {\n\t\t\t\t\tconst e = context.change;\n\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t\t}\n\t\t\t\t\tchangeSummary.didChange = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t}\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\t// didChange can never be true on the first autorun, so we know previousValue is defined\n\t\t\tcb(value, previousValue!, changeSummary.deltas);\n\t\t}\n\t\tif (_firstRun) {\n\t\t\t_firstRun = false;\n\t\t\t_previousValue = value;\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n\nexport function runOnChangeWithCancellationToken<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], token: CancellationToken) => Promise<void>): IDisposable {\n\treturn runOnChangeWithStore(observable, (value, previousValue, deltas, store) => {\n\t\tcb(value, previousValue, deltas, cancelOnDispose(store));\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange } from '../base.js';\nimport { CancellationToken, cancelOnDispose } from '../commonFacade/cancellation.js';\nimport { DisposableStore, IDisposable } from '../commonFacade/deps.js';\nimport { autorunWithStoreHandleChanges } from '../reactions/autorun.js';\n\nexport type RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\tlet _firstRun = true;\n\treturn autorunWithStoreHandleChanges({\n\t\tchangeTracker: {\n\t\t\tcreateChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\t\thandleChange: (context, changeSummary) => {\n\t\t\t\tif (context.didChange(observable)) {\n\t\t\t\t\tconst e = context.change;\n\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t\t}\n\t\t\t\t\tchangeSummary.didChange = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t}\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\t// didChange can never be true on the first autorun, so we know previousValue is defined\n\t\t\tcb(value, previousValue!, changeSummary.deltas);\n\t\t}\n\t\tif (_firstRun) {\n\t\t\t_firstRun = false;\n\t\t\t_previousValue = value;\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n\nexport function runOnChangeWithCancellationToken<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], token: CancellationToken) => Promise<void>): IDisposable {\n\treturn runOnChangeWithStore(observable, (value, previousValue, deltas, store) => {\n\t\tcb(value, previousValue, deltas, cancelOnDispose(store));\n\t});\n}\n"]}