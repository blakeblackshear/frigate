{"version":3,"file":"index.production.js","sources":["../../../autocomplete-shared/dist/esm/debounce.js","../../../autocomplete-shared/dist/esm/flatten.js","../../../autocomplete-shared/dist/esm/generateAutocompleteId.js","../../../autocomplete-shared/dist/esm/getItemsCount.js","../../../autocomplete-shared/dist/esm/isEqual.js","../../../autocomplete-shared/dist/esm/noop.js","../../../autocomplete-shared/dist/esm/version.js","../../../autocomplete-shared/dist/esm/userAgents.js","../../../autocomplete-plugin-algolia-insights/dist/esm/createClickedEvent.js","../../../autocomplete-plugin-algolia-insights/dist/esm/isModernInsightsClient.js","../../../autocomplete-plugin-algolia-insights/dist/esm/createSearchInsightsApi.js","../../../autocomplete-plugin-algolia-insights/dist/esm/createViewedEvents.js","../../../autocomplete-plugin-algolia-insights/dist/esm/isAlgoliaInsightsHit.js","../../../autocomplete-plugin-algolia-insights/dist/esm/createAlgoliaInsightsPlugin.js","../../../autocomplete-shared/dist/esm/safelyRunOnBrowser.js","../../../autocomplete-shared/dist/esm/createRef.js","../../src/utils/createCancelablePromise.ts","../../src/utils/createCancelablePromiseList.ts","../../src/utils/getNextActiveItemId.ts","../../src/utils/getPluginSubmitPromise.ts","../../src/utils/getActiveItem.ts","../../src/utils/getAutocompleteElementId.ts","../../src/utils/isSamsung.ts","../../src/utils/getNativeEvent.ts","../../src/getDefaultProps.ts","../../src/utils/getNormalizedSources.ts","../../src/resolve.ts","../../src/utils/mapToAlgoliaResponse.ts","../../src/utils/createConcurrentSafePromise.ts","../../src/onInput.ts","../../src/reshape.ts","../../src/getPropGetters.ts","../../src/utils/isOrContainsNode.ts","../../src/onKeyDown.ts","../../src/metadata.ts","../../src/getCompletion.ts","../../src/stateReducer.ts","../../src/createAutocomplete.ts","../../src/createStore.ts","../../src/getAutocompleteSetters.ts"],"sourcesContent":["export function debounce(fn, time) {\n  var timerId = undefined;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(function () {\n      return fn.apply(void 0, args);\n    }, time);\n  };\n}","export function flatten(values) {\n  return values.reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n}","var autocompleteId = 0;\nexport function generateAutocompleteId() {\n  return \"autocomplete-\".concat(autocompleteId++);\n}","export function getItemsCount(state) {\n  if (state.collections.length === 0) {\n    return 0;\n  }\n  return state.collections.reduce(function (sum, collection) {\n    return sum + collection.items.length;\n  }, 0);\n}","function isPrimitive(obj) {\n  return obj !== Object(obj);\n}\nexport function isEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n  if (isPrimitive(first) || isPrimitive(second) || typeof first === 'function' || typeof second === 'function') {\n    return first === second;\n  }\n  if (Object.keys(first).length !== Object.keys(second).length) {\n    return false;\n  }\n  for (var _i = 0, _Object$keys = Object.keys(first); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    if (!(key in second)) {\n      return false;\n    }\n    if (!isEqual(first[key], second[key])) {\n      return false;\n    }\n  }\n  return true;\n}","export var noop = function noop() {};","export var version = '1.19.2';","import { version } from './version';\nexport var userAgents = [{\n  segment: 'autocomplete-core',\n  version: version\n}];","export function createClickedEvent(_ref) {\n  var item = _ref.item,\n    _ref$items = _ref.items,\n    items = _ref$items === void 0 ? [] : _ref$items;\n  return {\n    index: item.__autocomplete_indexName,\n    items: [item],\n    positions: [1 + items.findIndex(function (x) {\n      return x.objectID === item.objectID;\n    })],\n    queryID: item.__autocomplete_queryID,\n    algoliaSource: ['autocomplete']\n  };\n}","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * Determines if a given insights `client` supports the optional call to `init`\n * and the ability to set credentials via extra parameters when sending events.\n */\nexport function isModernInsightsClient(client) {\n  var _split$map = (client.version || '').split('.').map(Number),\n    _split$map2 = _slicedToArray(_split$map, 2),\n    major = _split$map2[0],\n    minor = _split$map2[1];\n\n  /* eslint-disable @typescript-eslint/camelcase */\n  var v3 = major >= 3;\n  var v2_4 = major === 2 && minor >= 4;\n  var v1_10 = major === 1 && minor >= 10;\n  return v3 || v2_4 || v1_10;\n  /* eslint-enable @typescript-eslint/camelcase */\n}","var _excluded = [\"items\"],\n  _excluded2 = [\"items\"];\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isModernInsightsClient } from './isModernInsightsClient';\nfunction chunk(item) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n  var chunks = [];\n  for (var i = 0; i < item.objectIDs.length; i += chunkSize) {\n    chunks.push(_objectSpread(_objectSpread({}, item), {}, {\n      objectIDs: item.objectIDs.slice(i, i + chunkSize)\n    }));\n  }\n  return chunks;\n}\nfunction mapToInsightsParamsApi(params) {\n  return params.map(function (_ref) {\n    var items = _ref.items,\n      param = _objectWithoutProperties(_ref, _excluded);\n    return _objectSpread(_objectSpread({}, param), {}, {\n      objectIDs: (items === null || items === void 0 ? void 0 : items.map(function (_ref2) {\n        var objectID = _ref2.objectID;\n        return objectID;\n      })) || param.objectIDs\n    });\n  });\n}\nexport function createSearchInsightsApi(searchInsights) {\n  var canSendHeaders = isModernInsightsClient(searchInsights);\n  function sendToInsights(method, payloads, items) {\n    if (canSendHeaders && typeof items !== 'undefined') {\n      var _items$0$__autocomple = items[0].__autocomplete_algoliaCredentials,\n        appId = _items$0$__autocomple.appId,\n        apiKey = _items$0$__autocomple.apiKey;\n      var headers = {\n        'X-Algolia-Application-Id': appId,\n        'X-Algolia-API-Key': apiKey\n      };\n      searchInsights.apply(void 0, [method].concat(_toConsumableArray(payloads), [{\n        headers: headers\n      }]));\n    } else {\n      searchInsights.apply(void 0, [method].concat(_toConsumableArray(payloads)));\n    }\n  }\n  return {\n    /**\n     * Initializes Insights with Algolia credentials.\n     */\n    init: function init(appId, apiKey) {\n      searchInsights('init', {\n        appId: appId,\n        apiKey: apiKey\n      });\n    },\n    /**\n     * Sets the authenticated user token to attach to events.\n     * Unsets the authenticated token by passing `undefined`.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/set-authenticated-user-token/\n     */\n    setAuthenticatedUserToken: function setAuthenticatedUserToken(authenticatedUserToken) {\n      searchInsights('setAuthenticatedUserToken', authenticatedUserToken);\n    },\n    /**\n     * Sets the user token to attach to events.\n     */\n    setUserToken: function setUserToken(userToken) {\n      searchInsights('setUserToken', userToken);\n    },\n    /**\n     * Sends click events to capture a query and its clicked items and positions.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-object-ids-after-search/\n     */\n    clickedObjectIDsAfterSearch: function clickedObjectIDsAfterSearch() {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      if (params.length > 0) {\n        sendToInsights('clickedObjectIDsAfterSearch', mapToInsightsParamsApi(params), params[0].items);\n      }\n    },\n    /**\n     * Sends click events to capture clicked items.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-object-ids/\n     */\n    clickedObjectIDs: function clickedObjectIDs() {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      if (params.length > 0) {\n        sendToInsights('clickedObjectIDs', mapToInsightsParamsApi(params), params[0].items);\n      }\n    },\n    /**\n     * Sends click events to capture the filters a user clicks on.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-filters/\n     */\n    clickedFilters: function clickedFilters() {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      if (params.length > 0) {\n        searchInsights.apply(void 0, ['clickedFilters'].concat(params));\n      }\n    },\n    /**\n     * Sends conversion events to capture a query and its clicked items.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-object-ids-after-search/\n     */\n    convertedObjectIDsAfterSearch: function convertedObjectIDsAfterSearch() {\n      for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        params[_key4] = arguments[_key4];\n      }\n      if (params.length > 0) {\n        sendToInsights('convertedObjectIDsAfterSearch', mapToInsightsParamsApi(params), params[0].items);\n      }\n    },\n    /**\n     * Sends conversion events to capture clicked items.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-object-ids/\n     */\n    convertedObjectIDs: function convertedObjectIDs() {\n      for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        params[_key5] = arguments[_key5];\n      }\n      if (params.length > 0) {\n        sendToInsights('convertedObjectIDs', mapToInsightsParamsApi(params), params[0].items);\n      }\n    },\n    /**\n     * Sends conversion events to capture the filters a user uses when converting.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-filters/\n     */\n    convertedFilters: function convertedFilters() {\n      for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        params[_key6] = arguments[_key6];\n      }\n      if (params.length > 0) {\n        searchInsights.apply(void 0, ['convertedFilters'].concat(params));\n      }\n    },\n    /**\n     * Sends view events to capture clicked items.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/viewed-object-ids/\n     */\n    viewedObjectIDs: function viewedObjectIDs() {\n      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        params[_key7] = arguments[_key7];\n      }\n      if (params.length > 0) {\n        params.reduce(function (acc, _ref3) {\n          var items = _ref3.items,\n            param = _objectWithoutProperties(_ref3, _excluded2);\n          return [].concat(_toConsumableArray(acc), _toConsumableArray(chunk(_objectSpread(_objectSpread({}, param), {}, {\n            objectIDs: (items === null || items === void 0 ? void 0 : items.map(function (_ref4) {\n              var objectID = _ref4.objectID;\n              return objectID;\n            })) || param.objectIDs\n          })).map(function (payload) {\n            return {\n              items: items,\n              payload: payload\n            };\n          })));\n        }, []).forEach(function (_ref5) {\n          var items = _ref5.items,\n            payload = _ref5.payload;\n          return sendToInsights('viewedObjectIDs', [payload], items);\n        });\n      }\n    },\n    /**\n     * Sends view events to capture the filters a user uses when viewing.\n     *\n     * @link https://www.algolia.com/doc/api-reference/api-methods/viewed-filters/\n     */\n    viewedFilters: function viewedFilters() {\n      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        params[_key8] = arguments[_key8];\n      }\n      if (params.length > 0) {\n        searchInsights.apply(void 0, ['viewedFilters'].concat(params));\n      }\n    }\n  };\n}","export function createViewedEvents(_ref) {\n  var items = _ref.items;\n  var itemsByIndexName = items.reduce(function (acc, current) {\n    var _acc$current$__autoco;\n    acc[current.__autocomplete_indexName] = ((_acc$current$__autoco = acc[current.__autocomplete_indexName]) !== null && _acc$current$__autoco !== void 0 ? _acc$current$__autoco : []).concat(current);\n    return acc;\n  }, {});\n  return Object.keys(itemsByIndexName).map(function (indexName) {\n    var items = itemsByIndexName[indexName];\n    return {\n      index: indexName,\n      items: items,\n      algoliaSource: ['autocomplete']\n    };\n  });\n}","export function isAlgoliaInsightsHit(hit) {\n  return hit.objectID && hit.__autocomplete_indexName && hit.__autocomplete_queryID;\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { createRef, debounce, isEqual, noop, safelyRunOnBrowser } from '@algolia/autocomplete-shared';\nimport { createClickedEvent } from './createClickedEvent';\nimport { createSearchInsightsApi } from './createSearchInsightsApi';\nimport { createViewedEvents } from './createViewedEvents';\nimport { isAlgoliaInsightsHit } from './isAlgoliaInsightsHit';\nvar VIEW_EVENT_DELAY = 400;\nvar ALGOLIA_INSIGHTS_VERSION = '2.15.0';\nvar ALGOLIA_INSIGHTS_SRC = \"https://cdn.jsdelivr.net/npm/search-insights@\".concat(ALGOLIA_INSIGHTS_VERSION, \"/dist/search-insights.min.js\");\nvar sendViewedObjectIDs = debounce(function (_ref) {\n  var onItemsChange = _ref.onItemsChange,\n    items = _ref.items,\n    insights = _ref.insights,\n    state = _ref.state;\n  onItemsChange({\n    insights: insights,\n    insightsEvents: createViewedEvents({\n      items: items\n    }).map(function (event) {\n      return _objectSpread({\n        eventName: 'Items Viewed'\n      }, event);\n    }),\n    state: state\n  });\n}, VIEW_EVENT_DELAY);\nexport function createAlgoliaInsightsPlugin(options) {\n  var _getOptions = getOptions(options),\n    providedInsightsClient = _getOptions.insightsClient,\n    insightsInitParams = _getOptions.insightsInitParams,\n    onItemsChange = _getOptions.onItemsChange,\n    onSelectEvent = _getOptions.onSelect,\n    onActiveEvent = _getOptions.onActive,\n    __autocomplete_clickAnalytics = _getOptions.__autocomplete_clickAnalytics;\n  var insightsClient = providedInsightsClient;\n  if (!providedInsightsClient) {\n    safelyRunOnBrowser(function (_ref2) {\n      var window = _ref2.window;\n      var pointer = window.AlgoliaAnalyticsObject || 'aa';\n      if (typeof pointer === 'string') {\n        insightsClient = window[pointer];\n      }\n      if (!insightsClient) {\n        window.AlgoliaAnalyticsObject = pointer;\n        if (!window[pointer]) {\n          window[pointer] = function () {\n            if (!window[pointer].queue) {\n              window[pointer].queue = [];\n            }\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            window[pointer].queue.push(args);\n          };\n        }\n        window[pointer].version = ALGOLIA_INSIGHTS_VERSION;\n        insightsClient = window[pointer];\n        loadInsights(window);\n      }\n    });\n  }\n\n  // We return an empty plugin if `insightsClient` is still undefined at\n  // this stage, which can happen in server environments.\n  if (!insightsClient) {\n    return {};\n  }\n  if (insightsInitParams) {\n    insightsClient('init', _objectSpread({\n      partial: true\n    }, insightsInitParams));\n  }\n  var insights = createSearchInsightsApi(insightsClient);\n  var previousItems = createRef([]);\n  var debouncedOnStateChange = debounce(function (_ref3) {\n    var state = _ref3.state;\n    if (!state.isOpen) {\n      return;\n    }\n    var items = state.collections.reduce(function (acc, current) {\n      return [].concat(_toConsumableArray(acc), _toConsumableArray(current.items));\n    }, []).filter(isAlgoliaInsightsHit);\n    if (!isEqual(previousItems.current.map(function (x) {\n      return x.objectID;\n    }), items.map(function (x) {\n      return x.objectID;\n    }))) {\n      previousItems.current = items;\n      if (items.length > 0) {\n        sendViewedObjectIDs({\n          onItemsChange: onItemsChange,\n          items: items,\n          insights: insights,\n          state: state\n        });\n      }\n    }\n  }, 0);\n  return {\n    name: 'aa.algoliaInsightsPlugin',\n    subscribe: function subscribe(_ref4) {\n      var setContext = _ref4.setContext,\n        onSelect = _ref4.onSelect,\n        onActive = _ref4.onActive;\n      function setInsightsContext(userToken) {\n        setContext({\n          algoliaInsightsPlugin: {\n            __algoliaSearchParameters: _objectSpread(_objectSpread({}, __autocomplete_clickAnalytics ? {\n              clickAnalytics: true\n            } : {}), userToken ? {\n              userToken: normalizeUserToken(userToken)\n            } : {}),\n            insights: insights\n          }\n        });\n      }\n      insightsClient('addAlgoliaAgent', 'insights-plugin');\n      setInsightsContext();\n\n      // Handles user token changes\n      insightsClient('onUserTokenChange', function (userToken) {\n        setInsightsContext(userToken);\n      });\n      insightsClient('getUserToken', null, function (_error, userToken) {\n        setInsightsContext(userToken);\n      });\n      onSelect(function (_ref5) {\n        var item = _ref5.item,\n          state = _ref5.state,\n          event = _ref5.event,\n          source = _ref5.source;\n        if (!isAlgoliaInsightsHit(item)) {\n          return;\n        }\n        onSelectEvent({\n          state: state,\n          event: event,\n          insights: insights,\n          item: item,\n          insightsEvents: [_objectSpread({\n            eventName: 'Item Selected'\n          }, createClickedEvent({\n            item: item,\n            items: source.getItems().filter(isAlgoliaInsightsHit)\n          }))]\n        });\n      });\n      onActive(function (_ref6) {\n        var item = _ref6.item,\n          source = _ref6.source,\n          state = _ref6.state,\n          event = _ref6.event;\n        if (!isAlgoliaInsightsHit(item)) {\n          return;\n        }\n        onActiveEvent({\n          state: state,\n          event: event,\n          insights: insights,\n          item: item,\n          insightsEvents: [_objectSpread({\n            eventName: 'Item Active'\n          }, createClickedEvent({\n            item: item,\n            items: source.getItems().filter(isAlgoliaInsightsHit)\n          }))]\n        });\n      });\n    },\n    onStateChange: function onStateChange(_ref7) {\n      var state = _ref7.state;\n      debouncedOnStateChange({\n        state: state\n      });\n    },\n    __autocomplete_pluginOptions: options\n  };\n}\nfunction getAlgoliaSources() {\n  var _context$algoliaInsig;\n  var algoliaSourceBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var context = arguments.length > 1 ? arguments[1] : undefined;\n  return [].concat(_toConsumableArray(algoliaSourceBase), ['autocomplete-internal'], _toConsumableArray((_context$algoliaInsig = context.algoliaInsightsPlugin) !== null && _context$algoliaInsig !== void 0 && _context$algoliaInsig.__automaticInsights ? ['autocomplete-automatic'] : []));\n}\nfunction getOptions(options) {\n  return _objectSpread({\n    onItemsChange: function onItemsChange(_ref8) {\n      var insights = _ref8.insights,\n        insightsEvents = _ref8.insightsEvents,\n        state = _ref8.state;\n      insights.viewedObjectIDs.apply(insights, _toConsumableArray(insightsEvents.map(function (event) {\n        return _objectSpread(_objectSpread({}, event), {}, {\n          algoliaSource: getAlgoliaSources(event.algoliaSource, state.context)\n        });\n      })));\n    },\n    onSelect: function onSelect(_ref9) {\n      var insights = _ref9.insights,\n        insightsEvents = _ref9.insightsEvents,\n        state = _ref9.state;\n      insights.clickedObjectIDsAfterSearch.apply(insights, _toConsumableArray(insightsEvents.map(function (event) {\n        return _objectSpread(_objectSpread({}, event), {}, {\n          algoliaSource: getAlgoliaSources(event.algoliaSource, state.context)\n        });\n      })));\n    },\n    onActive: noop,\n    __autocomplete_clickAnalytics: true\n  }, options);\n}\nfunction loadInsights(environment) {\n  var errorMessage = \"[Autocomplete]: Could not load search-insights.js. Please load it manually following https://alg.li/insights-autocomplete\";\n  try {\n    var script = environment.document.createElement('script');\n    script.async = true;\n    script.src = ALGOLIA_INSIGHTS_SRC;\n    script.onerror = function () {\n      // eslint-disable-next-line no-console\n      console.error(errorMessage);\n    };\n    document.body.appendChild(script);\n  } catch (cause) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage);\n  }\n}\n\n/**\n * While `search-insights` supports both string and number user tokens,\n * the Search API only accepts strings. This function normalizes the user token.\n */\nfunction normalizeUserToken(userToken) {\n  return typeof userToken === 'number' ? userToken.toString() : userToken;\n}","/**\n * Safely runs code meant for browser environments only.\n */\nexport function safelyRunOnBrowser(callback) {\n  if (typeof window !== 'undefined') {\n    return callback({\n      window: window\n    });\n  }\n  return undefined;\n}","export function createRef(initialValue) {\n  return {\n    current: initialValue\n  };\n}","type PromiseExecutor<TValue> = (\n  resolve: (value: TValue | PromiseLike<TValue>) => void,\n  reject: (reason?: any) => void\n) => void;\n\ntype CancelablePromiseState = {\n  isCanceled: boolean;\n  onCancelList: Array<(...args: any[]) => any>;\n};\n\nfunction createInternalCancelablePromise<TValue>(\n  promise: Promise<TValue>,\n  initialState: CancelablePromiseState\n): CancelablePromise<TValue> {\n  const state = initialState;\n\n  return {\n    then(onfulfilled, onrejected) {\n      return createInternalCancelablePromise(\n        promise.then(\n          createCallback(onfulfilled, state, promise),\n          createCallback(onrejected, state, promise)\n        ),\n        state\n      );\n    },\n    catch(onrejected) {\n      return createInternalCancelablePromise(\n        promise.catch(createCallback(onrejected, state, promise)),\n        state\n      );\n    },\n    finally(onfinally) {\n      if (onfinally) {\n        state.onCancelList.push(onfinally);\n      }\n\n      return createInternalCancelablePromise<TValue>(\n        promise.finally(\n          createCallback(\n            onfinally &&\n              (() => {\n                state.onCancelList = [];\n\n                return onfinally();\n              }),\n            state,\n            promise\n          )\n        ),\n        state\n      );\n    },\n    cancel() {\n      state.isCanceled = true;\n      const callbacks = state.onCancelList;\n      state.onCancelList = [];\n\n      callbacks.forEach((callback) => {\n        callback();\n      });\n    },\n    isCanceled() {\n      return state.isCanceled === true;\n    },\n  };\n}\n\nexport type CancelablePromise<TValue> = {\n  then<TResultFulfilled = TValue, TResultRejected = never>(\n    onfulfilled?:\n      | ((\n          value: TValue\n        ) =>\n          | TResultFulfilled\n          | PromiseLike<TResultFulfilled>\n          | CancelablePromise<TResultFulfilled>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((\n          reason: any\n        ) =>\n          | TResultRejected\n          | PromiseLike<TResultRejected>\n          | CancelablePromise<TResultRejected>)\n      | undefined\n      | null\n  ): CancelablePromise<TResultFulfilled | TResultRejected>;\n  catch<TResult = never>(\n    onrejected?:\n      | ((\n          reason: any\n        ) => TResult | PromiseLike<TResult> | CancelablePromise<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<TValue | TResult>;\n  finally(\n    onfinally?: (() => void) | undefined | null\n  ): CancelablePromise<TValue>;\n  cancel(): void;\n  isCanceled(): boolean;\n};\n\nexport function createCancelablePromise<TValue>(\n  executor: PromiseExecutor<TValue>\n): CancelablePromise<TValue> {\n  return createInternalCancelablePromise(\n    new Promise<TValue>((resolve, reject) => {\n      return executor(resolve, reject);\n    }),\n    { isCanceled: false, onCancelList: [] }\n  );\n}\n\ncreateCancelablePromise.resolve = <TValue>(\n  value?: TValue | PromiseLike<TValue> | CancelablePromise<TValue>\n) => cancelable(Promise.resolve(value));\n\ncreateCancelablePromise.reject = (reason?: any) =>\n  cancelable(Promise.reject(reason));\n\nexport function cancelable<TValue>(promise: Promise<TValue>) {\n  return createInternalCancelablePromise(promise, {\n    isCanceled: false,\n    onCancelList: [],\n  });\n}\n\nfunction createCallback(\n  onResult: ((...args: any[]) => any) | null | undefined,\n  state: CancelablePromiseState,\n  fallback: any\n) {\n  if (!onResult) {\n    return fallback;\n  }\n\n  return function callback(arg?: any) {\n    if (state.isCanceled) {\n      return arg;\n    }\n\n    return onResult(arg);\n  };\n}\n","import { CancelablePromise } from '.';\n\nexport type CancelablePromiseList<TValue> = {\n  /**\n   * Add a cancelable promise to the list.\n   *\n   * @param cancelablePromise The cancelable promise to add.\n   */\n  add(cancelablePromise: CancelablePromise<TValue>): CancelablePromise<TValue>;\n  /**\n   * Cancel all pending promises.\n   *\n   * Requests aren't actually stopped. All pending promises will settle, but\n   * attached handlers won't run.\n   */\n  cancelAll(): void;\n  /**\n   * Whether there are pending promises in the list.\n   */\n  isEmpty(): boolean;\n  /**\n   * Waits for all pending promises to be resolved.\n   *\n   * @param timeout Maximum amount of time allowed to wait for pending promises. Returns early if this time is reached.\n   */\n  wait(timeout?: number): Promise<void>;\n};\n\n// Ensures multiple callers sync to the same promise.\nlet _hasWaitPromiseResolved = true;\nlet _waitPromise: Promise<any>;\n\nexport function createCancelablePromiseList<\n  TValue\n>(): CancelablePromiseList<TValue> {\n  let list: Array<CancelablePromise<TValue>> = [];\n\n  return {\n    add(cancelablePromise) {\n      list.push(cancelablePromise);\n\n      return cancelablePromise.finally(() => {\n        list = list.filter((item) => item !== cancelablePromise);\n      });\n    },\n    cancelAll() {\n      list.forEach((promise) => promise.cancel());\n    },\n    isEmpty() {\n      return list.length === 0;\n    },\n    wait(timeout) {\n      // Reuse promise if already exists. Keeps multiple callers subscribed to the same promise.\n      if (!_hasWaitPromiseResolved) {\n        return _waitPromise;\n      }\n\n      // Creates a promise which either resolves after all pending requests complete\n      // or the timeout is reached (if provided). Whichever comes first.\n      _hasWaitPromiseResolved = false;\n      _waitPromise = !timeout\n        ? Promise.all(list)\n        : Promise.race([\n            Promise.all(list),\n            new Promise<void>((resolve) => setTimeout(resolve, timeout)),\n          ]);\n\n      return _waitPromise.then(() => {\n        _hasWaitPromiseResolved = true;\n      });\n    },\n  };\n}\n","/**\n * Returns the next active item ID from the current state.\n *\n * We allow circular keyboard navigation from the base index.\n * The base index can either be `null` (nothing is highlighted) or `0`\n * (the first item is highlighted).\n * The base index is allowed to get assigned `null` only if\n * `props.defaultActiveItemId` is `null`. This pattern allows to \"stop\"\n * by the actual query before navigating to other suggestions as seen on\n * Google or Amazon.\n *\n * @param moveAmount The offset to increment (or decrement) the last index\n * @param baseIndex The current index to compute the next index from\n * @param itemCount The number of items\n * @param defaultActiveItemId The default active index to fallback to\n */\nexport function getNextActiveItemId(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultActiveItemId: number | null\n): number | null {\n  if (!itemCount) {\n    return null;\n  }\n\n  if (\n    moveAmount < 0 &&\n    (baseIndex === null || (defaultActiveItemId !== null && baseIndex === 0))\n  ) {\n    return itemCount + moveAmount;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultActiveItemId === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n","import type { InternalAutocompleteOptions } from '../types';\n\nimport { CancelablePromiseList } from './createCancelablePromiseList';\n\n/**\n * If a plugin is configured to await a submit event, this returns a promise\n * for either the max timeout value found or until it completes.\n * Otherwise, return undefined.\n */\nexport const getPluginSubmitPromise = (\n  plugins: InternalAutocompleteOptions<any>['plugins'],\n  pendingRequests: CancelablePromiseList<void>\n): Promise<void> | undefined => {\n  let waitUntilComplete = false;\n  const timeouts: number[] = [];\n\n  for (const plugin of plugins) {\n    const value: boolean | number | undefined =\n      plugin.__autocomplete_pluginOptions?.awaitSubmit?.();\n    if (typeof value === 'number') {\n      timeouts.push(value);\n    } else if (value === true) {\n      waitUntilComplete = true;\n      break; // break loop as bool overrides num array below\n    }\n  }\n\n  if (waitUntilComplete) {\n    return pendingRequests.wait();\n  } else if (timeouts.length > 0) {\n    return pendingRequests.wait(Math.max(...timeouts));\n  }\n\n  return undefined;\n};\n","import { AutocompleteCollection, AutocompleteState, BaseItem } from '../types';\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n): AutocompleteCollection<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedCollectionsCount = state.collections\n    .map((collections) => collections.items.length)\n    .reduce<number[]>((acc, collectionsCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + collectionsCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const collectionIndex = accumulatedCollectionsCount.reduce((acc, current) => {\n    if (current <= state.activeItemId!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      ↑\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeActiveItemId<TItem extends BaseItem>({\n  state,\n  collection,\n}: {\n  state: AutocompleteState<TItem>;\n  collection: AutocompleteCollection<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n\n    counter++;\n  }\n\n  return state.activeItemId! - previousItemsOffset;\n}\n\nexport function getActiveItem<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n) {\n  const collection = getCollectionFromActiveItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  const item = collection.items[getRelativeActiveItemId({ state, collection })];\n  const source = collection.source;\n  const itemInputValue = source.getItemInputValue({ item, state });\n  const itemUrl = source.getItemUrl({ item, state });\n\n  return {\n    item,\n    itemInputValue,\n    itemUrl,\n    source,\n  };\n}\n","import type { InternalAutocompleteSource } from '../types';\n\n/**\n * Returns a full element id for an autocomplete element.\n *\n * @param autocompleteInstanceId The id of the autocomplete instance\n * @param elementId The specific element id\n * @param source The source of the element, when it needs to be scoped\n */\nexport function getAutocompleteElementId(\n  autocompleteInstanceId: string,\n  elementId: string,\n  source?: InternalAutocompleteSource<any>\n) {\n  return [autocompleteInstanceId, source?.sourceId, elementId]\n    .filter(Boolean)\n    .join('-')\n    .replace(/\\s/g, '');\n}\n","const regex = /((gt|sm)-|galaxy nexus)|samsung[- ]|samsungbrowser/i;\n\nexport function isSamsung(userAgent: string) {\n  return Boolean(userAgent && userAgent.match(regex));\n}\n","export function getNativeEvent<TEvent>(event: TEvent) {\n  return (event as unknown as { nativeEvent: TEvent }).nativeEvent || event;\n}\n","import {\n  getItemsCount,\n  generateAutocompleteId,\n  flatten,\n} from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteEnvironment,\n  AutocompleteOptions,\n  AutocompleteSubscribers,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getNormalizedSources } from './utils';\n\nexport function getDefaultProps<TItem extends BaseItem>(\n  props: AutocompleteOptions<TItem>,\n  pluginSubscribers: AutocompleteSubscribers<TItem>\n): InternalAutocompleteOptions<TItem> {\n  /* eslint-disable no-restricted-globals */\n  const environment: AutocompleteEnvironment = (\n    typeof window !== 'undefined' ? window : {}\n  ) as typeof window;\n  /* eslint-enable no-restricted-globals */\n  const plugins = props.plugins || [];\n\n  return {\n    debug: false,\n    openOnFocus: false,\n    enterKeyHint: undefined,\n    ignoreCompositionEvents: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultActiveItemId: null,\n    stallThreshold: 300,\n    insights: undefined,\n    environment,\n    shouldPanelOpen: ({ state }) => getItemsCount(state) > 0,\n    reshape: ({ sources }) => sources,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // an internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    plugins,\n    // The following props need to be deeply defaulted.\n    initialState: {\n      activeItemId: null,\n      query: '',\n      completion: null,\n      collections: [],\n      isOpen: false,\n      status: 'idle',\n      context: {},\n      ...props.initialState,\n    },\n    onStateChange(params) {\n      props.onStateChange?.(params);\n      plugins.forEach((x) => x.onStateChange?.(params));\n    },\n    onSubmit(params) {\n      props.onSubmit?.(params);\n      plugins.forEach((x) => x.onSubmit?.(params));\n    },\n    onReset(params) {\n      props.onReset?.(params);\n      plugins.forEach((x) => x.onReset?.(params));\n    },\n    getSources(params) {\n      return Promise.all(\n        [...plugins.map((plugin) => plugin.getSources), props.getSources]\n          .filter(Boolean)\n          .map((getSources) => getNormalizedSources(getSources!, params))\n      )\n        .then((nested) => flatten(nested))\n        .then((sources) =>\n          sources.map((source) => ({\n            ...source,\n            onSelect(params) {\n              source.onSelect(params);\n              pluginSubscribers.forEach((x) => x.onSelect?.(params));\n            },\n            onActive(params) {\n              source.onActive(params);\n              pluginSubscribers.forEach((x) => x.onActive?.(params));\n            },\n            onResolve(params) {\n              source.onResolve(params);\n              pluginSubscribers.forEach((x) => x.onResolve?.(params));\n            },\n          }))\n        );\n    },\n    navigator: {\n      navigate({ itemUrl }) {\n        environment.location.assign(itemUrl);\n      },\n      navigateNewTab({ itemUrl }) {\n        const windowReference = environment.open(itemUrl, '_blank', 'noopener');\n        windowReference?.focus();\n      },\n      navigateNewWindow({ itemUrl }) {\n        environment.open(itemUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import { invariant, decycle, noop } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteSource,\n  BaseItem,\n  GetSources,\n  GetSourcesParams,\n  InternalAutocompleteSource,\n  InternalGetSources,\n} from '../types';\n\nexport function getNormalizedSources<TItem extends BaseItem>(\n  getSources: GetSources<TItem>,\n  params: GetSourcesParams<TItem>\n): ReturnType<InternalGetSources<TItem>> {\n  const seenSourceIds: string[] = [];\n\n  return Promise.resolve(getSources(params)).then((sources) => {\n    invariant(\n      Array.isArray(sources),\n      () =>\n        `The \\`getSources\\` function must return an array of sources but returned type ${JSON.stringify(\n          typeof sources\n        )}:\\n\\n${JSON.stringify(decycle(sources), null, 2)}`\n    );\n\n    return Promise.all(\n      sources\n        // We allow `undefined` and `false` sources to allow users to use\n        // `Boolean(query) && source` (=> `false`).\n        // We need to remove these values at this point.\n        .filter((maybeSource: any): maybeSource is AutocompleteSource<TItem> =>\n          Boolean(maybeSource)\n        )\n        .map((source) => {\n          invariant(\n            typeof source.sourceId === 'string',\n            'A source must provide a `sourceId` string.'\n          );\n\n          if (seenSourceIds.includes(source.sourceId)) {\n            throw new Error(\n              `[Autocomplete] The \\`sourceId\\` ${JSON.stringify(\n                source.sourceId\n              )} is not unique.`\n            );\n          }\n\n          seenSourceIds.push(source.sourceId);\n\n          const defaultSource: Omit<\n            InternalAutocompleteSource<TItem>,\n            'sourceId' | 'getItems'\n          > = {\n            getItemInputValue({ state }) {\n              return state.query;\n            },\n            getItemUrl() {\n              return undefined;\n            },\n            onSelect({ setIsOpen }) {\n              setIsOpen(false);\n            },\n            onActive: noop,\n            onResolve: noop,\n          };\n\n          Object.keys(defaultSource).forEach((key) => {\n            defaultSource[key].__default = true;\n          });\n\n          const normalizedSource: InternalAutocompleteSource<TItem> = {\n            ...defaultSource,\n            ...source,\n          };\n\n          return Promise.resolve(normalizedSource);\n        })\n    );\n  });\n}\n","import type {\n  Execute,\n  ExecuteResponse,\n  RequesterDescription,\n  TransformResponse,\n} from '@algolia/autocomplete-preset-algolia';\nimport { decycle, flatten, invariant } from '@algolia/autocomplete-shared';\nimport type { SearchResponse } from '@algolia/autocomplete-shared';\nimport {\n  MultipleQueriesQuery,\n  SearchForFacetValuesResponse,\n} from '@algolia/client-search';\nimport type { SearchClient } from 'algoliasearch/lite';\n\nimport {\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteSource,\n  OnResolveParams,\n} from './types';\nimport { mapToAlgoliaResponse } from './utils';\n\nfunction isDescription<TItem extends BaseItem>(\n  item:\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n    | PackedDescription<TItem>\n): item is RequestDescriptionPreResolved<TItem> {\n  return Boolean((item as RequestDescriptionPreResolved<TItem>).execute);\n}\n\nfunction isRequesterDescription<TItem extends BaseItem>(\n  description: TItem[] | TItem[][] | RequesterDescription<TItem>\n): description is RequesterDescription<TItem> {\n  return Boolean((description as RequesterDescription<TItem>)?.execute);\n}\n\ntype PackedDescription<TItem extends BaseItem> = {\n  searchClient: SearchClient;\n  execute: Execute<TItem>;\n  requesterId?: string;\n  items: RequestDescriptionPreResolved<TItem>['requests'];\n};\n\ntype RequestDescriptionPreResolved<TItem extends BaseItem> = Pick<\n  RequesterDescription<TItem>,\n  'execute' | 'requesterId' | 'searchClient' | 'transformResponse'\n> & {\n  requests: Array<{\n    query: MultipleQueriesQuery;\n    sourceId: string;\n    transformResponse: TransformResponse<TItem>;\n  }>;\n};\n\ntype RequestDescriptionPreResolvedCustom<TItem extends BaseItem> = {\n  items: TItem[] | TItem[][];\n  sourceId: string;\n  transformResponse?: undefined;\n};\n\nexport function preResolve<TItem extends BaseItem>(\n  itemsOrDescription: TItem[] | TItem[][] | RequesterDescription<TItem>,\n  sourceId: string,\n  state: AutocompleteState<TItem>\n):\n  | RequestDescriptionPreResolved<TItem>\n  | RequestDescriptionPreResolvedCustom<TItem> {\n  if (isRequesterDescription<TItem>(itemsOrDescription)) {\n    const contextParameters =\n      itemsOrDescription.requesterId === 'algolia'\n        ? Object.assign(\n            {},\n            ...Object.keys(state.context).map((key) => {\n              return (state.context[key] as Record<string, unknown>)\n                ?.__algoliaSearchParameters;\n            })\n          )\n        : {};\n\n    return {\n      ...itemsOrDescription,\n      requests: itemsOrDescription.queries.map((query) => ({\n        query:\n          itemsOrDescription.requesterId === 'algolia'\n            ? {\n                ...query,\n                params: {\n                  ...contextParameters,\n                  ...query.params,\n                },\n              }\n            : query,\n        sourceId,\n        transformResponse: itemsOrDescription.transformResponse,\n      })),\n    };\n  }\n\n  return {\n    items: itemsOrDescription,\n    sourceId,\n  };\n}\n\nexport function resolve<TItem extends BaseItem>(\n  items: Array<\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n  >\n) {\n  const packed = items.reduce<\n    Array<RequestDescriptionPreResolvedCustom<TItem> | PackedDescription<TItem>>\n  >((acc, current) => {\n    if (!isDescription(current)) {\n      acc.push(current);\n      return acc;\n    }\n\n    const { searchClient, execute, requesterId, requests } = current;\n\n    const container = acc.find<PackedDescription<TItem>>(\n      (item): item is PackedDescription<TItem> => {\n        return (\n          isDescription(current) &&\n          isDescription(item) &&\n          item.searchClient === searchClient &&\n          Boolean(requesterId) &&\n          item.requesterId === requesterId\n        );\n      }\n    );\n\n    if (container) {\n      container.items.push(...requests);\n    } else {\n      const request: PackedDescription<TItem> = {\n        execute,\n        requesterId,\n        items: requests,\n        searchClient,\n      };\n      acc.push(request);\n    }\n\n    return acc;\n  }, []);\n\n  const values = packed.map<\n    | Promise<RequestDescriptionPreResolvedCustom<TItem>>\n    | ReturnType<Execute<TItem>>\n  >((maybeDescription) => {\n    if (!isDescription<TItem>(maybeDescription)) {\n      return Promise.resolve(\n        maybeDescription as RequestDescriptionPreResolvedCustom<TItem>\n      );\n    }\n\n    const { execute, items, searchClient } =\n      maybeDescription as PackedDescription<TItem>;\n\n    return execute({\n      searchClient,\n      requests: items,\n    });\n  });\n\n  return Promise.all<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>\n  >(values).then((responses) =>\n    flatten<\n      RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n    >(responses)\n  );\n}\n\nexport function postResolve<TItem extends BaseItem>(\n  responses: Array<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n  >,\n  sources: Array<InternalAutocompleteSource<TItem>>,\n  store: AutocompleteStore<TItem>\n) {\n  return sources.map((source) => {\n    const matches = responses.filter(\n      (response) => response.sourceId === source.sourceId\n    );\n    const results = matches.map(({ items }) => items);\n    const transform = matches[0].transformResponse;\n    const items = transform\n      ? transform(\n          mapToAlgoliaResponse(\n            results as Array<\n              SearchForFacetValuesResponse | SearchResponse<TItem>\n            >\n          )\n        )\n      : results;\n\n    source.onResolve({\n      source,\n      results,\n      items,\n      state: store.getState(),\n    } as OnResolveParams<TItem>);\n\n    invariant(\n      Array.isArray(items),\n      () => `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned type ${JSON.stringify(\n        typeof items\n      )}:\\n\\n${JSON.stringify(decycle(items), null, 2)}.\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    invariant(\n      (items as Array<typeof items>).every(Boolean),\n      `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned ${JSON.stringify(\n        undefined\n      )}.\n\nDid you forget to return items?\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    return {\n      source,\n      items,\n    };\n  });\n}\n","import type { SearchResponse } from '@algolia/autocomplete-shared';\nimport type { SearchForFacetValuesResponse } from '@algolia/client-search';\n\nexport function mapToAlgoliaResponse<THit>(\n  rawResults: Array<SearchResponse<THit> | SearchForFacetValuesResponse>\n) {\n  return {\n    results: rawResults,\n    hits: rawResults\n      .map((result) => (result as SearchResponse<THit>).hits)\n      .filter(Boolean),\n    facetHits: rawResults\n      .map((result) =>\n        (result as SearchForFacetValuesResponse).facetHits?.map((facetHit) => {\n          // Bring support for the highlighting components.\n          return {\n            label: facetHit.value,\n            count: facetHit.count,\n            _highlightResult: {\n              label: {\n                value: facetHit.highlighted,\n              },\n            },\n          };\n        })\n      )\n      .filter(Boolean),\n  };\n}\n","import { MaybePromise } from '@algolia/autocomplete-shared';\n\n/**\n * Creates a runner that executes promises in a concurrent-safe way.\n *\n * This is useful to prevent older promises to resolve after a newer promise,\n * otherwise resulting in stale resolved values.\n */\nexport function createConcurrentSafePromise() {\n  let basePromiseId = -1;\n  let latestResolvedId = -1;\n  let latestResolvedValue: unknown = undefined;\n\n  return function runConcurrentSafePromise<TValue>(\n    promise: MaybePromise<TValue>\n  ) {\n    basePromiseId++;\n    const currentPromiseId = basePromiseId;\n\n    return Promise.resolve(promise).then((x) => {\n      // The promise might take too long to resolve and get outdated. This would\n      // result in resolving stale values.\n      // When this happens, we ignore the promise value and return the one\n      // coming from the latest resolved value.\n      //\n      // +----------------------------------+\n      // |        100ms                     |\n      // | run(1) +--->  R1                 |\n      // |        300ms                     |\n      // | run(2) +-------------> R2 (SKIP) |\n      // |        200ms                     |\n      // | run(3) +--------> R3             |\n      // +----------------------------------+\n      if (latestResolvedValue && currentPromiseId < latestResolvedId) {\n        return latestResolvedValue as TValue;\n      }\n\n      latestResolvedId = currentPromiseId;\n      latestResolvedValue = x;\n\n      return x;\n    });\n  };\n}\n","import { SearchResponse } from '@algolia/autocomplete-shared';\nimport { SearchForFacetValuesResponse } from '@algolia/client-search';\n\nimport { reshape } from './reshape';\nimport { preResolve, resolve, postResolve } from './resolve';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport {\n  cancelable,\n  CancelablePromise,\n  createConcurrentSafePromise,\n  getActiveItem,\n} from './utils';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: any;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the panel in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n  props: InternalAutocompleteOptions<TItem>;\n  query: string;\n  store: AutocompleteStore<TItem>;\n}\n\nconst runConcurrentSafePromise = createConcurrentSafePromise();\n\nexport function onInput<TItem extends BaseItem>({\n  event,\n  nextState = {},\n  props,\n  query,\n  refresh,\n  store,\n  ...setters\n}: OnInputParams<TItem>): CancelablePromise<void> {\n  if (lastStalledId) {\n    props.environment.clearTimeout(lastStalledId);\n  }\n\n  const {\n    setCollections,\n    setIsOpen,\n    setQuery,\n    setActiveItemId,\n    setStatus,\n    setContext,\n  } = setters;\n\n  setQuery(query);\n  setActiveItemId(props.defaultActiveItemId);\n\n  if (!query && props.openOnFocus === false) {\n    const collections = store.getState().collections.map((collection) => ({\n      ...collection,\n      items: [],\n    }));\n\n    setStatus('idle');\n    setCollections(collections);\n    setIsOpen(\n      nextState.isOpen ?? props.shouldPanelOpen({ state: store.getState() })\n    );\n\n    // We make sure to update the latest resolved value of the tracked\n    // promises to keep late resolving promises from \"cancelling\" the state\n    // updates performed in this code path.\n    // We chain with a void promise to respect `onInput`'s expected return type.\n    const request = cancelable(\n      runConcurrentSafePromise(collections).then(() => Promise.resolve())\n    );\n\n    return store.pendingRequests.add(request);\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  // We track the entire promise chain triggered by `onInput` before mutating\n  // the Autocomplete state to make sure that any state manipulation is based on\n  // fresh data regardless of when promises individually resolve.\n  // We don't track nested promises and only rely on the full chain resolution,\n  // meaning we should only ever manipulate the state once this concurrent-safe\n  // promise is resolved.\n  const request = cancelable(\n    runConcurrentSafePromise(\n      props\n        .getSources({\n          query,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        })\n        .then((sources) => {\n          return Promise.all(\n            sources.map((source) => {\n              return Promise.resolve(\n                source.getItems({\n                  query,\n                  refresh,\n                  state: store.getState(),\n                  ...setters,\n                })\n              ).then((itemsOrDescription) =>\n                preResolve<TItem>(\n                  itemsOrDescription,\n                  source.sourceId,\n                  store.getState()\n                )\n              );\n            })\n          )\n            .then(resolve)\n            .then((responses) => {\n              const __automaticInsights = responses.some(({ items }) =>\n                isSearchResponseWithAutomaticInsightsFlag<TItem>(items)\n              );\n\n              // No need to pollute the context if `__automaticInsights=false`\n              if (__automaticInsights) {\n                setContext({\n                  algoliaInsightsPlugin: {\n                    ...((store.getState().context?.algoliaInsightsPlugin ||\n                      {}) as Record<string, unknown>),\n                    __automaticInsights,\n                  },\n                });\n              }\n\n              return postResolve(responses, sources, store);\n            })\n            .then((collections) =>\n              reshape({ collections, props, state: store.getState() })\n            );\n        })\n    )\n  )\n    .then((collections) => {\n      // Parameters passed to `onInput` could be stale when the following code\n      // executes, because `onInput` calls may not resolve in order.\n      // If it becomes a problem we'll need to save the last passed parameters.\n      // See: https://codesandbox.io/s/agitated-cookies-y290z\n\n      setStatus('idle');\n\n      setCollections(collections as any);\n\n      const isPanelOpen = props.shouldPanelOpen({ state: store.getState() });\n\n      setIsOpen(\n        nextState.isOpen ??\n          ((props.openOnFocus && !query && isPanelOpen) || isPanelOpen)\n      );\n\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    })\n    .finally(() => {\n      setStatus('idle');\n\n      if (lastStalledId) {\n        props.environment.clearTimeout(lastStalledId);\n      }\n    });\n\n  return store.pendingRequests.add(request);\n}\n\nfunction isSearchResponseWithAutomaticInsightsFlag<TItem>(\n  items:\n    | TItem[]\n    | TItem[][]\n    | SearchForFacetValuesResponse\n    | SearchResponse<TItem>\n): items is SearchResponse<TItem> {\n  return (\n    !Array.isArray(items) &&\n    Boolean((items as SearchResponse<TItem>)?._automaticInsights)\n  );\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteCollection,\n  AutocompleteReshapeSourcesBySourceId,\n  AutocompleteState,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\n\ntype ReshapeParams<TItem extends BaseItem> = {\n  collections: Array<AutocompleteCollection<any>>;\n  props: InternalAutocompleteOptions<TItem>;\n  state: AutocompleteState<TItem>;\n};\n\nexport function reshape<TItem extends BaseItem>({\n  collections,\n  props,\n  state,\n}: ReshapeParams<TItem>) {\n  // Sources are grouped by `sourceId` to conveniently pick them via destructuring.\n  // Example: `const { recentSearchesPlugin } = sourcesBySourceId`\n  const originalSourcesBySourceId = collections.reduce<\n    AutocompleteReshapeSourcesBySourceId<TItem>\n  >(\n    (acc, collection) => ({\n      ...acc,\n      [collection.source.sourceId]: {\n        ...collection.source,\n        getItems() {\n          // We provide the resolved items from the collection to the `reshape` prop.\n          return flatten<any>(collection.items);\n        },\n      },\n    }),\n    {}\n  );\n\n  const { sourcesBySourceId } = props.plugins.reduce(\n    (acc, plugin) => {\n      if (plugin.reshape) {\n        return plugin.reshape(acc);\n      }\n      return acc;\n    },\n    {\n      sourcesBySourceId: originalSourcesBySourceId,\n      state,\n    }\n  );\n\n  const reshapeSources = props.reshape({\n    sourcesBySourceId,\n    sources: Object.values(sourcesBySourceId),\n    state,\n  });\n\n  // We reconstruct the collections with the items modified by the `reshape` prop.\n  return flatten(reshapeSources)\n    .filter(Boolean)\n    .map((source) => {\n      return {\n        source,\n        items: source.getItems(),\n      };\n    });\n}\n","import { noop } from '@algolia/autocomplete-shared';\n\nimport { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetListProps,\n  GetPanelProps,\n  GetRootProps,\n  InternalAutocompleteOptions,\n} from './types';\nimport {\n  getPluginSubmitPromise,\n  getActiveItem,\n  getAutocompleteElementId,\n  isOrContainsNode,\n  isSamsung,\n  getNativeEvent,\n} from './utils';\n\ninterface GetPropGettersOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: InternalAutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<\n  TItem extends BaseItem,\n  TEvent,\n  TMouseEvent,\n  TKeyboardEvent\n>({ props, refresh, store, ...setters }: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (providedProps) => {\n    const { inputElement, formElement, panelElement, ...rest } = providedProps;\n\n    function onMouseDownOrTouchStart(event: MouseEvent | TouchEvent) {\n      // The `onTouchStart`/`onMouseDown` events shouldn't trigger the `blur`\n      // handler when it's not an interaction with Autocomplete.\n      // We detect it with the following heuristics:\n      // - the panel is closed AND there are no pending requests\n      //   (no interaction with the autocomplete, no future state updates)\n      // - OR the touched target is the input element (should open the panel)\n      const isAutocompleteInteraction =\n        store.getState().isOpen || !store.pendingRequests.isEmpty();\n\n      if (!isAutocompleteInteraction || event.target === inputElement) {\n        return;\n      }\n\n      // @TODO: support cases where there are multiple Autocomplete instances.\n      // Right now, a second instance makes this computation return false.\n      const isTargetWithinAutocomplete = [formElement, panelElement].some(\n        (contextNode) => {\n          return isOrContainsNode(contextNode, event.target as Node);\n        }\n      );\n\n      if (isTargetWithinAutocomplete === false) {\n        store.dispatch('blur', null);\n\n        // If requests are still pending when the user closes the panel, they\n        // could reopen the panel once they resolve.\n        // We want to prevent any subsequent query from reopening the panel\n        // because it would result in an unsolicited UI behavior.\n        if (!props.debug) {\n          store.pendingRequests.cancelAll();\n        }\n      }\n    }\n\n    return {\n      // We do not rely on the native `blur` event of the input to close the\n      // panel, but rather on a custom `touchstart`/`mousedown` event outside\n      // of the autocomplete elements.\n      // This ensures we don't mistakenly interpret interactions within the\n      // autocomplete (but outside of the input) as a signal to close the panel.\n      // For example, clicking reset button causes an input blur, but if\n      // `openOnFocus=true`, it shouldn't close the panel.\n      // On touch devices, scrolling results (`touchmove`) causes an input blur\n      // but shouldn't close the panel.\n      onTouchStart: onMouseDownOrTouchStart,\n      onMouseDown: onMouseDownOrTouchStart,\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the panel.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          inputElement !== props.environment.document.activeElement ||\n          event.target === inputElement\n        ) {\n          return;\n        }\n\n        inputElement.blur();\n      },\n      ...rest,\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-controls': store.getState().isOpen\n        ? store\n            .getState()\n            .collections.map(({ source }) =>\n              getAutocompleteElementId(props.id, 'list', source)\n            )\n            .join(' ')\n        : undefined,\n      'aria-labelledby': getAutocompleteElementId(props.id, 'label'),\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    const handleSubmit = (event: TEvent) => {\n      props.onSubmit({\n        event,\n        refresh,\n        state: store.getState(),\n        ...setters,\n      });\n\n      store.dispatch('submit', null);\n      providedProps.inputElement?.blur();\n    };\n\n    return {\n      action: '',\n      noValidate: true,\n      role: 'search',\n      onSubmit: (event) => {\n        (event as unknown as Event).preventDefault();\n\n        const waitForSubmit = getPluginSubmitPromise(\n          props.plugins,\n          store.pendingRequests\n        );\n        if (waitForSubmit !== undefined) {\n          waitForSubmit.then(() => handleSubmit(event));\n        } else {\n          handleSubmit(event);\n        }\n      },\n      onReset: (event) => {\n        (event as unknown as Event).preventDefault();\n\n        props.onReset({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('reset', null);\n        providedProps.inputElement?.focus();\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus(event: TEvent) {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the panel should open with the current query.\n      if (props.openOnFocus || Boolean(store.getState().query)) {\n        onInput({\n          event,\n          props,\n          query: store.getState().completion || store.getState().query,\n          refresh,\n          store,\n          ...setters,\n        });\n      }\n\n      store.dispatch('focus', null);\n    }\n\n    const { inputElement, maxLength = 512, ...rest } = providedProps || {};\n    const activeItem = getActiveItem(store.getState());\n\n    const userAgent = props.environment.navigator?.userAgent || '';\n    const shouldFallbackKeyHint = isSamsung(userAgent);\n    const enterKeyHint =\n      props.enterKeyHint ||\n      (activeItem?.itemUrl && !shouldFallbackKeyHint ? 'go' : 'search');\n\n    return {\n      'aria-autocomplete': 'both',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().activeItemId !== null\n          ? getAutocompleteElementId(\n              props.id,\n              `item-${store.getState().activeItemId}`,\n              activeItem?.source\n            )\n          : undefined,\n      'aria-controls': store.getState().isOpen\n        ? store\n            .getState()\n            .collections.filter((collection) => collection.items.length > 0)\n            .map(({ source }) =>\n              getAutocompleteElementId(props.id, 'list', source)\n            )\n            .join(' ')\n        : undefined,\n      'aria-labelledby': getAutocompleteElementId(props.id, 'label'),\n      value: store.getState().completion || store.getState().query,\n      id: getAutocompleteElementId(props.id, 'input'),\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      enterKeyHint,\n      spellCheck: 'false',\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      type: 'search',\n      onChange: (event) => {\n        const value = (\n          (event as unknown as Event).currentTarget as HTMLInputElement\n        ).value;\n\n        if (\n          props.ignoreCompositionEvents &&\n          getNativeEvent(event as unknown as InputEvent).isComposing\n        ) {\n          setters.setQuery(value);\n          return;\n        }\n\n        onInput({\n          event,\n          props,\n          query: value.slice(0, maxLength),\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onCompositionEnd: (event) => {\n        onInput({\n          event,\n          props,\n          query: (\n            (event as unknown as Event).currentTarget as HTMLInputElement\n          ).value.slice(0, maxLength),\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onKeyDown: (event) => {\n        if (getNativeEvent(event as unknown as InputEvent).isComposing) {\n          return;\n        }\n\n        onKeyDown({\n          event: event as unknown as KeyboardEvent,\n          props,\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onFocus,\n      // We don't rely on the `blur` event.\n      // See explanation in `onTouchStart`/`onMouseDown`.\n      // @MAJOR See if we need to keep this handler.\n      onBlur: noop,\n      onClick: (event) => {\n        // When the panel is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the panel in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the panel to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus(event as unknown as TEvent);\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getLabelProps: GetLabelProps = (rest) => {\n    return {\n      htmlFor: getAutocompleteElementId(props.id, 'input'),\n      id: getAutocompleteElementId(props.id, 'label'),\n      ...rest,\n    };\n  };\n\n  const getListProps: GetListProps = (providedProps) => {\n    const { source, ...rest } = providedProps || {};\n\n    return {\n      role: 'listbox',\n      'aria-labelledby': getAutocompleteElementId(props.id, 'label'),\n      id: getAutocompleteElementId(props.id, 'list', source),\n      ...rest,\n    };\n  };\n\n  const getPanelProps: GetPanelProps<TMouseEvent> = (rest) => {\n    return {\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the panel so\n        // that the blur event is not triggered, otherwise it closes the\n        // panel.\n        (event as unknown as MouseEvent).preventDefault();\n      },\n      onMouseLeave() {\n        store.dispatch('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, ...rest } = providedProps;\n\n    return {\n      id: getAutocompleteElementId(\n        props.id,\n        `item-${item.__autocomplete_id}`,\n        source\n      ),\n      role: 'option',\n      'aria-selected': store.getState().activeItemId === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().activeItemId) {\n          return;\n        }\n\n        store.dispatch('mousemove', item.__autocomplete_id);\n\n        const activeItem = getActiveItem(store.getState());\n\n        if (store.getState().activeItemId !== null && activeItem) {\n          const { item, itemInputValue, itemUrl, source } = activeItem;\n\n          source.onActive({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        (event as unknown as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        const itemInputValue = source.getItemInputValue({\n          item,\n          state: store.getState(),\n        });\n        const itemUrl = source.getItemUrl({\n          item,\n          state: store.getState(),\n        });\n\n        // If `getItemUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `activeItemId`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        const runPreCommand = itemUrl\n          ? Promise.resolve()\n          : onInput({\n              event,\n              nextState: { isOpen: false },\n              props,\n              query: itemInputValue,\n              refresh,\n              store,\n              ...setters,\n            });\n\n        runPreCommand.then(() => {\n          source.onSelect({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getPanelProps,\n    getListProps,\n    getItemProps,\n  };\n}\n","export function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || parent.contains(child);\n}\n","import { onInput } from './onInput';\nimport {\n  ActionType,\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport {\n  getPluginSubmitPromise,\n  getActiveItem,\n  getAutocompleteElementId,\n} from './utils';\n\ninterface OnKeyDownOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: KeyboardEvent;\n  props: InternalAutocompleteOptions<TItem>;\n  store: AutocompleteStore<TItem>;\n}\n\nexport function onKeyDown<TItem extends BaseItem>({\n  event,\n  props,\n  refresh,\n  store,\n  ...setters\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // eslint-disable-next-line no-inner-declarations\n    function triggerScrollIntoView() {\n      const highlightedItem = getActiveItem(store.getState());\n\n      const nodeItem = props.environment.document.getElementById(\n        getAutocompleteElementId(\n          props.id,\n          `item-${store.getState().activeItemId}`,\n          highlightedItem?.source\n        )\n      );\n\n      if (nodeItem) {\n        if ((nodeItem as any).scrollIntoViewIfNeeded) {\n          (nodeItem as any).scrollIntoViewIfNeeded(false);\n        } else {\n          nodeItem.scrollIntoView(false);\n        }\n      }\n    }\n\n    // eslint-disable-next-line no-inner-declarations\n    function triggerOnActive() {\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    }\n\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // ArrowDown.\n    event.preventDefault();\n\n    // When re-opening the panel, we need to split the logic to keep the actions\n    // synchronized as `onInput` returns a promise.\n    if (\n      store.getState().isOpen === false &&\n      (props.openOnFocus || Boolean(store.getState().query))\n    ) {\n      onInput({\n        event,\n        props,\n        query: store.getState().query,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        store.dispatch(event.key as ActionType, {\n          nextActiveItemId: props.defaultActiveItemId,\n        });\n\n        triggerOnActive();\n        // Since we rely on the DOM, we need to wait for all the micro tasks to\n        // finish (which include re-opening the panel) to make sure all the\n        // elements are available.\n        setTimeout(triggerScrollIntoView, 0);\n      });\n    } else {\n      store.dispatch(event.key, {});\n\n      triggerOnActive();\n      triggerScrollIntoView();\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // from removing the query right away because we first want to close the\n    // panel.\n    event.preventDefault();\n\n    store.dispatch(event.key, null);\n\n    // Hitting the `Escape` key signals the end of a user interaction with the\n    // autocomplete. At this point, we should ignore any requests that are still\n    // pending and could reopen the panel once they resolve, because that would\n    // result in an unsolicited UI behavior.\n    store.pendingRequests.cancelAll();\n  } else if (event.key === 'Tab') {\n    store.dispatch('blur', null);\n\n    // Hitting the `Tab` key signals the end of a user interaction with the\n    // autocomplete. At this point, we should ignore any requests that are still\n    // pending and could reopen the panel once they resolve, because that would\n    // result in an unsolicited UI behavior.\n    store.pendingRequests.cancelAll();\n  } else if (event.key === 'Enter') {\n    // No active item, so we let the browser handle the native `onSubmit` form\n    // event.\n    if (\n      store.getState().activeItemId === null ||\n      store\n        .getState()\n        .collections.every((collection) => collection.items.length === 0)\n    ) {\n      const waitForSubmit = getPluginSubmitPromise(\n        props.plugins,\n        store.pendingRequests\n      );\n      if (waitForSubmit !== undefined) {\n        waitForSubmit.then(store.pendingRequests.cancelAll); // Cancel the rest if timeout number is provided\n      } else if (!props.debug) {\n        // If requests are still pending when the panel closes, they could reopen\n        // the panel once they resolve.\n        // We want to prevent any subsequent query from reopening the panel\n        // because it would result in an unsolicited UI behavior.\n        store.pendingRequests.cancelAll();\n      }\n\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemInputValue, itemUrl, source } = getActiveItem(\n      store.getState()\n    )!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewTab({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewWindow({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigate({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n\n        return;\n      }\n\n      onInput({\n        event,\n        nextState: { isOpen: false },\n        props,\n        query: itemInputValue,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      });\n    }\n  }\n}\n","import { UserAgent, userAgents } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteEnvironment,\n  AutocompleteOptions,\n  AutocompleteOptionsWithMetadata,\n  AutocompletePlugin,\n  BaseItem,\n} from '.';\n\ntype AutocompleteMetadata = {\n  plugins: Array<{\n    name: string | undefined;\n    options: string[];\n  }>;\n  options: Record<string, string[]>;\n  ua: UserAgent[];\n};\n\ntype GetMetadataParams<TItem extends BaseItem, TData = unknown> = {\n  plugins: Array<AutocompletePlugin<TItem, TData>>;\n  options: AutocompleteOptionsWithMetadata<TItem>;\n};\n\nexport function getMetadata<TItem extends BaseItem, TData = unknown>({\n  plugins,\n  options,\n}: GetMetadataParams<TItem, TData>) {\n  const optionsKey = ((options.__autocomplete_metadata\n    ?.userAgents as UserAgent[]) || [])[0]?.segment;\n\n  const extraOptions = optionsKey\n    ? {\n        [optionsKey]: Object.keys(\n          (options.__autocomplete_metadata\n            ?.options as AutocompleteOptions<TItem>) || {}\n        ),\n      }\n    : {};\n\n  return {\n    plugins: plugins.map((plugin) => ({\n      name: plugin.name,\n      options: Object.keys(plugin.__autocomplete_pluginOptions || []),\n    })),\n    options: {\n      'autocomplete-core': Object.keys(options),\n      ...extraOptions,\n    },\n    ua: userAgents.concat(\n      (options.__autocomplete_metadata?.userAgents as any) || []\n    ),\n  };\n}\n\ntype InlineMetadataParams = {\n  metadata: AutocompleteMetadata;\n  environment: AutocompleteEnvironment;\n};\n\nexport function injectMetadata({\n  metadata,\n  environment,\n}: InlineMetadataParams) {\n  const isMetadataEnabled =\n    environment.navigator?.userAgent?.includes('Algolia Crawler');\n\n  if (isMetadataEnabled) {\n    const metadataContainer = environment.document.createElement('meta');\n    const headRef = environment.document.querySelector('head');\n\n    metadataContainer.name = 'algolia:metadata';\n\n    setTimeout(() => {\n      metadataContainer.content = JSON.stringify(metadata);\n      headRef!.appendChild(metadataContainer);\n    }, 0);\n  }\n}\n","import { AutocompleteState, BaseItem } from './types';\nimport { getActiveItem } from './utils';\n\ninterface GetCompletionProps<TItem extends BaseItem> {\n  state: AutocompleteState<TItem>;\n}\n\nexport function getCompletion<TItem extends BaseItem>({\n  state,\n}: GetCompletionProps<TItem>): string | null {\n  if (state.isOpen === false || state.activeItemId === null) {\n    return null;\n  }\n\n  return getActiveItem(state)?.itemInputValue || null;\n}\n","import { getItemsCount, invariant } from '@algolia/autocomplete-shared';\n\nimport { getCompletion } from './getCompletion';\nimport { Reducer } from './types';\nimport { getNextActiveItemId } from './utils';\n\nexport const stateReducer: Reducer = (state, action) => {\n  switch (action.type) {\n    case 'setActiveItemId': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.payload,\n        completion: null,\n      };\n    }\n\n    case 'setCollections': {\n      return {\n        ...state,\n        collections: action.payload,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.payload,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.payload,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.payload,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      const nextState = {\n        ...state,\n        activeItemId: action.payload.hasOwnProperty('nextActiveItemId')\n          ? action.payload.nextActiveItemId\n          : getNextActiveItemId(\n              1,\n              state.activeItemId,\n              getItemsCount(state),\n              action.props.defaultActiveItemId\n            ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'ArrowUp': {\n      const nextState = {\n        ...state,\n        activeItemId: getNextActiveItemId(\n          -1,\n          state.activeItemId,\n          getItemsCount(state),\n          action.props.defaultActiveItemId\n        ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          activeItemId: null,\n          isOpen: false,\n          completion: null,\n        };\n      }\n\n      return {\n        ...state,\n        activeItemId: null,\n        query: '',\n        status: 'idle',\n        collections: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        activeItemId: null,\n        isOpen: false,\n        status: 'idle',\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        activeItemId:\n          // Since we open the panel on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultActiveItemId. (DocSearch use-case)\n\n          // Since we close the panel when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          action.props.openOnFocus === true\n            ? action.props.defaultActiveItemId\n            : null,\n        status: 'idle',\n        completion: null,\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n        isOpen:\n          (action.props.openOnFocus || Boolean(state.query)) &&\n          action.props.shouldPanelOpen({ state }),\n      };\n    }\n\n    case 'blur': {\n      if (action.props.debug) {\n        return state;\n      }\n\n      return {\n        ...state,\n        isOpen: false,\n        activeItemId: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n      };\n    }\n\n    default:\n      invariant(\n        false,\n        `The reducer action ${JSON.stringify(action.type)} is not supported.`\n      );\n\n      return state;\n  }\n};\n","import { createAlgoliaInsightsPlugin } from '@algolia/autocomplete-plugin-algolia-insights';\n\nimport { checkOptions } from './checkOptions';\nimport { createStore } from './createStore';\nimport { getAutocompleteSetters } from './getAutocompleteSetters';\nimport { getDefaultProps } from './getDefaultProps';\nimport { getPropGetters } from './getPropGetters';\nimport { getMetadata, injectMetadata } from './metadata';\nimport { onInput } from './onInput';\nimport { stateReducer } from './stateReducer';\nimport {\n  AutocompleteApi,\n  AutocompleteOptions as AutocompleteCoreOptions,\n  BaseItem,\n  AutocompleteSubscribers,\n} from './types';\n\nexport interface AutocompleteOptionsWithMetadata<TItem extends BaseItem>\n  extends AutocompleteCoreOptions<TItem> {\n  /**\n   * @internal\n   */\n  __autocomplete_metadata?: Record<string, unknown>;\n}\n\nexport function createAutocomplete<\n  TItem extends BaseItem,\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: AutocompleteOptionsWithMetadata<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  checkOptions(options);\n\n  const subscribers: AutocompleteSubscribers<TItem> = [];\n  const props = getDefaultProps(options, subscribers);\n  const store = createStore(stateReducer, props, onStoreStateChange);\n\n  const setters = getAutocompleteSetters({ store });\n  const propGetters = getPropGetters<\n    TItem,\n    TEvent,\n    TMouseEvent,\n    TKeyboardEvent\n  >({ props, refresh, store, navigator: props.navigator, ...setters });\n\n  function onStoreStateChange({ prevState, state }) {\n    props.onStateChange({\n      prevState,\n      state,\n      refresh,\n      navigator: props.navigator,\n      ...setters,\n    });\n\n    if (\n      !isAlgoliaInsightsPluginEnabled() &&\n      state.context?.algoliaInsightsPlugin?.__automaticInsights &&\n      props.insights !== false\n    ) {\n      const plugin = createAlgoliaInsightsPlugin({\n        __autocomplete_clickAnalytics: false,\n      });\n\n      props.plugins.push(plugin);\n\n      subscribePlugins([plugin]);\n    }\n  }\n\n  function refresh() {\n    return onInput({\n      event: new Event('input'),\n      nextState: { isOpen: store.getState().isOpen },\n      props,\n      navigator: props.navigator,\n      query: store.getState().query,\n      refresh,\n      store,\n      ...setters,\n    });\n  }\n\n  function subscribePlugins(plugins: typeof props.plugins) {\n    plugins.forEach((plugin) =>\n      plugin.subscribe?.({\n        ...setters,\n        navigator: props.navigator,\n        refresh,\n        onSelect(fn) {\n          subscribers.push({ onSelect: fn });\n        },\n        onActive(fn) {\n          subscribers.push({ onActive: fn });\n        },\n        onResolve(fn) {\n          subscribers.push({ onResolve: fn });\n        },\n      })\n    );\n  }\n\n  function isAlgoliaInsightsPluginEnabled() {\n    return props.plugins.some(\n      (plugin) => plugin.name === 'aa.algoliaInsightsPlugin'\n    );\n  }\n\n  if (props.insights && !isAlgoliaInsightsPluginEnabled()) {\n    const insightsParams =\n      typeof props.insights === 'boolean' ? {} : props.insights;\n    props.plugins.push(createAlgoliaInsightsPlugin(insightsParams));\n  }\n\n  subscribePlugins(props.plugins);\n\n  injectMetadata({\n    metadata: getMetadata({ plugins: props.plugins, options }),\n    environment: props.environment,\n  });\n\n  return {\n    refresh,\n    navigator: props.navigator,\n    ...propGetters,\n    ...setters,\n  };\n}\n","import {\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n  Reducer,\n} from './types';\nimport { createCancelablePromiseList } from './utils';\n\ntype OnStoreStateChange<TItem extends BaseItem> = ({\n  prevState,\n  state,\n}: {\n  prevState: AutocompleteState<TItem>;\n  state: AutocompleteState<TItem>;\n}) => void;\n\nexport function createStore<TItem extends BaseItem>(\n  reducer: Reducer,\n  props: InternalAutocompleteOptions<TItem>,\n  onStoreStateChange: OnStoreStateChange<TItem>\n): AutocompleteStore<TItem> {\n  let state = props.initialState;\n\n  return {\n    getState() {\n      return state;\n    },\n    dispatch(action, payload) {\n      const prevState = { ...state };\n      state = reducer(state, {\n        type: action,\n        props,\n        payload,\n      });\n\n      onStoreStateChange({ state, prevState });\n    },\n    pendingRequests: createCancelablePromiseList(),\n  };\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteApi,\n  AutocompleteCollection,\n  AutocompleteStore,\n  BaseItem,\n} from './types';\n\ninterface GetAutocompleteSettersOptions<TItem extends BaseItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem extends BaseItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setActiveItemId: AutocompleteApi<TItem>['setActiveItemId'] = (\n    value\n  ) => {\n    store.dispatch('setActiveItemId', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.dispatch('setQuery', value);\n  };\n\n  const setCollections: AutocompleteApi<TItem>['setCollections'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map<AutocompleteCollection<TItem>>((collection) => ({\n      ...collection,\n      // We flatten the stored items to support calling `getAlgoliaResults`\n      // from the source itself.\n      items: flatten(collection.items as any).map((item: any) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.dispatch('setCollections', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.dispatch('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.dispatch('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.dispatch('setContext', value);\n  };\n\n  return {\n    setActiveItemId,\n    setQuery,\n    setCollections,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n"],"names":["debounce","fn","time","timerId","undefined","_len","arguments","length","args","Array","_key","clearTimeout","setTimeout","apply","flatten","values","reduce","a","b","concat","autocompleteId","getItemsCount","state","collections","sum","collection","items","isPrimitive","obj","Object","isEqual","first","second","keys","_i","_Object$keys","key","noop","userAgents","segment","version","createClickedEvent","_ref","item","_ref$items","index","__autocomplete_indexName","positions","findIndex","x","objectID","queryID","__autocomplete_queryID","algoliaSource","_slicedToArray","arr","i","isArray","_arrayWithHoles","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","call","next","done","push","value","err","return","_iterableToArrayLimit","o","minLen","_arrayLikeToArray","n","prototype","toString","slice","constructor","name","from","test","_unsupportedIterableToArray","TypeError","_nonIterableRest","len","arr2","_excluded","_excluded2","_typeof","_toConsumableArray","_arrayWithoutHoles","iter","_iterableToArray","_nonIterableSpread","_objectWithoutProperties","source","excluded","target","sourceKeys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","arg","input","hint","prim","toPrimitive","res","String","Number","_toPrimitive","_toPropertyKey","configurable","writable","chunk","chunkSize","chunks","objectIDs","mapToInsightsParamsApi","params","map","param","_ref2","createSearchInsightsApi","searchInsights","_split$map2","major","minor","canSendHeaders","split","sendToInsights","method","payloads","_items$0$__autocomple","__autocomplete_algoliaCredentials","headers","appId","apiKey","init","setAuthenticatedUserToken","authenticatedUserToken","setUserToken","userToken","clickedObjectIDsAfterSearch","clickedObjectIDs","_len2","_key2","clickedFilters","_len3","_key3","convertedObjectIDsAfterSearch","_len4","_key4","convertedObjectIDs","_len5","_key5","convertedFilters","_len6","_key6","viewedObjectIDs","_len7","_key7","acc","_ref3","_ref4","payload","_ref5","viewedFilters","_len8","_key8","createViewedEvents","itemsByIndexName","current","_acc$current$__autoco","indexName","isAlgoliaInsightsHit","hit","ALGOLIA_INSIGHTS_VERSION","ALGOLIA_INSIGHTS_SRC","sendViewedObjectIDs","onItemsChange","insights","insightsEvents","event","eventName","createAlgoliaInsightsPlugin","options","_getOptions","_ref8","getAlgoliaSources","context","onSelect","_ref9","onActive","__autocomplete_clickAnalytics","getOptions","providedInsightsClient","insightsClient","insightsInitParams","onSelectEvent","onActiveEvent","callback","window","safelyRunOnBrowser","pointer","AlgoliaAnalyticsObject","queue","environment","errorMessage","script","document","createElement","async","src","onerror","console","error","body","appendChild","cause","loadInsights","partial","previousItems","debouncedOnStateChange","isOpen","subscribe","setContext","setInsightsContext","algoliaInsightsPlugin","__algoliaSearchParameters","clickAnalytics","normalizeUserToken","_error","getItems","_ref6","onStateChange","_ref7","__autocomplete_pluginOptions","_context$algoliaInsig","algoliaSourceBase","__automaticInsights","createInternalCancelablePromise","promise","initialState","then","onfulfilled","onrejected","createCallback","catch","finally","onfinally","onCancelList","cancel","isCanceled","callbacks","cancelable","onResult","fallback","_waitPromise","_hasWaitPromiseResolved","getNextActiveItemId","moveAmount","baseIndex","itemCount","defaultActiveItemId","numericIndex","getPluginSubmitPromise","plugins","pendingRequests","_step","waitUntilComplete","timeouts","_iterator","_createForOfIteratorHelper","s","_plugin$__autocomplet","_plugin$__autocomplet2","_plugin$__autocomplet3","awaitSubmit","e","f","wait","Math","max","getActiveItem","collectionIndex","collectionsCount","nextValue","activeItemId","getCollectionFromActiveItemId","isOffsetFound","counter","previousItemsOffset","currentCollection","getRelativeActiveItemId","itemInputValue","getItemInputValue","itemUrl","getItemUrl","getAutocompleteElementId","autocompleteInstanceId","elementId","sourceId","Boolean","join","replace","regex","getNativeEvent","nativeEvent","getDefaultProps","props","pluginSubscribers","_props$id","debug","openOnFocus","enterKeyHint","ignoreCompositionEvents","placeholder","autoFocus","stallThreshold","shouldPanelOpen","reshape","sources","id","query","completion","status","_props$onStateChange","_x$onStateChange","onSubmit","_props$onSubmit","_x$onSubmit","onReset","_props$onReset","_x$onReset","getSources","Promise","all","plugin","seenSourceIds","resolve","maybeSource","includes","Error","JSON","stringify","defaultSource","setIsOpen","onResolve","__default","normalizedSource","getNormalizedSources","nested","_x$onSelect","_x$onActive","_x$onResolve","navigator","navigate","location","assign","navigateNewTab","windowReference","open","focus","navigateNewWindow","isDescription","execute","preResolve","itemsOrDescription","description","contextParameters","requesterId","_state$context$key","requests","queries","transformResponse","searchClient","container","find","_container$items","request","maybeDescription","responses","postResolve","store","rawResults","matches","response","results","transform","hits","result","facetHits","_facetHits","facetHit","label","count","_highlightResult","highlighted","getState","every","basePromiseId","latestResolvedId","latestResolvedValue","lastStalledId","runConcurrentSafePromise","currentPromiseId","onInput","_ref$nextState","nextState","refresh","setters","setCollections","setQuery","setActiveItemId","setStatus","_nextState$isOpen","add","_store$getState$conte","some","_automaticInsights","isSearchResponseWithAutomaticInsightsFlag","originalSourcesBySourceId","sourcesBySourceId","_nextState$isOpen2","isPanelOpen","highlightedItem","getPropGetters","getEnvironmentProps","providedProps","inputElement","formElement","panelElement","onMouseDownOrTouchStart","isEmpty","contextNode","parent","child","contains","dispatch","cancelAll","onTouchStart","onMouseDown","onTouchMove","activeElement","blur","getRootProps","rest","role","getFormProps","_excluded3","handleSubmit","_providedProps$inputE","action","noValidate","preventDefault","waitForSubmit","_providedProps$inputE2","getLabelProps","htmlFor","getInputProps","_props$environment$na","onFocus","_ref3$maxLength","maxLength","_excluded4","activeItem","shouldFallbackKeyHint","userAgent","match","isSamsung","autoComplete","autoCorrect","autoCapitalize","spellCheck","type","onChange","currentTarget","isComposing","onCompositionEnd","onKeyDown","triggerScrollIntoView","nodeItem","getElementById","scrollIntoViewIfNeeded","scrollIntoView","triggerOnActive","nextActiveItemId","metaKey","ctrlKey","shiftKey","altKey","onBlur","onClick","getPanelProps","onMouseLeave","getListProps","_excluded5","getItemProps","_excluded6","__autocomplete_id","onMouseMove","getMetadata","_","_options$__autocomple","_options$__autocomple2","_options$__autocomple3","optionsKey","__autocomplete_metadata","extraOptions","ua","getCompletion","_getActiveItem","stateReducer","hasOwnProperty","subscribers","reducer","onStoreStateChange","list","prevState","cancelablePromise","timeout","race","createStore","_state$context","_state$context$algoli","isAlgoliaInsightsPluginEnabled","subscribePlugins","rawValue","baseItemId","getAutocompleteSetters","propGetters","Event","_plugin$subscribe","insightsParams","_environment$navigato","_environment$navigato2","metadata","metadataContainer","headRef","querySelector","content","injectMetadata"],"mappings":"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"}