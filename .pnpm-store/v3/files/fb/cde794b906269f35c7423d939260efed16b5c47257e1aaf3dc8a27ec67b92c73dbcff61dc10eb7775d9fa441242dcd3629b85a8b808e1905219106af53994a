{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/ui/tree/objectTreeModel.ts","vs/base/browser/ui/tree/objectTreeModel.ts"],"names":[],"mappings":"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","file":"objectTreeModel.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from '../list/list.js';\nimport { IIndexTreeModelOptions, IIndexTreeModelSpliceOptions, IndexTreeModel } from './indexTreeModel.js';\nimport { ICollapseStateChangeEvent, IObjectTreeElement, ITreeElement, ITreeListSpliceData, ITreeModel, ITreeModelSpliceEvent, ITreeNode, ITreeSorter, ObjectTreeElementCollapseState, TreeError } from './tree.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\n\nexport interface IObjectTreeModel<T extends NonNullable<any>, TFilterData extends NonNullable<any> = void> extends ITreeModel<T | null, TFilterData, T | null> {\n\tsetChildren(element: T | null, children: Iterable<IObjectTreeElement<T>> | undefined, options?: IObjectTreeModelSetChildrenOptions<T, TFilterData>): void;\n}\n\nexport interface IObjectTreeModelSetChildrenOptions<T, TFilterData> extends IIndexTreeModelSpliceOptions<T, TFilterData> {\n}\n\nexport interface IObjectTreeModelOptions<T, TFilterData> extends IIndexTreeModelOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly identityProvider?: IIdentityProvider<T>;\n}\n\nexport class ObjectTreeModel<T extends NonNullable<any>, TFilterData extends NonNullable<any> = void> implements IObjectTreeModel<T, TFilterData> {\n\n\treadonly rootRef = null;\n\n\tprivate model: IndexTreeModel<T | null, TFilterData>;\n\tprivate nodes = new Map<T | null, ITreeNode<T, TFilterData>>();\n\tprivate readonly nodesByIdentity = new Map<string, ITreeNode<T, TFilterData>>();\n\tprivate readonly identityProvider?: IIdentityProvider<T>;\n\tprivate sorter?: ITreeSorter<{ element: T }>;\n\n\treadonly onDidSpliceModel: Event<ITreeModelSpliceEvent<T | null, TFilterData>>;\n\treadonly onDidSpliceRenderedNodes: Event<ITreeListSpliceData<T | null, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\tconstructor(\n\t\tprivate user: string,\n\t\toptions: IObjectTreeModelOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.model = new IndexTreeModel(user, null, options);\n\t\tthis.onDidSpliceModel = this.model.onDidSpliceModel;\n\t\tthis.onDidSpliceRenderedNodes = this.model.onDidSpliceRenderedNodes;\n\t\tthis.onDidChangeCollapseState = this.model.onDidChangeCollapseState as Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\t\tthis.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount as Event<ITreeNode<T, TFilterData>>;\n\n\t\tif (options.sorter) {\n\t\t\tthis.sorter = {\n\t\t\t\tcompare(a, b) {\n\t\t\t\t\treturn options.sorter!.compare(a.element, b.element);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<IObjectTreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData> = {},\n\t): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis._setChildren(location, this.preserveCollapseState(children), options);\n\t}\n\n\tprivate _setChildren(\n\t\tlocation: number[],\n\t\tchildren: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData>,\n\t): void {\n\t\tconst insertedElements = new Set<T | null>();\n\t\tconst insertedElementIds = new Set<string>();\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tinsertedElements.add(tnode.element);\n\t\t\tthis.nodes.set(tnode.element, tnode);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(tnode.element).toString();\n\t\t\t\tinsertedElementIds.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, tnode);\n\t\t\t}\n\n\t\t\toptions.onDidCreateNode?.(tnode);\n\t\t};\n\n\t\tconst onDidDeleteNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tif (!insertedElements.has(tnode.element)) {\n\t\t\t\tthis.nodes.delete(tnode.element);\n\t\t\t}\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(tnode.element).toString();\n\t\t\t\tif (!insertedElementIds.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.onDidDeleteNode?.(tnode);\n\t\t};\n\n\t\tthis.model.splice(\n\t\t\t[...location, 0],\n\t\t\tNumber.MAX_VALUE,\n\t\t\tchildren,\n\t\t\t{ ...options, onDidCreateNode, onDidDeleteNode }\n\t\t);\n\t}\n\n\tprivate preserveCollapseState(elements: Iterable<IObjectTreeElement<T>> = Iterable.empty()): Iterable<ITreeElement<T>> {\n\t\tif (this.sorter) {\n\t\t\telements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn Iterable.map(elements, treeElement => {\n\t\t\tlet node = this.nodes.get(treeElement.element);\n\n\t\t\tif (!node && this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(treeElement.element).toString();\n\t\t\t\tnode = this.nodesByIdentity.get(id);\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\t\tif (typeof treeElement.collapsed === 'undefined') {\n\t\t\t\t\tcollapsed = undefined;\n\t\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed) {\n\t\t\t\t\tcollapsed = true;\n\t\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tcollapsed = false;\n\t\t\t\t} else {\n\t\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...treeElement,\n\t\t\t\t\tchildren: this.preserveCollapseState(treeElement.children),\n\t\t\t\t\tcollapsed\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\tif (typeof treeElement.collapsed === 'undefined' || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tcollapsed = node.collapsed;\n\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed) {\n\t\t\t\tcollapsed = true;\n\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded) {\n\t\t\t\tcollapsed = false;\n\t\t\t} else {\n\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...treeElement,\n\t\t\t\tcollapsible,\n\t\t\t\tcollapsed,\n\t\t\t\tchildren: this.preserveCollapseState(treeElement.children)\n\t\t\t};\n\t\t});\n\t}\n\n\trerender(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.rerender(location);\n\t}\n\n\tgetFirstElementChild(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getFirstElementChild(location);\n\t}\n\n\thas(element: T | null): boolean {\n\t\treturn this.nodes.has(element);\n\t}\n\n\tgetListIndex(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListIndex(location);\n\t}\n\n\tgetListRenderCount(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListRenderCount(location);\n\t}\n\n\tisCollapsible(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsible(location);\n\t}\n\n\tsetCollapsible(element: T | null, collapsible?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsible(location, collapsible);\n\t}\n\n\tisCollapsed(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsed(location);\n\t}\n\n\tsetCollapsed(element: T | null, collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsed(location, collapsed, recursive);\n\t}\n\n\texpandTo(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.expandTo(location);\n\t}\n\n\trefilter(): void {\n\t\tthis.model.refilter();\n\t}\n\n\tgetNode(element: T | null = null): ITreeNode<T | null, TFilterData> {\n\t\tif (element === null) {\n\t\t\treturn this.model.getNode(this.model.rootRef);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): T | null {\n\t\treturn node.element;\n\t}\n\n\tgetParentNodeLocation(element: T | null): T | null {\n\t\tif (element === null) {\n\t\t\tthrow new TreeError(this.user, `Invalid getParentNodeLocation call`);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\tconst location = this.model.getNodeLocation(node);\n\t\tconst parentLocation = this.model.getParentNodeLocation(location);\n\t\tconst parent = this.model.getNode(parentLocation);\n\n\t\treturn parent.element;\n\t}\n\n\tprivate getElementLocation(element: T | null): number[] {\n\t\tif (element === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn this.model.getNodeLocation(node);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from '../list/list.js';\nimport { IIndexTreeModelOptions, IIndexTreeModelSpliceOptions, IndexTreeModel } from './indexTreeModel.js';\nimport { ICollapseStateChangeEvent, IObjectTreeElement, ITreeElement, ITreeListSpliceData, ITreeModel, ITreeModelSpliceEvent, ITreeNode, ITreeSorter, ObjectTreeElementCollapseState, TreeError } from './tree.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\n\nexport interface IObjectTreeModel<T extends NonNullable<any>, TFilterData extends NonNullable<any> = void> extends ITreeModel<T | null, TFilterData, T | null> {\n\tsetChildren(element: T | null, children: Iterable<IObjectTreeElement<T>> | undefined, options?: IObjectTreeModelSetChildrenOptions<T, TFilterData>): void;\n}\n\nexport interface IObjectTreeModelSetChildrenOptions<T, TFilterData> extends IIndexTreeModelSpliceOptions<T, TFilterData> {\n}\n\nexport interface IObjectTreeModelOptions<T, TFilterData> extends IIndexTreeModelOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly identityProvider?: IIdentityProvider<T>;\n}\n\nexport class ObjectTreeModel<T extends NonNullable<any>, TFilterData extends NonNullable<any> = void> implements IObjectTreeModel<T, TFilterData> {\n\n\treadonly rootRef = null;\n\n\tprivate model: IndexTreeModel<T | null, TFilterData>;\n\tprivate nodes = new Map<T | null, ITreeNode<T, TFilterData>>();\n\tprivate readonly nodesByIdentity = new Map<string, ITreeNode<T, TFilterData>>();\n\tprivate readonly identityProvider?: IIdentityProvider<T>;\n\tprivate sorter?: ITreeSorter<{ element: T }>;\n\n\treadonly onDidSpliceModel: Event<ITreeModelSpliceEvent<T | null, TFilterData>>;\n\treadonly onDidSpliceRenderedNodes: Event<ITreeListSpliceData<T | null, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\tconstructor(\n\t\tprivate user: string,\n\t\toptions: IObjectTreeModelOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.model = new IndexTreeModel(user, null, options);\n\t\tthis.onDidSpliceModel = this.model.onDidSpliceModel;\n\t\tthis.onDidSpliceRenderedNodes = this.model.onDidSpliceRenderedNodes;\n\t\tthis.onDidChangeCollapseState = this.model.onDidChangeCollapseState as Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\t\tthis.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount as Event<ITreeNode<T, TFilterData>>;\n\n\t\tif (options.sorter) {\n\t\t\tthis.sorter = {\n\t\t\t\tcompare(a, b) {\n\t\t\t\t\treturn options.sorter!.compare(a.element, b.element);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: Iterable<IObjectTreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData> = {},\n\t): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis._setChildren(location, this.preserveCollapseState(children), options);\n\t}\n\n\tprivate _setChildren(\n\t\tlocation: number[],\n\t\tchildren: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IObjectTreeModelSetChildrenOptions<T, TFilterData>,\n\t): void {\n\t\tconst insertedElements = new Set<T | null>();\n\t\tconst insertedElementIds = new Set<string>();\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tinsertedElements.add(tnode.element);\n\t\t\tthis.nodes.set(tnode.element, tnode);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(tnode.element).toString();\n\t\t\t\tinsertedElementIds.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, tnode);\n\t\t\t}\n\n\t\t\toptions.onDidCreateNode?.(tnode);\n\t\t};\n\n\t\tconst onDidDeleteNode = (node: ITreeNode<T | null, TFilterData>) => {\n\t\t\tif (node.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tnode = node as ITreeNode<T, TFilterData>;\n\n\t\t\tif (!insertedElements.has(tnode.element)) {\n\t\t\t\tthis.nodes.delete(tnode.element);\n\t\t\t}\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(tnode.element).toString();\n\t\t\t\tif (!insertedElementIds.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.onDidDeleteNode?.(tnode);\n\t\t};\n\n\t\tthis.model.splice(\n\t\t\t[...location, 0],\n\t\t\tNumber.MAX_VALUE,\n\t\t\tchildren,\n\t\t\t{ ...options, onDidCreateNode, onDidDeleteNode }\n\t\t);\n\t}\n\n\tprivate preserveCollapseState(elements: Iterable<IObjectTreeElement<T>> = Iterable.empty()): Iterable<ITreeElement<T>> {\n\t\tif (this.sorter) {\n\t\t\telements = [...elements].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn Iterable.map(elements, treeElement => {\n\t\t\tlet node = this.nodes.get(treeElement.element);\n\n\t\t\tif (!node && this.identityProvider) {\n\t\t\t\tconst id = this.identityProvider.getId(treeElement.element).toString();\n\t\t\t\tnode = this.nodesByIdentity.get(id);\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\t\tif (typeof treeElement.collapsed === 'undefined') {\n\t\t\t\t\tcollapsed = undefined;\n\t\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed) {\n\t\t\t\t\tcollapsed = true;\n\t\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tcollapsed = false;\n\t\t\t\t} else {\n\t\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...treeElement,\n\t\t\t\t\tchildren: this.preserveCollapseState(treeElement.children),\n\t\t\t\t\tcollapsed\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n\t\t\tlet collapsed: boolean | undefined;\n\n\t\t\tif (typeof treeElement.collapsed === 'undefined' || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tcollapsed = node.collapsed;\n\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed) {\n\t\t\t\tcollapsed = true;\n\t\t\t} else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded) {\n\t\t\t\tcollapsed = false;\n\t\t\t} else {\n\t\t\t\tcollapsed = Boolean(treeElement.collapsed);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...treeElement,\n\t\t\t\tcollapsible,\n\t\t\t\tcollapsed,\n\t\t\t\tchildren: this.preserveCollapseState(treeElement.children)\n\t\t\t};\n\t\t});\n\t}\n\n\trerender(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.rerender(location);\n\t}\n\n\tgetFirstElementChild(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getFirstElementChild(location);\n\t}\n\n\thas(element: T | null): boolean {\n\t\treturn this.nodes.has(element);\n\t}\n\n\tgetListIndex(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListIndex(location);\n\t}\n\n\tgetListRenderCount(element: T | null): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListRenderCount(location);\n\t}\n\n\tisCollapsible(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsible(location);\n\t}\n\n\tsetCollapsible(element: T | null, collapsible?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsible(location, collapsible);\n\t}\n\n\tisCollapsed(element: T | null): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsed(location);\n\t}\n\n\tsetCollapsed(element: T | null, collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsed(location, collapsed, recursive);\n\t}\n\n\texpandTo(element: T | null): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.expandTo(location);\n\t}\n\n\trefilter(): void {\n\t\tthis.model.refilter();\n\t}\n\n\tgetNode(element: T | null = null): ITreeNode<T | null, TFilterData> {\n\t\tif (element === null) {\n\t\t\treturn this.model.getNode(this.model.rootRef);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): T | null {\n\t\treturn node.element;\n\t}\n\n\tgetParentNodeLocation(element: T | null): T | null {\n\t\tif (element === null) {\n\t\t\tthrow new TreeError(this.user, `Invalid getParentNodeLocation call`);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\tconst location = this.model.getNodeLocation(node);\n\t\tconst parentLocation = this.model.getParentNodeLocation(location);\n\t\tconst parent = this.model.getNode(parentLocation);\n\n\t\treturn parent.element;\n\t}\n\n\tprivate getElementLocation(element: T | null): number[] {\n\t\tif (element === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn this.model.getNodeLocation(node);\n\t}\n}\n"]}