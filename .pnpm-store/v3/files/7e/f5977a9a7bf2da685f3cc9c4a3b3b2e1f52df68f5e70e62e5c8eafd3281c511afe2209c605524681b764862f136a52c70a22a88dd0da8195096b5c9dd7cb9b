{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewModel/viewModelLines.ts","vs/editor/common/viewModel/viewModelLines.ts"],"names":[],"mappings":"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","file":"viewModelLines.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { WrappingIndent } from '../config/editorOptions.js';\nimport { FontInfo } from '../config/fontInfo.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IModelDecoration, IModelDeltaDecoration, ITextModel, PositionAffinity } from '../model.js';\nimport { IActiveIndentGuideInfo, BracketGuideOptions, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection, IModelLineProjection } from './modelLineProjection.js';\nimport { ILineBreaksComputer, ModelLineProjectionData, InjectedText, ILineBreaksComputerFactory } from '../modelLineProjectionData.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nimport { ICoordinatesConverter, IdentityCoordinatesConverter } from '../coordinatesConverter.js';\n\nexport interface IViewModelLines extends IDisposable {\n\tcreateCoordinatesConverter(): ICoordinatesConverter;\n\n\tsetWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean;\n\tsetTabSize(newTabSize: number): boolean;\n\tgetHiddenAreas(): Range[];\n\tsetHiddenAreas(_ranges: readonly Range[]): boolean;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\tonModelFlushed(): void;\n\tonModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null;\n\tonModelLinesInserted(versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null;\n\tonModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null];\n\tacceptVersionId(versionId: number): void;\n\n\tgetViewLineCount(): number;\n\tgetActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[];\n\tgetViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];\n\tgetViewLineContent(viewLineNumber: number): string;\n\tgetViewLineLength(viewLineNumber: number): number;\n\tgetViewLineMinColumn(viewLineNumber: number): number;\n\tgetViewLineMaxColumn(viewLineNumber: number): number;\n\tgetViewLineData(viewLineNumber: number): ViewLineData;\n\tgetViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null>;\n\n\tgetDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[];\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n}\n\nexport class ViewModelLinesFromProjectedModel implements IViewModelLines {\n\tprivate readonly _editorId: number;\n\tprivate readonly model: ITextModel;\n\tprivate _validModelVersionId: number;\n\n\tprivate readonly _domLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\tprivate readonly _monospaceLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\n\tprivate fontInfo: FontInfo;\n\tprivate tabSize: number;\n\tprivate wrappingColumn: number;\n\tprivate wrappingIndent: WrappingIndent;\n\tprivate wordBreak: 'normal' | 'keepAll';\n\tprivate wrappingStrategy: 'simple' | 'advanced';\n\tprivate wrapOnEscapedLineFeeds: boolean;\n\n\tprivate modelLineProjections!: IModelLineProjection[];\n\n\t/**\n\t * Reflects the sum of the line counts of all projected model lines.\n\t*/\n\tprivate projectedModelLineLineCounts!: ConstantTimePrefixSumComputer;\n\n\tprivate hiddenAreasDecorationIds!: string[];\n\n\tconstructor(\n\t\teditorId: number,\n\t\tmodel: ITextModel,\n\t\tdomLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tmonospaceLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingStrategy: 'simple' | 'advanced',\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: 'normal' | 'keepAll',\n\t\twrapOnEscapedLineFeeds: boolean\n\t) {\n\t\tthis._editorId = editorId;\n\t\tthis.model = model;\n\t\tthis._validModelVersionId = -1;\n\t\tthis._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n\t\tthis._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.tabSize = tabSize;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\t\tthis.wrapOnEscapedLineFeeds = wrapOnEscapedLineFeeds;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new CoordinatesConverter(this);\n\t}\n\n\tprivate _constructLines(resetHiddenAreas: boolean, previousLineBreaks: ((ModelLineProjectionData | null)[]) | null): void {\n\t\tthis.modelLineProjections = [];\n\n\t\tif (resetHiddenAreas) {\n\t\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t\t}\n\n\t\tconst linesContent = this.model.getLinesContent();\n\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n\t\tconst lineCount = linesContent.length;\n\t\tconst lineBreaksComputer = this.createLineBreaksComputer();\n\n\t\tconst injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n\t\t\tlineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n\t\t}\n\t\tconst linesBreaks = lineBreaksComputer.finalize();\n\n\t\tconst values: number[] = [];\n\n\t\tconst hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx]!.startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx]!.endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\t\t\t}\n\n\t\t\tconst isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n\t\t\tconst line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n\t\t\tvalues[i] = line.getViewLineCount();\n\t\t\tthis.modelLineProjections[i] = line;\n\t\t}\n\n\t\tthis._validModelVersionId = this.model.getVersionId();\n\n\t\tthis.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn this.hiddenAreasDecorationIds.map(\n\t\t\t(decId) => this.model.getDecorationRange(decId)!\n\t\t);\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\tconst validatedRanges = _ranges.map(r => this.model.validateRange(r));\n\t\tconst newRanges = normalizeLineRanges(validatedRanges);\n\n\t\t// TODO@Martin: Please stop calling this method on each model change!\n\n\t\t// This checks if there really was a change\n\t\tconst oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tif (newRanges.length === oldRanges.length) {\n\t\t\tlet hasDifference = false;\n\t\t\tfor (let i = 0; i < newRanges.length; i++) {\n\t\t\t\tif (!newRanges[i].equalsRange(oldRanges[i])) {\n\t\t\t\t\thasDifference = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasDifference) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst newDecorations = newRanges.map<IModelDeltaDecoration>(\n\t\t\t(r) =>\n\t\t\t({\n\t\t\t\trange: r,\n\t\t\t\toptions: ModelDecorationOptions.EMPTY,\n\t\t\t})\n\t\t);\n\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n\n\t\tconst hiddenAreas = newRanges;\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\n\t\tlet hasVisibleLine = false;\n\t\tfor (let i = 0; i < this.modelLineProjections.length; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\t\t\t}\n\n\t\t\tlet lineChanged = false;\n\t\t\tif (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n\t\t\t\t// Line should be hidden\n\t\t\t\tif (this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasVisibleLine = true;\n\t\t\t\t// Line should be visible\n\t\t\t\tif (!this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineChanged) {\n\t\t\t\tconst newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n\t\t\t\tthis.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasVisibleLine) {\n\t\t\t// Cannot have everything be hidden => reveal everything!\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic modelPositionIsVisible(modelLineNumber: number, _modelColumn: number): boolean {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].isVisible();\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn 1;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n\t}\n\n\tpublic setTabSize(newTabSize: number): boolean {\n\t\tif (this.tabSize === newTabSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.tabSize = newTabSize;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, null);\n\n\t\treturn true;\n\t}\n\n\tpublic setWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean {\n\t\tconst equalFontInfo = this.fontInfo.equals(fontInfo);\n\t\tconst equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n\t\tconst equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n\t\tconst equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n\t\tconst equalWordBreak = (this.wordBreak === wordBreak);\n\t\tif (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tlet previousLineBreaks: ((ModelLineProjectionData | null)[]) | null = null;\n\t\tif (onlyWrappingColumnChanged) {\n\t\t\tpreviousLineBreaks = [];\n\t\t\tfor (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n\t\t\t\tpreviousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n\t\t\t}\n\t\t}\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, previousLineBreaks);\n\n\t\treturn true;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst lineBreaksComputerFactory = (\n\t\t\tthis.wrappingStrategy === 'advanced'\n\t\t\t\t? this._domLineBreaksComputerFactory\n\t\t\t\t: this._monospaceLineBreaksComputerFactory\n\t\t);\n\t\treturn lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak, this.wrapOnEscapedLineFeeds);\n\t}\n\n\tpublic onModelFlushed(): void {\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic onModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\t\tconst outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n\n\t\tthis.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\t\tthis.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\n\t\treturn new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(versionId: number | null, fromLineNumber: number, _toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\t// cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\t\tconst isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\n\t\tlet totalOutputLineCount = 0;\n\t\tconst insertLines: IModelLineProjection[] = [];\n\t\tconst insertPrefixSumValues: number[] = [];\n\n\t\tfor (let i = 0, len = lineBreaks.length; i < len; i++) {\n\t\t\tconst line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n\t\t\tinsertLines.push(line);\n\n\t\t\tconst outputLineCount = line.getViewLineCount();\n\t\t\ttotalOutputLineCount += outputLineCount;\n\t\t\tinsertPrefixSumValues[i] = outputLineCount;\n\t\t}\n\n\t\t// TODO@Alex: use arrays.arrayInsert\n\t\tthis.modelLineProjections =\n\t\t\tthis.modelLineProjections.slice(0, fromLineNumber - 1)\n\t\t\t\t.concat(insertLines)\n\t\t\t\t.concat(this.modelLineProjections.slice(fromLineNumber - 1));\n\n\t\tthis.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n\n\t\treturn new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n\t}\n\n\tpublic onModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\tif (versionId !== null && versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn [false, null, null, null];\n\t\t}\n\n\t\tconst lineIndex = lineNumber - 1;\n\n\t\tconst oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\t\tconst isVisible = this.modelLineProjections[lineIndex].isVisible();\n\t\tconst line = createModelLineProjection(lineBreakData, isVisible);\n\t\tthis.modelLineProjections[lineIndex] = line;\n\t\tconst newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\n\t\tlet lineMappingChanged = false;\n\t\tlet changeFrom = 0;\n\t\tlet changeTo = -1;\n\t\tlet insertFrom = 0;\n\t\tlet insertTo = -1;\n\t\tlet deleteFrom = 0;\n\t\tlet deleteTo = -1;\n\n\t\tif (oldOutputLineCount > newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t\tdeleteFrom = changeTo + 1;\n\t\t\tdeleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else if (oldOutputLineCount < newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + oldOutputLineCount - 1;\n\t\t\tinsertFrom = changeTo + 1;\n\t\t\tinsertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t}\n\n\t\tthis.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n\n\t\tconst viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n\t\tconst viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n\t\tconst viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n\n\t\treturn [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n\t}\n\n\tpublic acceptVersionId(versionId: number): void {\n\t\tthis._validModelVersionId = versionId;\n\t\tif (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n\t\t\t// At least one line must be visible => reset hidden areas\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.projectedModelLineLineCounts.getTotalSum();\n\t}\n\n\tprivate _toValidViewLineNumber(viewLineNumber: number): number {\n\t\tif (viewLineNumber < 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst viewLineCount = this.getViewLineCount();\n\t\tif (viewLineNumber > viewLineCount) {\n\t\t\treturn viewLineCount;\n\t\t}\n\t\treturn viewLineNumber | 0;\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tminLineNumber = this._toValidViewLineNumber(minLineNumber);\n\t\tmaxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n\n\t\tconst modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n\t\tconst modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n\t\tconst modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n\t\tconst result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n\n\t\tconst viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n\t\tconst viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n\t\treturn {\n\t\t\tstartLineNumber: viewStartPosition.lineNumber,\n\t\t\tendLineNumber: viewEndPosition.lineNumber,\n\t\t\tindent: result.indent\n\t\t};\n\t}\n\n\t// #region ViewLineInfo\n\n\tprivate getViewLineInfo(viewLineNumber: number): ViewLineInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\t\treturn new ViewLineInfo(lineIndex + 1, remainder);\n\t}\n\n\tprivate getMinColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getMaxColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getModelStartPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst minViewColumn = line.getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tminViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getModelEndPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst maxViewColumn = line.getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tmaxViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getViewLineInfosGroupedByModelRanges(viewStartLineNumber: number, viewEndLineNumber: number): ViewLineInfoGroupedByModelRange[] {\n\t\tconst startViewLine = this.getViewLineInfo(viewStartLineNumber);\n\t\tconst endViewLine = this.getViewLineInfo(viewEndLineNumber);\n\n\t\tconst result = new Array<ViewLineInfoGroupedByModelRange>();\n\t\tlet lastVisibleModelPos: Position | null = this.getModelStartPositionOfViewLine(startViewLine);\n\t\tlet viewLines = new Array<ViewLineInfo>();\n\n\t\tfor (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n\t\t\tconst line = this.modelLineProjections[curModelLine - 1];\n\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst startOffset =\n\t\t\t\t\tcurModelLine === startViewLine.modelLineNumber\n\t\t\t\t\t\t? startViewLine.modelLineWrappedLineIdx\n\t\t\t\t\t\t: 0;\n\n\t\t\t\tconst endOffset =\n\t\t\t\t\tcurModelLine === endViewLine.modelLineNumber\n\t\t\t\t\t\t? endViewLine.modelLineWrappedLineIdx + 1\n\t\t\t\t\t\t: line.getViewLineCount();\n\n\t\t\t\tfor (let i = startOffset; i < endOffset; i++) {\n\t\t\t\t\tviewLines.push(new ViewLineInfo(curModelLine, i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!line.isVisible() && lastVisibleModelPos) {\n\t\t\t\tconst lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n\n\t\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n\t\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t\t\tviewLines = [];\n\n\t\t\t\tlastVisibleModelPos = null;\n\t\t\t} else if (line.isVisible() && !lastVisibleModelPos) {\n\t\t\t\tlastVisibleModelPos = new Position(curModelLine, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (lastVisibleModelPos) {\n\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// #endregion\n\n\tpublic getViewLinesBracketGuides(viewStartLineNumber: number, viewEndLineNumber: number, activeViewPosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][] {\n\t\tconst modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n\t\tconst resultPerViewLine: IndentGuide[][] = [];\n\n\t\tfor (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n\t\t\tconst modelRangeStartLineNumber = group.modelRange.startLineNumber;\n\n\t\t\tconst bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(\n\t\t\t\tmodelRangeStartLineNumber,\n\t\t\t\tgroup.modelRange.endLineNumber,\n\t\t\t\tmodelActivePosition,\n\t\t\t\toptions\n\t\t\t);\n\n\t\t\tfor (const viewLineInfo of group.viewLines) {\n\n\t\t\t\tconst bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n\n\t\t\t\t// visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n\t\t\t\t// model-columns must be converted to view-model columns.\n\t\t\t\tconst result = bracketGuides.map(g => {\n\t\t\t\t\tif (g.forWrappedLinesAfterColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n\t\t\t\t\t\tif (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n\t\t\t\t\t\tif (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!g.horizontalLine) {\n\t\t\t\t\t\treturn g;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet column = -1;\n\t\t\t\t\tif (g.column !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n\t\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = p.column;\n\t\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = this.getMinColumnOfViewLine(viewLineInfo);\n\t\t\t\t\t\t} else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tviewPosition.column),\n\t\t\t\t\t\t\t- 1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (g.visibleColumn !== -1) {\n\t\t\t\t\t\t\t// Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tthis.getMaxColumnOfViewLine(viewLineInfo)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresultPerViewLine.push(result.filter((r): r is IndentGuide => !!r));\n\n\t\t\t}\n\t\t}\n\n\t\treturn resultPerViewLine;\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\t// TODO: Use the same code as in `getViewLinesBracketGuides`.\n\t\t// Future TODO: Merge with `getViewLinesBracketGuides`.\n\t\t// However, this requires more refactoring of indent guides.\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n\n\t\tlet result: number[] = [];\n\t\tconst resultRepeatCount: number[] = [];\n\t\tconst resultRepeatOption: IndentGuideRepeatOption[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\tconst viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n\t\t\t\tconst count = viewLineEndIndex - viewLineStartIndex + 1;\n\t\t\t\tlet option = IndentGuideRepeatOption.BlockNone;\n\t\t\t\tif (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n\t\t\t\t\t// wrapped lines should block indent guides\n\t\t\t\t\toption = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n\t\t\t\t}\n\t\t\t\tresultRepeatCount.push(count);\n\t\t\t\tresultRepeatOption.push(option);\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst viewIndents = new Array<number>(viewLineCount);\n\t\tlet currIndex = 0;\n\t\tfor (let i = 0, len = result.length; i < len; i++) {\n\t\t\tlet value = result[i];\n\t\t\tconst count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n\t\t\tconst option = resultRepeatOption[i];\n\t\t\tlet blockAtIndex: number;\n\t\t\tif (option === IndentGuideRepeatOption.BlockAll) {\n\t\t\t\tblockAtIndex = 0;\n\t\t\t} else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n\t\t\t\tblockAtIndex = 1;\n\t\t\t} else {\n\t\t\t\tblockAtIndex = count;\n\t\t\t}\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tif (j === blockAtIndex) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\t\t\t\tviewIndents[currIndex++] = value;\n\t\t\t}\n\t\t}\n\t\treturn viewIndents;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): ViewLineData[] {\n\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n\t\tlet viewLineNumber = viewStartLineNumber;\n\t\tconst startModelLineIndex = start.index;\n\t\tconst startRemainder = start.remainder;\n\n\t\tconst result: ViewLineData[] = [];\n\t\tfor (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (!line.isVisible()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n\t\t\tlet remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n\n\t\t\tlet lastLine = false;\n\t\t\tif (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n\t\t\t\tlastLine = true;\n\t\t\t\tremainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n\t\t\t}\n\n\t\t\tline.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n\n\t\t\tviewLineNumber += remainingViewLineCount;\n\n\t\t\tif (lastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic validateViewPosition(viewLineNumber: number, viewColumn: number, expectedModelPosition: Position): Position {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\n\t\tconst line = this.modelLineProjections[lineIndex];\n\n\t\tconst minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n\t\tconst maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\t\tif (viewColumn < minColumn) {\n\t\t\tviewColumn = minColumn;\n\t\t}\n\t\tif (viewColumn > maxColumn) {\n\t\t\tviewColumn = maxColumn;\n\t\t}\n\n\t\tconst computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n\t\tconst computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n\t\tif (computedModelPosition.equals(expectedModelPosition)) {\n\t\t\treturn new Position(viewLineNumber, viewColumn);\n\t\t}\n\n\t\treturn this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\tconst validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n\t\tconst validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n\t\treturn new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n\t}\n\n\tpublic convertViewPositionToModelPosition(viewLineNumber: number, viewColumn: number): Position {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\n\t\tconst inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n\t\t// console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\t\treturn this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\tconst start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n\t\tconst end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\tpublic convertModelPositionToViewPosition(_modelLineNumber: number, _modelColumn: number, affinity: PositionAffinity = PositionAffinity.None, allowZeroLineNumber: boolean = false, belowHiddenRanges: boolean = false): Position {\n\n\t\tconst validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n\t\tconst inputLineNumber = validPosition.lineNumber;\n\t\tconst inputColumn = validPosition.column;\n\n\t\tlet lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n\t\tif (belowHiddenRanges) {\n\t\t\twhile (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex++;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex--;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n\t\t\t// TODO@alexdima@hediet this isn't soo pretty\n\t\t\treturn new Position(allowZeroLineNumber ? 0 : 1, 1);\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\n\t\tlet r: Position;\n\t\tif (lineIndexChanged) {\n\t\t\tif (belowHiddenRanges) {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n\t\t\t} else {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n\t\t\t}\n\t\t} else {\n\t\t\tr = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n\t\t}\n\n\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\t\treturn r;\n\t}\n\n\t/**\n\t * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n\t*/\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity: PositionAffinity = PositionAffinity.Left): Range {\n\t\tif (modelRange.isEmpty()) {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n\t\t\treturn Range.fromPositions(start);\n\t\t} else {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, PositionAffinity.Right);\n\t\t\tconst end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, PositionAffinity.Left);\n\t\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t\t}\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\tlet lineIndex = modelLineNumber - 1;\n\t\tif (this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// this model line is visible\n\t\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n\t\t}\n\n\t\t// this model line is not visible\n\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\tlineIndex--;\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\treturn 1;\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\tconst modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n\t\tif (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n\t\t\t// most likely there are no hidden lines => fast path\n\t\t\t// fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n\t\t\treturn this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations, onlyMarginDecorations);\n\t\t}\n\n\t\tlet result: IModelDecoration[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tconst maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n\t\t\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tresult.sort((a, b) => {\n\t\t\tconst res = Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\tif (res === 0) {\n\t\t\t\tif (a.id < b.id) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.id > b.id) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\n\t\t// Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\t\tconst finalResult: IModelDecoration[] = [];\n\t\tlet finalResultLen = 0;\n\t\tlet prevDecId: string | null = null;\n\t\tfor (const dec of result) {\n\t\t\tconst decId = dec.id;\n\t\t\tif (prevDecId === decId) {\n\t\t\t\t// skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprevDecId = decId;\n\t\t\tfinalResult[finalResultLen++] = dec;\n\t\t}\n\n\t\treturn finalResult;\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(lineNumber);\n\t\tif (info.modelLineWrappedLineIdx === 0) {\n\t\t\treturn this.model.getLineIndentColumn(info.modelLineNumber);\n\t\t}\n\n\t\t// wrapped lines have no indentation.\n\t\t// We deliberately don't handle the case that indentation is wrapped\n\t\t// to avoid two view lines reporting indentation for the very same model line.\n\t\treturn 0;\n\t}\n}\n\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges: Range[]): Range[] {\n\tif (ranges.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst sortedRanges = ranges.slice();\n\tsortedRanges.sort(Range.compareRangesUsingStarts);\n\n\tconst result: Range[] = [];\n\tlet currentRangeStart = sortedRanges[0].startLineNumber;\n\tlet currentRangeEnd = sortedRanges[0].endLineNumber;\n\n\tfor (let i = 1, len = sortedRanges.length; i < len; i++) {\n\t\tconst range = sortedRanges[i];\n\n\t\tif (range.startLineNumber > currentRangeEnd + 1) {\n\t\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\t\tcurrentRangeStart = range.startLineNumber;\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t} else if (range.endLineNumber > currentRangeEnd) {\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t}\n\t}\n\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\treturn result;\n}\n\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n\n\tconstructor(\n\t\tpublic readonly modelLineNumber: number,\n\t\tpublic readonly modelLineWrappedLineIdx: number,\n\t) { }\n}\n\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n\tconstructor(public readonly modelRange: Range, public readonly viewLines: ViewLineInfo[]) {\n\t}\n}\n\nclass CoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromProjectedModel;\n\n\tconstructor(lines: ViewModelLinesFromProjectedModel) {\n\t\tthis._lines = lines;\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._lines.convertViewRangeToModelRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\treturn this._lines.validateViewRange(viewRange, expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position, affinity?: PositionAffinity, allowZero?: boolean, belowHiddenRanges?: boolean): Position {\n\t\treturn this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity?: PositionAffinity): Range {\n\t\treturn this._lines.convertModelRangeToViewRange(modelRange, affinity);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\treturn this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn this._lines.getModelLineViewLineCount(modelLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\treturn this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n\t}\n}\n\nconst enum IndentGuideRepeatOption {\n\tBlockNone = 0,\n\tBlockSubsequent = 1,\n\tBlockAll = 2\n}\n\nexport class ViewModelLinesFromModelAsIs implements IViewModelLines {\n\tpublic readonly model: ITextModel;\n\n\tconstructor(model: ITextModel) {\n\t\tthis.model = model;\n\t}\n\n\tpublic dispose(): void {\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new IdentityCoordinatesConverter(this.model);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn [];\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setTabSize(_newTabSize: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setWrappingSettings(_fontInfo: FontInfo, _wrappingStrategy: 'simple' | 'advanced', _wrappingColumn: number, _wrappingIndent: WrappingIndent): boolean {\n\t\treturn false;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst result: null[] = [];\n\t\treturn {\n\t\t\taddRequest: (lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null) => {\n\t\t\t\tresult.push(null);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic onModelFlushed(): void {\n\t}\n\n\tpublic onModelLinesDeleted(_versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\treturn new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(_versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\treturn new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLineChanged(_versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\treturn [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n\t}\n\n\tpublic acceptVersionId(_versionId: number): void {\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.model.getLineCount();\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, _minLineNumber: number, _maxLineNumber: number): IActiveIndentGuideInfo {\n\t\treturn {\n\t\t\tstartLineNumber: viewLineNumber,\n\t\t\tendLineNumber: viewLineNumber,\n\t\t\tindent: 0\n\t\t};\n\t}\n\n\tpublic getViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null): IndentGuide[][] {\n\t\treturn new Array(endLineNumber - startLineNumber + 1).fill([]);\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst result = new Array<number>(viewLineCount);\n\t\tfor (let i = 0; i < viewLineCount; i++) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\treturn this.model.getLineContent(viewLineNumber);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\treturn this.model.getLineLength(viewLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMinColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMaxColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull\n\t\t);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null> {\n\t\tconst lineCount = this.model.getLineCount();\n\t\tviewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n\t\tviewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n\n\t\tconst result: Array<ViewLineData | null> = [];\n\t\tfor (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n\t\t\tconst idx = lineNumber - viewStartLineNumber;\n\t\t\tresult[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\treturn this.model.getDecorationsInRange(range, ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations, onlyMarginDecorations);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\treturn this.model.normalizePosition(position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\treturn this.model.getLineIndentColumn(lineNumber);\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\t// Identity lines collection does not support injected text.\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { WrappingIndent } from '../config/editorOptions.js';\nimport { FontInfo } from '../config/fontInfo.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IModelDecoration, IModelDeltaDecoration, ITextModel, PositionAffinity } from '../model.js';\nimport { IActiveIndentGuideInfo, BracketGuideOptions, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection, IModelLineProjection } from './modelLineProjection.js';\nimport { ILineBreaksComputer, ModelLineProjectionData, InjectedText, ILineBreaksComputerFactory } from '../modelLineProjectionData.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nimport { ICoordinatesConverter, IdentityCoordinatesConverter } from '../coordinatesConverter.js';\n\nexport interface IViewModelLines extends IDisposable {\n\tcreateCoordinatesConverter(): ICoordinatesConverter;\n\n\tsetWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean;\n\tsetTabSize(newTabSize: number): boolean;\n\tgetHiddenAreas(): Range[];\n\tsetHiddenAreas(_ranges: readonly Range[]): boolean;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\tonModelFlushed(): void;\n\tonModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null;\n\tonModelLinesInserted(versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null;\n\tonModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null];\n\tacceptVersionId(versionId: number): void;\n\n\tgetViewLineCount(): number;\n\tgetActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[];\n\tgetViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];\n\tgetViewLineContent(viewLineNumber: number): string;\n\tgetViewLineLength(viewLineNumber: number): number;\n\tgetViewLineMinColumn(viewLineNumber: number): number;\n\tgetViewLineMaxColumn(viewLineNumber: number): number;\n\tgetViewLineData(viewLineNumber: number): ViewLineData;\n\tgetViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null>;\n\n\tgetDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[];\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n}\n\nexport class ViewModelLinesFromProjectedModel implements IViewModelLines {\n\tprivate readonly _editorId: number;\n\tprivate readonly model: ITextModel;\n\tprivate _validModelVersionId: number;\n\n\tprivate readonly _domLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\tprivate readonly _monospaceLineBreaksComputerFactory: ILineBreaksComputerFactory;\n\n\tprivate fontInfo: FontInfo;\n\tprivate tabSize: number;\n\tprivate wrappingColumn: number;\n\tprivate wrappingIndent: WrappingIndent;\n\tprivate wordBreak: 'normal' | 'keepAll';\n\tprivate wrappingStrategy: 'simple' | 'advanced';\n\tprivate wrapOnEscapedLineFeeds: boolean;\n\n\tprivate modelLineProjections!: IModelLineProjection[];\n\n\t/**\n\t * Reflects the sum of the line counts of all projected model lines.\n\t*/\n\tprivate projectedModelLineLineCounts!: ConstantTimePrefixSumComputer;\n\n\tprivate hiddenAreasDecorationIds!: string[];\n\n\tconstructor(\n\t\teditorId: number,\n\t\tmodel: ITextModel,\n\t\tdomLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tmonospaceLineBreaksComputerFactory: ILineBreaksComputerFactory,\n\t\tfontInfo: FontInfo,\n\t\ttabSize: number,\n\t\twrappingStrategy: 'simple' | 'advanced',\n\t\twrappingColumn: number,\n\t\twrappingIndent: WrappingIndent,\n\t\twordBreak: 'normal' | 'keepAll',\n\t\twrapOnEscapedLineFeeds: boolean\n\t) {\n\t\tthis._editorId = editorId;\n\t\tthis.model = model;\n\t\tthis._validModelVersionId = -1;\n\t\tthis._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n\t\tthis._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.tabSize = tabSize;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\t\tthis.wrapOnEscapedLineFeeds = wrapOnEscapedLineFeeds;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new CoordinatesConverter(this);\n\t}\n\n\tprivate _constructLines(resetHiddenAreas: boolean, previousLineBreaks: ((ModelLineProjectionData | null)[]) | null): void {\n\t\tthis.modelLineProjections = [];\n\n\t\tif (resetHiddenAreas) {\n\t\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n\t\t}\n\n\t\tconst linesContent = this.model.getLinesContent();\n\t\tconst injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n\t\tconst lineCount = linesContent.length;\n\t\tconst lineBreaksComputer = this.createLineBreaksComputer();\n\n\t\tconst injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n\t\t\tlineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n\t\t}\n\t\tconst linesBreaks = lineBreaksComputer.finalize();\n\n\t\tconst values: number[] = [];\n\n\t\tconst hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx]!.startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx]!.endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\t\t\t}\n\n\t\t\tconst isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n\t\t\tconst line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n\t\t\tvalues[i] = line.getViewLineCount();\n\t\t\tthis.modelLineProjections[i] = line;\n\t\t}\n\n\t\tthis._validModelVersionId = this.model.getVersionId();\n\n\t\tthis.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn this.hiddenAreasDecorationIds.map(\n\t\t\t(decId) => this.model.getDecorationRange(decId)!\n\t\t);\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\tconst validatedRanges = _ranges.map(r => this.model.validateRange(r));\n\t\tconst newRanges = normalizeLineRanges(validatedRanges);\n\n\t\t// TODO@Martin: Please stop calling this method on each model change!\n\n\t\t// This checks if there really was a change\n\t\tconst oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tif (newRanges.length === oldRanges.length) {\n\t\t\tlet hasDifference = false;\n\t\t\tfor (let i = 0; i < newRanges.length; i++) {\n\t\t\t\tif (!newRanges[i].equalsRange(oldRanges[i])) {\n\t\t\t\t\thasDifference = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasDifference) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst newDecorations = newRanges.map<IModelDeltaDecoration>(\n\t\t\t(r) =>\n\t\t\t({\n\t\t\t\trange: r,\n\t\t\t\toptions: ModelDecorationOptions.EMPTY,\n\t\t\t})\n\t\t);\n\n\t\tthis.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n\n\t\tconst hiddenAreas = newRanges;\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\n\t\tlet hasVisibleLine = false;\n\t\tfor (let i = 0; i < this.modelLineProjections.length; i++) {\n\t\t\tconst lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n\t\t\t}\n\n\t\t\tlet lineChanged = false;\n\t\t\tif (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n\t\t\t\t// Line should be hidden\n\t\t\t\tif (this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasVisibleLine = true;\n\t\t\t\t// Line should be visible\n\t\t\t\tif (!this.modelLineProjections[i].isVisible()) {\n\t\t\t\t\tthis.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineChanged) {\n\t\t\t\tconst newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n\t\t\t\tthis.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasVisibleLine) {\n\t\t\t// Cannot have everything be hidden => reveal everything!\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic modelPositionIsVisible(modelLineNumber: number, _modelColumn: number): boolean {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].isVisible();\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n\t\t\t// invalid arguments\n\t\t\treturn 1;\n\t\t}\n\t\treturn this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n\t}\n\n\tpublic setTabSize(newTabSize: number): boolean {\n\t\tif (this.tabSize === newTabSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.tabSize = newTabSize;\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, null);\n\n\t\treturn true;\n\t}\n\n\tpublic setWrappingSettings(fontInfo: FontInfo, wrappingStrategy: 'simple' | 'advanced', wrappingColumn: number, wrappingIndent: WrappingIndent, wordBreak: 'normal' | 'keepAll'): boolean {\n\t\tconst equalFontInfo = this.fontInfo.equals(fontInfo);\n\t\tconst equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n\t\tconst equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n\t\tconst equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n\t\tconst equalWordBreak = (this.wordBreak === wordBreak);\n\t\tif (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n\n\t\tthis.fontInfo = fontInfo;\n\t\tthis.wrappingStrategy = wrappingStrategy;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wordBreak = wordBreak;\n\n\t\tlet previousLineBreaks: ((ModelLineProjectionData | null)[]) | null = null;\n\t\tif (onlyWrappingColumnChanged) {\n\t\t\tpreviousLineBreaks = [];\n\t\t\tfor (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n\t\t\t\tpreviousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n\t\t\t}\n\t\t}\n\n\t\tthis._constructLines(/*resetHiddenAreas*/false, previousLineBreaks);\n\n\t\treturn true;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst lineBreaksComputerFactory = (\n\t\t\tthis.wrappingStrategy === 'advanced'\n\t\t\t\t? this._domLineBreaksComputerFactory\n\t\t\t\t: this._monospaceLineBreaksComputerFactory\n\t\t);\n\t\treturn lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak, this.wrapOnEscapedLineFeeds);\n\t}\n\n\tpublic onModelFlushed(): void {\n\t\tthis._constructLines(/*resetHiddenAreas*/true, null);\n\t}\n\n\tpublic onModelLinesDeleted(versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\t\tconst outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n\n\t\tthis.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\t\tthis.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\n\t\treturn new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(versionId: number | null, fromLineNumber: number, _toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\tif (!versionId || versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\t// cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\t\tconst isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n\n\t\tconst outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n\n\t\tlet totalOutputLineCount = 0;\n\t\tconst insertLines: IModelLineProjection[] = [];\n\t\tconst insertPrefixSumValues: number[] = [];\n\n\t\tfor (let i = 0, len = lineBreaks.length; i < len; i++) {\n\t\t\tconst line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n\t\t\tinsertLines.push(line);\n\n\t\t\tconst outputLineCount = line.getViewLineCount();\n\t\t\ttotalOutputLineCount += outputLineCount;\n\t\t\tinsertPrefixSumValues[i] = outputLineCount;\n\t\t}\n\n\t\t// TODO@Alex: use arrays.arrayInsert\n\t\tthis.modelLineProjections =\n\t\t\tthis.modelLineProjections.slice(0, fromLineNumber - 1)\n\t\t\t\t.concat(insertLines)\n\t\t\t\t.concat(this.modelLineProjections.slice(fromLineNumber - 1));\n\n\t\tthis.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n\n\t\treturn new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n\t}\n\n\tpublic onModelLineChanged(versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\tif (versionId !== null && versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn [false, null, null, null];\n\t\t}\n\n\t\tconst lineIndex = lineNumber - 1;\n\n\t\tconst oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\t\tconst isVisible = this.modelLineProjections[lineIndex].isVisible();\n\t\tconst line = createModelLineProjection(lineBreakData, isVisible);\n\t\tthis.modelLineProjections[lineIndex] = line;\n\t\tconst newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n\n\t\tlet lineMappingChanged = false;\n\t\tlet changeFrom = 0;\n\t\tlet changeTo = -1;\n\t\tlet insertFrom = 0;\n\t\tlet insertTo = -1;\n\t\tlet deleteFrom = 0;\n\t\tlet deleteTo = -1;\n\n\t\tif (oldOutputLineCount > newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t\tdeleteFrom = changeTo + 1;\n\t\t\tdeleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else if (oldOutputLineCount < newOutputLineCount) {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + oldOutputLineCount - 1;\n\t\t\tinsertFrom = changeTo + 1;\n\t\t\tinsertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else {\n\t\t\tchangeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t}\n\n\t\tthis.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n\n\t\tconst viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n\t\tconst viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n\t\tconst viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n\n\t\treturn [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n\t}\n\n\tpublic acceptVersionId(versionId: number): void {\n\t\tthis._validModelVersionId = versionId;\n\t\tif (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n\t\t\t// At least one line must be visible => reset hidden areas\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.projectedModelLineLineCounts.getTotalSum();\n\t}\n\n\tprivate _toValidViewLineNumber(viewLineNumber: number): number {\n\t\tif (viewLineNumber < 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst viewLineCount = this.getViewLineCount();\n\t\tif (viewLineNumber > viewLineCount) {\n\t\t\treturn viewLineCount;\n\t\t}\n\t\treturn viewLineNumber | 0;\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tminLineNumber = this._toValidViewLineNumber(minLineNumber);\n\t\tmaxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n\n\t\tconst modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n\t\tconst modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n\t\tconst modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n\t\tconst result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n\n\t\tconst viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n\t\tconst viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n\t\treturn {\n\t\t\tstartLineNumber: viewStartPosition.lineNumber,\n\t\t\tendLineNumber: viewEndPosition.lineNumber,\n\t\t\tindent: result.indent\n\t\t};\n\t}\n\n\t// #region ViewLineInfo\n\n\tprivate getViewLineInfo(viewLineNumber: number): ViewLineInfo {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\t\treturn new ViewLineInfo(lineIndex + 1, remainder);\n\t}\n\n\tprivate getMinColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getMaxColumnOfViewLine(viewLineInfo: ViewLineInfo): number {\n\t\treturn this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t}\n\n\tprivate getModelStartPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst minViewColumn = line.getViewLineMinColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tminViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getModelEndPositionOfViewLine(viewLineInfo: ViewLineInfo): Position {\n\t\tconst line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n\t\tconst maxViewColumn = line.getViewLineMaxColumn(\n\t\t\tthis.model,\n\t\t\tviewLineInfo.modelLineNumber,\n\t\t\tviewLineInfo.modelLineWrappedLineIdx\n\t\t);\n\t\tconst column = line.getModelColumnOfViewPosition(\n\t\t\tviewLineInfo.modelLineWrappedLineIdx,\n\t\t\tmaxViewColumn\n\t\t);\n\t\treturn new Position(viewLineInfo.modelLineNumber, column);\n\t}\n\n\tprivate getViewLineInfosGroupedByModelRanges(viewStartLineNumber: number, viewEndLineNumber: number): ViewLineInfoGroupedByModelRange[] {\n\t\tconst startViewLine = this.getViewLineInfo(viewStartLineNumber);\n\t\tconst endViewLine = this.getViewLineInfo(viewEndLineNumber);\n\n\t\tconst result = new Array<ViewLineInfoGroupedByModelRange>();\n\t\tlet lastVisibleModelPos: Position | null = this.getModelStartPositionOfViewLine(startViewLine);\n\t\tlet viewLines = new Array<ViewLineInfo>();\n\n\t\tfor (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n\t\t\tconst line = this.modelLineProjections[curModelLine - 1];\n\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst startOffset =\n\t\t\t\t\tcurModelLine === startViewLine.modelLineNumber\n\t\t\t\t\t\t? startViewLine.modelLineWrappedLineIdx\n\t\t\t\t\t\t: 0;\n\n\t\t\t\tconst endOffset =\n\t\t\t\t\tcurModelLine === endViewLine.modelLineNumber\n\t\t\t\t\t\t? endViewLine.modelLineWrappedLineIdx + 1\n\t\t\t\t\t\t: line.getViewLineCount();\n\n\t\t\t\tfor (let i = startOffset; i < endOffset; i++) {\n\t\t\t\t\tviewLines.push(new ViewLineInfo(curModelLine, i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!line.isVisible() && lastVisibleModelPos) {\n\t\t\t\tconst lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n\n\t\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n\t\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t\t\tviewLines = [];\n\n\t\t\t\tlastVisibleModelPos = null;\n\t\t\t} else if (line.isVisible() && !lastVisibleModelPos) {\n\t\t\t\tlastVisibleModelPos = new Position(curModelLine, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (lastVisibleModelPos) {\n\t\t\tconst modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n\t\t\tresult.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// #endregion\n\n\tpublic getViewLinesBracketGuides(viewStartLineNumber: number, viewEndLineNumber: number, activeViewPosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][] {\n\t\tconst modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n\t\tconst resultPerViewLine: IndentGuide[][] = [];\n\n\t\tfor (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n\t\t\tconst modelRangeStartLineNumber = group.modelRange.startLineNumber;\n\n\t\t\tconst bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(\n\t\t\t\tmodelRangeStartLineNumber,\n\t\t\t\tgroup.modelRange.endLineNumber,\n\t\t\t\tmodelActivePosition,\n\t\t\t\toptions\n\t\t\t);\n\n\t\t\tfor (const viewLineInfo of group.viewLines) {\n\n\t\t\t\tconst bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n\n\t\t\t\t// visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n\t\t\t\t// model-columns must be converted to view-model columns.\n\t\t\t\tconst result = bracketGuides.map(g => {\n\t\t\t\t\tif (g.forWrappedLinesAfterColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n\t\t\t\t\t\tif (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n\t\t\t\t\t\tif (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!g.horizontalLine) {\n\t\t\t\t\t\treturn g;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet column = -1;\n\t\t\t\t\tif (g.column !== -1) {\n\t\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n\t\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = p.column;\n\t\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\tcolumn = this.getMinColumnOfViewLine(viewLineInfo);\n\t\t\t\t\t\t} else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n\t\t\t\t\tconst p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n\t\t\t\t\tif (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tviewPosition.column),\n\t\t\t\t\t\t\t- 1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (g.visibleColumn !== -1) {\n\t\t\t\t\t\t\t// Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new IndentGuide(g.visibleColumn, column, g.className,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(g.horizontalLine.top,\n\t\t\t\t\t\t\t\tthis.getMaxColumnOfViewLine(viewLineInfo)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresultPerViewLine.push(result.filter((r): r is IndentGuide => !!r));\n\n\t\t\t}\n\t\t}\n\n\t\treturn resultPerViewLine;\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\t// TODO: Use the same code as in `getViewLinesBracketGuides`.\n\t\t// Future TODO: Merge with `getViewLinesBracketGuides`.\n\t\t// However, this requires more refactoring of indent guides.\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n\n\t\tlet result: number[] = [];\n\t\tconst resultRepeatCount: number[] = [];\n\t\tconst resultRepeatOption: IndentGuideRepeatOption[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\tconst viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\tconst viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n\t\t\t\tconst count = viewLineEndIndex - viewLineStartIndex + 1;\n\t\t\t\tlet option = IndentGuideRepeatOption.BlockNone;\n\t\t\t\tif (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n\t\t\t\t\t// wrapped lines should block indent guides\n\t\t\t\t\toption = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n\t\t\t\t}\n\t\t\t\tresultRepeatCount.push(count);\n\t\t\t\tresultRepeatOption.push(option);\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst viewIndents = new Array<number>(viewLineCount);\n\t\tlet currIndex = 0;\n\t\tfor (let i = 0, len = result.length; i < len; i++) {\n\t\t\tlet value = result[i];\n\t\t\tconst count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n\t\t\tconst option = resultRepeatOption[i];\n\t\t\tlet blockAtIndex: number;\n\t\t\tif (option === IndentGuideRepeatOption.BlockAll) {\n\t\t\t\tblockAtIndex = 0;\n\t\t\t} else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n\t\t\t\tblockAtIndex = 1;\n\t\t\t} else {\n\t\t\t\tblockAtIndex = count;\n\t\t\t}\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tif (j === blockAtIndex) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\t\t\t\tviewIndents[currIndex++] = value;\n\t\t\t}\n\t\t}\n\t\treturn viewIndents;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): ViewLineData[] {\n\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n\t\tlet viewLineNumber = viewStartLineNumber;\n\t\tconst startModelLineIndex = start.index;\n\t\tconst startRemainder = start.remainder;\n\n\t\tconst result: ViewLineData[] = [];\n\t\tfor (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (!line.isVisible()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n\t\t\tlet remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n\n\t\t\tlet lastLine = false;\n\t\t\tif (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n\t\t\t\tlastLine = true;\n\t\t\t\tremainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n\t\t\t}\n\n\t\t\tline.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n\n\t\t\tviewLineNumber += remainingViewLineCount;\n\n\t\t\tif (lastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic validateViewPosition(viewLineNumber: number, viewColumn: number, expectedModelPosition: Position): Position {\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tconst r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n\t\tconst lineIndex = r.index;\n\t\tconst remainder = r.remainder;\n\n\t\tconst line = this.modelLineProjections[lineIndex];\n\n\t\tconst minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n\t\tconst maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\t\tif (viewColumn < minColumn) {\n\t\t\tviewColumn = minColumn;\n\t\t}\n\t\tif (viewColumn > maxColumn) {\n\t\t\tviewColumn = maxColumn;\n\t\t}\n\n\t\tconst computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n\t\tconst computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n\t\tif (computedModelPosition.equals(expectedModelPosition)) {\n\t\t\treturn new Position(viewLineNumber, viewColumn);\n\t\t}\n\n\t\treturn this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\tconst validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n\t\tconst validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n\t\treturn new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n\t}\n\n\tpublic convertViewPositionToModelPosition(viewLineNumber: number, viewColumn: number): Position {\n\t\tconst info = this.getViewLineInfo(viewLineNumber);\n\n\t\tconst inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n\t\t// console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\t\treturn this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\tconst start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n\t\tconst end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\tpublic convertModelPositionToViewPosition(_modelLineNumber: number, _modelColumn: number, affinity: PositionAffinity = PositionAffinity.None, allowZeroLineNumber: boolean = false, belowHiddenRanges: boolean = false): Position {\n\n\t\tconst validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n\t\tconst inputLineNumber = validPosition.lineNumber;\n\t\tconst inputColumn = validPosition.column;\n\n\t\tlet lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n\t\tif (belowHiddenRanges) {\n\t\t\twhile (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex++;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t\tlineIndex--;\n\t\t\t\tlineIndexChanged = true;\n\t\t\t}\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n\t\t\t// TODO@alexdima@hediet this isn't soo pretty\n\t\t\treturn new Position(allowZeroLineNumber ? 0 : 1, 1);\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\n\t\tlet r: Position;\n\t\tif (lineIndexChanged) {\n\t\t\tif (belowHiddenRanges) {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n\t\t\t} else {\n\t\t\t\tr = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n\t\t\t}\n\t\t} else {\n\t\t\tr = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n\t\t}\n\n\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\t\treturn r;\n\t}\n\n\t/**\n\t * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n\t*/\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity: PositionAffinity = PositionAffinity.Left): Range {\n\t\tif (modelRange.isEmpty()) {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n\t\t\treturn Range.fromPositions(start);\n\t\t} else {\n\t\t\tconst start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, PositionAffinity.Right);\n\t\t\tconst end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, PositionAffinity.Left);\n\t\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t\t}\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\tlet lineIndex = modelLineNumber - 1;\n\t\tif (this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// this model line is visible\n\t\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n\t\t}\n\n\t\t// this model line is not visible\n\t\twhile (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\tlineIndex--;\n\t\t}\n\t\tif (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\treturn 1;\n\t\t}\n\t\tconst deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n\t\treturn this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\tconst modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n\t\tif (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n\t\t\t// most likely there are no hidden lines => fast path\n\t\t\t// fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n\t\t\treturn this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations, onlyMarginDecorations);\n\t\t}\n\n\t\tlet result: IModelDecoration[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.modelLineProjections[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tconst maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n\t\t\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tresult.sort((a, b) => {\n\t\t\tconst res = Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\tif (res === 0) {\n\t\t\t\tif (a.id < b.id) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.id > b.id) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\n\t\t// Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\t\tconst finalResult: IModelDecoration[] = [];\n\t\tlet finalResultLen = 0;\n\t\tlet prevDecId: string | null = null;\n\t\tfor (const dec of result) {\n\t\t\tconst decId = dec.id;\n\t\t\tif (prevDecId === decId) {\n\t\t\t\t// skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprevDecId = decId;\n\t\t\tfinalResult[finalResultLen++] = dec;\n\t\t}\n\n\t\treturn finalResult;\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\tconst info = this.getViewLineInfo(position.lineNumber);\n\t\treturn this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\tconst info = this.getViewLineInfo(lineNumber);\n\t\tif (info.modelLineWrappedLineIdx === 0) {\n\t\t\treturn this.model.getLineIndentColumn(info.modelLineNumber);\n\t\t}\n\n\t\t// wrapped lines have no indentation.\n\t\t// We deliberately don't handle the case that indentation is wrapped\n\t\t// to avoid two view lines reporting indentation for the very same model line.\n\t\treturn 0;\n\t}\n}\n\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges: Range[]): Range[] {\n\tif (ranges.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst sortedRanges = ranges.slice();\n\tsortedRanges.sort(Range.compareRangesUsingStarts);\n\n\tconst result: Range[] = [];\n\tlet currentRangeStart = sortedRanges[0].startLineNumber;\n\tlet currentRangeEnd = sortedRanges[0].endLineNumber;\n\n\tfor (let i = 1, len = sortedRanges.length; i < len; i++) {\n\t\tconst range = sortedRanges[i];\n\n\t\tif (range.startLineNumber > currentRangeEnd + 1) {\n\t\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\t\tcurrentRangeStart = range.startLineNumber;\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t} else if (range.endLineNumber > currentRangeEnd) {\n\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t}\n\t}\n\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\treturn result;\n}\n\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n\n\tconstructor(\n\t\tpublic readonly modelLineNumber: number,\n\t\tpublic readonly modelLineWrappedLineIdx: number,\n\t) { }\n}\n\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n\tconstructor(public readonly modelRange: Range, public readonly viewLines: ViewLineInfo[]) {\n\t}\n}\n\nclass CoordinatesConverter implements ICoordinatesConverter {\n\tprivate readonly _lines: ViewModelLinesFromProjectedModel;\n\n\tconstructor(lines: ViewModelLinesFromProjectedModel) {\n\t\tthis._lines = lines;\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._lines.convertViewRangeToModelRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\treturn this._lines.validateViewRange(viewRange, expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position, affinity?: PositionAffinity, allowZero?: boolean, belowHiddenRanges?: boolean): Position {\n\t\treturn this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range, affinity?: PositionAffinity): Range {\n\t\treturn this._lines.convertModelRangeToViewRange(modelRange, affinity);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\treturn this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n\t}\n\n\tpublic getModelLineViewLineCount(modelLineNumber: number): number {\n\t\treturn this._lines.getModelLineViewLineCount(modelLineNumber);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number {\n\t\treturn this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n\t}\n}\n\nconst enum IndentGuideRepeatOption {\n\tBlockNone = 0,\n\tBlockSubsequent = 1,\n\tBlockAll = 2\n}\n\nexport class ViewModelLinesFromModelAsIs implements IViewModelLines {\n\tpublic readonly model: ITextModel;\n\n\tconstructor(model: ITextModel) {\n\t\tthis.model = model;\n\t}\n\n\tpublic dispose(): void {\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new IdentityCoordinatesConverter(this.model);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn [];\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setTabSize(_newTabSize: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setWrappingSettings(_fontInfo: FontInfo, _wrappingStrategy: 'simple' | 'advanced', _wrappingColumn: number, _wrappingIndent: WrappingIndent): boolean {\n\t\treturn false;\n\t}\n\n\tpublic createLineBreaksComputer(): ILineBreaksComputer {\n\t\tconst result: null[] = [];\n\t\treturn {\n\t\t\taddRequest: (lineText: string, injectedText: LineInjectedText[] | null, previousLineBreakData: ModelLineProjectionData | null) => {\n\t\t\t\tresult.push(null);\n\t\t\t},\n\t\t\tfinalize: () => {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic onModelFlushed(): void {\n\t}\n\n\tpublic onModelLinesDeleted(_versionId: number | null, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\treturn new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(_versionId: number | null, fromLineNumber: number, toLineNumber: number, lineBreaks: (ModelLineProjectionData | null)[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\treturn new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLineChanged(_versionId: number | null, lineNumber: number, lineBreakData: ModelLineProjectionData | null): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\treturn [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n\t}\n\n\tpublic acceptVersionId(_versionId: number): void {\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.model.getLineCount();\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, _minLineNumber: number, _maxLineNumber: number): IActiveIndentGuideInfo {\n\t\treturn {\n\t\t\tstartLineNumber: viewLineNumber,\n\t\t\tendLineNumber: viewLineNumber,\n\t\t\tindent: 0\n\t\t};\n\t}\n\n\tpublic getViewLinesBracketGuides(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null): IndentGuide[][] {\n\t\treturn new Array(endLineNumber - startLineNumber + 1).fill([]);\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tconst result = new Array<number>(viewLineCount);\n\t\tfor (let i = 0; i < viewLineCount; i++) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\treturn this.model.getLineContent(viewLineNumber);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\treturn this.model.getLineLength(viewLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMinColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMaxColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tconst lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n\t\tconst lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\t0,\n\t\t\tlineTokens.inflate(),\n\t\t\tnull\n\t\t);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null> {\n\t\tconst lineCount = this.model.getLineCount();\n\t\tviewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n\t\tviewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n\n\t\tconst result: Array<ViewLineData | null> = [];\n\t\tfor (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n\t\t\tconst idx = lineNumber - viewStartLineNumber;\n\t\t\tresult[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMinimapDecorations: boolean, onlyMarginDecorations: boolean): IModelDecoration[] {\n\t\treturn this.model.getDecorationsInRange(range, ownerId, filterOutValidation, filterFontDecorations, onlyMinimapDecorations, onlyMarginDecorations);\n\t}\n\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position {\n\t\treturn this.model.normalizePosition(position, affinity);\n\t}\n\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\treturn this.model.getLineIndentColumn(lineNumber);\n\t}\n\n\tpublic getInjectedTextAt(position: Position): InjectedText | null {\n\t\t// Identity lines collection does not support injected text.\n\t\treturn null;\n\t}\n}\n"]}