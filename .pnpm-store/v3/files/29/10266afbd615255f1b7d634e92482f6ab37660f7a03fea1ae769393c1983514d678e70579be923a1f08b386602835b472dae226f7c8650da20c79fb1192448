{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/comment/browser/lineCommentCommand.ts","vs/editor/contrib/comment/browser/lineCommentCommand.ts"],"names":[],"mappings":"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","file":"lineCommentCommand.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Constants } from '../../../../base/common/uint.js';\nimport { EditOperation, ISingleEditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../../../common/editorCommon.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\n\nexport interface IInsertionPoint {\n\tignore: boolean;\n\tcommentStrOffset: number;\n}\n\nexport interface ILinePreflightData {\n\tignore: boolean;\n\tcommentStr: string;\n\tcommentStrOffset: number;\n\tcommentStrLength: number;\n}\n\nexport interface IPreflightDataSupported {\n\tsupported: true;\n\tshouldRemoveComments: boolean;\n\tlines: ILinePreflightData[];\n}\nexport interface IPreflightDataUnsupported {\n\tsupported: false;\n}\nexport type IPreflightData = IPreflightDataSupported | IPreflightDataUnsupported;\n\nexport interface ISimpleModel {\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum Type {\n\tToggle = 0,\n\tForceAdd = 1,\n\tForceRemove = 2\n}\n\nexport class LineCommentCommand implements ICommand {\n\n\tprivate readonly _selection: Selection;\n\tprivate readonly _indentSize: number;\n\tprivate readonly _type: Type;\n\tprivate readonly _insertSpace: boolean;\n\tprivate readonly _ignoreEmptyLines: boolean;\n\tprivate _selectionId: string | null;\n\tprivate _deltaColumn: number;\n\tprivate _moveEndPositionDown: boolean;\n\tprivate _ignoreFirstLine: boolean;\n\n\tconstructor(\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService,\n\t\tselection: Selection,\n\t\tindentSize: number,\n\t\ttype: Type,\n\t\tinsertSpace: boolean,\n\t\tignoreEmptyLines: boolean,\n\t\tignoreFirstLine?: boolean,\n\t) {\n\t\tthis._selection = selection;\n\t\tthis._indentSize = indentSize;\n\t\tthis._type = type;\n\t\tthis._insertSpace = insertSpace;\n\t\tthis._selectionId = null;\n\t\tthis._deltaColumn = 0;\n\t\tthis._moveEndPositionDown = false;\n\t\tthis._ignoreEmptyLines = ignoreEmptyLines;\n\t\tthis._ignoreFirstLine = ignoreFirstLine || false;\n\t}\n\n\t/**\n\t * Do an initial pass over the lines and gather info about the line comment string.\n\t * Returns null if any of the lines doesn't support a line comment string.\n\t */\n\tprivate static _gatherPreflightCommentStrings(model: ITextModel, startLineNumber: number, endLineNumber: number, languageConfigurationService: ILanguageConfigurationService): ILinePreflightData[] | null {\n\n\t\tmodel.tokenization.tokenizeIfCheap(startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\n\t\tconst config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tconst commentStr = (config ? config.lineCommentToken : null);\n\t\tif (!commentStr) {\n\t\t\t// Mode does not support line comments\n\t\t\treturn null;\n\t\t}\n\n\t\tconst lines: ILinePreflightData[] = [];\n\t\tfor (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n\t\t\tlines[i] = {\n\t\t\t\tignore: false,\n\t\t\t\tcommentStr: commentStr,\n\t\t\t\tcommentStrOffset: 0,\n\t\t\t\tcommentStrLength: commentStr.length\n\t\t\t};\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Analyze lines and decide which lines are relevant and what the toggle should do.\n\t * Also, build up several offsets and lengths useful in the generation of editor operations.\n\t */\n\tpublic static _analyzeLines(type: Type, insertSpace: boolean, model: ISimpleModel, lines: ILinePreflightData[], startLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService, languageId: string): IPreflightData {\n\t\tlet onlyWhitespaceLines = true;\n\n\t\tconst config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tconst lineCommentNoIndent = config?.lineCommentNoIndent ?? false;\n\n\t\tlet shouldRemoveComments: boolean;\n\t\tif (type === Type.Toggle) {\n\t\t\tshouldRemoveComments = true;\n\t\t} else if (type === Type.ForceAdd) {\n\t\t\tshouldRemoveComments = false;\n\t\t} else {\n\t\t\tshouldRemoveComments = true;\n\t\t}\n\n\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\tconst lineData = lines[i];\n\t\t\tconst lineNumber = startLineNumber + i;\n\n\t\t\tif (lineNumber === startLineNumber && ignoreFirstLine) {\n\t\t\t\t// first line ignored\n\t\t\t\tlineData.ignore = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n\t\t\tif (lineContentStartOffset === -1) {\n\t\t\t\t// Empty or whitespace only line\n\t\t\t\tlineData.ignore = ignoreEmptyLines;\n\t\t\t\tlineData.commentStrOffset = lineCommentNoIndent ? 0 : lineContent.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tonlyWhitespaceLines = false;\n\t\t\tconst offset = lineCommentNoIndent ? 0 : lineContentStartOffset;\n\t\t\tlineData.ignore = false;\n\t\t\tlineData.commentStrOffset = offset;\n\n\t\t\tif (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, offset)) {\n\t\t\t\tif (type === Type.Toggle) {\n\t\t\t\t\t// Every line so far has been a line comment, but this one is not\n\t\t\t\t\tshouldRemoveComments = false;\n\t\t\t\t} else if (type === Type.ForceAdd) {\n\t\t\t\t\t// Will not happen\n\t\t\t\t} else {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shouldRemoveComments && insertSpace) {\n\t\t\t\t// Remove a following space if present\n\t\t\t\tconst commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\t\t\t\tif (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === CharCode.Space) {\n\t\t\t\t\tlineData.commentStrLength += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type === Type.Toggle && onlyWhitespaceLines) {\n\t\t\t// For only whitespace lines, we insert comments\n\t\t\tshouldRemoveComments = false;\n\n\t\t\t// Also, no longer ignore them\n\t\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\t\tlines[i].ignore = false;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsupported: true,\n\t\t\tshouldRemoveComments: shouldRemoveComments,\n\t\t\tlines: lines\n\t\t};\n\t}\n\n\t/**\n\t * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n\t */\n\tpublic static _gatherPreflightData(type: Type, insertSpace: boolean, model: ITextModel, startLineNumber: number, endLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService): IPreflightData {\n\t\tconst lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\t\tif (lines === null) {\n\t\t\treturn {\n\t\t\t\tsupported: false\n\t\t\t};\n\t\t}\n\n\t\treturn LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService, languageId);\n\t}\n\n\t/**\n\t * Given a successful analysis, execute either insert line comments, either remove line comments\n\t */\n\tprivate _executeLineComments(model: ISimpleModel, builder: IEditOperationBuilder, data: IPreflightDataSupported, s: Selection): void {\n\n\t\tlet ops: ISingleEditOperation[];\n\n\t\tif (data.shouldRemoveComments) {\n\t\t\tops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t} else {\n\t\t\tLineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n\t\t\tops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t}\n\n\t\tconst cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n\t\tfor (let i = 0, len = ops.length; i < len; i++) {\n\t\t\tbuilder.addEditOperation(ops[i].range, ops[i].text);\n\t\t\tif (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n\t\t\t\tconst lineContent = model.getLineContent(cursorPosition.lineNumber);\n\t\t\t\tif (lineContent.length + 1 === cursorPosition.column) {\n\t\t\t\t\tthis._deltaColumn = (ops[i].text || '').length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(s);\n\t}\n\n\tprivate _attemptRemoveBlockComment(model: ITextModel, s: Selection, startToken: string, endToken: string): ISingleEditOperation[] | null {\n\t\tlet startLineNumber = s.startLineNumber;\n\t\tlet endLineNumber = s.endLineNumber;\n\n\t\tconst startTokenAllowedBeforeColumn = endToken.length + Math.max(\n\t\t\tmodel.getLineFirstNonWhitespaceColumn(s.startLineNumber),\n\t\t\ts.startColumn\n\t\t);\n\n\t\tlet startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n\t\tlet endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex === -1) {\n\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\tendLineNumber = startLineNumber;\n\t\t}\n\n\t\tif (startTokenIndex === -1 && endTokenIndex !== -1) {\n\t\t\tstartTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n\t\t\tstartLineNumber = endLineNumber;\n\t\t}\n\n\t\tif (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n\t\t\tstartTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\t\t\tif (startTokenIndex !== -1) {\n\t\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\t}\n\t\t}\n\n\t\t// We have to adjust to possible inner white space.\n\t\t// For Space after startToken, add Space to startToken - range math will work out.\n\t\tif (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === CharCode.Space) {\n\t\t\tstartToken += ' ';\n\t\t}\n\n\t\t// For Space before endToken, add Space before endToken and shift index one left.\n\t\tif (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === CharCode.Space) {\n\t\t\tendToken = ' ' + endToken;\n\t\t\tendTokenIndex -= 1;\n\t\t}\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\t\t\treturn BlockCommentCommand._createRemoveBlockCommentOperations(\n\t\t\t\tnew Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Given an unsuccessful analysis, delegate to the block comment command\n\t */\n\tprivate _executeBlockComment(model: ITextModel, builder: IEditOperationBuilder, s: Selection): void {\n\t\tmodel.tokenization.tokenizeIfCheap(s.startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n\t\tconst config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tif (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n\t\t\t// Mode does not support block comments\n\t\t\treturn;\n\t\t}\n\n\t\tconst startToken = config.blockCommentStartToken;\n\t\tconst endToken = config.blockCommentEndToken;\n\n\t\tlet ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\t\tif (!ops) {\n\t\t\tif (s.isEmpty()) {\n\t\t\t\tconst lineContent = model.getLineContent(s.startLineNumber);\n\t\t\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\t\t\t// Line is empty or contains only whitespace\n\t\t\t\t\tfirstNonWhitespaceIndex = lineContent.length;\n\t\t\t\t}\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (ops.length === 1) {\n\t\t\t\t// Leave cursor after token and Space\n\t\t\t\tthis._deltaColumn = startToken.length + 1;\n\t\t\t}\n\t\t}\n\t\tthis._selectionId = builder.trackSelection(s);\n\t\tfor (const op of ops) {\n\t\t\tbuilder.addEditOperation(op.range, op.text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\n\t\tlet s = this._selection;\n\t\tthis._moveEndPositionDown = false;\n\n\t\tif (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n\t\t\tbuilder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n\t\t\tthis._selectionId = builder.trackSelection(s);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n\t\t\tthis._moveEndPositionDown = true;\n\t\t\ts = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n\t\t}\n\n\t\tconst data = LineCommentCommand._gatherPreflightData(\n\t\t\tthis._type,\n\t\t\tthis._insertSpace,\n\t\t\tmodel,\n\t\t\ts.startLineNumber,\n\t\t\ts.endLineNumber,\n\t\t\tthis._ignoreEmptyLines,\n\t\t\tthis._ignoreFirstLine,\n\t\t\tthis.languageConfigurationService\n\t\t);\n\n\t\tif (data.supported) {\n\t\t\treturn this._executeLineComments(model, builder, data, s);\n\t\t}\n\n\t\treturn this._executeBlockComment(model, builder, s);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tlet result = helper.getTrackedSelection(this._selectionId!);\n\n\t\tif (this._moveEndPositionDown) {\n\t\t\tresult = result.setEndPosition(result.endLineNumber + 1, 1);\n\t\t}\n\n\t\treturn new Selection(\n\t\t\tresult.selectionStartLineNumber,\n\t\t\tresult.selectionStartColumn + this._deltaColumn,\n\t\t\tresult.positionLineNumber,\n\t\t\tresult.positionColumn + this._deltaColumn\n\t\t);\n\t}\n\n\t/**\n\t * Generate edit operations in the remove line comment case\n\t */\n\tpublic static _createRemoveLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + 1,\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1\n\t\t\t)));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Generate edit operations in the add line comment case\n\t */\n\tprivate _createAddLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\t\tconst afterCommentStr = this._insertSpace ? ' ' : '';\n\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static nextVisibleColumn(currentVisibleColumn: number, indentSize: number, isTab: boolean, columnSize: number): number {\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (indentSize - (currentVisibleColumn % indentSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\t/**\n\t * Adjust insertion points to have them vertically aligned in the add line comment case\n\t */\n\tpublic static _normalizeInsertionPoint(model: ISimpleModel, lines: IInsertionPoint[], startLineNumber: number, indentSize: number): void {\n\t\tlet minVisibleColumn = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tlet j: number;\n\t\tlet lenJ: number;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn < minVisibleColumn) {\n\t\t\t\tminVisibleColumn = currentVisibleColumn;\n\t\t\t}\n\t\t}\n\n\t\tminVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn > minVisibleColumn) {\n\t\t\t\tlines[i].commentStrOffset = j - 1;\n\t\t\t} else {\n\t\t\t\tlines[i].commentStrOffset = j;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Constants } from '../../../../base/common/uint.js';\nimport { EditOperation, ISingleEditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../../../common/editorCommon.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\n\nexport interface IInsertionPoint {\n\tignore: boolean;\n\tcommentStrOffset: number;\n}\n\nexport interface ILinePreflightData {\n\tignore: boolean;\n\tcommentStr: string;\n\tcommentStrOffset: number;\n\tcommentStrLength: number;\n}\n\nexport interface IPreflightDataSupported {\n\tsupported: true;\n\tshouldRemoveComments: boolean;\n\tlines: ILinePreflightData[];\n}\nexport interface IPreflightDataUnsupported {\n\tsupported: false;\n}\nexport type IPreflightData = IPreflightDataSupported | IPreflightDataUnsupported;\n\nexport interface ISimpleModel {\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum Type {\n\tToggle = 0,\n\tForceAdd = 1,\n\tForceRemove = 2\n}\n\nexport class LineCommentCommand implements ICommand {\n\n\tprivate readonly _selection: Selection;\n\tprivate readonly _indentSize: number;\n\tprivate readonly _type: Type;\n\tprivate readonly _insertSpace: boolean;\n\tprivate readonly _ignoreEmptyLines: boolean;\n\tprivate _selectionId: string | null;\n\tprivate _deltaColumn: number;\n\tprivate _moveEndPositionDown: boolean;\n\tprivate _ignoreFirstLine: boolean;\n\n\tconstructor(\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService,\n\t\tselection: Selection,\n\t\tindentSize: number,\n\t\ttype: Type,\n\t\tinsertSpace: boolean,\n\t\tignoreEmptyLines: boolean,\n\t\tignoreFirstLine?: boolean,\n\t) {\n\t\tthis._selection = selection;\n\t\tthis._indentSize = indentSize;\n\t\tthis._type = type;\n\t\tthis._insertSpace = insertSpace;\n\t\tthis._selectionId = null;\n\t\tthis._deltaColumn = 0;\n\t\tthis._moveEndPositionDown = false;\n\t\tthis._ignoreEmptyLines = ignoreEmptyLines;\n\t\tthis._ignoreFirstLine = ignoreFirstLine || false;\n\t}\n\n\t/**\n\t * Do an initial pass over the lines and gather info about the line comment string.\n\t * Returns null if any of the lines doesn't support a line comment string.\n\t */\n\tprivate static _gatherPreflightCommentStrings(model: ITextModel, startLineNumber: number, endLineNumber: number, languageConfigurationService: ILanguageConfigurationService): ILinePreflightData[] | null {\n\n\t\tmodel.tokenization.tokenizeIfCheap(startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\n\t\tconst config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tconst commentStr = (config ? config.lineCommentToken : null);\n\t\tif (!commentStr) {\n\t\t\t// Mode does not support line comments\n\t\t\treturn null;\n\t\t}\n\n\t\tconst lines: ILinePreflightData[] = [];\n\t\tfor (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n\t\t\tlines[i] = {\n\t\t\t\tignore: false,\n\t\t\t\tcommentStr: commentStr,\n\t\t\t\tcommentStrOffset: 0,\n\t\t\t\tcommentStrLength: commentStr.length\n\t\t\t};\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Analyze lines and decide which lines are relevant and what the toggle should do.\n\t * Also, build up several offsets and lengths useful in the generation of editor operations.\n\t */\n\tpublic static _analyzeLines(type: Type, insertSpace: boolean, model: ISimpleModel, lines: ILinePreflightData[], startLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService, languageId: string): IPreflightData {\n\t\tlet onlyWhitespaceLines = true;\n\n\t\tconst config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tconst lineCommentNoIndent = config?.lineCommentNoIndent ?? false;\n\n\t\tlet shouldRemoveComments: boolean;\n\t\tif (type === Type.Toggle) {\n\t\t\tshouldRemoveComments = true;\n\t\t} else if (type === Type.ForceAdd) {\n\t\t\tshouldRemoveComments = false;\n\t\t} else {\n\t\t\tshouldRemoveComments = true;\n\t\t}\n\n\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\tconst lineData = lines[i];\n\t\t\tconst lineNumber = startLineNumber + i;\n\n\t\t\tif (lineNumber === startLineNumber && ignoreFirstLine) {\n\t\t\t\t// first line ignored\n\t\t\t\tlineData.ignore = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n\t\t\tif (lineContentStartOffset === -1) {\n\t\t\t\t// Empty or whitespace only line\n\t\t\t\tlineData.ignore = ignoreEmptyLines;\n\t\t\t\tlineData.commentStrOffset = lineCommentNoIndent ? 0 : lineContent.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tonlyWhitespaceLines = false;\n\t\t\tconst offset = lineCommentNoIndent ? 0 : lineContentStartOffset;\n\t\t\tlineData.ignore = false;\n\t\t\tlineData.commentStrOffset = offset;\n\n\t\t\tif (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, offset)) {\n\t\t\t\tif (type === Type.Toggle) {\n\t\t\t\t\t// Every line so far has been a line comment, but this one is not\n\t\t\t\t\tshouldRemoveComments = false;\n\t\t\t\t} else if (type === Type.ForceAdd) {\n\t\t\t\t\t// Will not happen\n\t\t\t\t} else {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shouldRemoveComments && insertSpace) {\n\t\t\t\t// Remove a following space if present\n\t\t\t\tconst commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\t\t\t\tif (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === CharCode.Space) {\n\t\t\t\t\tlineData.commentStrLength += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type === Type.Toggle && onlyWhitespaceLines) {\n\t\t\t// For only whitespace lines, we insert comments\n\t\t\tshouldRemoveComments = false;\n\n\t\t\t// Also, no longer ignore them\n\t\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\t\tlines[i].ignore = false;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsupported: true,\n\t\t\tshouldRemoveComments: shouldRemoveComments,\n\t\t\tlines: lines\n\t\t};\n\t}\n\n\t/**\n\t * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n\t */\n\tpublic static _gatherPreflightData(type: Type, insertSpace: boolean, model: ITextModel, startLineNumber: number, endLineNumber: number, ignoreEmptyLines: boolean, ignoreFirstLine: boolean, languageConfigurationService: ILanguageConfigurationService): IPreflightData {\n\t\tconst lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\t\tif (lines === null) {\n\t\t\treturn {\n\t\t\t\tsupported: false\n\t\t\t};\n\t\t}\n\n\t\treturn LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService, languageId);\n\t}\n\n\t/**\n\t * Given a successful analysis, execute either insert line comments, either remove line comments\n\t */\n\tprivate _executeLineComments(model: ISimpleModel, builder: IEditOperationBuilder, data: IPreflightDataSupported, s: Selection): void {\n\n\t\tlet ops: ISingleEditOperation[];\n\n\t\tif (data.shouldRemoveComments) {\n\t\t\tops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t} else {\n\t\t\tLineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n\t\t\tops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t}\n\n\t\tconst cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n\t\tfor (let i = 0, len = ops.length; i < len; i++) {\n\t\t\tbuilder.addEditOperation(ops[i].range, ops[i].text);\n\t\t\tif (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n\t\t\t\tconst lineContent = model.getLineContent(cursorPosition.lineNumber);\n\t\t\t\tif (lineContent.length + 1 === cursorPosition.column) {\n\t\t\t\t\tthis._deltaColumn = (ops[i].text || '').length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(s);\n\t}\n\n\tprivate _attemptRemoveBlockComment(model: ITextModel, s: Selection, startToken: string, endToken: string): ISingleEditOperation[] | null {\n\t\tlet startLineNumber = s.startLineNumber;\n\t\tlet endLineNumber = s.endLineNumber;\n\n\t\tconst startTokenAllowedBeforeColumn = endToken.length + Math.max(\n\t\t\tmodel.getLineFirstNonWhitespaceColumn(s.startLineNumber),\n\t\t\ts.startColumn\n\t\t);\n\n\t\tlet startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n\t\tlet endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex === -1) {\n\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\tendLineNumber = startLineNumber;\n\t\t}\n\n\t\tif (startTokenIndex === -1 && endTokenIndex !== -1) {\n\t\t\tstartTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n\t\t\tstartLineNumber = endLineNumber;\n\t\t}\n\n\t\tif (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n\t\t\tstartTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\t\t\tif (startTokenIndex !== -1) {\n\t\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\t}\n\t\t}\n\n\t\t// We have to adjust to possible inner white space.\n\t\t// For Space after startToken, add Space to startToken - range math will work out.\n\t\tif (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === CharCode.Space) {\n\t\t\tstartToken += ' ';\n\t\t}\n\n\t\t// For Space before endToken, add Space before endToken and shift index one left.\n\t\tif (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === CharCode.Space) {\n\t\t\tendToken = ' ' + endToken;\n\t\t\tendTokenIndex -= 1;\n\t\t}\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\t\t\treturn BlockCommentCommand._createRemoveBlockCommentOperations(\n\t\t\t\tnew Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Given an unsuccessful analysis, delegate to the block comment command\n\t */\n\tprivate _executeBlockComment(model: ITextModel, builder: IEditOperationBuilder, s: Selection): void {\n\t\tmodel.tokenization.tokenizeIfCheap(s.startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n\t\tconst config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\t\tif (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n\t\t\t// Mode does not support block comments\n\t\t\treturn;\n\t\t}\n\n\t\tconst startToken = config.blockCommentStartToken;\n\t\tconst endToken = config.blockCommentEndToken;\n\n\t\tlet ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\t\tif (!ops) {\n\t\t\tif (s.isEmpty()) {\n\t\t\t\tconst lineContent = model.getLineContent(s.startLineNumber);\n\t\t\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\t\t\t// Line is empty or contains only whitespace\n\t\t\t\t\tfirstNonWhitespaceIndex = lineContent.length;\n\t\t\t\t}\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)),\n\t\t\t\t\tstartToken,\n\t\t\t\t\tendToken,\n\t\t\t\t\tthis._insertSpace\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (ops.length === 1) {\n\t\t\t\t// Leave cursor after token and Space\n\t\t\t\tthis._deltaColumn = startToken.length + 1;\n\t\t\t}\n\t\t}\n\t\tthis._selectionId = builder.trackSelection(s);\n\t\tfor (const op of ops) {\n\t\t\tbuilder.addEditOperation(op.range, op.text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\n\t\tlet s = this._selection;\n\t\tthis._moveEndPositionDown = false;\n\n\t\tif (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n\t\t\tbuilder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n\t\t\tthis._selectionId = builder.trackSelection(s);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n\t\t\tthis._moveEndPositionDown = true;\n\t\t\ts = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n\t\t}\n\n\t\tconst data = LineCommentCommand._gatherPreflightData(\n\t\t\tthis._type,\n\t\t\tthis._insertSpace,\n\t\t\tmodel,\n\t\t\ts.startLineNumber,\n\t\t\ts.endLineNumber,\n\t\t\tthis._ignoreEmptyLines,\n\t\t\tthis._ignoreFirstLine,\n\t\t\tthis.languageConfigurationService\n\t\t);\n\n\t\tif (data.supported) {\n\t\t\treturn this._executeLineComments(model, builder, data, s);\n\t\t}\n\n\t\treturn this._executeBlockComment(model, builder, s);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tlet result = helper.getTrackedSelection(this._selectionId!);\n\n\t\tif (this._moveEndPositionDown) {\n\t\t\tresult = result.setEndPosition(result.endLineNumber + 1, 1);\n\t\t}\n\n\t\treturn new Selection(\n\t\t\tresult.selectionStartLineNumber,\n\t\t\tresult.selectionStartColumn + this._deltaColumn,\n\t\t\tresult.positionLineNumber,\n\t\t\tresult.positionColumn + this._deltaColumn\n\t\t);\n\t}\n\n\t/**\n\t * Generate edit operations in the remove line comment case\n\t */\n\tpublic static _createRemoveLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + 1,\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1\n\t\t\t)));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Generate edit operations in the add line comment case\n\t */\n\tprivate _createAddLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): ISingleEditOperation[] {\n\t\tconst res: ISingleEditOperation[] = [];\n\t\tconst afterCommentStr = this._insertSpace ? ' ' : '';\n\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static nextVisibleColumn(currentVisibleColumn: number, indentSize: number, isTab: boolean, columnSize: number): number {\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (indentSize - (currentVisibleColumn % indentSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\t/**\n\t * Adjust insertion points to have them vertically aligned in the add line comment case\n\t */\n\tpublic static _normalizeInsertionPoint(model: ISimpleModel, lines: IInsertionPoint[], startLineNumber: number, indentSize: number): void {\n\t\tlet minVisibleColumn = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tlet j: number;\n\t\tlet lenJ: number;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn < minVisibleColumn) {\n\t\t\t\tminVisibleColumn = currentVisibleColumn;\n\t\t\t}\n\t\t}\n\n\t\tminVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn > minVisibleColumn) {\n\t\t\t\tlines[i].commentStrOffset = j - 1;\n\t\t\t} else {\n\t\t\t\tlines[i].commentStrOffset = j;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}