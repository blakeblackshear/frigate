{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/viewParts/viewLines/viewLine.ts","vs/editor/browser/viewParts/viewLines/viewLine.ts"],"names":[],"mappings":"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","file":"viewLine.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from '../../../../base/browser/browser.js';\nimport { FastDomNode, createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { IVisibleLine } from '../../view/viewLayer.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { CharacterMapping, ForeignElementType, RenderLineInput, renderViewLine, DomPosition, RenderWhitespace } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nimport { DomReadingContext } from './domReadingContext.js';\nimport { ViewLineOptions } from './viewLineOptions.js';\nimport { ViewGpuContext } from '../../gpu/viewGpuContext.js';\nimport { OffsetRange } from '../../../common/core/ranges/offsetRange.js';\nimport { InlineDecorationType } from '../../../common/viewModel/inlineDecorations.js';\nimport { TextDirection } from '../../../common/model.js';\n\nconst canUseFastRenderedViewLine = (function () {\n\tif (platform.isNative) {\n\t\t// In VSCode we know very well when the zoom level changes\n\t\treturn true;\n\t}\n\n\tif (platform.isLinux || browser.isFirefox || browser.isSafari) {\n\t\t// On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n\t\t// --\n\t\t// Even though we read character widths correctly, having read them at a specific zoom level\n\t\t// does not mean they are the same at the current zoom level.\n\t\t// --\n\t\t// This could be improved if we ever figure out how to get an event when browsers zoom,\n\t\t// but until then we have to stick with reading client rects.\n\t\t// --\n\t\t// The same has been observed with Firefox on Windows7\n\t\t// --\n\t\t// The same has been oversved with Safari\n\t\treturn false;\n\t}\n\n\treturn true;\n})();\n\nlet monospaceAssumptionsAreValid = true;\n\nexport class ViewLine implements IVisibleLine {\n\n\tpublic static readonly CLASS_NAME = 'view-line';\n\n\tprivate _options: ViewLineOptions;\n\tprivate _isMaybeInvalid: boolean;\n\tprivate _renderedViewLine: IRenderedViewLine | null;\n\n\tconstructor(private readonly _viewGpuContext: ViewGpuContext | undefined, options: ViewLineOptions) {\n\t\tthis._options = options;\n\t\tthis._isMaybeInvalid = true;\n\t\tthis._renderedViewLine = null;\n\t}\n\n\t// --- begin IVisibleLineData\n\n\tpublic getDomNode(): HTMLElement | null {\n\t\tif (this._renderedViewLine && this._renderedViewLine.domNode) {\n\t\t\treturn this._renderedViewLine.domNode.domNode;\n\t\t}\n\t\treturn null;\n\t}\n\tpublic setDomNode(domNode: HTMLElement): void {\n\t\tif (this._renderedViewLine) {\n\t\t\tthis._renderedViewLine.domNode = createFastDomNode(domNode);\n\t\t} else {\n\t\t\tthrow new Error('I have no rendered view line to set the dom node to...');\n\t\t}\n\t}\n\n\tpublic onContentChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onTokensChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onDecorationsChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onOptionsChanged(newOptions: ViewLineOptions): void {\n\t\tthis._isMaybeInvalid = true;\n\t\tthis._options = newOptions;\n\t}\n\tpublic onSelectionChanged(): boolean {\n\t\tif (isHighContrast(this._options.themeType) || this._renderedViewLine?.input.renderWhitespace === RenderWhitespace.Selection) {\n\t\t\tthis._isMaybeInvalid = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic renderLine(lineNumber: number, deltaTop: number, lineHeight: number, viewportData: ViewportData, sb: StringBuilder): boolean {\n\t\tif (this._options.useGpu && this._viewGpuContext?.canRender(this._options, viewportData, lineNumber)) {\n\t\t\tthis._renderedViewLine?.domNode?.domNode.remove();\n\t\t\tthis._renderedViewLine = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._isMaybeInvalid === false) {\n\t\t\t// it appears that nothing relevant has changed\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._isMaybeInvalid = false;\n\n\t\tconst lineData = viewportData.getViewLineRenderingData(lineNumber);\n\t\tconst options = this._options;\n\t\tconst actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n\t\tconst renderWhitespace = (lineData.hasVariableFonts || options.experimentalWhitespaceRendering === 'off') ? options.renderWhitespace : 'none';\n\t\tconst allowFastRendering = !lineData.hasVariableFonts;\n\n\t\t// Only send selection information when needed for rendering whitespace\n\t\tlet selectionsOnLine: OffsetRange[] | null = null;\n\t\tif (isHighContrast(options.themeType) || renderWhitespace === 'selection') {\n\t\t\tconst selections = viewportData.selections;\n\t\t\tfor (const selection of selections) {\n\n\t\t\t\tif (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n\t\t\t\t\t// Selection does not intersect line\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\n\t\t\t\tconst endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\n\n\t\t\t\tif (startColumn < endColumn) {\n\t\t\t\t\tif (isHighContrast(options.themeType)) {\n\t\t\t\t\t\tactualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', InlineDecorationType.Regular));\n\t\t\t\t\t}\n\t\t\t\t\tif (renderWhitespace === 'selection') {\n\t\t\t\t\t\tif (!selectionsOnLine) {\n\t\t\t\t\t\t\tselectionsOnLine = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselectionsOnLine.push(new OffsetRange(startColumn - 1, endColumn - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst renderLineInput = new RenderLineInput(\n\t\t\toptions.useMonospaceOptimizations,\n\t\t\toptions.canUseHalfwidthRightwardsArrow,\n\t\t\tlineData.content,\n\t\t\tlineData.continuesWithWrappedLine,\n\t\t\tlineData.isBasicASCII,\n\t\t\tlineData.containsRTL,\n\t\t\tlineData.minColumn - 1,\n\t\t\tlineData.tokens,\n\t\t\tactualInlineDecorations,\n\t\t\tlineData.tabSize,\n\t\t\tlineData.startVisibleColumn,\n\t\t\toptions.spaceWidth,\n\t\t\toptions.middotWidth,\n\t\t\toptions.wsmiddotWidth,\n\t\t\toptions.stopRenderingLineAfter,\n\t\t\trenderWhitespace,\n\t\t\toptions.renderControlCharacters,\n\t\t\toptions.fontLigatures !== EditorFontLigatures.OFF,\n\t\t\tselectionsOnLine,\n\t\t\tlineData.textDirection,\n\t\t\toptions.verticalScrollbarSize\n\t\t);\n\n\t\tif (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n\t\t\t// no need to do anything, we have the same render input\n\t\t\treturn false;\n\t\t}\n\n\t\tsb.appendString('<div ');\n\t\tif (lineData.textDirection === TextDirection.RTL) {\n\t\t\tsb.appendString('dir=\"rtl\" ');\n\t\t} else if (lineData.containsRTL) {\n\t\t\tsb.appendString('dir=\"ltr\" ');\n\t\t}\n\t\tsb.appendString('style=\"top:');\n\t\tsb.appendString(String(deltaTop));\n\t\tsb.appendString('px;height:');\n\t\tsb.appendString(String(lineHeight));\n\t\tsb.appendString('px;line-height:');\n\t\tsb.appendString(String(lineHeight));\n\t\tif (lineData.textDirection === TextDirection.RTL) {\n\t\t\tsb.appendString('px;padding-right:');\n\t\t\tsb.appendString(String(options.verticalScrollbarSize));\n\t\t}\n\t\tsb.appendString('px;\" class=\"');\n\t\tsb.appendString(ViewLine.CLASS_NAME);\n\t\tsb.appendString('\">');\n\n\t\tconst output = renderViewLine(renderLineInput, sb);\n\n\t\tsb.appendString('</div>');\n\n\t\tlet renderedViewLine: IRenderedViewLine | null = null;\n\t\tif (\n\t\t\tallowFastRendering\n\t\t\t&& monospaceAssumptionsAreValid\n\t\t\t&& canUseFastRenderedViewLine\n\t\t\t&& lineData.isBasicASCII\n\t\t\t&& renderLineInput.isLTR\n\t\t\t&& options.useMonospaceOptimizations\n\t\t\t&& output.containsForeignElements === ForeignElementType.None\n\t\t) {\n\t\t\trenderedViewLine = new FastRenderedViewLine(\n\t\t\t\tthis._renderedViewLine ? this._renderedViewLine.domNode : null,\n\t\t\t\trenderLineInput,\n\t\t\t\toutput.characterMapping\n\t\t\t);\n\t\t}\n\n\t\tif (!renderedViewLine) {\n\t\t\trenderedViewLine = createRenderedLine(\n\t\t\t\tthis._renderedViewLine ? this._renderedViewLine.domNode : null,\n\t\t\t\trenderLineInput,\n\t\t\t\toutput.characterMapping,\n\t\t\t\toutput.containsForeignElements\n\t\t\t);\n\t\t}\n\n\t\tthis._renderedViewLine = renderedViewLine;\n\n\t\treturn true;\n\t}\n\n\tpublic layoutLine(lineNumber: number, deltaTop: number, lineHeight: number): void {\n\t\tif (this._renderedViewLine && this._renderedViewLine.domNode) {\n\t\t\tthis._renderedViewLine.domNode.setTop(deltaTop);\n\t\t\tthis._renderedViewLine.domNode.setHeight(lineHeight);\n\t\t\tthis._renderedViewLine.domNode.setLineHeight(lineHeight);\n\t\t}\n\t}\n\n\t// --- end IVisibleLineData\n\n\tpublic isRenderedRTL(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._renderedViewLine.input.textDirection === TextDirection.RTL;\n\t}\n\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._renderedViewLine.getWidth(context);\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._renderedViewLine.getWidthIsFast();\n\t}\n\n\tpublic needsMonospaceFontCheck(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._renderedViewLine instanceof FastRenderedViewLine);\n\t}\n\n\tpublic monospaceAssumptionsAreValid(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn monospaceAssumptionsAreValid;\n\t\t}\n\t\tif (this._renderedViewLine instanceof FastRenderedViewLine) {\n\t\t\treturn this._renderedViewLine.monospaceAssumptionsAreValid();\n\t\t}\n\t\treturn monospaceAssumptionsAreValid;\n\t}\n\n\tpublic onMonospaceAssumptionsInvalidated(): void {\n\t\tif (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n\t\t\tthis._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n\t\t}\n\t}\n\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): VisibleRanges | null {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstartColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n\t\tendColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n\n\t\tconst stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter;\n\n\t\tif (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n\t\t\t// This range is obviously not visible\n\t\t\treturn new VisibleRanges(true, [new FloatHorizontalRange(this.getWidth(context), 0)]);\n\t\t}\n\n\t\tif (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n\t\t\tstartColumn = stopRenderingLineAfter + 1;\n\t\t}\n\n\t\tif (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n\t\t\tendColumn = stopRenderingLineAfter + 1;\n\t\t}\n\n\t\tconst horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n\t\tif (horizontalRanges && horizontalRanges.length > 0) {\n\t\t\treturn new VisibleRanges(false, horizontalRanges);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._renderedViewLine.getColumnOfNodeOffset(spanNode, offset);\n\t}\n}\n\ninterface IRenderedViewLine {\n\tdomNode: FastDomNode<HTMLElement> | null;\n\treadonly input: RenderLineInput;\n\tgetWidth(context: DomReadingContext | null): number;\n\tgetWidthIsFast(): boolean;\n\tgetVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null;\n\tgetColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number;\n}\n\nconst enum Constants {\n\t/**\n\t * It seems that rounding errors occur with long lines, so the purely multiplication based\n\t * method is only viable for short lines. For longer lines, we look up the real position of\n\t * every 300th character and use multiplication based on that.\n\t *\n\t * See https://github.com/microsoft/vscode/issues/33178\n\t */\n\tMaxMonospaceDistance = 300\n}\n\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nclass FastRenderedViewLine implements IRenderedViewLine {\n\n\tpublic domNode: FastDomNode<HTMLElement> | null;\n\tpublic readonly input: RenderLineInput;\n\n\tprivate readonly _characterMapping: CharacterMapping;\n\tprivate readonly _charWidth: number;\n\tprivate readonly _keyColumnPixelOffsetCache: Float32Array | null;\n\tprivate _cachedWidth: number = -1;\n\n\tconstructor(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping) {\n\t\tthis.domNode = domNode;\n\t\tthis.input = renderLineInput;\n\t\tconst keyColumnCount = Math.floor(renderLineInput.lineContent.length / Constants.MaxMonospaceDistance);\n\t\tif (keyColumnCount > 0) {\n\t\t\tthis._keyColumnPixelOffsetCache = new Float32Array(keyColumnCount);\n\t\t\tfor (let i = 0; i < keyColumnCount; i++) {\n\t\t\t\tthis._keyColumnPixelOffsetCache[i] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._keyColumnPixelOffsetCache = null;\n\t\t}\n\n\t\tthis._characterMapping = characterMapping;\n\t\tthis._charWidth = renderLineInput.spaceWidth;\n\t}\n\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this.domNode || this.input.lineContent.length < Constants.MaxMonospaceDistance) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(this._characterMapping.length);\n\t\t\treturn Math.round(this._charWidth * horizontalOffset);\n\t\t}\n\t\tif (this._cachedWidth === -1) {\n\t\t\tthis._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n\t\t\tcontext?.markDidDomLayout();\n\t\t}\n\t\treturn this._cachedWidth;\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\treturn (this.input.lineContent.length < Constants.MaxMonospaceDistance) || this._cachedWidth !== -1;\n\t}\n\n\tpublic monospaceAssumptionsAreValid(): boolean {\n\t\tif (!this.domNode) {\n\t\t\treturn monospaceAssumptionsAreValid;\n\t\t}\n\t\tif (this.input.lineContent.length < Constants.MaxMonospaceDistance) {\n\t\t\tconst expectedWidth = this.getWidth(null);\n\t\t\tconst actualWidth = (<HTMLSpanElement>this.domNode.domNode.firstChild).offsetWidth;\n\t\t\tif (Math.abs(expectedWidth - actualWidth) >= 2) {\n\t\t\t\t// more than 2px off\n\t\t\t\tconsole.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n\t\t\t\tmonospaceAssumptionsAreValid = false;\n\t\t\t}\n\t\t}\n\t\treturn monospaceAssumptionsAreValid;\n\t}\n\n\tpublic toSlowRenderedLine(): RenderedViewLine {\n\t\treturn createRenderedLine(this.domNode, this.input, this._characterMapping, ForeignElementType.None);\n\t}\n\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tconst startPosition = this._getColumnPixelOffset(lineNumber, startColumn, context);\n\t\tconst endPosition = this._getColumnPixelOffset(lineNumber, endColumn, context);\n\t\treturn [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n\t}\n\n\tprivate _getColumnPixelOffset(lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (column <= Constants.MaxMonospaceDistance) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\treturn this._charWidth * horizontalOffset;\n\t\t}\n\n\t\tconst keyColumnOrdinal = Math.floor((column - 1) / Constants.MaxMonospaceDistance) - 1;\n\t\tconst keyColumn = (keyColumnOrdinal + 1) * Constants.MaxMonospaceDistance + 1;\n\t\tlet keyColumnPixelOffset = -1;\n\t\tif (this._keyColumnPixelOffsetCache) {\n\t\t\tkeyColumnPixelOffset = this._keyColumnPixelOffsetCache[keyColumnOrdinal];\n\t\t\tif (keyColumnPixelOffset === -1) {\n\t\t\t\tkeyColumnPixelOffset = this._actualReadPixelOffset(lineNumber, keyColumn, context);\n\t\t\t\tthis._keyColumnPixelOffsetCache[keyColumnOrdinal] = keyColumnPixelOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (keyColumnPixelOffset === -1) {\n\t\t\t// Could not read actual key column pixel offset\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\treturn this._charWidth * horizontalOffset;\n\t\t}\n\n\t\tconst keyColumnHorizontalOffset = this._characterMapping.getHorizontalOffset(keyColumn);\n\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\treturn keyColumnPixelOffset + this._charWidth * (horizontalOffset - keyColumnHorizontalOffset);\n\t}\n\n\tprivate _getReadingTarget(myDomNode: FastDomNode<HTMLElement>): HTMLElement {\n\t\treturn <HTMLSpanElement>myDomNode.domNode.firstChild;\n\t}\n\n\tprivate _actualReadPixelOffset(lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (!this.domNode) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst domPosition = this._characterMapping.getDomPosition(column);\n\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(this.domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n\t\tif (!r || r.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn r[0].left;\n\t}\n\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\treturn getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n\t}\n}\n\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nclass RenderedViewLine implements IRenderedViewLine {\n\n\tpublic domNode: FastDomNode<HTMLElement> | null;\n\tpublic readonly input: RenderLineInput;\n\n\tprotected readonly _characterMapping: CharacterMapping;\n\tprivate readonly _isWhitespaceOnly: boolean;\n\tprivate readonly _containsForeignElements: ForeignElementType;\n\tprivate _cachedWidth: number;\n\n\t/**\n\t * This is a map that is used only when the line is guaranteed to be rendered LTR and has no RTL text.\n\t */\n\tprivate readonly _pixelOffsetCache: Float32Array | null;\n\n\tconstructor(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType) {\n\t\tthis.domNode = domNode;\n\t\tthis.input = renderLineInput;\n\t\tthis._characterMapping = characterMapping;\n\t\tthis._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n\t\tthis._containsForeignElements = containsForeignElements;\n\t\tthis._cachedWidth = -1;\n\n\t\tthis._pixelOffsetCache = null;\n\t\tif (renderLineInput.isLTR) {\n\t\t\tthis._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n\t\t\tfor (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n\t\t\t\tthis._pixelOffsetCache[column] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// --- Reading from the DOM methods\n\n\tprotected _getReadingTarget(myDomNode: FastDomNode<HTMLElement>): HTMLElement {\n\t\treturn <HTMLSpanElement>myDomNode.domNode.firstChild;\n\t}\n\n\t/**\n\t * Width of the line in pixels\n\t */\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this.domNode) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (this._cachedWidth === -1) {\n\t\t\tthis._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n\t\t\tcontext?.markDidDomLayout();\n\t\t}\n\t\treturn this._cachedWidth;\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\tif (this._cachedWidth === -1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Visible ranges for a model range\n\t */\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tif (!this.domNode) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._pixelOffsetCache !== null) {\n\t\t\t// the text is guaranteed to be entirely LTR\n\t\t\tconst startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n\t\t\tif (startOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n\t\t\tif (endOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n\t\t}\n\n\t\treturn this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n\t}\n\n\tprotected _readVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tif (startColumn === endColumn) {\n\t\t\tconst pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n\t\t\tif (pixelOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn [new FloatHorizontalRange(pixelOffset, 0)];\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n\t\t}\n\t}\n\n\tprotected _readPixelOffset(domNode: FastDomNode<HTMLElement>, lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (this.input.isLTR && this._characterMapping.length === 0) {\n\t\t\t// This line has no content\n\t\t\tif (this._containsForeignElements === ForeignElementType.None) {\n\t\t\t\t// We can assume the line is really empty\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this._containsForeignElements === ForeignElementType.After) {\n\t\t\t\t// We have foreign elements after the (empty) line\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this._containsForeignElements === ForeignElementType.Before) {\n\t\t\t\t// We have foreign elements before the (empty) line\n\t\t\t\treturn this.getWidth(context);\n\t\t\t}\n\t\t\t// We have foreign elements before & after the (empty) line\n\t\t\tconst readingTarget = this._getReadingTarget(domNode);\n\t\t\tif (readingTarget.firstChild) {\n\t\t\t\tcontext.markDidDomLayout();\n\t\t\t\treturn (<HTMLSpanElement>readingTarget.firstChild).offsetWidth;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (this._pixelOffsetCache !== null) {\n\t\t\t// the text is guaranteed to be LTR\n\n\t\t\tconst cachedPixelOffset = this._pixelOffsetCache[column];\n\t\t\tif (cachedPixelOffset !== -1) {\n\t\t\t\treturn cachedPixelOffset;\n\t\t\t}\n\n\t\t\tconst result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n\t\t\tthis._pixelOffsetCache[column] = result;\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this._actualReadPixelOffset(domNode, lineNumber, column, context);\n\t}\n\n\tprivate _actualReadPixelOffset(domNode: FastDomNode<HTMLElement>, lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (this._characterMapping.length === 0) {\n\t\t\t// This line has no content\n\t\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context);\n\t\t\tif (!r || r.length === 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn r[0].left;\n\t\t}\n\n\t\tif (this.input.isLTR && column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === ForeignElementType.None) {\n\t\t\t// This branch helps in the case of whitespace only lines which have a width set\n\t\t\treturn this.getWidth(context);\n\t\t}\n\n\t\tconst domPosition = this._characterMapping.getDomPosition(column);\n\n\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n\t\tif (!r || r.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst result = r[0].left;\n\t\tif (this.input.isBasicASCII) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\tconst expectedResult = Math.round(this.input.spaceWidth * horizontalOffset);\n\t\t\tif (Math.abs(expectedResult - result) <= 1) {\n\t\t\t\treturn expectedResult;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _readRawVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\n\t\tif (this.input.isLTR && startColumn === 1 && endColumn === this._characterMapping.length) {\n\t\t\t// This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n\n\t\t\treturn [new FloatHorizontalRange(0, this.getWidth(context))];\n\t\t}\n\n\t\tconst startDomPosition = this._characterMapping.getDomPosition(startColumn);\n\t\tconst endDomPosition = this._characterMapping.getDomPosition(endColumn);\n\n\t\treturn RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context);\n\t}\n\n\t/**\n\t * Returns the column for the text found at a specific offset inside a rendered dom node\n\t */\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\treturn getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n\t}\n}\n\nclass WebKitRenderedViewLine extends RenderedViewLine {\n\tprotected override _readVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tconst output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);\n\n\t\tif (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\n\t\t\treturn output;\n\t\t}\n\n\t\t// WebKit is buggy and returns an expanded range (to contain words in some cases)\n\t\t// The last client rect is enlarged (I think)\n\t\tif (this.input.isLTR) {\n\t\t\t// This is an attempt to patch things up\n\t\t\t// Find position of last column\n\t\t\tconst endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n\t\t\tif (endPixelOffset !== -1) {\n\t\t\t\tconst lastRange = output[output.length - 1];\n\t\t\t\tif (lastRange.left < endPixelOffset) {\n\t\t\t\t\t// Trim down the width of the last visible range to not go after the last column's position\n\t\t\t\t\tlastRange.width = endPixelOffset - lastRange.left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}\n}\n\nconst createRenderedLine: (domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType) => RenderedViewLine = (function () {\n\tif (browser.isWebKit) {\n\t\treturn createWebKitRenderedLine;\n\t}\n\treturn createNormalRenderedLine;\n})();\n\nfunction createWebKitRenderedLine(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType): RenderedViewLine {\n\treturn new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsForeignElements);\n}\n\nfunction createNormalRenderedLine(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType): RenderedViewLine {\n\treturn new RenderedViewLine(domNode, renderLineInput, characterMapping, containsForeignElements);\n}\n\nexport function getColumnOfNodeOffset(characterMapping: CharacterMapping, spanNode: HTMLElement, offset: number): number {\n\tconst spanNodeTextContentLength = spanNode.textContent!.length;\n\n\tlet spanIndex = -1;\n\twhile (spanNode) {\n\t\tspanNode = <HTMLElement>spanNode.previousSibling;\n\t\tspanIndex++;\n\t}\n\n\treturn characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from '../../../../base/browser/browser.js';\nimport { FastDomNode, createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { IVisibleLine } from '../../view/viewLayer.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { CharacterMapping, ForeignElementType, RenderLineInput, renderViewLine, DomPosition, RenderWhitespace } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nimport { DomReadingContext } from './domReadingContext.js';\nimport { ViewLineOptions } from './viewLineOptions.js';\nimport { ViewGpuContext } from '../../gpu/viewGpuContext.js';\nimport { OffsetRange } from '../../../common/core/ranges/offsetRange.js';\nimport { InlineDecorationType } from '../../../common/viewModel/inlineDecorations.js';\nimport { TextDirection } from '../../../common/model.js';\n\nconst canUseFastRenderedViewLine = (function () {\n\tif (platform.isNative) {\n\t\t// In VSCode we know very well when the zoom level changes\n\t\treturn true;\n\t}\n\n\tif (platform.isLinux || browser.isFirefox || browser.isSafari) {\n\t\t// On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n\t\t// --\n\t\t// Even though we read character widths correctly, having read them at a specific zoom level\n\t\t// does not mean they are the same at the current zoom level.\n\t\t// --\n\t\t// This could be improved if we ever figure out how to get an event when browsers zoom,\n\t\t// but until then we have to stick with reading client rects.\n\t\t// --\n\t\t// The same has been observed with Firefox on Windows7\n\t\t// --\n\t\t// The same has been oversved with Safari\n\t\treturn false;\n\t}\n\n\treturn true;\n})();\n\nlet monospaceAssumptionsAreValid = true;\n\nexport class ViewLine implements IVisibleLine {\n\n\tpublic static readonly CLASS_NAME = 'view-line';\n\n\tprivate _options: ViewLineOptions;\n\tprivate _isMaybeInvalid: boolean;\n\tprivate _renderedViewLine: IRenderedViewLine | null;\n\n\tconstructor(private readonly _viewGpuContext: ViewGpuContext | undefined, options: ViewLineOptions) {\n\t\tthis._options = options;\n\t\tthis._isMaybeInvalid = true;\n\t\tthis._renderedViewLine = null;\n\t}\n\n\t// --- begin IVisibleLineData\n\n\tpublic getDomNode(): HTMLElement | null {\n\t\tif (this._renderedViewLine && this._renderedViewLine.domNode) {\n\t\t\treturn this._renderedViewLine.domNode.domNode;\n\t\t}\n\t\treturn null;\n\t}\n\tpublic setDomNode(domNode: HTMLElement): void {\n\t\tif (this._renderedViewLine) {\n\t\t\tthis._renderedViewLine.domNode = createFastDomNode(domNode);\n\t\t} else {\n\t\t\tthrow new Error('I have no rendered view line to set the dom node to...');\n\t\t}\n\t}\n\n\tpublic onContentChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onTokensChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onDecorationsChanged(): void {\n\t\tthis._isMaybeInvalid = true;\n\t}\n\tpublic onOptionsChanged(newOptions: ViewLineOptions): void {\n\t\tthis._isMaybeInvalid = true;\n\t\tthis._options = newOptions;\n\t}\n\tpublic onSelectionChanged(): boolean {\n\t\tif (isHighContrast(this._options.themeType) || this._renderedViewLine?.input.renderWhitespace === RenderWhitespace.Selection) {\n\t\t\tthis._isMaybeInvalid = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic renderLine(lineNumber: number, deltaTop: number, lineHeight: number, viewportData: ViewportData, sb: StringBuilder): boolean {\n\t\tif (this._options.useGpu && this._viewGpuContext?.canRender(this._options, viewportData, lineNumber)) {\n\t\t\tthis._renderedViewLine?.domNode?.domNode.remove();\n\t\t\tthis._renderedViewLine = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._isMaybeInvalid === false) {\n\t\t\t// it appears that nothing relevant has changed\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._isMaybeInvalid = false;\n\n\t\tconst lineData = viewportData.getViewLineRenderingData(lineNumber);\n\t\tconst options = this._options;\n\t\tconst actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n\t\tconst renderWhitespace = (lineData.hasVariableFonts || options.experimentalWhitespaceRendering === 'off') ? options.renderWhitespace : 'none';\n\t\tconst allowFastRendering = !lineData.hasVariableFonts;\n\n\t\t// Only send selection information when needed for rendering whitespace\n\t\tlet selectionsOnLine: OffsetRange[] | null = null;\n\t\tif (isHighContrast(options.themeType) || renderWhitespace === 'selection') {\n\t\t\tconst selections = viewportData.selections;\n\t\t\tfor (const selection of selections) {\n\n\t\t\t\tif (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n\t\t\t\t\t// Selection does not intersect line\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\n\t\t\t\tconst endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\n\n\t\t\t\tif (startColumn < endColumn) {\n\t\t\t\t\tif (isHighContrast(options.themeType)) {\n\t\t\t\t\t\tactualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', InlineDecorationType.Regular));\n\t\t\t\t\t}\n\t\t\t\t\tif (renderWhitespace === 'selection') {\n\t\t\t\t\t\tif (!selectionsOnLine) {\n\t\t\t\t\t\t\tselectionsOnLine = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselectionsOnLine.push(new OffsetRange(startColumn - 1, endColumn - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst renderLineInput = new RenderLineInput(\n\t\t\toptions.useMonospaceOptimizations,\n\t\t\toptions.canUseHalfwidthRightwardsArrow,\n\t\t\tlineData.content,\n\t\t\tlineData.continuesWithWrappedLine,\n\t\t\tlineData.isBasicASCII,\n\t\t\tlineData.containsRTL,\n\t\t\tlineData.minColumn - 1,\n\t\t\tlineData.tokens,\n\t\t\tactualInlineDecorations,\n\t\t\tlineData.tabSize,\n\t\t\tlineData.startVisibleColumn,\n\t\t\toptions.spaceWidth,\n\t\t\toptions.middotWidth,\n\t\t\toptions.wsmiddotWidth,\n\t\t\toptions.stopRenderingLineAfter,\n\t\t\trenderWhitespace,\n\t\t\toptions.renderControlCharacters,\n\t\t\toptions.fontLigatures !== EditorFontLigatures.OFF,\n\t\t\tselectionsOnLine,\n\t\t\tlineData.textDirection,\n\t\t\toptions.verticalScrollbarSize\n\t\t);\n\n\t\tif (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n\t\t\t// no need to do anything, we have the same render input\n\t\t\treturn false;\n\t\t}\n\n\t\tsb.appendString('<div ');\n\t\tif (lineData.textDirection === TextDirection.RTL) {\n\t\t\tsb.appendString('dir=\"rtl\" ');\n\t\t} else if (lineData.containsRTL) {\n\t\t\tsb.appendString('dir=\"ltr\" ');\n\t\t}\n\t\tsb.appendString('style=\"top:');\n\t\tsb.appendString(String(deltaTop));\n\t\tsb.appendString('px;height:');\n\t\tsb.appendString(String(lineHeight));\n\t\tsb.appendString('px;line-height:');\n\t\tsb.appendString(String(lineHeight));\n\t\tif (lineData.textDirection === TextDirection.RTL) {\n\t\t\tsb.appendString('px;padding-right:');\n\t\t\tsb.appendString(String(options.verticalScrollbarSize));\n\t\t}\n\t\tsb.appendString('px;\" class=\"');\n\t\tsb.appendString(ViewLine.CLASS_NAME);\n\t\tsb.appendString('\">');\n\n\t\tconst output = renderViewLine(renderLineInput, sb);\n\n\t\tsb.appendString('</div>');\n\n\t\tlet renderedViewLine: IRenderedViewLine | null = null;\n\t\tif (\n\t\t\tallowFastRendering\n\t\t\t&& monospaceAssumptionsAreValid\n\t\t\t&& canUseFastRenderedViewLine\n\t\t\t&& lineData.isBasicASCII\n\t\t\t&& renderLineInput.isLTR\n\t\t\t&& options.useMonospaceOptimizations\n\t\t\t&& output.containsForeignElements === ForeignElementType.None\n\t\t) {\n\t\t\trenderedViewLine = new FastRenderedViewLine(\n\t\t\t\tthis._renderedViewLine ? this._renderedViewLine.domNode : null,\n\t\t\t\trenderLineInput,\n\t\t\t\toutput.characterMapping\n\t\t\t);\n\t\t}\n\n\t\tif (!renderedViewLine) {\n\t\t\trenderedViewLine = createRenderedLine(\n\t\t\t\tthis._renderedViewLine ? this._renderedViewLine.domNode : null,\n\t\t\t\trenderLineInput,\n\t\t\t\toutput.characterMapping,\n\t\t\t\toutput.containsForeignElements\n\t\t\t);\n\t\t}\n\n\t\tthis._renderedViewLine = renderedViewLine;\n\n\t\treturn true;\n\t}\n\n\tpublic layoutLine(lineNumber: number, deltaTop: number, lineHeight: number): void {\n\t\tif (this._renderedViewLine && this._renderedViewLine.domNode) {\n\t\t\tthis._renderedViewLine.domNode.setTop(deltaTop);\n\t\t\tthis._renderedViewLine.domNode.setHeight(lineHeight);\n\t\t\tthis._renderedViewLine.domNode.setLineHeight(lineHeight);\n\t\t}\n\t}\n\n\t// --- end IVisibleLineData\n\n\tpublic isRenderedRTL(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._renderedViewLine.input.textDirection === TextDirection.RTL;\n\t}\n\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._renderedViewLine.getWidth(context);\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._renderedViewLine.getWidthIsFast();\n\t}\n\n\tpublic needsMonospaceFontCheck(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._renderedViewLine instanceof FastRenderedViewLine);\n\t}\n\n\tpublic monospaceAssumptionsAreValid(): boolean {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn monospaceAssumptionsAreValid;\n\t\t}\n\t\tif (this._renderedViewLine instanceof FastRenderedViewLine) {\n\t\t\treturn this._renderedViewLine.monospaceAssumptionsAreValid();\n\t\t}\n\t\treturn monospaceAssumptionsAreValid;\n\t}\n\n\tpublic onMonospaceAssumptionsInvalidated(): void {\n\t\tif (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n\t\t\tthis._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n\t\t}\n\t}\n\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): VisibleRanges | null {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstartColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n\t\tendColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n\n\t\tconst stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter;\n\n\t\tif (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n\t\t\t// This range is obviously not visible\n\t\t\treturn new VisibleRanges(true, [new FloatHorizontalRange(this.getWidth(context), 0)]);\n\t\t}\n\n\t\tif (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n\t\t\tstartColumn = stopRenderingLineAfter + 1;\n\t\t}\n\n\t\tif (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n\t\t\tendColumn = stopRenderingLineAfter + 1;\n\t\t}\n\n\t\tconst horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n\t\tif (horizontalRanges && horizontalRanges.length > 0) {\n\t\t\treturn new VisibleRanges(false, horizontalRanges);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\tif (!this._renderedViewLine) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._renderedViewLine.getColumnOfNodeOffset(spanNode, offset);\n\t}\n}\n\ninterface IRenderedViewLine {\n\tdomNode: FastDomNode<HTMLElement> | null;\n\treadonly input: RenderLineInput;\n\tgetWidth(context: DomReadingContext | null): number;\n\tgetWidthIsFast(): boolean;\n\tgetVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null;\n\tgetColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number;\n}\n\nconst enum Constants {\n\t/**\n\t * It seems that rounding errors occur with long lines, so the purely multiplication based\n\t * method is only viable for short lines. For longer lines, we look up the real position of\n\t * every 300th character and use multiplication based on that.\n\t *\n\t * See https://github.com/microsoft/vscode/issues/33178\n\t */\n\tMaxMonospaceDistance = 300\n}\n\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nclass FastRenderedViewLine implements IRenderedViewLine {\n\n\tpublic domNode: FastDomNode<HTMLElement> | null;\n\tpublic readonly input: RenderLineInput;\n\n\tprivate readonly _characterMapping: CharacterMapping;\n\tprivate readonly _charWidth: number;\n\tprivate readonly _keyColumnPixelOffsetCache: Float32Array | null;\n\tprivate _cachedWidth: number = -1;\n\n\tconstructor(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping) {\n\t\tthis.domNode = domNode;\n\t\tthis.input = renderLineInput;\n\t\tconst keyColumnCount = Math.floor(renderLineInput.lineContent.length / Constants.MaxMonospaceDistance);\n\t\tif (keyColumnCount > 0) {\n\t\t\tthis._keyColumnPixelOffsetCache = new Float32Array(keyColumnCount);\n\t\t\tfor (let i = 0; i < keyColumnCount; i++) {\n\t\t\t\tthis._keyColumnPixelOffsetCache[i] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._keyColumnPixelOffsetCache = null;\n\t\t}\n\n\t\tthis._characterMapping = characterMapping;\n\t\tthis._charWidth = renderLineInput.spaceWidth;\n\t}\n\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this.domNode || this.input.lineContent.length < Constants.MaxMonospaceDistance) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(this._characterMapping.length);\n\t\t\treturn Math.round(this._charWidth * horizontalOffset);\n\t\t}\n\t\tif (this._cachedWidth === -1) {\n\t\t\tthis._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n\t\t\tcontext?.markDidDomLayout();\n\t\t}\n\t\treturn this._cachedWidth;\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\treturn (this.input.lineContent.length < Constants.MaxMonospaceDistance) || this._cachedWidth !== -1;\n\t}\n\n\tpublic monospaceAssumptionsAreValid(): boolean {\n\t\tif (!this.domNode) {\n\t\t\treturn monospaceAssumptionsAreValid;\n\t\t}\n\t\tif (this.input.lineContent.length < Constants.MaxMonospaceDistance) {\n\t\t\tconst expectedWidth = this.getWidth(null);\n\t\t\tconst actualWidth = (<HTMLSpanElement>this.domNode.domNode.firstChild).offsetWidth;\n\t\t\tif (Math.abs(expectedWidth - actualWidth) >= 2) {\n\t\t\t\t// more than 2px off\n\t\t\t\tconsole.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n\t\t\t\tmonospaceAssumptionsAreValid = false;\n\t\t\t}\n\t\t}\n\t\treturn monospaceAssumptionsAreValid;\n\t}\n\n\tpublic toSlowRenderedLine(): RenderedViewLine {\n\t\treturn createRenderedLine(this.domNode, this.input, this._characterMapping, ForeignElementType.None);\n\t}\n\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tconst startPosition = this._getColumnPixelOffset(lineNumber, startColumn, context);\n\t\tconst endPosition = this._getColumnPixelOffset(lineNumber, endColumn, context);\n\t\treturn [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n\t}\n\n\tprivate _getColumnPixelOffset(lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (column <= Constants.MaxMonospaceDistance) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\treturn this._charWidth * horizontalOffset;\n\t\t}\n\n\t\tconst keyColumnOrdinal = Math.floor((column - 1) / Constants.MaxMonospaceDistance) - 1;\n\t\tconst keyColumn = (keyColumnOrdinal + 1) * Constants.MaxMonospaceDistance + 1;\n\t\tlet keyColumnPixelOffset = -1;\n\t\tif (this._keyColumnPixelOffsetCache) {\n\t\t\tkeyColumnPixelOffset = this._keyColumnPixelOffsetCache[keyColumnOrdinal];\n\t\t\tif (keyColumnPixelOffset === -1) {\n\t\t\t\tkeyColumnPixelOffset = this._actualReadPixelOffset(lineNumber, keyColumn, context);\n\t\t\t\tthis._keyColumnPixelOffsetCache[keyColumnOrdinal] = keyColumnPixelOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (keyColumnPixelOffset === -1) {\n\t\t\t// Could not read actual key column pixel offset\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\treturn this._charWidth * horizontalOffset;\n\t\t}\n\n\t\tconst keyColumnHorizontalOffset = this._characterMapping.getHorizontalOffset(keyColumn);\n\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\treturn keyColumnPixelOffset + this._charWidth * (horizontalOffset - keyColumnHorizontalOffset);\n\t}\n\n\tprivate _getReadingTarget(myDomNode: FastDomNode<HTMLElement>): HTMLElement {\n\t\treturn <HTMLSpanElement>myDomNode.domNode.firstChild;\n\t}\n\n\tprivate _actualReadPixelOffset(lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (!this.domNode) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst domPosition = this._characterMapping.getDomPosition(column);\n\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(this.domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n\t\tif (!r || r.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn r[0].left;\n\t}\n\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\treturn getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n\t}\n}\n\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nclass RenderedViewLine implements IRenderedViewLine {\n\n\tpublic domNode: FastDomNode<HTMLElement> | null;\n\tpublic readonly input: RenderLineInput;\n\n\tprotected readonly _characterMapping: CharacterMapping;\n\tprivate readonly _isWhitespaceOnly: boolean;\n\tprivate readonly _containsForeignElements: ForeignElementType;\n\tprivate _cachedWidth: number;\n\n\t/**\n\t * This is a map that is used only when the line is guaranteed to be rendered LTR and has no RTL text.\n\t */\n\tprivate readonly _pixelOffsetCache: Float32Array | null;\n\n\tconstructor(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType) {\n\t\tthis.domNode = domNode;\n\t\tthis.input = renderLineInput;\n\t\tthis._characterMapping = characterMapping;\n\t\tthis._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n\t\tthis._containsForeignElements = containsForeignElements;\n\t\tthis._cachedWidth = -1;\n\n\t\tthis._pixelOffsetCache = null;\n\t\tif (renderLineInput.isLTR) {\n\t\t\tthis._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n\t\t\tfor (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n\t\t\t\tthis._pixelOffsetCache[column] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// --- Reading from the DOM methods\n\n\tprotected _getReadingTarget(myDomNode: FastDomNode<HTMLElement>): HTMLElement {\n\t\treturn <HTMLSpanElement>myDomNode.domNode.firstChild;\n\t}\n\n\t/**\n\t * Width of the line in pixels\n\t */\n\tpublic getWidth(context: DomReadingContext | null): number {\n\t\tif (!this.domNode) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (this._cachedWidth === -1) {\n\t\t\tthis._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n\t\t\tcontext?.markDidDomLayout();\n\t\t}\n\t\treturn this._cachedWidth;\n\t}\n\n\tpublic getWidthIsFast(): boolean {\n\t\tif (this._cachedWidth === -1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Visible ranges for a model range\n\t */\n\tpublic getVisibleRangesForRange(lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tif (!this.domNode) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._pixelOffsetCache !== null) {\n\t\t\t// the text is guaranteed to be entirely LTR\n\t\t\tconst startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n\t\t\tif (startOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n\t\t\tif (endOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n\t\t}\n\n\t\treturn this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n\t}\n\n\tprotected _readVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tif (startColumn === endColumn) {\n\t\t\tconst pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n\t\t\tif (pixelOffset === -1) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn [new FloatHorizontalRange(pixelOffset, 0)];\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n\t\t}\n\t}\n\n\tprotected _readPixelOffset(domNode: FastDomNode<HTMLElement>, lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (this.input.isLTR && this._characterMapping.length === 0) {\n\t\t\t// This line has no content\n\t\t\tif (this._containsForeignElements === ForeignElementType.None) {\n\t\t\t\t// We can assume the line is really empty\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this._containsForeignElements === ForeignElementType.After) {\n\t\t\t\t// We have foreign elements after the (empty) line\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this._containsForeignElements === ForeignElementType.Before) {\n\t\t\t\t// We have foreign elements before the (empty) line\n\t\t\t\treturn this.getWidth(context);\n\t\t\t}\n\t\t\t// We have foreign elements before & after the (empty) line\n\t\t\tconst readingTarget = this._getReadingTarget(domNode);\n\t\t\tif (readingTarget.firstChild) {\n\t\t\t\tcontext.markDidDomLayout();\n\t\t\t\treturn (<HTMLSpanElement>readingTarget.firstChild).offsetWidth;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (this._pixelOffsetCache !== null) {\n\t\t\t// the text is guaranteed to be LTR\n\n\t\t\tconst cachedPixelOffset = this._pixelOffsetCache[column];\n\t\t\tif (cachedPixelOffset !== -1) {\n\t\t\t\treturn cachedPixelOffset;\n\t\t\t}\n\n\t\t\tconst result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n\t\t\tthis._pixelOffsetCache[column] = result;\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this._actualReadPixelOffset(domNode, lineNumber, column, context);\n\t}\n\n\tprivate _actualReadPixelOffset(domNode: FastDomNode<HTMLElement>, lineNumber: number, column: number, context: DomReadingContext): number {\n\t\tif (this._characterMapping.length === 0) {\n\t\t\t// This line has no content\n\t\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context);\n\t\t\tif (!r || r.length === 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn r[0].left;\n\t\t}\n\n\t\tif (this.input.isLTR && column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === ForeignElementType.None) {\n\t\t\t// This branch helps in the case of whitespace only lines which have a width set\n\t\t\treturn this.getWidth(context);\n\t\t}\n\n\t\tconst domPosition = this._characterMapping.getDomPosition(column);\n\n\t\tconst r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n\t\tif (!r || r.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst result = r[0].left;\n\t\tif (this.input.isBasicASCII) {\n\t\t\tconst horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n\t\t\tconst expectedResult = Math.round(this.input.spaceWidth * horizontalOffset);\n\t\t\tif (Math.abs(expectedResult - result) <= 1) {\n\t\t\t\treturn expectedResult;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _readRawVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\n\t\tif (this.input.isLTR && startColumn === 1 && endColumn === this._characterMapping.length) {\n\t\t\t// This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n\n\t\t\treturn [new FloatHorizontalRange(0, this.getWidth(context))];\n\t\t}\n\n\t\tconst startDomPosition = this._characterMapping.getDomPosition(startColumn);\n\t\tconst endDomPosition = this._characterMapping.getDomPosition(endColumn);\n\n\t\treturn RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context);\n\t}\n\n\t/**\n\t * Returns the column for the text found at a specific offset inside a rendered dom node\n\t */\n\tpublic getColumnOfNodeOffset(spanNode: HTMLElement, offset: number): number {\n\t\treturn getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n\t}\n}\n\nclass WebKitRenderedViewLine extends RenderedViewLine {\n\tprotected override _readVisibleRangesForRange(domNode: FastDomNode<HTMLElement>, lineNumber: number, startColumn: number, endColumn: number, context: DomReadingContext): FloatHorizontalRange[] | null {\n\t\tconst output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);\n\n\t\tif (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\n\t\t\treturn output;\n\t\t}\n\n\t\t// WebKit is buggy and returns an expanded range (to contain words in some cases)\n\t\t// The last client rect is enlarged (I think)\n\t\tif (this.input.isLTR) {\n\t\t\t// This is an attempt to patch things up\n\t\t\t// Find position of last column\n\t\t\tconst endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n\t\t\tif (endPixelOffset !== -1) {\n\t\t\t\tconst lastRange = output[output.length - 1];\n\t\t\t\tif (lastRange.left < endPixelOffset) {\n\t\t\t\t\t// Trim down the width of the last visible range to not go after the last column's position\n\t\t\t\t\tlastRange.width = endPixelOffset - lastRange.left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}\n}\n\nconst createRenderedLine: (domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType) => RenderedViewLine = (function () {\n\tif (browser.isWebKit) {\n\t\treturn createWebKitRenderedLine;\n\t}\n\treturn createNormalRenderedLine;\n})();\n\nfunction createWebKitRenderedLine(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType): RenderedViewLine {\n\treturn new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsForeignElements);\n}\n\nfunction createNormalRenderedLine(domNode: FastDomNode<HTMLElement> | null, renderLineInput: RenderLineInput, characterMapping: CharacterMapping, containsForeignElements: ForeignElementType): RenderedViewLine {\n\treturn new RenderedViewLine(domNode, renderLineInput, characterMapping, containsForeignElements);\n}\n\nexport function getColumnOfNodeOffset(characterMapping: CharacterMapping, spanNode: HTMLElement, offset: number): number {\n\tconst spanNodeTextContentLength = spanNode.textContent!.length;\n\n\tlet spanIndex = -1;\n\twhile (spanNode) {\n\t\tspanNode = <HTMLElement>spanNode.previousSibling;\n\t\tspanIndex++;\n\t}\n\n\treturn characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n}\n"]}