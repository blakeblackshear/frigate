{"version":3,"sources":["../src/index.ts","../src/cache/createBrowserLocalStorageCache.ts","../src/cache/createNullCache.ts","../src/cache/createFallbackableCache.ts","../src/cache/createMemoryCache.ts","../src/constants.ts","../src/createAlgoliaAgent.ts","../src/createAuth.ts","../src/createIterablePromise.ts","../src/getAlgoliaAgent.ts","../src/logger/createNullLogger.ts","../src/transporter/createStatefulHost.ts","../src/transporter/errors.ts","../src/transporter/helpers.ts","../src/transporter/responses.ts","../src/transporter/stackTrace.ts","../src/transporter/createTransporter.ts","../src/types/logger.ts"],"sourcesContent":["export * from './cache';\nexport * from './constants';\nexport * from './createAlgoliaAgent';\nexport * from './createAuth';\nexport * from './createIterablePromise';\nexport * from './getAlgoliaAgent';\nexport * from './logger';\nexport * from './transporter';\nexport * from './types';\n","import type { BrowserLocalStorageCacheItem, BrowserLocalStorageOptions, Cache, CacheEvents } from '../types';\n\nexport function createBrowserLocalStorageCache(options: BrowserLocalStorageOptions): Cache {\n  let storage: Storage;\n  // We've changed the namespace to avoid conflicts with v4, as this version is a huge breaking change\n  const namespaceKey = `algolia-client-js-${options.key}`;\n\n  function getStorage(): Storage {\n    if (storage === undefined) {\n      storage = options.localStorage || window.localStorage;\n    }\n\n    return storage;\n  }\n\n  function getNamespace<TValue>(): Record<string, TValue> {\n    return JSON.parse(getStorage().getItem(namespaceKey) || '{}');\n  }\n\n  function setNamespace(namespace: Record<string, any>): void {\n    getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n  }\n\n  function removeOutdatedCacheItems(): void {\n    const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n    const namespace = getNamespace<BrowserLocalStorageCacheItem>();\n\n    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(\n      Object.entries(namespace).filter(([, cacheItem]) => {\n        return cacheItem.timestamp !== undefined;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n\n    if (!timeToLive) {\n      return;\n    }\n\n    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(\n      Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\n        const currentTimestamp = new Date().getTime();\n        const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n\n        return !isExpired;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutExpiredItems);\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: () => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return Promise.resolve()\n        .then(() => {\n          removeOutdatedCacheItems();\n\n          return getNamespace<Promise<BrowserLocalStorageCacheItem>>()[JSON.stringify(key)];\n        })\n        .then((value) => {\n          return Promise.all([value ? value.value : defaultValue(), value !== undefined]);\n        })\n        .then(([value, exists]) => {\n          return Promise.all([value, exists || events.miss(value)]);\n        })\n        .then(([value]) => value);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        namespace[JSON.stringify(key)] = {\n          timestamp: new Date().getTime(),\n          value,\n        };\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n\n        return value;\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        delete namespace[JSON.stringify(key)];\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n      });\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve().then(() => {\n        getStorage().removeItem(namespaceKey);\n      });\n    },\n  };\n}\n","import type { Cache, CacheEvents } from '../types';\n\nexport function createNullCache(): Cache {\n  return {\n    get<TValue>(\n      _key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const value = defaultValue();\n\n      return value.then((result) => Promise.all([result, events.miss(result)])).then(([result]) => result);\n    },\n\n    set<TValue>(_key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve(value);\n    },\n\n    delete(_key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n","import type { Cache, CacheEvents, FallbackableCacheOptions } from '../types';\nimport { createNullCache } from './createNullCache';\n\nexport function createFallbackableCache(options: FallbackableCacheOptions): Cache {\n  const caches = [...options.caches];\n  const current = caches.shift();\n\n  if (current === undefined) {\n    return createNullCache();\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return current.get(key, defaultValue, events).catch(() => {\n        return createFallbackableCache({ caches }).get(key, defaultValue, events);\n      });\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return current.set(key, value).catch(() => {\n        return createFallbackableCache({ caches }).set(key, value);\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return current.delete(key).catch(() => {\n        return createFallbackableCache({ caches }).delete(key);\n      });\n    },\n\n    clear(): Promise<void> {\n      return current.clear().catch(() => {\n        return createFallbackableCache({ caches }).clear();\n      });\n    },\n  };\n}\n","import type { Cache, CacheEvents, MemoryCacheOptions } from '../types';\n\nexport function createMemoryCache(options: MemoryCacheOptions = { serializable: true }): Cache {\n  let cache: Record<string, any> = {};\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const keyAsString = JSON.stringify(key);\n\n      if (keyAsString in cache) {\n        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n      }\n\n      const promise = defaultValue();\n\n      return promise.then((value: TValue) => events.miss(value)).then(() => promise);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n\n      return Promise.resolve(value);\n    },\n\n    delete(key: Record<string, unknown> | string): Promise<void> {\n      delete cache[JSON.stringify(key)];\n\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      cache = {};\n\n      return Promise.resolve();\n    },\n  };\n}\n","export const DEFAULT_CONNECT_TIMEOUT_BROWSER = 1000;\nexport const DEFAULT_READ_TIMEOUT_BROWSER = 2000;\nexport const DEFAULT_WRITE_TIMEOUT_BROWSER = 30000;\n\nexport const DEFAULT_CONNECT_TIMEOUT_NODE = 2000;\nexport const DEFAULT_READ_TIMEOUT_NODE = 5000;\nexport const DEFAULT_WRITE_TIMEOUT_NODE = 30000;\n","import type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport function createAlgoliaAgent(version: string): AlgoliaAgent {\n  const algoliaAgent = {\n    value: `Algolia for JavaScript (${version})`,\n    add(options: AlgoliaAgentOptions): AlgoliaAgent {\n      const addedAlgoliaAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;\n\n      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {\n        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;\n      }\n\n      return algoliaAgent;\n    },\n  };\n\n  return algoliaAgent;\n}\n","import type { AuthMode, Headers, QueryParameters } from './types';\n\nexport function createAuth(\n  appId: string,\n  apiKey: string,\n  authMode: AuthMode = 'WithinHeaders',\n): {\n  readonly headers: () => Headers;\n  readonly queryParameters: () => QueryParameters;\n} {\n  const credentials = {\n    'x-algolia-api-key': apiKey,\n    'x-algolia-application-id': appId,\n  };\n\n  return {\n    headers(): Headers {\n      return authMode === 'WithinHeaders' ? credentials : {};\n    },\n\n    queryParameters(): QueryParameters {\n      return authMode === 'WithinQueryParameters' ? credentials : {};\n    },\n  };\n}\n","import type { CreateIterablePromise } from './types/createIterablePromise';\n\n/**\n * Helper: Returns the promise of a given `func` to iterate on, based on a given `validate` condition.\n *\n * @param createIterator - The createIterator options.\n * @param createIterator.func - The function to run, which returns a promise.\n * @param createIterator.validate - The validator function. It receives the resolved return of `func`.\n * @param createIterator.aggregator - The function that runs right after the `func` method has been executed, allows you to do anything with the response before `validate`.\n * @param createIterator.error - The `validate` condition to throw an error, and its message.\n * @param createIterator.timeout - The function to decide how long to wait between iterations.\n */\nexport function createIterablePromise<TResponse>({\n  func,\n  validate,\n  aggregator,\n  error,\n  timeout = (): number => 0,\n}: CreateIterablePromise<TResponse>): Promise<TResponse> {\n  const retry = (previousResponse?: TResponse | undefined): Promise<TResponse> => {\n    return new Promise<TResponse>((resolve, reject) => {\n      func(previousResponse)\n        .then(async (response) => {\n          if (aggregator) {\n            await aggregator(response);\n          }\n\n          if (await validate(response)) {\n            return resolve(response);\n          }\n\n          if (error && (await error.validate(response))) {\n            return reject(new Error(await error.message(response)));\n          }\n\n          return setTimeout(\n            () => {\n              retry(response).then(resolve).catch(reject);\n            },\n            await timeout(),\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  };\n\n  return retry();\n}\n","import { createAlgoliaAgent } from './createAlgoliaAgent';\nimport type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport type GetAlgoliaAgent = {\n  algoliaAgents: AlgoliaAgentOptions[];\n  client: string;\n  version: string;\n};\n\nexport function getAlgoliaAgent({ algoliaAgents, client, version }: GetAlgoliaAgent): AlgoliaAgent {\n  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({\n    segment: client,\n    version,\n  });\n\n  algoliaAgents.forEach((algoliaAgent) => defaultAlgoliaAgent.add(algoliaAgent));\n\n  return defaultAlgoliaAgent;\n}\n","import type { Logger } from '../types/logger';\n\nexport function createNullLogger(): Logger {\n  return {\n    debug(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n    info(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n    error(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n","import type { Host, StatefulHost } from '../types';\n\n// By default, API Clients at Algolia have expiration delay of 5 mins.\n// In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\n\nexport function createStatefulHost(host: Host, status: StatefulHost['status'] = 'up'): StatefulHost {\n  const lastUpdate = Date.now();\n\n  function isUp(): boolean {\n    return status === 'up' || Date.now() - lastUpdate > EXPIRATION_DELAY;\n  }\n\n  function isTimedOut(): boolean {\n    return status === 'timed out' && Date.now() - lastUpdate <= EXPIRATION_DELAY;\n  }\n\n  return { ...host, status, lastUpdate, isUp, isTimedOut };\n}\n","import type { Response, StackFrame } from '../types';\n\nexport class AlgoliaError extends Error {\n  override name: string = 'AlgoliaError';\n\n  constructor(message: string, name: string) {\n    super(message);\n\n    if (name) {\n      this.name = name;\n    }\n  }\n}\n\nexport class IndexNotFoundError extends AlgoliaError {\n  constructor(indexName: string) {\n    super(`${indexName} does not exist`, 'IndexNotFoundError');\n  }\n}\n\nexport class IndicesInSameAppError extends AlgoliaError {\n  constructor() {\n    super('Indices are in the same application. Use operationIndex instead.', 'IndicesInSameAppError');\n  }\n}\n\nexport class IndexAlreadyExistsError extends AlgoliaError {\n  constructor(indexName: string) {\n    super(`${indexName} index already exists.`, 'IndexAlreadyExistsError');\n  }\n}\n\nexport class ErrorWithStackTrace extends AlgoliaError {\n  stackTrace: StackFrame[];\n\n  constructor(message: string, stackTrace: StackFrame[], name: string) {\n    super(message, name);\n    // the array and object should be frozen to reflect the stackTrace at the time of the error\n    this.stackTrace = stackTrace;\n  }\n}\n\nexport class RetryError extends ErrorWithStackTrace {\n  constructor(stackTrace: StackFrame[]) {\n    super(\n      'Unreachable hosts - your application id may be incorrect. If the error persists, please visit our help center https://alg.li/support-unreachable-hosts or reach out to the Algolia Support team: https://alg.li/support',\n      stackTrace,\n      'RetryError',\n    );\n  }\n}\n\nexport class ApiError extends ErrorWithStackTrace {\n  status: number;\n\n  constructor(message: string, status: number, stackTrace: StackFrame[], name = 'ApiError') {\n    super(message, stackTrace, name);\n    this.status = status;\n  }\n}\n\nexport class DeserializationError extends AlgoliaError {\n  response: Response;\n\n  constructor(message: string, response: Response) {\n    super(message, 'DeserializationError');\n    this.response = response;\n  }\n}\n\nexport type DetailedErrorWithMessage = {\n  message: string;\n  label: string;\n};\n\nexport type DetailedErrorWithTypeID = {\n  id: string;\n  type: string;\n  name?: string | undefined;\n};\n\nexport type DetailedError = {\n  code: string;\n  details?: DetailedErrorWithMessage[] | DetailedErrorWithTypeID[] | undefined;\n};\n\n// DetailedApiError is only used by the ingestion client to return more informative error, other clients will use ApiClient.\nexport class DetailedApiError extends ApiError {\n  error: DetailedError;\n\n  constructor(message: string, status: number, error: DetailedError, stackTrace: StackFrame[]) {\n    super(message, status, stackTrace, 'DetailedApiError');\n    this.error = error;\n  }\n}\n","import type { Headers, Host, QueryParameters, Request, RequestOptions, Response, StackFrame } from '../types';\nimport { ApiError, DeserializationError, DetailedApiError } from './errors';\n\nexport function shuffle<TData>(array: TData[]): TData[] {\n  const shuffledArray = array;\n\n  for (let c = array.length - 1; c > 0; c--) {\n    const b = Math.floor(Math.random() * (c + 1));\n    const a = array[c];\n\n    shuffledArray[c] = array[b];\n    shuffledArray[b] = a;\n  }\n\n  return shuffledArray;\n}\n\nexport function serializeUrl(host: Host, path: string, queryParameters: QueryParameters): string {\n  const queryParametersAsString = serializeQueryParameters(queryParameters);\n  let url = `${host.protocol}://${host.url}${host.port ? `:${host.port}` : ''}/${\n    path.charAt(0) === '/' ? path.substring(1) : path\n  }`;\n\n  if (queryParametersAsString.length) {\n    url += `?${queryParametersAsString}`;\n  }\n\n  return url;\n}\n\nexport function serializeQueryParameters(parameters: QueryParameters): string {\n  return Object.keys(parameters)\n    .filter((key) => parameters[key] !== undefined)\n    .sort()\n    .map(\n      (key) =>\n        `${key}=${encodeURIComponent(\n          Object.prototype.toString.call(parameters[key]) === '[object Array]'\n            ? parameters[key].join(',')\n            : parameters[key],\n        ).replace(/\\+/g, '%20')}`,\n    )\n    .join('&');\n}\n\nexport function serializeData(request: Request, requestOptions: RequestOptions): string | undefined {\n  if (request.method === 'GET' || (request.data === undefined && requestOptions.data === undefined)) {\n    return undefined;\n  }\n\n  const data = Array.isArray(request.data) ? request.data : { ...request.data, ...requestOptions.data };\n\n  return JSON.stringify(data);\n}\n\nexport function serializeHeaders(\n  baseHeaders: Headers,\n  requestHeaders: Headers,\n  requestOptionsHeaders?: Headers | undefined,\n): Headers {\n  const headers: Headers = {\n    Accept: 'application/json',\n    ...baseHeaders,\n    ...requestHeaders,\n    ...requestOptionsHeaders,\n  };\n  const serializedHeaders: Headers = {};\n\n  Object.keys(headers).forEach((header) => {\n    const value = headers[header];\n    serializedHeaders[header.toLowerCase()] = value;\n  });\n\n  return serializedHeaders;\n}\n\nexport function deserializeSuccess<TObject>(response: Response): TObject {\n  try {\n    return JSON.parse(response.content);\n  } catch (e) {\n    throw new DeserializationError((e as Error).message, response);\n  }\n}\n\nexport function deserializeFailure({ content, status }: Response, stackFrame: StackFrame[]): Error {\n  try {\n    const parsed = JSON.parse(content);\n    if ('error' in parsed) {\n      return new DetailedApiError(parsed.message, status, parsed.error, stackFrame);\n    }\n    return new ApiError(parsed.message, status, stackFrame);\n  } catch {\n    // ..\n  }\n  return new ApiError(content, status, stackFrame);\n}\n","import type { Response } from '../types';\n\nexport function isNetworkError({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return !isTimedOut && ~~status === 0;\n}\n\nexport function isRetryable({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return isTimedOut || isNetworkError({ isTimedOut, status }) || (~~(status / 100) !== 2 && ~~(status / 100) !== 4);\n}\n\nexport function isSuccess({ status }: Pick<Response, 'status'>): boolean {\n  return ~~(status / 100) === 2;\n}\n","import type { Headers, StackFrame } from '../types';\n\nexport function stackTraceWithoutCredentials(stackTrace: StackFrame[]): StackFrame[] {\n  return stackTrace.map((stackFrame) => stackFrameWithoutCredentials(stackFrame));\n}\n\nexport function stackFrameWithoutCredentials(stackFrame: StackFrame): StackFrame {\n  const modifiedHeaders: Headers = stackFrame.request.headers['x-algolia-api-key']\n    ? { 'x-algolia-api-key': '*****' }\n    : {};\n\n  return {\n    ...stackFrame,\n    request: {\n      ...stackFrame.request,\n      headers: {\n        ...stackFrame.request.headers,\n        ...modifiedHeaders,\n      },\n    },\n  };\n}\n","import type {\n  EndRequest,\n  Host,\n  QueryParameters,\n  Request,\n  RequestOptions,\n  Response,\n  StackFrame,\n  Transporter,\n  TransporterOptions,\n} from '../types';\nimport { createStatefulHost } from './createStatefulHost';\nimport { RetryError } from './errors';\nimport { deserializeFailure, deserializeSuccess, serializeData, serializeHeaders, serializeUrl } from './helpers';\nimport { isRetryable, isSuccess } from './responses';\nimport { stackFrameWithoutCredentials, stackTraceWithoutCredentials } from './stackTrace';\n\ntype RetryableOptions = {\n  hosts: Host[];\n  getTimeout: (retryCount: number, timeout: number) => number;\n};\n\nexport function createTransporter({\n  hosts,\n  hostsCache,\n  baseHeaders,\n  logger,\n  baseQueryParameters,\n  algoliaAgent,\n  timeouts,\n  requester,\n  requestsCache,\n  responsesCache,\n}: TransporterOptions): Transporter {\n  async function createRetryableOptions(compatibleHosts: Host[]): Promise<RetryableOptions> {\n    const statefulHosts = await Promise.all(\n      compatibleHosts.map((compatibleHost) => {\n        return hostsCache.get(compatibleHost, () => {\n          return Promise.resolve(createStatefulHost(compatibleHost));\n        });\n      }),\n    );\n    const hostsUp = statefulHosts.filter((host) => host.isUp());\n    const hostsTimedOut = statefulHosts.filter((host) => host.isTimedOut());\n\n    // Note, we put the hosts that previously timed out on the end of the list.\n    const hostsAvailable = [...hostsUp, ...hostsTimedOut];\n    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;\n\n    return {\n      hosts: compatibleHostsAvailable,\n      getTimeout(timeoutsCount: number, baseTimeout: number): number {\n        /**\n         * Imagine that you have 4 hosts, if timeouts will increase\n         * on the following way: 1 (timed out) > 4 (timed out) > 5 (200).\n         *\n         * Note that, the very next request, we start from the previous timeout.\n         *\n         *  5 (timed out) > 6 (timed out) > 7 ...\n         *\n         * This strategy may need to be reviewed, but is the strategy on the our\n         * current v3 version.\n         */\n        const timeoutMultiplier =\n          hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;\n\n        return timeoutMultiplier * baseTimeout;\n      },\n    };\n  }\n\n  async function retryableRequest<TResponse>(\n    request: Request,\n    requestOptions: RequestOptions,\n    isRead = true,\n  ): Promise<TResponse> {\n    const stackTrace: StackFrame[] = [];\n\n    /**\n     * First we prepare the payload that do not depend from hosts.\n     */\n    const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);\n\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters: QueryParameters =\n      request.method === 'GET'\n        ? {\n            ...request.data,\n            ...requestOptions.data,\n          }\n        : {};\n\n    const queryParameters: QueryParameters = {\n      ...baseQueryParameters,\n      ...request.queryParameters,\n      ...dataQueryParameters,\n    };\n\n    if (algoliaAgent.value) {\n      queryParameters['x-algolia-agent'] = algoliaAgent.value;\n    }\n\n    if (requestOptions && requestOptions.queryParameters) {\n      for (const key of Object.keys(requestOptions.queryParameters)) {\n        // We want to keep `undefined` and `null` values,\n        // but also avoid stringifying `object`s, as they are\n        // handled in the `serializeUrl` step right after.\n        if (\n          !requestOptions.queryParameters[key] ||\n          Object.prototype.toString.call(requestOptions.queryParameters[key]) === '[object Object]'\n        ) {\n          queryParameters[key] = requestOptions.queryParameters[key];\n        } else {\n          queryParameters[key] = requestOptions.queryParameters[key].toString();\n        }\n      }\n    }\n\n    let timeoutsCount = 0;\n\n    const retry = async (\n      retryableHosts: Host[],\n      getTimeout: (timeoutsCount: number, timeout: number) => number,\n    ): Promise<TResponse> => {\n      /**\n       * We iterate on each host, until there is no host left.\n       */\n      const host = retryableHosts.pop();\n      if (host === undefined) {\n        throw new RetryError(stackTraceWithoutCredentials(stackTrace));\n      }\n\n      const timeout = { ...timeouts, ...requestOptions.timeouts };\n\n      const payload: EndRequest = {\n        data,\n        headers,\n        method: request.method,\n        url: serializeUrl(host, request.path, queryParameters),\n        connectTimeout: getTimeout(timeoutsCount, timeout.connect),\n        responseTimeout: getTimeout(timeoutsCount, isRead ? timeout.read : timeout.write),\n      };\n\n      /**\n       * The stackFrame is pushed to the stackTrace so we\n       * can have information about onRetry and onFailure\n       * decisions.\n       */\n      const pushToStackTrace = (response: Response): StackFrame => {\n        const stackFrame: StackFrame = {\n          request: payload,\n          response,\n          host,\n          triesLeft: retryableHosts.length,\n        };\n\n        stackTrace.push(stackFrame);\n\n        return stackFrame;\n      };\n\n      const response = await requester.send(payload);\n\n      if (isRetryable(response)) {\n        const stackFrame = pushToStackTrace(response);\n\n        // If response is a timeout, we increase the number of timeouts so we can increase the timeout later.\n        if (response.isTimedOut) {\n          timeoutsCount++;\n        }\n        /**\n         * Failures are individually sent to the logger, allowing\n         * the end user to debug / store stack frames even\n         * when a retry error does not happen.\n         */\n        logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame));\n\n        /**\n         * We also store the state of the host in failure cases. If the host, is\n         * down it will remain down for the next 2 minutes. In a timeout situation,\n         * this host will be added end of the list of hosts on the next request.\n         */\n        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? 'timed out' : 'down'));\n\n        return retry(retryableHosts, getTimeout);\n      }\n\n      if (isSuccess(response)) {\n        return deserializeSuccess(response);\n      }\n\n      pushToStackTrace(response);\n      throw deserializeFailure(response, stackTrace);\n    };\n\n    /**\n     * Finally, for each retryable host perform request until we got a non\n     * retryable response. Some notes here:\n     *\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\n     * for the current context.\n     */\n    const compatibleHosts = hosts.filter(\n      (host) => host.accept === 'readWrite' || (isRead ? host.accept === 'read' : host.accept === 'write'),\n    );\n    const options = await createRetryableOptions(compatibleHosts);\n\n    return retry([...options.hosts].reverse(), options.getTimeout);\n  }\n\n  function createRequest<TResponse>(request: Request, requestOptions: RequestOptions = {}): Promise<TResponse> {\n    /**\n     * A read request is either a `GET` request, or a request that we make\n     * via the `read` transporter (e.g. `search`).\n     */\n    const isRead = request.useReadTransporter || request.method === 'GET';\n    if (!isRead) {\n      /**\n       * On write requests, no cache mechanisms are applied, and we\n       * proxy the request immediately to the requester.\n       */\n      return retryableRequest<TResponse>(request, requestOptions, isRead);\n    }\n\n    const createRetryableRequest = (): Promise<TResponse> => {\n      /**\n       * Then, we prepare a function factory that contains the construction of\n       * the retryable request. At this point, we may *not* perform the actual\n       * request. But we want to have the function factory ready.\n       */\n      return retryableRequest<TResponse>(request, requestOptions);\n    };\n\n    /**\n     * Once we have the function factory ready, we need to determine of the\n     * request is \"cacheable\" - should be cached. Note that, once again,\n     * the user can force this option.\n     */\n    const cacheable = requestOptions.cacheable || request.cacheable;\n\n    /**\n     * If is not \"cacheable\", we immediately trigger the retryable request, no\n     * need to check cache implementations.\n     */\n    if (cacheable !== true) {\n      return createRetryableRequest();\n    }\n\n    /**\n     * If the request is \"cacheable\", we need to first compute the key to ask\n     * the cache implementations if this request is on progress or if the\n     * response already exists on the cache.\n     */\n    const key = {\n      request,\n      requestOptions,\n      transporter: {\n        queryParameters: baseQueryParameters,\n        headers: baseHeaders,\n      },\n    };\n\n    /**\n     * With the computed key, we first ask the responses cache\n     * implementation if this request was been resolved before.\n     */\n    return responsesCache.get(\n      key,\n      () => {\n        /**\n         * If the request has never resolved before, we actually ask if there\n         * is a current request with the same key on progress.\n         */\n        return requestsCache.get(key, () =>\n          /**\n           * Finally, if there is no request in progress with the same key,\n           * this `createRetryableRequest()` will actually trigger the\n           * retryable request.\n           */\n          requestsCache\n            .set(key, createRetryableRequest())\n            .then(\n              (response) => Promise.all([requestsCache.delete(key), response]),\n              (err) => Promise.all([requestsCache.delete(key), Promise.reject(err)]),\n            )\n            .then(([_, response]) => response),\n        );\n      },\n      {\n        /**\n         * Of course, once we get this response back from the server, we\n         * tell response cache to actually store the received response\n         * to be used later.\n         */\n        miss: (response) => responsesCache.set(key, response),\n      },\n    );\n  }\n\n  return {\n    hostsCache,\n    requester,\n    timeouts,\n    logger,\n    algoliaAgent,\n    baseHeaders,\n    baseQueryParameters,\n    hosts,\n    request: createRequest,\n    requestsCache,\n    responsesCache,\n  };\n}\n","export const LogLevelEnum: Readonly<Record<string, LogLevelType>> = {\n  Debug: 1,\n  Info: 2,\n  Error: 3,\n};\n\nexport type LogLevelType = 1 | 2 | 3;\n\nexport type Logger = {\n  /**\n   * Logs debug messages.\n   */\n  debug: (message: string, args?: any | undefined) => Promise<void>;\n\n  /**\n   * Logs info messages.\n   */\n  info: (message: string, args?: any | undefined) => Promise<void>;\n\n  /**\n   * Logs error messages.\n   */\n  error: (message: string, args?: any | undefined) => Promise<void>;\n};\n"],"mappings":"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","names":["response"]}