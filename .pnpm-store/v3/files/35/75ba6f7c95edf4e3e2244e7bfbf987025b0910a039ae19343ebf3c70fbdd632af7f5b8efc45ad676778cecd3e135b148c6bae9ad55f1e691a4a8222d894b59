{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/iconLabels.ts","vs/base/common/iconLabels.ts"],"names":[],"mappings":"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","file":"iconLabels.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMatch, matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\n\nconst iconStartMarker = '$(';\n\nconst iconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text: string): string {\n\treturn text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\n\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text: string): string {\n\t// Need to add an extra \\ for escaping in markdown\n\treturn text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\n\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\n\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text: string): string {\n\tif (text.indexOf(iconStartMarker) === -1) {\n\t\treturn text;\n\t}\n\n\treturn text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n\n\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text: string | undefined) {\n\tif (!text) {\n\t\treturn '';\n\t}\n\n\treturn text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\n\n\nexport interface IParsedLabelWithIcons {\n\treadonly text: string;\n\treadonly iconOffsets?: readonly number[];\n}\n\nconst _parseIconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g');\n\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input: string): IParsedLabelWithIcons {\n\n\t_parseIconsRegex.lastIndex = 0;\n\n\tlet text = '';\n\tconst iconOffsets: number[] = [];\n\tlet iconsOffset = 0;\n\n\twhile (true) {\n\t\tconst pos = _parseIconsRegex.lastIndex;\n\t\tconst match = _parseIconsRegex.exec(input);\n\n\t\tconst chars = input.substring(pos, match?.index);\n\t\tif (chars.length > 0) {\n\t\t\ttext += chars;\n\t\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\t\ticonOffsets.push(iconsOffset);\n\t\t\t}\n\t\t}\n\t\tif (!match) {\n\t\t\tbreak;\n\t\t}\n\t\ticonsOffset += match[0].length;\n\t}\n\n\treturn { text, iconOffsets };\n}\n\n\nexport function matchesFuzzyIconAware(query: string, target: IParsedLabelWithIcons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, iconOffsets } = target;\n\n\t// Return early if there are no icon markers in the word to match against\n\tif (!iconOffsets || iconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an icon\n\tconst wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n\n\t// match on value without icon\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with icon and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += iconOffset;\n\t\t\tmatch.end += iconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMatch, matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\n\nconst iconStartMarker = '$(';\n\nconst iconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text: string): string {\n\treturn text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\n\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text: string): string {\n\t// Need to add an extra \\ for escaping in markdown\n\treturn text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\n\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\n\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text: string): string {\n\tif (text.indexOf(iconStartMarker) === -1) {\n\t\treturn text;\n\t}\n\n\treturn text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n\n\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text: string | undefined) {\n\tif (!text) {\n\t\treturn '';\n\t}\n\n\treturn text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\n\n\nexport interface IParsedLabelWithIcons {\n\treadonly text: string;\n\treadonly iconOffsets?: readonly number[];\n}\n\nconst _parseIconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g');\n\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input: string): IParsedLabelWithIcons {\n\n\t_parseIconsRegex.lastIndex = 0;\n\n\tlet text = '';\n\tconst iconOffsets: number[] = [];\n\tlet iconsOffset = 0;\n\n\twhile (true) {\n\t\tconst pos = _parseIconsRegex.lastIndex;\n\t\tconst match = _parseIconsRegex.exec(input);\n\n\t\tconst chars = input.substring(pos, match?.index);\n\t\tif (chars.length > 0) {\n\t\t\ttext += chars;\n\t\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\t\ticonOffsets.push(iconsOffset);\n\t\t\t}\n\t\t}\n\t\tif (!match) {\n\t\t\tbreak;\n\t\t}\n\t\ticonsOffset += match[0].length;\n\t}\n\n\treturn { text, iconOffsets };\n}\n\n\nexport function matchesFuzzyIconAware(query: string, target: IParsedLabelWithIcons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, iconOffsets } = target;\n\n\t// Return early if there are no icon markers in the word to match against\n\tif (!iconOffsets || iconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an icon\n\tconst wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n\n\t// match on value without icon\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with icon and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += iconOffset;\n\t\t\tmatch.end += iconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}\n"]}