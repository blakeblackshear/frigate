{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorWordOperations.ts","vs/editor/common/cursor/cursorWordOperations.ts"],"names":[],"mappings":"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","file":"cursorWordOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { WordCharacterClass, WordCharacterClassifier, IntlWordSegmentData, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ITextModel } from '../model.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from '../languages/languageConfiguration.js';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3 // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _createIntlWord(intlWord: IntlWordSegmentData, nextCharClass: WordCharacterClass): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: WordType.Regular, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType, hasMulticursor: boolean): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\t&& prevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine\n\t\t\t\t&& (nextWordOnLine.wordType === WordType.Separator\n\t\t\t\t\t|| nextWordOnLine.start + 1 <= column\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static deleteInsideWord(wordSeparators: WordCharacterClassifier, model: ITextModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn (charCode === CharCode.Space || charCode === CharCode.Tab);\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n\t\t\t} else {\n\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// empty model\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (word.start + 1 <= position.column && position.column <= word.end + 1);\n\t\t};\n\t\tconst createRangeWithPosition = (startColumn: number, endColumn: number) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _createWordAtPosition(model: ITextModel, lineNumber: number, word: IFindWordResult): IWordAtPosition {\n\t\tconst range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(model: ITextModel, _wordSeparators: string, _intlSegmenterLocales: string[], position: Position): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), SelectionStartKind.Word, 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, hasMulticursor: boolean): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart, hasMulticursor),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd, hasMulticursor),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { WordCharacterClass, WordCharacterClassifier, IntlWordSegmentData, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ITextModel } from '../model.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from '../languages/languageConfiguration.js';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3 // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _createIntlWord(intlWord: IntlWordSegmentData, nextCharClass: WordCharacterClass): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: WordType.Regular, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType, hasMulticursor: boolean): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\t&& prevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine\n\t\t\t\t&& (nextWordOnLine.wordType === WordType.Separator\n\t\t\t\t\t|| nextWordOnLine.start + 1 <= column\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static deleteInsideWord(wordSeparators: WordCharacterClassifier, model: ITextModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn (charCode === CharCode.Space || charCode === CharCode.Tab);\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n\t\t\t} else {\n\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// empty model\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (word.start + 1 <= position.column && position.column <= word.end + 1);\n\t\t};\n\t\tconst createRangeWithPosition = (startColumn: number, endColumn: number) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _createWordAtPosition(model: ITextModel, lineNumber: number, word: IFindWordResult): IWordAtPosition {\n\t\tconst range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(model: ITextModel, _wordSeparators: string, _intlSegmenterLocales: string[], position: Position): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), SelectionStartKind.Word, 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, hasMulticursor: boolean): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart, hasMulticursor),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd, hasMulticursor),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}\n"]}