{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/languages/supports.ts","vs/editor/common/languages/supports.ts"],"names":[],"mappings":"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","file":"supports.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IViewLineTokens, LineTokens } from '../tokens/lineTokens.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../languages.js';\n\nexport function createScopedLineTokens(context: LineTokens, offset: number): ScopedLineTokens {\n\tconst tokenCount = context.getCount();\n\tconst tokenIndex = context.findTokenIndexAtOffset(offset);\n\tconst desiredLanguageId = context.getLanguageId(tokenIndex);\n\n\tlet lastTokenIndex = tokenIndex;\n\twhile (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n\t\tlastTokenIndex++;\n\t}\n\n\tlet firstTokenIndex = tokenIndex;\n\twhile (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n\t\tfirstTokenIndex--;\n\t}\n\n\treturn new ScopedLineTokens(\n\t\tcontext,\n\t\tdesiredLanguageId,\n\t\tfirstTokenIndex,\n\t\tlastTokenIndex + 1,\n\t\tcontext.getStartOffset(firstTokenIndex),\n\t\tcontext.getEndOffset(lastTokenIndex)\n\t);\n}\n\nexport class ScopedLineTokens {\n\t_scopedLineTokensBrand: void = undefined;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\tpublic readonly languageId: string;\n\tprivate readonly _actual: LineTokens;\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _lastTokenIndex: number;\n\tpublic readonly firstCharOffset: number;\n\tprivate readonly _lastCharOffset: number;\n\n\tconstructor(\n\t\tactual: LineTokens,\n\t\tlanguageId: string,\n\t\tfirstTokenIndex: number,\n\t\tlastTokenIndex: number,\n\t\tfirstCharOffset: number,\n\t\tlastCharOffset: number\n\t) {\n\t\tthis._actual = actual;\n\t\tthis.languageId = languageId;\n\t\tthis._firstTokenIndex = firstTokenIndex;\n\t\tthis._lastTokenIndex = lastTokenIndex;\n\t\tthis.firstCharOffset = firstCharOffset;\n\t\tthis._lastCharOffset = lastCharOffset;\n\t\tthis.languageIdCodec = actual.languageIdCodec;\n\t}\n\n\tpublic getLineContent(): string {\n\t\tconst actualLineContent = this._actual.getLineContent();\n\t\treturn actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n\t}\n\n\tpublic getLineLength(): number {\n\t\treturn this._lastCharOffset - this.firstCharOffset;\n\t}\n\n\tpublic getActualLineContentBefore(offset: number): string {\n\t\tconst actualLineContent = this._actual.getLineContent();\n\t\treturn actualLineContent.substring(0, this.firstCharOffset + offset);\n\t}\n\n\tpublic getTokenCount(): number {\n\t\treturn this._lastTokenIndex - this._firstTokenIndex;\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\treturn this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n\t}\n\n\tpublic toIViewLineTokens(): IViewLineTokens {\n\t\treturn this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n\t}\n}\n\nconst enum IgnoreBracketsInTokens {\n\tvalue = StandardTokenType.Comment | StandardTokenType.String | StandardTokenType.RegEx\n}\n\nexport function ignoreBracketsInToken(standardTokenType: StandardTokenType): boolean {\n\treturn (standardTokenType & IgnoreBracketsInTokens.value) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IViewLineTokens, LineTokens } from '../tokens/lineTokens.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../languages.js';\n\nexport function createScopedLineTokens(context: LineTokens, offset: number): ScopedLineTokens {\n\tconst tokenCount = context.getCount();\n\tconst tokenIndex = context.findTokenIndexAtOffset(offset);\n\tconst desiredLanguageId = context.getLanguageId(tokenIndex);\n\n\tlet lastTokenIndex = tokenIndex;\n\twhile (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n\t\tlastTokenIndex++;\n\t}\n\n\tlet firstTokenIndex = tokenIndex;\n\twhile (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n\t\tfirstTokenIndex--;\n\t}\n\n\treturn new ScopedLineTokens(\n\t\tcontext,\n\t\tdesiredLanguageId,\n\t\tfirstTokenIndex,\n\t\tlastTokenIndex + 1,\n\t\tcontext.getStartOffset(firstTokenIndex),\n\t\tcontext.getEndOffset(lastTokenIndex)\n\t);\n}\n\nexport class ScopedLineTokens {\n\t_scopedLineTokensBrand: void = undefined;\n\n\tpublic readonly languageIdCodec: ILanguageIdCodec;\n\tpublic readonly languageId: string;\n\tprivate readonly _actual: LineTokens;\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _lastTokenIndex: number;\n\tpublic readonly firstCharOffset: number;\n\tprivate readonly _lastCharOffset: number;\n\n\tconstructor(\n\t\tactual: LineTokens,\n\t\tlanguageId: string,\n\t\tfirstTokenIndex: number,\n\t\tlastTokenIndex: number,\n\t\tfirstCharOffset: number,\n\t\tlastCharOffset: number\n\t) {\n\t\tthis._actual = actual;\n\t\tthis.languageId = languageId;\n\t\tthis._firstTokenIndex = firstTokenIndex;\n\t\tthis._lastTokenIndex = lastTokenIndex;\n\t\tthis.firstCharOffset = firstCharOffset;\n\t\tthis._lastCharOffset = lastCharOffset;\n\t\tthis.languageIdCodec = actual.languageIdCodec;\n\t}\n\n\tpublic getLineContent(): string {\n\t\tconst actualLineContent = this._actual.getLineContent();\n\t\treturn actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n\t}\n\n\tpublic getLineLength(): number {\n\t\treturn this._lastCharOffset - this.firstCharOffset;\n\t}\n\n\tpublic getActualLineContentBefore(offset: number): string {\n\t\tconst actualLineContent = this._actual.getLineContent();\n\t\treturn actualLineContent.substring(0, this.firstCharOffset + offset);\n\t}\n\n\tpublic getTokenCount(): number {\n\t\treturn this._lastTokenIndex - this._firstTokenIndex;\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\treturn this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n\t}\n\n\tpublic toIViewLineTokens(): IViewLineTokens {\n\t\treturn this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n\t}\n}\n\nconst enum IgnoreBracketsInTokens {\n\tvalue = StandardTokenType.Comment | StandardTokenType.String | StandardTokenType.RegEx\n}\n\nexport function ignoreBracketsInToken(standardTokenType: StandardTokenType): boolean {\n\treturn (standardTokenType & IgnoreBracketsInTokens.value) !== 0;\n}\n"]}