{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts"],"names":[],"mappings":"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","file":"nodeReader.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast.js';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length.js';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast.js';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length.js';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"]}