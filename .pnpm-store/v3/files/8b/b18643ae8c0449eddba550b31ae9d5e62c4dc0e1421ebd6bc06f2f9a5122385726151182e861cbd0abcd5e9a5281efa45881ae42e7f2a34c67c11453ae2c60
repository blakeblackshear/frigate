{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/performance.ts","vs/base/browser/performance.ts"],"names":[],"mappings":"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","file":"performance.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = { total: 0, min: Number.MAX_VALUE, max: 0 };\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tlet measurementsCount = 0;\n\n\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tconst enum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark('inputlatency/start');\n\t\tperformance.mark('keydown/start');\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark('keydown/end');\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark('input/start');\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark('input/end');\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Before) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark('render/start');\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark('render/end');\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Finished) {\n\t\t\tperformance.mark('inputlatency/end');\n\n\t\t\tperformance.measure('keydown', 'keydown/start', 'keydown/end');\n\t\t\tperformance.measure('input', 'input/start', 'input/end');\n\t\t\tperformance.measure('render', 'render/start', 'render/end');\n\t\t\tperformance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n\n\t\t\taddMeasure('keydown', totalKeydownTime);\n\t\t\taddMeasure('input', totalInputTime);\n\t\t\taddMeasure('render', totalRenderTime);\n\t\t\taddMeasure('inputlatency', totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(entryName: string, cumulativeMeasurement: ICumulativeMeasurement): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n\t\tcumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks('keydown/start');\n\t\tperformance.clearMarks('keydown/end');\n\t\tperformance.clearMarks('input/start');\n\t\tperformance.clearMarks('input/end');\n\t\tperformance.clearMarks('render/start');\n\t\tperformance.clearMarks('render/end');\n\t\tperformance.clearMarks('inputlatency/start');\n\t\tperformance.clearMarks('inputlatency/end');\n\n\t\tperformance.clearMeasures('keydown');\n\t\tperformance.clearMeasures('input');\n\t\tperformance.clearMeasures('render');\n\t\tperformance.clearMeasures('inputlatency');\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements(): IInputLatencyMeasurements | undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(cumulative: ICumulativeMeasurement): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(cumulative: ICumulativeMeasurement): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace inputLatency {\n\n\t// Measurements are recorded as totals, the average is calculated when the final measurements\n\t// are created.\n\tinterface ICumulativeMeasurement {\n\t\ttotal: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\tconst totalKeydownTime: ICumulativeMeasurement = { total: 0, min: Number.MAX_VALUE, max: 0 };\n\tconst totalInputTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalRenderTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tconst totalInputLatencyTime: ICumulativeMeasurement = { ...totalKeydownTime };\n\tlet measurementsCount = 0;\n\n\n\n\t// The state of each event, this helps ensure the integrity of the measurement and that\n\t// something unexpected didn't happen that could skew the measurement.\n\tconst enum EventPhase {\n\t\tBefore = 0,\n\t\tInProgress = 1,\n\t\tFinished = 2\n\t}\n\tconst state = {\n\t\tkeydown: EventPhase.Before,\n\t\tinput: EventPhase.Before,\n\t\trender: EventPhase.Before,\n\t};\n\n\t/**\n\t * Record the start of the keydown event.\n\t */\n\texport function onKeyDown() {\n\t\t/** Direct Check C. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t\tperformance.mark('inputlatency/start');\n\t\tperformance.mark('keydown/start');\n\t\tstate.keydown = EventPhase.InProgress;\n\t\tqueueMicrotask(markKeyDownEnd);\n\t}\n\n\t/**\n\t * Mark the end of the keydown event.\n\t */\n\tfunction markKeyDownEnd() {\n\t\tif (state.keydown === EventPhase.InProgress) {\n\t\t\tperformance.mark('keydown/end');\n\t\t\tstate.keydown = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the beforeinput event.\n\t */\n\texport function onBeforeInput() {\n\t\tperformance.mark('input/start');\n\t\tstate.input = EventPhase.InProgress;\n\t\t/** Schedule Task A. See explanation in {@link recordIfFinished} */\n\t\tscheduleRecordIfFinishedTask();\n\t}\n\n\t/**\n\t * Record the start of the input event.\n\t */\n\texport function onInput() {\n\t\tif (state.input === EventPhase.Before) {\n\t\t\t// it looks like we didn't receive a `beforeinput`\n\t\t\tonBeforeInput();\n\t\t}\n\t\tqueueMicrotask(markInputEnd);\n\t}\n\n\tfunction markInputEnd() {\n\t\tif (state.input === EventPhase.InProgress) {\n\t\t\tperformance.mark('input/end');\n\t\t\tstate.input = EventPhase.Finished;\n\t\t}\n\t}\n\n\t/**\n\t * Record the start of the keyup event.\n\t */\n\texport function onKeyUp() {\n\t\t/** Direct Check D. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the selectionchange event.\n\t */\n\texport function onSelectionChange() {\n\t\t/** Direct Check E. See explanation in {@link recordIfFinished} */\n\t\trecordIfFinished();\n\t}\n\n\t/**\n\t * Record the start of the animation frame performing the rendering.\n\t */\n\texport function onRenderStart() {\n\t\t// Render may be triggered during input, but we only measure the following animation frame\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Before) {\n\t\t\t// Only measure the first render after keyboard input\n\t\t\tperformance.mark('render/start');\n\t\t\tstate.render = EventPhase.InProgress;\n\t\t\tqueueMicrotask(markRenderEnd);\n\t\t\t/** Schedule Task B. See explanation in {@link recordIfFinished} */\n\t\t\tscheduleRecordIfFinishedTask();\n\t\t}\n\t}\n\n\t/**\n\t * Mark the end of the animation frame performing the rendering.\n\t */\n\tfunction markRenderEnd() {\n\t\tif (state.render === EventPhase.InProgress) {\n\t\t\tperformance.mark('render/end');\n\t\t\tstate.render = EventPhase.Finished;\n\t\t}\n\t}\n\n\tfunction scheduleRecordIfFinishedTask() {\n\t\t// Here we can safely assume that the `setTimeout` will not be\n\t\t// artificially delayed by 4ms because we schedule it from\n\t\t// event handlers\n\t\tsetTimeout(recordIfFinished);\n\t}\n\n\t/**\n\t * Record the input latency sample if input handling and rendering are finished.\n\t *\n\t * The challenge here is that we want to record the latency in such a way that it includes\n\t * also the layout and painting work the browser does during the animation frame task.\n\t *\n\t * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n\t * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n\t * so we need to use multiple strategies to make sure our task runs before others:\n\t *\n\t * We schedule tasks (A and B):\n\t *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n\t *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n\t *      chance of being the very first task after the animation frame and thus will record the input latency.\n\t *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n\t *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n\t *\n\t * We do direct checks in browser event handlers (C, D, E):\n\t *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n\t *      so we do a direct check in the keydown event handler (C).\n\t *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n\t *      do a direct check there too (E).\n\t *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n\t */\n\tfunction recordIfFinished() {\n\t\tif (state.keydown === EventPhase.Finished && state.input === EventPhase.Finished && state.render === EventPhase.Finished) {\n\t\t\tperformance.mark('inputlatency/end');\n\n\t\t\tperformance.measure('keydown', 'keydown/start', 'keydown/end');\n\t\t\tperformance.measure('input', 'input/start', 'input/end');\n\t\t\tperformance.measure('render', 'render/start', 'render/end');\n\t\t\tperformance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n\n\t\t\taddMeasure('keydown', totalKeydownTime);\n\t\t\taddMeasure('input', totalInputTime);\n\t\t\taddMeasure('render', totalRenderTime);\n\t\t\taddMeasure('inputlatency', totalInputLatencyTime);\n\n\t\t\t// console.info(\n\t\t\t// \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n\t\t\t// \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n\t\t\t// \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n\t\t\t// \t`]`\n\t\t\t// );\n\n\t\t\tmeasurementsCount++;\n\n\t\t\treset();\n\t\t}\n\t}\n\n\tfunction addMeasure(entryName: string, cumulativeMeasurement: ICumulativeMeasurement): void {\n\t\tconst duration = performance.getEntriesByName(entryName)[0].duration;\n\t\tcumulativeMeasurement.total += duration;\n\t\tcumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n\t\tcumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n\t}\n\n\t/**\n\t * Clear the current sample.\n\t */\n\tfunction reset() {\n\t\tperformance.clearMarks('keydown/start');\n\t\tperformance.clearMarks('keydown/end');\n\t\tperformance.clearMarks('input/start');\n\t\tperformance.clearMarks('input/end');\n\t\tperformance.clearMarks('render/start');\n\t\tperformance.clearMarks('render/end');\n\t\tperformance.clearMarks('inputlatency/start');\n\t\tperformance.clearMarks('inputlatency/end');\n\n\t\tperformance.clearMeasures('keydown');\n\t\tperformance.clearMeasures('input');\n\t\tperformance.clearMeasures('render');\n\t\tperformance.clearMeasures('inputlatency');\n\n\t\tstate.keydown = EventPhase.Before;\n\t\tstate.input = EventPhase.Before;\n\t\tstate.render = EventPhase.Before;\n\t}\n\n\texport interface IInputLatencyMeasurements {\n\t\tkeydown: IInputLatencySingleMeasurement;\n\t\tinput: IInputLatencySingleMeasurement;\n\t\trender: IInputLatencySingleMeasurement;\n\t\ttotal: IInputLatencySingleMeasurement;\n\t\tsampleCount: number;\n\t}\n\n\texport interface IInputLatencySingleMeasurement {\n\t\taverage: number;\n\t\tmin: number;\n\t\tmax: number;\n\t}\n\n\t/**\n\t * Gets all input latency samples and clears the internal buffers to start recording a new set\n\t * of samples.\n\t */\n\texport function getAndClearMeasurements(): IInputLatencyMeasurements | undefined {\n\t\tif (measurementsCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Assemble the result\n\t\tconst result = {\n\t\t\tkeydown: cumulativeToFinalMeasurement(totalKeydownTime),\n\t\t\tinput: cumulativeToFinalMeasurement(totalInputTime),\n\t\t\trender: cumulativeToFinalMeasurement(totalRenderTime),\n\t\t\ttotal: cumulativeToFinalMeasurement(totalInputLatencyTime),\n\t\t\tsampleCount: measurementsCount\n\t\t};\n\n\t\t// Clear the cumulative measurements\n\t\tclearCumulativeMeasurement(totalKeydownTime);\n\t\tclearCumulativeMeasurement(totalInputTime);\n\t\tclearCumulativeMeasurement(totalRenderTime);\n\t\tclearCumulativeMeasurement(totalInputLatencyTime);\n\t\tmeasurementsCount = 0;\n\n\t\treturn result;\n\t}\n\n\tfunction cumulativeToFinalMeasurement(cumulative: ICumulativeMeasurement): IInputLatencySingleMeasurement {\n\t\treturn {\n\t\t\taverage: cumulative.total / measurementsCount,\n\t\t\tmax: cumulative.max,\n\t\t\tmin: cumulative.min,\n\t\t};\n\t}\n\n\tfunction clearCumulativeMeasurement(cumulative: ICumulativeMeasurement): void {\n\t\tcumulative.total = 0;\n\t\tcumulative.min = Number.MAX_VALUE;\n\t\tcumulative.max = 0;\n\t}\n\n}\n"]}