{"version":3,"sources":["../src/emojify.ts","../src/findByName.ts","../src/data.ts","../src/utils.ts","../src/findByCode.ts","../src/find.ts","../src/get.ts","../src/has.ts","../src/random.ts","../src/replace.ts","../src/search.ts","../src/strip.ts","../src/unemojify.ts","../src/which.ts"],"sourcesContent":["import is from '@sindresorhus/is'\n\nimport { findByName } from './findByName.js'\nimport { asFunction, normalizeName } from './utils.js'\n\nexport type EmojifyFormat = (\n  name: string,\n  part?: string,\n  input?: string,\n) => string\n\nexport interface EmojifyOptions {\n  /**\n   * The string to fallback to if an emoji was not found.\n   */\n  fallback?: ((part: string) => string) | string\n\n  /**\n   * Adds a middleware layer to modify each matched emoji after parsing.\n   */\n  format?: EmojifyFormat\n}\n\n/**\n * Parse all markdown-encoded emojis in a string.\n */\nexport const emojify = (\n  input: string,\n  { fallback, format = name => name }: EmojifyOptions = {},\n) => {\n  const fallbackFunction =\n    fallback === undefined ? fallback : asFunction(fallback)\n\n  is.assert.string(input)\n  is.assert.any([is.default.undefined, is.default.function_], fallbackFunction)\n  is.assert.function_(format)\n\n  return input.replace(/:[\\w\\-+]+:/g, part => {\n    const found = findByName(part)\n    if (found) {\n      return format(found.emoji, part, input)\n    }\n\n    if (fallbackFunction) {\n      return format(fallbackFunction(normalizeName(part)))\n    }\n\n    return format(part)\n  })\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName } from './data.js'\nimport { normalizeName } from './utils.js'\n\nexport const findByName = (name: string) => {\n  assert.string(name)\n\n  const nameNormalized = normalizeName(name)\n  const emoji = emojiCodesByName.get(nameNormalized)\n\n  return emoji ? { emoji, key: nameNormalized } : undefined\n}\n","import emojilib from 'emojilib'\n\nimport { normalizeCode } from './utils.js'\n\nexport interface Emoji {\n  emoji: string\n  key: string\n}\n\nexport const emojiData = Object.entries(emojilib.lib).map(\n  ([name, { char: emoji }]) => [name, emoji] as const,\n)\n\nexport const emojiCodesByName = new Map(emojiData)\n\nexport const emojiNamesByCode = new Map(\n  emojiData.map(([name, emoji]) => [normalizeCode(emoji), name]),\n)\n","import charRegex from 'char-regex'\n\nexport const charRegexMatcher = charRegex()\n\nexport function asFunction<T extends PropertyKey, Args extends unknown[]>(\n  input: ((...args: Args) => T) | T,\n): (...args: Args) => T {\n  return typeof input === 'function' ? input : () => input\n}\n\n/**\n * Non spacing mark contained by some emoticons (65039 - 'Ô∏è' - 0xFE0F).\n *\n * It's the 'Variant Form', which provides more information so that emoticons\n * can be rendered as more colorful graphics. FE0E is a unicode text version\n * whereas FE0F should be rendered as a graphical version.\n * The code gracefully degrades.\n */\nconst NON_SPACING_MARK = String.fromCharCode(65039)\n\nconst nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g')\n\n/**\n * Removes the non-spacing-mark from the emoji code.\n *\n * Never send a stripped version to clients, as it kills graphical emoticons.\n */\nexport function normalizeCode(code: string) {\n  return code.replace(nonSpacingRegex, '')\n}\n\nexport function normalizeName(name: string) {\n  return /:.+:/.test(name) ? name.slice(1, -1) : name\n}\n\nexport function randomItem<T>(array: T[]) {\n  return array[Math.floor(Math.random() * array.length)]\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiNamesByCode } from './data.js'\nimport { normalizeCode } from './utils.js'\n\nexport const findByCode = (code: string) => {\n  assert.string(code)\n\n  const emojiNormalized = normalizeCode(code)\n  const key = emojiNamesByCode.get(emojiNormalized)\n\n  return key ? { emoji: emojiNormalized, key } : undefined\n}\n","import { findByCode } from './findByCode.js'\nimport { findByName } from './findByName.js'\n\n/**\n * Get the name and character of an emoji.\n */\nexport const find = (codeOrName: string) => {\n  return findByCode(codeOrName) ?? findByName(codeOrName)\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName } from './data.js'\nimport { normalizeName } from './utils.js'\n\n/**\n * Get an emoji from an emoji name.\n */\nexport const get = (codeOrName: string) => {\n  assert.string(codeOrName)\n\n  return emojiCodesByName.get(normalizeName(codeOrName))\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName, emojiNamesByCode } from './data.js'\nimport { normalizeCode, normalizeName } from './utils.js'\n\n/**\n * Check if this library supports a specific emoji.\n */\nexport const has = (codeOrName: string) => {\n  assert.string(codeOrName)\n\n  return (\n    emojiCodesByName.has(normalizeName(codeOrName)) ||\n    emojiNamesByCode.has(normalizeCode(codeOrName))\n  )\n}\n","import { emojiData } from './data.js'\nimport { randomItem } from './utils.js'\n\n/**\n * Get a random emoji.\n */\nexport const random = () => {\n  const [name, emoji] = randomItem(emojiData)\n  return { emoji, name }\n}\n","import { assert } from '@sindresorhus/is'\n\nimport { Emoji } from './data.js'\nimport { findByCode } from './findByCode.js'\nimport { asFunction, charRegexMatcher } from './utils.js'\n\nexport type ReplaceReplacement = (\n  emoji: Emoji,\n  index: number,\n  string: string,\n) => string\n\n/**\n * Replace the emojis in a string.\n */\nexport const replace = (\n  input: string,\n  replacement: ReplaceReplacement | string,\n  { preserveSpaces = false } = {},\n) => {\n  const replace = asFunction(replacement)\n\n  assert.string(input)\n  assert.function_(replace)\n  assert.boolean(preserveSpaces)\n\n  const characters = input.match(charRegexMatcher)\n  if (characters === null) {\n    return input\n  }\n\n  return characters\n    .map((character, index) => {\n      const found = findByCode(character)\n      if (!found) {\n        return character\n      }\n\n      if (!preserveSpaces && characters[index + 1] === ' ') {\n        characters[index + 1] = ''\n      }\n\n      return replace(found, index, input)\n    })\n    .join('')\n}\n","import is, { assert } from '@sindresorhus/is'\n\nimport { emojiData } from './data.js'\nimport { normalizeName } from './utils.js'\n\n/**\n * Search for emojis containing the provided name or pattern in their name.\n */\nexport const search = (keyword: RegExp | string) => {\n  assert.any([is.default.string, is.default.regExp], keyword)\n\n  if (is.default.string(keyword)) {\n    keyword = normalizeName(keyword)\n  }\n\n  if (is.default.regExp(keyword)) {\n    const normalizedPattern = normalizeName(keyword.source)\n    keyword = new RegExp(normalizedPattern)\n  }\n\n  return emojiData\n    .filter(([name]) => name.match(keyword))\n    .map(([name, emoji]) => ({ emoji, name }))\n}\n","import { replace } from './replace.js'\n\nexport interface StripOptions {\n  /**\n   * Whether to keep the extra space after a stripped emoji.\n   */\n  preserveSpaces?: boolean\n}\n\n/**\n * Remove all the emojis from a string.\n */\nexport const strip = (input: string, { preserveSpaces }: StripOptions = {}) =>\n  replace(input, '', { preserveSpaces })\n","import { assert } from '@sindresorhus/is'\n\nimport { charRegexMatcher } from './utils.js'\nimport { which } from './which.js'\n\n/**\n * Convert all emojis in a string to their markdown-encoded counterparts.\n */\nexport const unemojify = (input: string) => {\n  assert.string(input)\n\n  const characters = input.match(charRegexMatcher)\n  if (characters === null) {\n    return input\n  }\n\n  return characters\n    .map(character => which(character, { markdown: true }) ?? character)\n    .join('')\n}\n","import { assert } from '@sindresorhus/is'\nimport skinTone from 'skin-tone'\n\nimport { findByCode } from './findByCode.js'\n\nexport interface WhichOptions {\n  markdown?: boolean\n}\n\n/**\n * Get an emoji name from an emoji.\n */\nexport const which = (\n  emoji: string,\n  { markdown = false }: WhichOptions = {},\n) => {\n  assert.string(emoji)\n  assert.boolean(markdown)\n\n  const result = findByCode(skinTone(emoji, 'none'))\n  if (result === undefined) {\n    return undefined\n  }\n\n  return markdown ? `:${result.key}:` : result.key\n}\n"],"mappings":"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","names":["assert","assert","assert","assert","assert","assert","assert","replace","assert","is","assert","assert","is","assert","assert","assert","assert"]}