{"version":3,"sources":["../src/index.ts","../src/createHttpRequester.ts"],"sourcesContent":["export * from './createHttpRequester';\n","import http from 'http';\nimport https from 'https';\nimport { URL } from 'url';\n\nimport type { EndRequest, Requester, Response } from '@algolia/client-common';\n\nexport type CreateHttpRequesterOptions = Partial<{\n  agent: http.Agent | https.Agent;\n  httpAgent: http.Agent;\n  httpsAgent: https.Agent;\n  /**\n   * RequestOptions to be merged with the end request, it will override default options if provided.\n   */\n  requesterOptions: https.RequestOptions;\n}>;\n\n// Global agents allow us to reuse the TCP protocol with multiple clients\nconst agentOptions = { keepAlive: true };\nconst defaultHttpAgent = new http.Agent(agentOptions);\nconst defaultHttpsAgent = new https.Agent(agentOptions);\n\nexport function createHttpRequester({\n  agent: userGlobalAgent,\n  httpAgent: userHttpAgent,\n  httpsAgent: userHttpsAgent,\n  requesterOptions = {},\n}: CreateHttpRequesterOptions = {}): Requester {\n  const httpAgent = userHttpAgent || userGlobalAgent || defaultHttpAgent;\n  const httpsAgent = userHttpsAgent || userGlobalAgent || defaultHttpsAgent;\n\n  function send(request: EndRequest): Promise<Response> {\n    return new Promise((resolve) => {\n      let responseTimeout: NodeJS.Timeout | undefined;\n      let connectTimeout: NodeJS.Timeout | undefined;\n      const url = new URL(request.url);\n      const path = url.search === null ? url.pathname : `${url.pathname}${url.search}`;\n      const options: https.RequestOptions = {\n        agent: url.protocol === 'https:' ? httpsAgent : httpAgent,\n        hostname: url.hostname,\n        path,\n        method: request.method,\n        ...requesterOptions,\n        headers: {\n          ...request.headers,\n          ...requesterOptions.headers,\n        },\n      };\n\n      if (url.port && !requesterOptions.port) {\n        options.port = url.port;\n      }\n\n      const req = (url.protocol === 'https:' ? https : http).request(options, (response) => {\n        let contentBuffers: Buffer[] = [];\n\n        response.on('data', (chunk) => {\n          contentBuffers = contentBuffers.concat(chunk);\n        });\n\n        response.on('end', () => {\n          clearTimeout(connectTimeout as NodeJS.Timeout);\n          clearTimeout(responseTimeout as NodeJS.Timeout);\n\n          resolve({\n            status: response.statusCode || 0,\n            content: Buffer.concat(contentBuffers).toString(),\n            isTimedOut: false,\n          });\n        });\n      });\n\n      const createTimeout = (timeout: number, content: string): NodeJS.Timeout => {\n        return setTimeout(() => {\n          req.destroy();\n\n          resolve({\n            status: 0,\n            content,\n            isTimedOut: true,\n          });\n        }, timeout);\n      };\n\n      connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');\n\n      req.on('error', (error) => {\n        clearTimeout(connectTimeout as NodeJS.Timeout);\n        clearTimeout(responseTimeout!);\n        resolve({ status: 0, content: error.message, isTimedOut: false });\n      });\n\n      req.once('response', () => {\n        clearTimeout(connectTimeout as NodeJS.Timeout);\n        responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');\n      });\n\n      if (request.data !== undefined) {\n        req.write(request.data);\n      }\n\n      req.end();\n    });\n  }\n\n  return { send };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,kBAAiB;AACjB,mBAAkB;AAClB,iBAAoB;AAepB,IAAM,eAAe,EAAE,WAAW,KAAK;AACvC,IAAM,mBAAmB,IAAI,YAAAA,QAAK,MAAM,YAAY;AACpD,IAAM,oBAAoB,IAAI,aAAAC,QAAM,MAAM,YAAY;AAE/C,SAAS,oBAAoB;AAAA,EAClC,OAAO;AAAA,EACP,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,mBAAmB,CAAC;AACtB,IAAgC,CAAC,GAAc;AAC7C,QAAM,YAAY,iBAAiB,mBAAmB;AACtD,QAAM,aAAa,kBAAkB,mBAAmB;AAExD,WAAS,KAAK,SAAwC;AACpD,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,UAAI;AACJ,UAAI;AACJ,YAAM,MAAM,IAAI,eAAI,QAAQ,GAAG;AAC/B,YAAM,OAAO,IAAI,WAAW,OAAO,IAAI,WAAW,GAAG,IAAI,QAAQ,GAAG,IAAI,MAAM;AAC9E,YAAM,UAAgC;AAAA,QACpC,OAAO,IAAI,aAAa,WAAW,aAAa;AAAA,QAChD,UAAU,IAAI;AAAA,QACd;AAAA,QACA,QAAQ,QAAQ;AAAA,QAChB,GAAG;AAAA,QACH,SAAS;AAAA,UACP,GAAG,QAAQ;AAAA,UACX,GAAG,iBAAiB;AAAA,QACtB;AAAA,MACF;AAEA,UAAI,IAAI,QAAQ,CAAC,iBAAiB,MAAM;AACtC,gBAAQ,OAAO,IAAI;AAAA,MACrB;AAEA,YAAM,OAAO,IAAI,aAAa,WAAW,aAAAA,UAAQ,YAAAD,SAAM,QAAQ,SAAS,CAAC,aAAa;AACpF,YAAI,iBAA2B,CAAC;AAEhC,iBAAS,GAAG,QAAQ,CAAC,UAAU;AAC7B,2BAAiB,eAAe,OAAO,KAAK;AAAA,QAC9C,CAAC;AAED,iBAAS,GAAG,OAAO,MAAM;AACvB,uBAAa,cAAgC;AAC7C,uBAAa,eAAiC;AAE9C,kBAAQ;AAAA,YACN,QAAQ,SAAS,cAAc;AAAA,YAC/B,SAAS,OAAO,OAAO,cAAc,EAAE,SAAS;AAAA,YAChD,YAAY;AAAA,UACd,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAED,YAAM,gBAAgB,CAAC,SAAiB,YAAoC;AAC1E,eAAO,WAAW,MAAM;AACtB,cAAI,QAAQ;AAEZ,kBAAQ;AAAA,YACN,QAAQ;AAAA,YACR;AAAA,YACA,YAAY;AAAA,UACd,CAAC;AAAA,QACH,GAAG,OAAO;AAAA,MACZ;AAEA,uBAAiB,cAAc,QAAQ,gBAAgB,oBAAoB;AAE3E,UAAI,GAAG,SAAS,CAAC,UAAU;AACzB,qBAAa,cAAgC;AAC7C,qBAAa,eAAgB;AAC7B,gBAAQ,EAAE,QAAQ,GAAG,SAAS,MAAM,SAAS,YAAY,MAAM,CAAC;AAAA,MAClE,CAAC;AAED,UAAI,KAAK,YAAY,MAAM;AACzB,qBAAa,cAAgC;AAC7C,0BAAkB,cAAc,QAAQ,iBAAiB,gBAAgB;AAAA,MAC3E,CAAC;AAED,UAAI,QAAQ,SAAS,QAAW;AAC9B,YAAI,MAAM,QAAQ,IAAI;AAAA,MACxB;AAEA,UAAI,IAAI;AAAA,IACV,CAAC;AAAA,EACH;AAEA,SAAO,EAAE,KAAK;AAChB;","names":["http","https"]}