{"version":3,"sources":["hamt.js"],"names":["hamt","SIZE","BUCKET_SIZE","Math","pow","MASK","MAX_INDEX_NODE","MIN_ARRAY_NODE","nothing","constant","x","hash","type","str","i","len","length","c","charCodeAt","popcount","hashFragment","shift","h","toBitmap","fromBitmap","bitmap","bit","arrayUpdate","mutate","at","v","arr","out","Array","arraySpliceOut","newLen","g","arraySpliceIn","LEAF","COLLISION","INDEX","ARRAY","empty","__hamt_isEmpty","isEmptyNode","Leaf","edit","key","value","_modify","Leaf__modify","Collision","children","Collision__modify","IndexedNode","mask","IndexedNode__modify","ArrayNode","size","ArrayNode__modify","isLeaf","node","expand","frag","child","subNodes","count","pack","removed","elements","elem","mergeLeaves","h1","n1","h2","n2","subH1","subH2","updateCollisionList","keyEq","list","f","k","newValue","canEditNode","canEdit","indx","exists","current","newChildren","newChild","Map","editable","config","root","_editable","_edit","_config","_root","_size","prototype","setTree","newRoot","newSize","tryGetHash","alt","map","tryGet","getHash","undefined","get","hasHash","has","defKeyCompare","y","make","isEmpty","modifyHash","NaN","modify","setHash","set","del","removeHash","deleteHash","remove","delete","beginMutation","endMutation","transient","appk","lazyVisitChildren","lazyVisit","rest","DONE","done","MapIterator","next","v0","Symbol","iterator","visit","buildPairs","entries","buildKeys","keys","buildValues","values","fold","z","m","toVisit","pop","push","forEach","_","Object","defineProperty","module","exports","define","amd"],"mappings":"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","file":"hamt.js","sourcesContent":["/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\nconst hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\nconst SIZE = 5;\n\nconst BUCKET_SIZE = Math.pow(2, SIZE);\n\nconst MASK = BUCKET_SIZE - 1;\n\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2;\n\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n\n/*\n ******************************************************************************/\nconst nothing = ({});\n\nconst constant = x => () => x;\n\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\nconst hash = hamt.hash = str => {\n    const type = typeof str;\n    if (type === 'number')\n        return str;\n    if (type !== 'string')\n        str += '';\n\n    let hash = 0;\n    for (let i = 0, len = str.length; i < len; ++i) {\n        const c = str.charCodeAt(i);\n        hash = (((hash << 5) - hash) + c) | 0;\n    }\n    return hash;\n};\n\n/* Bit Ops\n ******************************************************************************/\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\nconst popcount = (x) => {\n    x -= ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += (x >> 8);\n    x += (x >> 16);\n    return (x & 0x7f);\n};\n\nconst hashFragment = (shift, h) =>\n    (h >>> shift) & MASK;\n\nconst toBitmap = x =>\n    1 << x;\n\nconst fromBitmap = (bitmap, bit) =>\n    popcount(bitmap & (bit - 1));\n\n/* Array Ops\n ******************************************************************************/\n/**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\nconst arrayUpdate = (mutate, at, v, arr) => {\n    let out = arr;\n    if (!mutate) {\n        const len = arr.length;\n        out = new Array(len);\n        for (let i = 0; i < len; ++i)\n            out[i] = arr[i];\n    }\n    out[at] = v;\n    return out;\n};\n\n/**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/\nconst arraySpliceOut = (mutate, at, arr) => {\n    const newLen = arr.length - 1;\n    let i = 0;\n    let g = 0;\n    let out = arr;\n    if (mutate) {\n        i = g = at;\n    } else {\n        out = new Array(newLen);\n        while (i < at)\n            out[g++] = arr[i++];\n    }\n    ++i;\n    while (i <= newLen)\n        out[g++] = arr[i++];\n    if (mutate) {\n        out.length = newLen;\n    }\n    return out;\n};\n\n/**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\nconst arraySpliceIn = (mutate, at, v, arr) => {\n    const len = arr.length;\n    if (mutate) {\n        let i = len;\n        while (i >= at)\n            arr[i--] = arr[i];\n        arr[at] = v;\n        return arr;\n    }\n    let i = 0, g = 0;\n    const out = new Array(len + 1);\n    while (i < at)\n        out[g++] = arr[i++];\n    out[at] = v;\n    while (i < len)\n        out[++g] = arr[i++];\n    return out;\n};\n\n/* Node Structures\n ******************************************************************************/\nconst LEAF = 1;\nconst COLLISION = 2;\nconst INDEX = 3;\nconst ARRAY = 4;\n\n/**\n    Empty node.\n*/\nconst empty = ({\n    __hamt_isEmpty: true\n});\n\nconst isEmptyNode = x =>\n    x === empty || (x && x.__hamt_isEmpty);\n\n/**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\nconst Leaf = (edit, hash, key, value) => ({\n    type: LEAF,\n    edit: edit,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n});\n\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\nconst Collision = (edit, hash, children) => ({\n    type: COLLISION,\n    edit: edit,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n});\n\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\nconst IndexedNode = (edit, mask, children) => ({\n    type: INDEX,\n    edit: edit,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n});\n\n/**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\nconst ArrayNode = (edit, size, children) => ({\n    type: ARRAY,\n    edit: edit,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n});\n\n/**\n    Is `node` a leaf node?\n*/\nconst isLeaf = node =>\n    (node === empty || node.type === LEAF || node.type === COLLISION);\n\n/* Internal node operations.\n ******************************************************************************/\n/**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\nconst expand = (edit, frag, child, bitmap, subNodes) => {\n    const arr = [];\n    let bit = bitmap;\n    let count = 0;\n    for (let i = 0; bit; ++i) {\n        if (bit & 1)\n            arr[i] = subNodes[count++];\n        bit >>>= 1;\n    }\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n};\n\n/**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\nconst pack = (edit, count, removed, elements) => {\n    const children = new Array(count - 1);\n    let g = 0;\n    let bitmap = 0;\n    for (let i = 0, len = elements.length; i < len; ++i) {\n        if (i !== removed) {\n            const elem = elements[i];\n            if (elem && !isEmptyNode(elem)) {\n                children[g++] = elem;\n                bitmap |= 1 << i;\n            }\n        }\n    }\n    return IndexedNode(edit, bitmap, children);\n};\n\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\nconst mergeLeaves = (edit, shift, h1, n1, h2, n2) => {\n    if (h1 === h2)\n        return Collision(edit, h1, [n2, n1]);\n\n    const subH1 = hashFragment(shift, h1);\n    const subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2),\n        subH1 === subH2\n            ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)]\n            : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n\n/**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/\nconst updateCollisionList = (mutate, edit, keyEq, h, list, f, k, size) => {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n        const child = list[i];\n        if (keyEq(k, child.key)) {\n            const value = child.value;\n            const newValue = f(value);\n            if (newValue === value)\n                return list;\n\n            if (newValue === nothing) {\n                --size.value;\n                return arraySpliceOut(mutate, i, list);\n            }\n            return arrayUpdate(mutate, i, Leaf(edit, h, k, newValue), list);\n        }\n    }\n\n    const newValue = f();\n    if (newValue === nothing)\n        return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n};\n\nconst canEditNode = (edit, node) => edit === node.edit;\n\n/* Editing\n ******************************************************************************/\nconst Leaf__modify = function (edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n        const v = f(this.value);\n        if (v === this.value)\n            return this;\n        else if (v === nothing) {\n            --size.value;\n            return empty;\n        }\n        if (canEditNode(edit, this)) {\n            this.value = v;\n            return this;\n        }\n        return Leaf(edit, h, k, v);\n    }\n    const v = f();\n    if (v === nothing)\n        return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nconst Collision__modify = function (edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n        const canEdit = canEditNode(edit, this);\n        const list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n        if (list === this.children)\n            return this;\n\n        return list.length > 1\n            ? Collision(edit, this.hash, list)\n            : list[0]; // collapse single element collision list\n    }\n    const v = f();\n    if (v === nothing)\n        return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nconst IndexedNode__modify = function (edit, keyEq, shift, f, h, k, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    const current = exists ? children[indx] : empty;\n    const child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child)\n        return this;\n\n    const canEdit = canEditNode(edit, this);\n    let bitmap = mask;\n    let newChildren;\n    if (exists && isEmptyNode(child)) { // remove\n        bitmap &= ~bit;\n        if (!bitmap)\n            return empty;\n        if (children.length <= 2 && isLeaf(children[indx ^ 1]))\n            return children[indx ^ 1] // collapse\n\n        newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) { // add\n        if (children.length >= MAX_INDEX_NODE)\n            return expand(edit, frag, child, mask, children);\n\n        bitmap |= bit;\n        newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else { // modify\n        newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n        this.mask = bitmap;\n        this.children = newChildren;\n        return this;\n    }\n    return IndexedNode(edit, bitmap, newChildren);\n};\n\nconst ArrayNode__modify = function (edit, keyEq, shift, f, h, k, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const child = children[frag];\n    const newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild)\n        return this;\n\n    const canEdit = canEditNode(edit, this);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) { // add\n        ++count;\n        newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) { // remove\n        --count;\n        if (count <= MIN_ARRAY_NODE)\n            return pack(edit, count, frag, children);\n        newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else { // modify\n        newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n        this.size = count;\n        this.children = newChildren;\n        return this;\n    }\n    return ArrayNode(edit, count, newChildren);\n};\n\nempty._modify = (edit, keyEq, shift, f, h, k, size) => {\n    const v = f();\n    if (v === nothing)\n        return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n};\n\n/*\n ******************************************************************************/\nfunction Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n};\n\nMap.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n        this._root = newRoot;\n        this._size = newSize;\n        return this;\n    }\n    return newRoot === this._root\n        ? this\n        : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n};\n\n/* Queries\n ******************************************************************************/\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\nconst tryGetHash = hamt.tryGetHash = (alt, hash, key, map) => {\n    let node = map._root;\n    let shift = 0;\n    const keyEq = map._config.keyEq;\n    while (true) switch (node.type) {\n        case LEAF:\n            {\n                return keyEq(key, node.key) ? node.value : alt;\n            }\n        case COLLISION:\n            {\n                if (hash === node.hash) {\n                    const children = node.children;\n                    for (let i = 0, len = children.length; i < len; ++i) {\n                        const child = children[i];\n                        if (keyEq(key, child.key))\n                            return child.value;\n                    }\n                }\n                return alt;\n            }\n        case INDEX:\n            {\n                const frag = hashFragment(shift, hash);\n                const bit = toBitmap(frag);\n                if (node.mask & bit) {\n                    node = node.children[fromBitmap(node.mask, bit)]\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        case ARRAY:\n            {\n                node = node.children[hashFragment(shift, hash)];\n                if (node) {\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        default:\n            return alt;\n    }\n};\n\nMap.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\nconst tryGet = hamt.tryGet = (alt, key, map) =>\n    tryGetHash(alt, map._config.hash(key), key, map);\n\nMap.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\nconst getHash = hamt.getHash = (hash, key, map) =>\n    tryGetHash(undefined, hash, key, map);\n\nMap.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\nconst get = hamt.get = (key, map) =>\n    tryGetHash(undefined, map._config.hash(key), key, map);\n\nMap.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\nconst hasHash = hamt.has = (hash, key, map) =>\n    tryGetHash(nothing, hash, key, map) !== nothing;\n\nMap.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\nconst has = hamt.has = (key, map) =>\n    hasHash(map._config.hash(key), key, map);\n\nMap.prototype.has = function (key) {\n    return has(key, this);\n};\n\nconst defKeyCompare = (x, y) => x === y;\n\n/**\n    Create an empty map.\n\n    @param config Configuration.\n*/\nhamt.make = (config) =>\n    new Map(0, 0, {\n        keyEq: (config && config.keyEq) || defKeyCompare,\n        hash: (config && config.hash) || hash\n    }, empty, 0);\n\n/**\n    Empty map.\n*/\nhamt.empty = hamt.make();\n\n/**\n    Does `map` contain any elements?\n*/\nconst isEmpty = hamt.isEmpty = (map) =>\n    map && !!isEmptyNode(map._root);\n\nMap.prototype.isEmpty = function () {\n    return isEmpty(this);\n};\n\n/* Updates\n ******************************************************************************/\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst modifyHash = hamt.modifyHash = (f, hash, key, map) => {\n    const size = { value: map._size };\n    const newRoot = map._root._modify(\n        map._editable ? map._edit : NaN,\n        map._config.keyEq,\n        0,\n        f,\n        hash,\n        key,\n        size);\n    return map.setTree(newRoot, size.value);\n};\n\nMap.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n};\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\nconst modify = hamt.modify = (f, key, map) =>\n    modifyHash(f, map._config.hash(key), key, map);\n\nMap.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst setHash = hamt.setHash = (hash, key, value, map) =>\n    modifyHash(constant(value), hash, key, map);\n\nMap.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n};\n\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\nconst set = hamt.set = (key, value, map) =>\n    setHash(map._config.hash(key), key, value, map);\n\nMap.prototype.set = function (key, value) {\n    return set(key, value, this);\n};\n\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\nconst del = constant(nothing);\nconst removeHash = hamt.removeHash = (hash, key, map) =>\n    modifyHash(del, hash, key, map);\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\nconst remove = hamt.remove = (key, map) =>\n    removeHash(map._config.hash(key), key, map);\n\nMap.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n};\n\n/* Mutation\n ******************************************************************************/\n/**\n    Mark `map` as mutable.\n */\nconst beginMutation = hamt.beginMutation = (map) =>\n    new Map(\n        map._editable + 1,\n        map._edit + 1,\n        map._config,\n        map._root,\n        map._size);\n\nMap.prototype.beginMutation = function () {\n    return beginMutation(this);\n};\n\n/**\n    Mark `map` as immutable.\n */\nconst endMutation = hamt.endMutation = (map) => {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n};\n\nMap.prototype.endMutation = function () {\n    return endMutation(this);\n};\n\n/**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/\nconst mutate = hamt.mutate = (f, map) => {\n    const transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n};\n\nMap.prototype.mutate = function (f) {\n    return mutate(f, this);\n};\n\n/* Traversal\n ******************************************************************************/\n/**\n    Apply a continuation.\n*/\nconst appk = k =>\n    k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\nvar lazyVisitChildren = (len, children, i, f, k) => {\n    while (i < len) {\n        const child = children[i++];\n        if (child && !isEmptyNode(child))\n            return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n    return appk(k);\n};\n\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\nconst lazyVisit = (node, f, k) => {\n    switch (node.type) {\n        case LEAF:\n            return {\n                value: f(node),\n                rest: k\n            };\n\n        case COLLISION:\n        case ARRAY:\n        case INDEX:\n            const children = node.children;\n            return lazyVisitChildren(children.length, children, 0, f, k);\n\n        default:\n            return appk(k);\n    }\n};\n\nconst DONE = {\n    done: true\n};\n\n/**\n    Javascript iterator over a map.\n*/\nfunction MapIterator(v) {\n    this.v = v;\n};\n\nMapIterator.prototype.next = function () {\n    if (!this.v)\n        return DONE;\n    const v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n};\n\nMapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n};\n\n/**\n    Lazily visit each value in map with function `f`.\n*/\nconst visit = (map, f) =>\n    new MapIterator(lazyVisit(map._root, f));\n\n/**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\nconst buildPairs = (x) => [x.key, x.value];\nconst entries = hamt.entries = (map) =>\n    visit(map, buildPairs);\n\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n};\n\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\nconst buildKeys = (x) => x.key;\nconst keys = hamt.keys = (map) =>\n    visit(map, buildKeys);\n\nMap.prototype.keys = function () {\n    return keys(this);\n}\n\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\nconst buildValues = x => x.value;\nconst values = hamt.values = Map.prototype.values = map =>\n    visit(map, buildValues);\n\nMap.prototype.values = function () {\n    return values(this);\n};\n\n/* Fold\n ******************************************************************************/\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\nconst fold = hamt.fold = (f, z, m) => {\n    const root = m._root;\n    if (root.type === LEAF)\n        return f(z, root.value, root.key);\n\n    const toVisit = [root.children];\n    let children;\n    while (children = toVisit.pop()) {\n        for (let i = 0, len = children.length; i < len;) {\n            const child = children[i++];\n            if (child && child.type) {\n                if (child.type === LEAF)\n                    z = f(z, child.value, child.key);\n                else\n                    toVisit.push(child.children);\n            }\n        }\n    }\n    return z;\n};\n\nMap.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n};\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\nconst forEach = hamt.forEach = (f, map) =>\n    fold((_, value, key) => f(value, key, map), null, map);\n\nMap.prototype.forEach = function (f) {\n    return forEach(f, this);\n};\n\n/* Aggregate\n ******************************************************************************/\n/**\n    Get the number of entries in `map`.\n*/\nconst count = hamt.count = map =>\n    map._size;\n\nMap.prototype.count = function () {\n    return count(this);\n};\n\nObject.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n});\n\n/* Export\n ******************************************************************************/\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = hamt;\n} else if (typeof define === 'function' && define.amd) {\n    define('hamt', [], () => hamt);\n} else {\n    this.hamt = hamt;\n}\n"]}