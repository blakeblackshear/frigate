{"version":3,"file":"hls.worker.js.map","sources":["node_modules/eventemitter3/index.js","node_modules/@svta/common-media-library/dist/id3/util/isId3Footer.js","node_modules/@svta/common-media-library/dist/id3/util/isId3Header.js","node_modules/@svta/common-media-library/dist/id3/util/readId3Size.js","node_modules/@svta/common-media-library/dist/id3/getId3Data.js","src/errors.ts","src/events.ts","src/utils/logger.ts","src/demux/audio/adts.ts","src/polyfills/number.ts","node_modules/@svta/common-media-library/dist/id3/canParseId3.js","node_modules/@svta/common-media-library/dist/utils/utf8ArrayToStr.js","node_modules/@svta/common-media-library/dist/id3/util/utf8.js","node_modules/@svta/common-media-library/dist/id3/util/decodeId3ImageFrame.js","node_modules/@svta/common-media-library/dist/id3/util/toArrayBuffer.js","node_modules/@svta/common-media-library/dist/id3/util/decodeId3Frame.js","node_modules/@svta/common-media-library/dist/id3/util/decodeId3PrivFrame.js","node_modules/@svta/common-media-library/dist/id3/util/decodeId3UrlFrame.js","node_modules/@svta/common-media-library/dist/id3/util/decodeId3TextFrame.js","node_modules/@svta/common-media-library/dist/id3/util/getId3FrameData.js","node_modules/@svta/common-media-library/dist/id3/getId3Frames.js","node_modules/@svta/common-media-library/dist/id3/isId3TimestampFrame.js","node_modules/@svta/common-media-library/dist/id3/util/readId3Timestamp.js","node_modules/@svta/common-media-library/dist/id3/getId3Timestamp.js","src/types/demuxer.ts","src/utils/hex.ts","node_modules/url-toolkit/src/url-toolkit.js","src/loader/fragment.ts","src/utils/mp4-tools.ts","src/demux/dummy-demuxed-track.ts","src/demux/audio/base-audio-demuxer.ts","src/demux/audio/mpegaudio.ts","src/demux/audio/aacdemuxer.ts","src/demux/audio/dolby.ts","src/demux/audio/ac3-demuxer.ts","src/demux/audio/mp3demuxer.ts","src/crypt/decrypter-aes-mode.ts","src/crypt/aes-crypto.ts","src/crypt/aes-decryptor.ts","src/crypt/fast-aes-key.ts","src/crypt/decrypter.ts","src/demux/mp4demuxer.ts","src/demux/sample-aes.ts","src/demux/video/base-video-parser.ts","src/demux/video/exp-golomb.ts","src/demux/video/avc-video-parser.ts","src/demux/video/hevc-video-parser.ts","src/demux/tsdemuxer.ts","src/remux/aac-helper.ts","src/remux/mp4-generator.ts","src/types/loader.ts","src/utils/timescale-conversion.ts","src/remux/mp4-remuxer.ts","src/utils/mediasource-helper.ts","src/utils/codecs.ts","src/remux/passthrough-remuxer.ts","src/demux/transmuxer.ts","src/utils/encryption-methods-util.ts","src/demux/transmuxer-worker.ts"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n * Returns true if an ID3 footer can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 footer is found\n *\n * @internal\n *\n * @group ID3\n */\nexport function isId3Footer(data, offset) {\n    /*\n     * The footer is a copy of the header, but with a different identifier\n     */\n    if (offset + 10 <= data.length) {\n        // look for '3DI' identifier\n        if (data[offset] === 0x33 &&\n            data[offset + 1] === 0x44 &&\n            data[offset + 2] === 0x49) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 &&\n                    data[offset + 7] < 0x80 &&\n                    data[offset + 8] < 0x80 &&\n                    data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isId3Footer.js.map","/**\n * Returns true if an ID3 header can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 header is found\n *\n * @internal\n *\n * @group ID3\n */\nexport function isId3Header(data, offset) {\n    /*\n     * http://id3.org/id3v2.3.0\n     * [0]     = 'I'\n     * [1]     = 'D'\n     * [2]     = '3'\n     * [3,4]   = {Version}\n     * [5]     = {Flags}\n     * [6-9]   = {ID3 Size}\n     *\n     * An ID3v2 tag can be detected with the following pattern:\n     *  $49 44 33 yy yy xx zz zz zz zz\n     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n     */\n    if (offset + 10 <= data.length) {\n        // look for 'ID3' identifier\n        if (data[offset] === 0x49 &&\n            data[offset + 1] === 0x44 &&\n            data[offset + 2] === 0x33) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 &&\n                    data[offset + 7] < 0x80 &&\n                    data[offset + 8] < 0x80 &&\n                    data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isId3Header.js.map","/**\n * Read ID3 size\n *\n * @param data - The data to read from\n * @param offset - The offset at which to start reading\n *\n * @returns The size\n *\n * @internal\n *\n * @group ID3\n */\nexport function readId3Size(data, offset) {\n    let size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n}\n//# sourceMappingURL=readId3Size.js.map","import { isId3Footer } from './util/isId3Footer.js';\nimport { isId3Header } from './util/isId3Header.js';\nimport { readId3Size } from './util/readId3Size.js';\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns The block of data containing any ID3 tags found\n * or `undefined` if no header is found at the starting offset\n *\n * @internal\n *\n * @group ID3\n */\nexport function getId3Data(data, offset) {\n    const front = offset;\n    let length = 0;\n    while (isId3Header(data, offset)) {\n        // ID3 header is 10 bytes\n        length += 10;\n        const size = readId3Size(data, offset + 6);\n        length += size;\n        if (isId3Footer(data, offset + 10)) {\n            // ID3 footer is 10 bytes\n            length += 10;\n        }\n        offset += length;\n    }\n    if (length > 0) {\n        return data.subarray(front, front + length);\n    }\n    return undefined;\n}\n//# sourceMappingURL=getId3Data.js.map","export enum ErrorTypes {\n  // Identifier for a network error (loading error / timeout ...)\n  NETWORK_ERROR = 'networkError',\n  // Identifier for a media Error (video/parsing/mediasource error)\n  MEDIA_ERROR = 'mediaError',\n  // EME (encrypted media extensions) errors\n  KEY_SYSTEM_ERROR = 'keySystemError',\n  // Identifier for a mux Error (demuxing/remuxing)\n  MUX_ERROR = 'muxError',\n  // Identifier for all other errors\n  OTHER_ERROR = 'otherError',\n}\n\nexport enum ErrorDetails {\n  KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys',\n  KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess',\n  KEY_SYSTEM_NO_SESSION = 'keySystemNoSession',\n  KEY_SYSTEM_NO_CONFIGURED_LICENSE = 'keySystemNoConfiguredLicense',\n  KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed',\n  KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = 'keySystemServerCertificateRequestFailed',\n  KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = 'keySystemServerCertificateUpdateFailed',\n  KEY_SYSTEM_SESSION_UPDATE_FAILED = 'keySystemSessionUpdateFailed',\n  KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = 'keySystemStatusOutputRestricted',\n  KEY_SYSTEM_STATUS_INTERNAL_ERROR = 'keySystemStatusInternalError',\n  KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = 'keySystemDestroyMediaKeysError',\n  KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = 'keySystemDestroyCloseSessionError',\n  KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = 'keySystemDestroyRemoveSessionError',\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_ERROR = 'manifestLoadError',\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut',\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_PARSING_ERROR = 'manifestParsingError',\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError',\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\n  LEVEL_EMPTY_ERROR = 'levelEmptyError',\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_ERROR = 'levelLoadError',\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut',\n  // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\n  LEVEL_PARSING_ERROR = 'levelParsingError',\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  LEVEL_SWITCH_ERROR = 'levelSwitchError',\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError',\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut',\n  // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  SUBTITLE_LOAD_ERROR = 'subtitleTrackLoadError',\n  // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  SUBTITLE_TRACK_LOAD_TIMEOUT = 'subtitleTrackLoadTimeOut',\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  FRAG_LOAD_ERROR = 'fragLoadError',\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut',\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  FRAG_DECRYPT_ERROR = 'fragDecryptError',\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  FRAG_PARSING_ERROR = 'fragParsingError',\n  // Identifier for a fragment or part load skipped because of a GAP tag or attribute\n  FRAG_GAP = 'fragGap',\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  REMUX_ALLOC_ERROR = 'remuxAllocError',\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  KEY_LOAD_ERROR = 'keyLoadError',\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  KEY_LOAD_TIMEOUT = 'keyLoadTimeOut',\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\n  BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError',\n  // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\n  BUFFER_INCOMPATIBLE_CODECS_ERROR = 'bufferIncompatibleCodecsError',\n  // Identifier for a buffer append error - data: append error description\n  BUFFER_APPEND_ERROR = 'bufferAppendError',\n  // Identifier for a buffer appending error event - data: appending error description\n  BUFFER_APPENDING_ERROR = 'bufferAppendingError',\n  // Identifier for a buffer stalled error event\n  BUFFER_STALLED_ERROR = 'bufferStalledError',\n  // Identifier for a buffer full event\n  BUFFER_FULL_ERROR = 'bufferFullError',\n  // Identifier for a buffer seek over hole event\n  BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole',\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall',\n  // Identifier for a Interstitial Asset List load error - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ASSET_LIST_LOAD_ERROR = 'assetListLoadError',\n  // Identifier for a Interstitial Asset List load timeout - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ASSET_LIST_LOAD_TIMEOUT = 'assetListLoadTimeout',\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  ASSET_LIST_PARSING_ERROR = 'assetListParsingError',\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  INTERSTITIAL_ASSET_ITEM_ERROR = 'interstitialAssetItemError',\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  INTERNAL_EXCEPTION = 'internalException',\n  // Identifier for an internal call to abort a loader\n  INTERNAL_ABORTED = 'aborted',\n  // Triggered when attachMedia fails\n  ATTACH_MEDIA_ERROR = 'attachMediaError',\n  // Uncategorized error\n  UNKNOWN = 'unknown',\n}\n","import type {\n  AssetListLoadedData,\n  AssetListLoadingData,\n  AudioTrackLoadedData,\n  AudioTracksUpdatedData,\n  AudioTrackSwitchedData,\n  AudioTrackSwitchingData,\n  AudioTrackUpdatedData,\n  BackBufferData,\n  BufferAppendedData,\n  BufferAppendingData,\n  BufferCodecsData,\n  BufferCreatedData,\n  BufferEOSData,\n  BufferFlushedData,\n  BufferFlushingData,\n  CuesParsedData,\n  ErrorData,\n  FPSDropData,\n  FPSDropLevelCappingData,\n  FragBufferedData,\n  FragChangedData,\n  FragDecryptedData,\n  FragLoadedData,\n  FragLoadEmergencyAbortedData,\n  FragLoadingData,\n  FragParsedData,\n  FragParsingInitSegmentData,\n  FragParsingMetadataData,\n  FragParsingUserdataData,\n  InitPTSFoundData,\n  InterstitialAssetEndedData,\n  InterstitialAssetErrorData,\n  InterstitialAssetPlayerCreatedData,\n  InterstitialAssetStartedData,\n  InterstitialEndedData,\n  InterstitialsBufferedToBoundaryData,\n  InterstitialsPrimaryResumed,\n  InterstitialStartedData,\n  InterstitialsUpdatedData,\n  KeyLoadedData,\n  KeyLoadingData,\n  LevelLoadedData,\n  LevelLoadingData,\n  LevelPTSUpdatedData,\n  LevelsUpdatedData,\n  LevelSwitchedData,\n  LevelSwitchingData,\n  LevelUpdatedData,\n  LiveBackBufferData,\n  ManifestLoadedData,\n  ManifestLoadingData,\n  ManifestParsedData,\n  MaxAutoLevelUpdatedData,\n  MediaAttachedData,\n  MediaAttachingData,\n  MediaDetachedData,\n  MediaDetachingData,\n  MediaEndedData,\n  NonNativeTextTracksData,\n  SteeringManifestLoadedData,\n  SubtitleFragProcessedData,\n  SubtitleTrackLoadedData,\n  SubtitleTracksUpdatedData,\n  SubtitleTrackSwitchData,\n  SubtitleTrackUpdatedData,\n  TrackLoadingData,\n} from './types/events';\n\nexport enum Events {\n  // Fired before MediaSource is attaching to media element\n  MEDIA_ATTACHING = 'hlsMediaAttaching',\n  // Fired when MediaSource has been successfully attached to media element\n  MEDIA_ATTACHED = 'hlsMediaAttached',\n  // Fired before detaching MediaSource from media element\n  MEDIA_DETACHING = 'hlsMediaDetaching',\n  // Fired when MediaSource has been detached from media element\n  MEDIA_DETACHED = 'hlsMediaDetached',\n  // Fired when HTMLMediaElement dispatches \"ended\" event, or stalls at end of VOD program\n  MEDIA_ENDED = 'hlsMediaEnded',\n  // Fired after playback stall is resolved with playing, seeked, or ended event following BUFFER_STALLED_ERROR\n  STALL_RESOLVED = 'hlsStallResolved',\n  // Fired when the buffer is going to be reset\n  BUFFER_RESET = 'hlsBufferReset',\n  // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  BUFFER_CODECS = 'hlsBufferCodecs',\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\n  BUFFER_CREATED = 'hlsBufferCreated',\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  BUFFER_APPENDING = 'hlsBufferAppending',\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n  BUFFER_APPENDED = 'hlsBufferAppended',\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n  BUFFER_EOS = 'hlsBufferEos',\n  // fired when all buffers are full to the end of the program, after calling MediaSource.endOfStream() (unless restricted)\n  BUFFERED_TO_END = 'hlsBufferedToEnd',\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\n  BUFFER_FLUSHING = 'hlsBufferFlushing',\n  // fired when the media buffer has been flushed - data: { }\n  BUFFER_FLUSHED = 'hlsBufferFlushed',\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  MANIFEST_LOADING = 'hlsManifestLoading',\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\n  MANIFEST_LOADED = 'hlsManifestLoaded',\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n  MANIFEST_PARSED = 'hlsManifestParsed',\n  // fired when a level switch is requested - data: { level : id of new level }\n  LEVEL_SWITCHING = 'hlsLevelSwitching',\n  // fired when a level switch is effective - data: { level : id of new level }\n  LEVEL_SWITCHED = 'hlsLevelSwitched',\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n  LEVEL_LOADING = 'hlsLevelLoading',\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\n  LEVEL_LOADED = 'hlsLevelLoaded',\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n  LEVEL_UPDATED = 'hlsLevelUpdated',\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  LEVEL_PTS_UPDATED = 'hlsLevelPtsUpdated',\n  // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\n  LEVELS_UPDATED = 'hlsLevelsUpdated',\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n  AUDIO_TRACKS_UPDATED = 'hlsAudioTracksUpdated',\n  // fired when an audio track switching is requested - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHING = 'hlsAudioTrackSwitching',\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHED = 'hlsAudioTrackSwitched',\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n  AUDIO_TRACK_LOADING = 'hlsAudioTrackLoading',\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\n  AUDIO_TRACK_LOADED = 'hlsAudioTrackLoaded',\n  // fired when an audio tracks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  AUDIO_TRACK_UPDATED = 'hlsAudioTrackUpdated',\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n  SUBTITLE_TRACKS_UPDATED = 'hlsSubtitleTracksUpdated',\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\n  SUBTITLE_TRACKS_CLEARED = 'hlsSubtitleTracksCleared',\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n  SUBTITLE_TRACK_SWITCH = 'hlsSubtitleTrackSwitch',\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n  SUBTITLE_TRACK_LOADING = 'hlsSubtitleTrackLoading',\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\n  SUBTITLE_TRACK_LOADED = 'hlsSubtitleTrackLoaded',\n  // fired when a subtitle  racks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  SUBTITLE_TRACK_UPDATED = 'hlsSubtitleTrackUpdated',\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n  SUBTITLE_FRAG_PROCESSED = 'hlsSubtitleFragProcessed',\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n  CUES_PARSED = 'hlsCuesParsed',\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n  NON_NATIVE_TEXT_TRACKS_FOUND = 'hlsNonNativeTextTracksFound',\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\n  INIT_PTS_FOUND = 'hlsInitPtsFound',\n  // fired when a fragment loading starts - data: { frag : fragment object }\n  FRAG_LOADING = 'hlsFragLoading',\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n  // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n  FRAG_LOAD_EMERGENCY_ABORTED = 'hlsFragLoadEmergencyAborted',\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\n  FRAG_LOADED = 'hlsFragLoaded',\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n  FRAG_DECRYPTED = 'hlsFragDecrypted',\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n  FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment',\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n  FRAG_PARSING_USERDATA = 'hlsFragParsingUserdata',\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  FRAG_PARSING_METADATA = 'hlsFragParsingMetadata',\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  // FRAG_PARSING_DATA = 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n  FRAG_PARSED = 'hlsFragParsed',\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\n  FRAG_BUFFERED = 'hlsFragBuffered',\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  FRAG_CHANGED = 'hlsFragChanged',\n  // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\n  FPS_DROP = 'hlsFpsDrop',\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\n  FPS_DROP_LEVEL_CAPPING = 'hlsFpsDropLevelCapping',\n  // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }\n  MAX_AUTO_LEVEL_UPDATED = 'hlsMaxAutoLevelUpdated',\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n  ERROR = 'hlsError',\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n  DESTROYING = 'hlsDestroying',\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\n  KEY_LOADING = 'hlsKeyLoading',\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\n  KEY_LOADED = 'hlsKeyLoaded',\n  // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\n  LIVE_BACK_BUFFER_REACHED = 'hlsLiveBackBufferReached',\n  // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\n  BACK_BUFFER_REACHED = 'hlsBackBufferReached',\n  // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }\n  STEERING_MANIFEST_LOADED = 'hlsSteeringManifestLoaded',\n  // fired when asset list has begun loading\n  ASSET_LIST_LOADING = 'hlsAssetListLoading',\n  // fired when a valid asset list is loaded\n  ASSET_LIST_LOADED = 'hlsAssetListLoaded',\n  // fired when the list of Interstitial Events and Interstitial Schedule is updated\n  INTERSTITIALS_UPDATED = 'hlsInterstitialsUpdated',\n  // fired when the buffer reaches an Interstitial Schedule boundary (both Primary segments and Interstitial Assets)\n  INTERSTITIALS_BUFFERED_TO_BOUNDARY = 'hlsInterstitialsBufferedToBoundary',\n  // fired when a player instance for an Interstitial Asset has been created\n  INTERSTITIAL_ASSET_PLAYER_CREATED = 'hlsInterstitialAssetPlayerCreated',\n  // Interstitial playback started\n  INTERSTITIAL_STARTED = 'hlsInterstitialStarted',\n  // InterstitialAsset playback started\n  INTERSTITIAL_ASSET_STARTED = 'hlsInterstitialAssetStarted',\n  // InterstitialAsset playback ended\n  INTERSTITIAL_ASSET_ENDED = 'hlsInterstitialAssetEnded',\n  // InterstitialAsset playback errored\n  INTERSTITIAL_ASSET_ERROR = 'hlsInterstitialAssetError',\n  // Interstitial playback ended\n  INTERSTITIAL_ENDED = 'hlsInterstitialEnded',\n  // Interstitial schedule resumed primary playback\n  INTERSTITIALS_PRIMARY_RESUMED = 'hlsInterstitialsPrimaryResumed',\n  // Interstitial players dispatch this event when playout limit is reached\n  PLAYOUT_LIMIT_REACHED = 'hlsPlayoutLimitReached',\n  // Event DateRange cue \"enter\" event dispatched\n  EVENT_CUE_ENTER = 'hlsEventCueEnter',\n}\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\nexport interface HlsListeners {\n  [Events.MEDIA_ATTACHING]: (\n    event: Events.MEDIA_ATTACHING,\n    data: MediaAttachingData,\n  ) => void;\n  [Events.MEDIA_ATTACHED]: (\n    event: Events.MEDIA_ATTACHED,\n    data: MediaAttachedData,\n  ) => void;\n  [Events.MEDIA_DETACHING]: (\n    event: Events.MEDIA_DETACHING,\n    data: MediaDetachingData,\n  ) => void;\n  [Events.MEDIA_DETACHED]: (\n    event: Events.MEDIA_DETACHED,\n    data: MediaDetachedData,\n  ) => void;\n  [Events.MEDIA_ENDED]: (\n    event: Events.MEDIA_ENDED,\n    data: MediaEndedData,\n  ) => void;\n  [Events.STALL_RESOLVED]: (event: Events.STALL_RESOLVED, data: {}) => void;\n  [Events.BUFFER_RESET]: (event: Events.BUFFER_RESET) => void;\n  [Events.BUFFER_CODECS]: (\n    event: Events.BUFFER_CODECS,\n    data: BufferCodecsData,\n  ) => void;\n  [Events.BUFFER_CREATED]: (\n    event: Events.BUFFER_CREATED,\n    data: BufferCreatedData,\n  ) => void;\n  [Events.BUFFER_APPENDING]: (\n    event: Events.BUFFER_APPENDING,\n    data: BufferAppendingData,\n  ) => void;\n  [Events.BUFFER_APPENDED]: (\n    event: Events.BUFFER_APPENDED,\n    data: BufferAppendedData,\n  ) => void;\n  [Events.BUFFER_EOS]: (event: Events.BUFFER_EOS, data: BufferEOSData) => void;\n  [Events.BUFFERED_TO_END]: (event: Events.BUFFERED_TO_END) => void;\n  [Events.BUFFER_FLUSHING]: (\n    event: Events.BUFFER_FLUSHING,\n    data: BufferFlushingData,\n  ) => void;\n  [Events.BUFFER_FLUSHED]: (\n    event: Events.BUFFER_FLUSHED,\n    data: BufferFlushedData,\n  ) => void;\n  [Events.MANIFEST_LOADING]: (\n    event: Events.MANIFEST_LOADING,\n    data: ManifestLoadingData,\n  ) => void;\n  [Events.MANIFEST_LOADED]: (\n    event: Events.MANIFEST_LOADED,\n    data: ManifestLoadedData,\n  ) => void;\n  [Events.MANIFEST_PARSED]: (\n    event: Events.MANIFEST_PARSED,\n    data: ManifestParsedData,\n  ) => void;\n  [Events.LEVEL_SWITCHING]: (\n    event: Events.LEVEL_SWITCHING,\n    data: LevelSwitchingData,\n  ) => void;\n  [Events.LEVEL_SWITCHED]: (\n    event: Events.LEVEL_SWITCHED,\n    data: LevelSwitchedData,\n  ) => void;\n  [Events.LEVEL_LOADING]: (\n    event: Events.LEVEL_LOADING,\n    data: LevelLoadingData,\n  ) => void;\n  [Events.LEVEL_LOADED]: (\n    event: Events.LEVEL_LOADED,\n    data: LevelLoadedData,\n  ) => void;\n  [Events.LEVEL_UPDATED]: (\n    event: Events.LEVEL_UPDATED,\n    data: LevelUpdatedData,\n  ) => void;\n  [Events.LEVEL_PTS_UPDATED]: (\n    event: Events.LEVEL_PTS_UPDATED,\n    data: LevelPTSUpdatedData,\n  ) => void;\n  [Events.LEVELS_UPDATED]: (\n    event: Events.LEVELS_UPDATED,\n    data: LevelsUpdatedData,\n  ) => void;\n  [Events.AUDIO_TRACKS_UPDATED]: (\n    event: Events.AUDIO_TRACKS_UPDATED,\n    data: AudioTracksUpdatedData,\n  ) => void;\n  [Events.AUDIO_TRACK_SWITCHING]: (\n    event: Events.AUDIO_TRACK_SWITCHING,\n    data: AudioTrackSwitchingData,\n  ) => void;\n  [Events.AUDIO_TRACK_SWITCHED]: (\n    event: Events.AUDIO_TRACK_SWITCHED,\n    data: AudioTrackSwitchedData,\n  ) => void;\n  [Events.AUDIO_TRACK_LOADING]: (\n    event: Events.AUDIO_TRACK_LOADING,\n    data: TrackLoadingData,\n  ) => void;\n  [Events.AUDIO_TRACK_LOADED]: (\n    event: Events.AUDIO_TRACK_LOADED,\n    data: AudioTrackLoadedData,\n  ) => void;\n  [Events.AUDIO_TRACK_UPDATED]: (\n    event: Events.AUDIO_TRACK_UPDATED,\n    data: AudioTrackUpdatedData,\n  ) => void;\n  [Events.SUBTITLE_TRACKS_UPDATED]: (\n    event: Events.SUBTITLE_TRACKS_UPDATED,\n    data: SubtitleTracksUpdatedData,\n  ) => void;\n  [Events.SUBTITLE_TRACKS_CLEARED]: (\n    event: Events.SUBTITLE_TRACKS_CLEARED,\n  ) => void;\n  [Events.SUBTITLE_TRACK_SWITCH]: (\n    event: Events.SUBTITLE_TRACK_SWITCH,\n    data: SubtitleTrackSwitchData,\n  ) => void;\n  [Events.SUBTITLE_TRACK_LOADING]: (\n    event: Events.SUBTITLE_TRACK_LOADING,\n    data: TrackLoadingData,\n  ) => void;\n  [Events.SUBTITLE_TRACK_LOADED]: (\n    event: Events.SUBTITLE_TRACK_LOADED,\n    data: SubtitleTrackLoadedData,\n  ) => void;\n  [Events.SUBTITLE_TRACK_UPDATED]: (\n    event: Events.SUBTITLE_TRACK_UPDATED,\n    data: SubtitleTrackUpdatedData,\n  ) => void;\n  [Events.SUBTITLE_FRAG_PROCESSED]: (\n    event: Events.SUBTITLE_FRAG_PROCESSED,\n    data: SubtitleFragProcessedData,\n  ) => void;\n  [Events.CUES_PARSED]: (\n    event: Events.CUES_PARSED,\n    data: CuesParsedData,\n  ) => void;\n  [Events.NON_NATIVE_TEXT_TRACKS_FOUND]: (\n    event: Events.NON_NATIVE_TEXT_TRACKS_FOUND,\n    data: NonNativeTextTracksData,\n  ) => void;\n  [Events.INIT_PTS_FOUND]: (\n    event: Events.INIT_PTS_FOUND,\n    data: InitPTSFoundData,\n  ) => void;\n  [Events.FRAG_LOADING]: (\n    event: Events.FRAG_LOADING,\n    data: FragLoadingData,\n  ) => void;\n  // [Events.FRAG_LOAD_PROGRESS]: TodoEventType\n  [Events.FRAG_LOAD_EMERGENCY_ABORTED]: (\n    event: Events.FRAG_LOAD_EMERGENCY_ABORTED,\n    data: FragLoadEmergencyAbortedData,\n  ) => void;\n  [Events.FRAG_LOADED]: (\n    event: Events.FRAG_LOADED,\n    data: FragLoadedData,\n  ) => void;\n  [Events.FRAG_DECRYPTED]: (\n    event: Events.FRAG_DECRYPTED,\n    data: FragDecryptedData,\n  ) => void;\n  [Events.FRAG_PARSING_INIT_SEGMENT]: (\n    event: Events.FRAG_PARSING_INIT_SEGMENT,\n    data: FragParsingInitSegmentData,\n  ) => void;\n  [Events.FRAG_PARSING_USERDATA]: (\n    event: Events.FRAG_PARSING_USERDATA,\n    data: FragParsingUserdataData,\n  ) => void;\n  [Events.FRAG_PARSING_METADATA]: (\n    event: Events.FRAG_PARSING_METADATA,\n    data: FragParsingMetadataData,\n  ) => void;\n  // [Events.FRAG_PARSING_DATA]: TodoEventType\n  [Events.FRAG_PARSED]: (\n    event: Events.FRAG_PARSED,\n    data: FragParsedData,\n  ) => void;\n  [Events.FRAG_BUFFERED]: (\n    event: Events.FRAG_BUFFERED,\n    data: FragBufferedData,\n  ) => void;\n  [Events.FRAG_CHANGED]: (\n    event: Events.FRAG_CHANGED,\n    data: FragChangedData,\n  ) => void;\n  [Events.FPS_DROP]: (event: Events.FPS_DROP, data: FPSDropData) => void;\n  [Events.FPS_DROP_LEVEL_CAPPING]: (\n    event: Events.FPS_DROP_LEVEL_CAPPING,\n    data: FPSDropLevelCappingData,\n  ) => void;\n  [Events.MAX_AUTO_LEVEL_UPDATED]: (\n    event: Events.MAX_AUTO_LEVEL_UPDATED,\n    data: MaxAutoLevelUpdatedData,\n  ) => void;\n  [Events.ERROR]: (event: Events.ERROR, data: ErrorData) => void;\n  [Events.DESTROYING]: (event: Events.DESTROYING) => void;\n  [Events.KEY_LOADING]: (\n    event: Events.KEY_LOADING,\n    data: KeyLoadingData,\n  ) => void;\n  [Events.KEY_LOADED]: (event: Events.KEY_LOADED, data: KeyLoadedData) => void;\n  [Events.LIVE_BACK_BUFFER_REACHED]: (\n    event: Events.LIVE_BACK_BUFFER_REACHED,\n    data: LiveBackBufferData,\n  ) => void;\n  [Events.BACK_BUFFER_REACHED]: (\n    event: Events.BACK_BUFFER_REACHED,\n    data: BackBufferData,\n  ) => void;\n  [Events.STEERING_MANIFEST_LOADED]: (\n    event: Events.STEERING_MANIFEST_LOADED,\n    data: SteeringManifestLoadedData,\n  ) => void;\n  [Events.ASSET_LIST_LOADING]: (\n    event: Events.ASSET_LIST_LOADING,\n    data: AssetListLoadingData,\n  ) => void;\n  [Events.ASSET_LIST_LOADED]: (\n    event: Events.ASSET_LIST_LOADED,\n    data: AssetListLoadedData,\n  ) => void;\n  [Events.INTERSTITIALS_UPDATED]: (\n    event: Events.INTERSTITIALS_UPDATED,\n    data: InterstitialsUpdatedData,\n  ) => void;\n  [Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY]: (\n    event: Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY,\n    data: InterstitialsBufferedToBoundaryData,\n  ) => void;\n  [Events.INTERSTITIAL_ASSET_PLAYER_CREATED]: (\n    event: Events.INTERSTITIAL_ASSET_PLAYER_CREATED,\n    data: InterstitialAssetPlayerCreatedData,\n  ) => void;\n  [Events.INTERSTITIAL_STARTED]: (\n    event: Events.INTERSTITIAL_STARTED,\n    data: InterstitialStartedData,\n  ) => void;\n  [Events.INTERSTITIAL_ASSET_STARTED]: (\n    event: Events.INTERSTITIAL_ASSET_STARTED,\n    data: InterstitialAssetStartedData,\n  ) => void;\n  [Events.INTERSTITIAL_ASSET_ENDED]: (\n    event: Events.INTERSTITIAL_ASSET_ENDED,\n    data: InterstitialAssetEndedData,\n  ) => void;\n  [Events.INTERSTITIAL_ASSET_ERROR]: (\n    event: Events.INTERSTITIAL_ASSET_ERROR,\n    data: InterstitialAssetErrorData,\n  ) => void;\n  [Events.INTERSTITIAL_ENDED]: (\n    event: Events.INTERSTITIAL_ENDED,\n    data: InterstitialEndedData,\n  ) => void;\n  [Events.INTERSTITIALS_PRIMARY_RESUMED]: (\n    event: Events.INTERSTITIALS_PRIMARY_RESUMED,\n    data: InterstitialsPrimaryResumed,\n  ) => void;\n  [Events.PLAYOUT_LIMIT_REACHED]: (\n    event: Events.PLAYOUT_LIMIT_REACHED,\n    data: {},\n  ) => void;\n  [Events.EVENT_CUE_ENTER]: (event: Events.EVENT_CUE_ENTER, data: {}) => void;\n}\nexport interface HlsEventEmitter {\n  on<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener: HlsListeners[E],\n    context?: Context,\n  ): void;\n  once<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener: HlsListeners[E],\n    context?: Context,\n  ): void;\n\n  removeAllListeners<E extends keyof HlsListeners>(event?: E): void;\n  off<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener?: HlsListeners[E],\n    context?: Context,\n    once?: boolean,\n  ): void;\n\n  listeners<E extends keyof HlsListeners>(event: E): HlsListeners[E][];\n  emit<E extends keyof HlsListeners>(\n    event: E,\n    name: E,\n    eventObject: Parameters<HlsListeners[E]>[1],\n  ): boolean;\n  listenerCount<E extends keyof HlsListeners>(event: E): number;\n}\n","export interface ILogFunction {\n  (message?: any, ...optionalParams: any[]): void;\n}\n\nexport interface ILogger {\n  trace: ILogFunction;\n  debug: ILogFunction;\n  log: ILogFunction;\n  warn: ILogFunction;\n  info: ILogFunction;\n  error: ILogFunction;\n}\n\nexport class Logger implements ILogger {\n  trace: ILogFunction;\n  debug: ILogFunction;\n  log: ILogFunction;\n  warn: ILogFunction;\n  info: ILogFunction;\n  error: ILogFunction;\n\n  constructor(label: string, logger: ILogger) {\n    const lb = `[${label}]:`;\n    this.trace = noop;\n    this.debug = logger.debug.bind(null, lb);\n    this.log = logger.log.bind(null, lb);\n    this.warn = logger.warn.bind(null, lb);\n    this.info = logger.info.bind(null, lb);\n    this.error = logger.error.bind(null, lb);\n  }\n}\n\nconst noop: ILogFunction = function () {};\n\nconst fakeLogger: ILogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop,\n};\n\nfunction createLogger() {\n  return Object.assign({}, fakeLogger);\n}\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type: string, id: string | undefined): ILogFunction {\n  const func: ILogFunction = self.console[type];\n  return func\n    ? func.bind(self.console, `${id ? '[' + id + '] ' : ''}[${type}] >`)\n    : noop;\n}\n\nfunction getLoggerFn(\n  key: string,\n  debugConfig: boolean | Partial<ILogger>,\n  id?: string,\n): ILogFunction {\n  return debugConfig[key]\n    ? debugConfig[key].bind(debugConfig)\n    : consolePrintFn(key, id);\n}\n\nconst exportedLogger: ILogger = createLogger();\n\nexport function enableLogs(\n  debugConfig: boolean | ILogger,\n  context: string,\n  id?: string | undefined,\n): ILogger {\n  // check that console is available\n  const newLogger = createLogger();\n  if (\n    (typeof console === 'object' && debugConfig === true) ||\n    typeof debugConfig === 'object'\n  ) {\n    const keys: (keyof ILogger)[] = [\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      'debug',\n      'log',\n      'info',\n      'warn',\n      'error',\n    ];\n    keys.forEach((key) => {\n      newLogger[key] = getLoggerFn(key, debugConfig, id);\n    });\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      newLogger.log(\n        `Debug logs enabled for \"${context}\" in hls.js version ${__VERSION__}`,\n      );\n    } catch (e) {\n      /* log fn threw an exception. All logger methods are no-ops. */\n      return createLogger();\n    }\n    // global exported logger uses the same functions as new logger without `id`\n    keys.forEach((key) => {\n      exportedLogger[key] = getLoggerFn(key, debugConfig);\n    });\n  } else {\n    // Reset global exported logger\n    Object.assign(exportedLogger, newLogger);\n  }\n  return newLogger;\n}\n\nexport const logger: ILogger = exportedLogger;\n","/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\nimport { ErrorDetails, ErrorTypes } from '../../errors';\nimport { Events } from '../../events';\nimport { logger } from '../../utils/logger';\nimport type { HlsEventEmitter } from '../../events';\nimport type {\n  AudioFrame,\n  AudioSample,\n  DemuxedAudioTrack,\n} from '../../types/demuxer';\n\ntype AudioConfig = {\n  config: [number, number];\n  samplerate: number;\n  channelCount: number;\n  codec: string;\n  parsedCodec: string;\n  manifestCodec: string | undefined;\n};\n\ntype FrameHeader = {\n  headerLength: number;\n  frameLength: number;\n};\n\nexport function getAudioConfig(\n  observer: HlsEventEmitter,\n  data: Uint8Array,\n  offset: number,\n  manifestCodec: string | undefined,\n): AudioConfig | void {\n  const adtsSamplingRates = [\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025,\n    8000, 7350,\n  ];\n  const byte2 = data[offset + 2];\n  const adtsSamplingIndex = (byte2 >> 2) & 0xf;\n  if (adtsSamplingIndex > 12) {\n    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      error,\n      reason: error.message,\n    });\n    return;\n  }\n  // MPEG-4 Audio Object Type (profile_ObjectType+1)\n  const adtsObjectType = ((byte2 >> 6) & 0x3) + 1;\n  const channelCount = ((data[offset + 3] >> 6) & 0x3) | ((byte2 & 1) << 2);\n  const codec = 'mp4a.40.' + adtsObjectType;\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO/IEC 14496-3 - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  const samplerate = adtsSamplingRates[adtsSamplingIndex];\n  let aacSampleIndex = adtsSamplingIndex;\n  if (adtsObjectType === 5 || adtsObjectType === 29) {\n    // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n    // there is a factor 2 between frame sample rate and output sample rate\n    // multiply frequency by 2 (see table above, equivalent to substract 3)\n    aacSampleIndex -= 3;\n  }\n  const config: [number, number] = [\n    (adtsObjectType << 3) | ((aacSampleIndex & 0x0e) >> 1),\n    ((aacSampleIndex & 0x01) << 7) | (channelCount << 3),\n  ];\n  logger.log(\n    `manifest codec:${manifestCodec}, parsed codec:${codec}, channels:${channelCount}, rate:${samplerate} (ADTS object type:${adtsObjectType} sampling index:${adtsSamplingIndex})`,\n  );\n  return {\n    config,\n    samplerate,\n    channelCount,\n    codec,\n    parsedCodec: codec,\n    manifestCodec,\n  };\n}\n\nexport function isHeaderPattern(data: Uint8Array, offset: number): boolean {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\n\nexport function getHeaderLength(data: Uint8Array, offset: number): number {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\n\nexport function getFullFrameLength(data: Uint8Array, offset: number): number {\n  return (\n    ((data[offset + 3] & 0x03) << 11) |\n    (data[offset + 4] << 3) |\n    ((data[offset + 5] & 0xe0) >>> 5)\n  );\n}\n\nexport function canGetFrameLength(data: Uint8Array, offset: number): boolean {\n  return offset + 5 < data.length;\n}\n\nexport function isHeader(data: Uint8Array, offset: number): boolean {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\n\nexport function canParse(data: Uint8Array, offset: number): boolean {\n  return (\n    canGetFrameLength(data, offset) &&\n    isHeaderPattern(data, offset) &&\n    getFullFrameLength(data, offset) <= data.length - offset\n  );\n}\n\nexport function probe(data: Uint8Array, offset: number): boolean {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\nexport function initTrackConfig(\n  track: DemuxedAudioTrack,\n  observer: HlsEventEmitter,\n  data: Uint8Array,\n  offset: number,\n  audioCodec: string | undefined,\n) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    Object.assign(track, config);\n  }\n}\n\nexport function getFrameDuration(samplerate: number): number {\n  return (1024 * 90000) / samplerate;\n}\n\nexport function parseFrameHeader(\n  data: Uint8Array,\n  offset: number,\n): FrameHeader | void {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return { headerLength, frameLength };\n    }\n  }\n}\n\nexport function appendFrame(\n  track: DemuxedAudioTrack,\n  data: Uint8Array,\n  offset: number,\n  pts: number,\n  frameIndex: number,\n): AudioFrame {\n  const frameDuration = getFrameDuration(track.samplerate as number);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit: Uint8Array;\n  if (header) {\n    const { frameLength, headerLength } = header;\n    const length = headerLength + frameLength;\n    const missing = Math.max(0, offset + length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + length);\n    }\n\n    const sample: AudioSample = {\n      unit,\n      pts: stamp,\n    };\n    if (!missing) {\n      track.samples.push(sample as AudioSample);\n    }\n\n    return { sample, length, missing };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample: AudioSample = {\n    unit,\n    pts: stamp,\n  };\n  return { sample, length, missing: -1 };\n}\n","// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nexport const isFiniteNumber =\n  Number.isFinite ||\n  function (value) {\n    return typeof value === 'number' && isFinite(value);\n  };\n\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nexport const isSafeInteger =\n  Number.isSafeInteger ||\n  function (value) {\n    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n  };\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n","import { isId3Header } from './util/isId3Header.js';\nimport { readId3Size } from './util/readId3Size.js';\n/**\n * Checks if the given data contains an ID3 tag.\n *\n * @param data - The data to check\n * @param offset - The offset at which to start checking\n *\n * @returns `true` if an ID3 tag is found\n *\n * @group ID3\n *\n * @beta\n */\nexport function canParseId3(data, offset) {\n    return (isId3Header(data, offset) &&\n        readId3Size(data, offset + 6) + 10 <= data.length - offset);\n}\n//# sourceMappingURL=canParseId3.js.map","// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n/**\n * Converts a UTF-8 array to a string.\n *\n * @param array - The UTF-8 array to convert\n *\n * @returns The string\n *\n * @group Utils\n *\n * @beta\n */\nexport function utf8ArrayToStr(array, exitOnNull = false) {\n    if (typeof TextDecoder !== 'undefined') {\n        const decoder = new TextDecoder('utf-8');\n        const decoded = decoder.decode(array);\n        if (exitOnNull) {\n            // grab up to the first null\n            const idx = decoded.indexOf('\\0');\n            return idx !== -1 ? decoded.substring(0, idx) : decoded;\n        }\n        // remove any null characters\n        return decoded.replace(/\\0/g, '');\n    }\n    const len = array.length;\n    let c;\n    let char2;\n    let char3;\n    let out = '';\n    let i = 0;\n    while (i < len) {\n        c = array[i++];\n        if (c === 0x00 && exitOnNull) {\n            return out;\n        }\n        else if (c === 0x00 || c === 0x03) {\n            // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n            continue;\n        }\n        switch (c >> 4) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                // 0xxxxxxx\n                out += String.fromCharCode(c);\n                break;\n            case 12:\n            case 13:\n                // 110x xxxx   10xx xxxx\n                char2 = array[i++];\n                out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));\n                break;\n            case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));\n                break;\n            default:\n        }\n    }\n    return out;\n}\n//# sourceMappingURL=utf8ArrayToStr.js.map","export function toUint8(data, offset = 0, length = Infinity) {\n    return view(data, offset, length, Uint8Array);\n}\nfunction view(data, offset, length, Type) {\n    const buffer = unsafeGetArrayBuffer(data);\n    let bytesPerElement = 1;\n    if ('BYTES_PER_ELEMENT' in Type) {\n        bytesPerElement = Type.BYTES_PER_ELEMENT;\n    }\n    // Absolute end of the |data| view within |buffer|.\n    const dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;\n    const dataEnd = ((dataOffset) + data.byteLength) / bytesPerElement;\n    // Absolute start of the result within |buffer|.\n    const rawStart = ((dataOffset) + offset) / bytesPerElement;\n    const start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));\n    // Absolute end of the result within |buffer|.\n    const end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));\n    return new Type(buffer, start, end - start);\n}\nfunction unsafeGetArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n        return view;\n    }\n    else {\n        return view.buffer;\n    }\n}\nfunction isArrayBufferView(obj) {\n    return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== undefined && obj.byteOffset !== undefined;\n}\n//# sourceMappingURL=utf8.js.map","import { utf8ArrayToStr } from '../../utils/utf8ArrayToStr.js';\nimport { toArrayBuffer } from './toArrayBuffer.js';\nimport { toUint8 } from './utf8.js';\nexport function decodeId3ImageFrame(frame) {\n    const metadataFrame = {\n        key: frame.type,\n        description: '',\n        data: '',\n        mimeType: null,\n        pictureType: null,\n    };\n    const utf8Encoding = 0x03;\n    if (frame.size < 2) {\n        return undefined;\n    }\n    if (frame.data[0] !== utf8Encoding) {\n        console.log('Ignore frame with unrecognized character ' + 'encoding');\n        return undefined;\n    }\n    const mimeTypeEndIndex = frame.data.subarray(1).indexOf(0);\n    if (mimeTypeEndIndex === -1) {\n        return undefined;\n    }\n    const mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex));\n    const pictureType = frame.data[2 + mimeTypeEndIndex];\n    const descriptionEndIndex = frame.data\n        .subarray(3 + mimeTypeEndIndex)\n        .indexOf(0);\n    if (descriptionEndIndex === -1) {\n        return undefined;\n    }\n    const description = utf8ArrayToStr(toUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex));\n    let data;\n    if (mimeType === '-->') {\n        data = utf8ArrayToStr(toUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex));\n    }\n    else {\n        data = toArrayBuffer(frame.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));\n    }\n    metadataFrame.mimeType = mimeType;\n    metadataFrame.pictureType = pictureType;\n    metadataFrame.description = description;\n    metadataFrame.data = data;\n    return metadataFrame;\n}\n//# sourceMappingURL=decodeId3ImageFrame.js.map","export function toArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n        return view;\n    }\n    else {\n        if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n            // This is a TypedArray over the whole buffer.\n            return view.buffer;\n        }\n        // This is a 'view' on the buffer.  Create a new buffer that only contains\n        // the data.  Note that since this isn't an ArrayBuffer, the 'new' call\n        // will allocate a new buffer to hold the copy.\n        return new Uint8Array(view).buffer;\n    }\n}\n//# sourceMappingURL=toArrayBuffer.js.map","import { decodeId3ImageFrame } from './decodeId3ImageFrame.js';\nimport { decodeId3PrivFrame } from './decodeId3PrivFrame.js';\nimport { decodeId3TextFrame } from './decodeId3TextFrame.js';\nimport { decodeId3UrlFrame } from './decodeId3UrlFrame.js';\n/**\n * Decode an ID3 frame.\n *\n * @param frame - the ID3 frame\n *\n * @returns The decoded ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function decodeId3Frame(frame) {\n    if (frame.type === 'PRIV') {\n        return decodeId3PrivFrame(frame);\n    }\n    else if (frame.type[0] === 'W') {\n        return decodeId3UrlFrame(frame);\n    }\n    else if (frame.type === 'APIC') {\n        return decodeId3ImageFrame(frame);\n    }\n    return decodeId3TextFrame(frame);\n}\n//# sourceMappingURL=decodeId3Frame.js.map","import { utf8ArrayToStr } from '../../utils/utf8ArrayToStr.js';\n/**\n * Decode an ID3 PRIV frame.\n *\n * @param frame - the ID3 PRIV frame\n *\n * @returns The decoded ID3 PRIV frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function decodeId3PrivFrame(frame) {\n    /*\n    Format: <text string>\\0<binary data>\n    */\n    if (frame.size < 2) {\n        return undefined;\n    }\n    const owner = utf8ArrayToStr(frame.data, true);\n    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n    return { key: frame.type, info: owner, data: privateData.buffer };\n}\n//# sourceMappingURL=decodeId3PrivFrame.js.map","import { utf8ArrayToStr } from '../../utils/utf8ArrayToStr.js';\n/**\n * Decode a URL frame\n *\n * @param frame - the ID3 URL frame\n *\n * @returns The decoded ID3 URL frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function decodeId3UrlFrame(frame) {\n    if (frame.type === 'WXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{URL}\n        */\n        if (frame.size < 2) {\n            return undefined;\n        }\n        let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return { key: frame.type, info: description, data: value };\n    }\n    /*\n    Format:\n    [0-?] = {URL}\n    */\n    const url = utf8ArrayToStr(frame.data);\n    return { key: frame.type, info: '', data: url };\n}\n//# sourceMappingURL=decodeId3UrlFrame.js.map","import { utf8ArrayToStr } from '../../utils/utf8ArrayToStr.js';\n/**\n * Decodes an ID3 text frame\n *\n * @param frame - the ID3 text frame\n *\n * @returns The decoded ID3 text frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function decodeId3TextFrame(frame) {\n    if (frame.size < 2) {\n        return undefined;\n    }\n    if (frame.type === 'TXXX') {\n        /*\n        Format:\n        [0]   = {Text Encoding}\n        [1-?] = {Description}\\0{Value}\n        */\n        let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return { key: frame.type, info: description, data: value };\n    }\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Value}\n    */\n    const text = utf8ArrayToStr(frame.data.subarray(1));\n    return { key: frame.type, info: '', data: text };\n}\n//# sourceMappingURL=decodeId3TextFrame.js.map","import { readId3Size } from './readId3Size.js';\n/**\n * Returns the data of an ID3 frame.\n *\n * @param data - The data to read from\n *\n * @returns The data of the ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function getId3FrameData(data) {\n    /*\n    Frame ID       $xx xx xx xx (four characters)\n    Size           $xx xx xx xx\n    Flags          $xx xx\n    */\n    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    const size = readId3Size(data, 4);\n    // skip frame id, size, and flags\n    const offset = 10;\n    return { type, size, data: data.subarray(offset, offset + size) };\n}\n//# sourceMappingURL=getId3FrameData.js.map","import { decodeId3Frame } from './util/decodeId3Frame.js';\nimport { getId3FrameData } from './util/getId3FrameData.js';\nimport { isId3Footer } from './util/isId3Footer.js';\nimport { isId3Header } from './util/isId3Header.js';\nimport { readId3Size } from './util/readId3Size.js';\nconst HEADER_FOOTER_SIZE = 10;\nconst FRAME_SIZE = 10;\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n *\n * @param id3Data - The ID3 data containing one or more ID3 tags\n *\n * @returns Array of ID3 frame objects\n *\n * @group ID3\n *\n * @beta\n */\nexport function getId3Frames(id3Data) {\n    let offset = 0;\n    const frames = [];\n    while (isId3Header(id3Data, offset)) {\n        const size = readId3Size(id3Data, offset + 6);\n        if ((id3Data[offset + 5] >> 6) & 1) {\n            // skip extended header\n            offset += HEADER_FOOTER_SIZE;\n        }\n        // skip past ID3 header\n        offset += HEADER_FOOTER_SIZE;\n        const end = offset + size;\n        // loop through frames in the ID3 tag\n        while (offset + FRAME_SIZE < end) {\n            const frameData = getId3FrameData(id3Data.subarray(offset));\n            const frame = decodeId3Frame(frameData);\n            if (frame) {\n                frames.push(frame);\n            }\n            // skip frame header and frame data\n            offset += frameData.size + HEADER_FOOTER_SIZE;\n        }\n        if (isId3Footer(id3Data, offset)) {\n            offset += HEADER_FOOTER_SIZE;\n        }\n    }\n    return frames;\n}\n//# sourceMappingURL=getId3Frames.js.map","/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @param frame - the ID3 frame\n *\n * @returns `true` if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @internal\n *\n * @group ID3\n */\nexport function isId3TimestampFrame(frame) {\n    return (frame &&\n        frame.key === 'PRIV' &&\n        frame.info === 'com.apple.streaming.transportStreamTimestamp');\n}\n//# sourceMappingURL=isId3TimestampFrame.js.map","/**\n * Read a 33 bit timestamp from an ID3 frame.\n *\n * @param timeStampFrame - the ID3 frame\n *\n * @returns The timestamp\n *\n * @internal\n *\n * @group ID3\n */\nexport function readId3Timestamp(timeStampFrame) {\n    if (timeStampFrame.data.byteLength === 8) {\n        const data = new Uint8Array(timeStampFrame.data);\n        // timestamp is 33 bit expressed as a big-endian eight-octet number,\n        // with the upper 31 bits set to zero.\n        const pts33Bit = data[3] & 0x1;\n        let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n        timestamp /= 45;\n        if (pts33Bit) {\n            timestamp += 47721858.84;\n        } // 2^32 / 90\n        return Math.round(timestamp);\n    }\n    return undefined;\n}\n//# sourceMappingURL=readId3Timestamp.js.map","import { getId3Frames } from './getId3Frames.js';\nimport { isId3TimestampFrame } from './isId3TimestampFrame.js';\nimport { readId3Timestamp } from './util/readId3Timestamp.js';\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n *\n * @param data - Block of data containing one or more ID3 tags\n *\n * @returns The timestamp\n *\n * @group ID3\n *\n * @beta\n */\nexport function getId3Timestamp(data) {\n    const frames = getId3Frames(data);\n    for (let i = 0; i < frames.length; i++) {\n        const frame = frames[i];\n        if (isId3TimestampFrame(frame)) {\n            return readId3Timestamp(frame);\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=getId3Timestamp.js.map","import type { RationalTimestamp } from '../utils/timescale-conversion';\n\nexport interface Demuxer {\n  demux(\n    data: Uint8Array,\n    timeOffset: number,\n    isSampleAes?: boolean,\n    flush?: boolean,\n  ): DemuxerResult;\n  demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number,\n  ): Promise<DemuxerResult>;\n  flush(timeOffset?: number): DemuxerResult | Promise<DemuxerResult>;\n  destroy(): void;\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  );\n  resetTimeStamp(defaultInitPTS?: RationalTimestamp | null): void;\n  resetContiguity(): void;\n}\n\nexport interface DemuxerResult {\n  audioTrack: DemuxedAudioTrack;\n  videoTrack: DemuxedVideoTrackBase;\n  id3Track: DemuxedMetadataTrack;\n  textTrack: DemuxedUserdataTrack;\n}\n\nexport interface DemuxedTrack {\n  type: string;\n  id: number;\n  pid: number;\n  inputTimeScale: number;\n  sequenceNumber: number;\n  samples:\n    | AudioSample[]\n    | VideoSample[]\n    | MetadataSample[]\n    | UserdataSample[]\n    | Uint8Array;\n  timescale?: number;\n  container?: string;\n  dropped: number;\n  duration?: number;\n  pesData?: ElementaryStreamData | null;\n  codec?: string;\n}\n\nexport interface PassthroughTrack extends DemuxedTrack {\n  sampleDuration: number;\n  samples: Uint8Array;\n  timescale: number;\n  duration: number;\n  codec: string;\n  supplemental: string | undefined;\n}\nexport interface DemuxedAudioTrack extends DemuxedTrack {\n  type: 'audio';\n  segmentCodec: 'aac' | 'ac3' | 'mp3';\n  config?: number[] | Uint8Array;\n  samplerate?: number;\n  channelCount?: number;\n  manifestCodec?: string;\n  parsedCodec?: string;\n  samples: AudioSample[];\n}\n\nexport type DemuxedAAC = DemuxedAudioTrack & {\n  segmentCodec: 'aac';\n  samples: AACAudioSample[];\n};\n\nexport type DemuxedAC3 = DemuxedAudioTrack & {\n  segmentCodec: 'ac3';\n  config: Uint8Array;\n};\n\nexport interface DemuxedVideoTrackBase extends DemuxedTrack {\n  width?: number;\n  height?: number;\n  pixelRatio?: [number, number];\n  audFound?: boolean;\n  vps?: Uint8Array[];\n  pps?: Uint8Array[];\n  sps?: Uint8Array[];\n  naluState?: number;\n  segmentCodec?: string;\n  manifestCodec?: string;\n  samples: VideoSample[] | Uint8Array;\n  params?: object;\n}\n\nexport interface DemuxedVideoTrack extends DemuxedVideoTrackBase {\n  type: 'video';\n  segmentCodec: 'avc' | 'hevc';\n  samples: VideoSample[];\n  pixelRatio: [number, number];\n  width: number;\n  height: number;\n}\n\nexport type DemuxedAVC1 = DemuxedVideoTrack & {\n  segmentCodec: 'avc';\n  pps: Uint8Array[];\n  sps: Uint8Array[];\n};\n\nexport type DemuxedHEVC = DemuxedVideoTrack & {\n  segmentCodec: 'hevc';\n  params: {\n    general_profile_space: number;\n    general_tier_flag: number;\n    general_profile_idc: number;\n    general_profile_compatibility_flags: number[];\n    general_constraint_indicator_flags: number[];\n    general_level_idc: number;\n    min_spatial_segmentation_idc: number;\n    parallelismType: number;\n    chroma_format_idc: number;\n    bit_depth_luma_minus8: number;\n    bit_depth_chroma_minus8: number;\n    frame_rate: { fps: string; fixed: boolean };\n    temporal_id_nested: number;\n    num_temporal_layers: number;\n  };\n  pps: Uint8Array[];\n  sps: Uint8Array[];\n  vps: Uint8Array;\n};\n\nexport interface DemuxedMetadataTrack extends DemuxedTrack {\n  samples: MetadataSample[];\n}\n\nexport interface DemuxedUserdataTrack extends DemuxedTrack {\n  samples: UserdataSample[];\n}\n\nexport enum MetadataSchema {\n  audioId3 = 'org.id3',\n  dateRange = 'com.apple.quicktime.HLS',\n  emsg = 'https://aomedia.org/emsg/ID3',\n  misbklv = 'urn:misb:KLV:bin:1910.1',\n}\nexport interface MetadataSample {\n  pts: number;\n  dts: number;\n  duration: number;\n  len?: number;\n  data: Uint8Array;\n  type: MetadataSchema;\n}\n\nexport interface UserdataSample {\n  pts: number;\n  bytes?: Uint8Array;\n  type?: number;\n  payloadType?: number;\n  uuid?: string;\n  userData?: string;\n  userDataBytes?: Uint8Array;\n}\n\nexport interface VideoSample {\n  dts: number;\n  pts: number;\n  key: boolean;\n  frame: boolean;\n  units: VideoSampleUnit[];\n  length: number;\n}\n\nexport interface VideoSampleUnit {\n  data: Uint8Array;\n  type: number;\n  state?: number;\n}\n\nexport type AudioSample = {\n  unit: Uint8Array;\n  pts: number;\n};\n\nexport type AACAudioSample = {\n  unit: Uint8Array<ArrayBuffer>;\n};\n\nexport type AudioFrame = {\n  sample: AudioSample;\n  length: number;\n  missing: number;\n};\n\nexport interface ElementaryStreamData {\n  data: Uint8Array[];\n  size: number;\n}\n\nexport interface KeyData {\n  method: string;\n  key: Uint8Array<ArrayBuffer>;\n  iv: Uint8Array<ArrayBuffer>;\n}\n","/**\n *  hex dump helper class\n */\n\nexport function arrayToHex(array: Uint8Array<ArrayBuffer> | number[]) {\n  let str = '';\n  for (let i = 0; i < array.length; i++) {\n    let h = array[i].toString(16);\n    if (h.length < 2) {\n      h = '0' + h;\n    }\n\n    str += h;\n  }\n  return str;\n}\n\nexport function hexToArrayBuffer(str: string): ArrayBuffer {\n  return Uint8Array.from(\n    str\n      .replace(/^0x/, '')\n      .replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ')\n      .replace(/ +$/, '')\n      .split(' '),\n  ).buffer;\n}\n\nconst Hex = {\n  hexDump: arrayToHex,\n};\n\nexport default Hex;\n","// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (typeof exports === 'object' && typeof module === 'object')\n    module.exports = URLToolkit;\n  else if (typeof define === 'function' && define.amd)\n    define([], function () {\n      return URLToolkit;\n    });\n  else if (typeof exports === 'object') exports['URLToolkit'] = URLToolkit;\n  else root['URLToolkit'] = URLToolkit;\n})(this);\n","import { buildAbsoluteURL } from 'url-toolkit';\nimport { LoadStats } from './load-stats';\nimport type { LevelKey } from './level-key';\nimport type {\n  FragmentLoaderContext,\n  KeyLoaderContext,\n  Loader,\n  PlaylistLevelType,\n} from '../types/loader';\nimport type { AttrList } from '../utils/attr-list';\nimport type { KeySystemFormats } from '../utils/mediakeys-helper';\n\nexport const enum ElementaryStreamTypes {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n  AUDIOVIDEO = 'audiovideo',\n}\n\nexport interface ElementaryStreamInfo {\n  startPTS: number;\n  endPTS: number;\n  startDTS: number;\n  endDTS: number;\n  partial?: boolean;\n}\n\nexport type ElementaryStreams = Record<\n  ElementaryStreamTypes,\n  ElementaryStreamInfo | null\n>;\n\nexport type Base = {\n  url: string;\n};\n\nexport class BaseSegment {\n  private _byteRange: [number, number] | null = null;\n  private _url: string | null = null;\n  private _stats: LoadStats | null = null;\n  private _streams: ElementaryStreams | null = null;\n\n  // baseurl is the URL to the playlist\n  public readonly base: Base;\n\n  // relurl is the portion of the URL that comes from inside the playlist.\n  public relurl?: string;\n\n  constructor(base: Base | string) {\n    if (typeof base === 'string') {\n      base = { url: base };\n    }\n    this.base = base;\n    makeEnumerable(this, 'stats');\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value: string, previous?: BaseSegment) {\n    const params = value.split('@', 2);\n    let start: number;\n    if (params.length === 1) {\n      start = previous?.byteRangeEndOffset || 0;\n    } else {\n      start = parseInt(params[1]);\n    }\n    this._byteRange = [start, parseInt(params[0]) + start];\n  }\n\n  get baseurl(): string {\n    return this.base.url;\n  }\n\n  get byteRange(): [number, number] | [] {\n    if (this._byteRange === null) {\n      return [];\n    }\n\n    return this._byteRange;\n  }\n\n  get byteRangeStartOffset(): number | undefined {\n    return this.byteRange[0];\n  }\n\n  get byteRangeEndOffset(): number | undefined {\n    return this.byteRange[1];\n  }\n\n  get elementaryStreams(): ElementaryStreams {\n    if (this._streams === null) {\n      this._streams = {\n        [ElementaryStreamTypes.AUDIO]: null,\n        [ElementaryStreamTypes.VIDEO]: null,\n        [ElementaryStreamTypes.AUDIOVIDEO]: null,\n      };\n    }\n    return this._streams;\n  }\n\n  set elementaryStreams(value: ElementaryStreams) {\n    this._streams = value;\n  }\n\n  get hasStats(): boolean {\n    return this._stats !== null;\n  }\n\n  get hasStreams(): boolean {\n    return this._streams !== null;\n  }\n\n  get stats(): LoadStats {\n    if (this._stats === null) {\n      this._stats = new LoadStats();\n    }\n    return this._stats;\n  }\n\n  set stats(value: LoadStats) {\n    this._stats = value;\n  }\n\n  get url(): string {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true,\n      });\n    }\n    return this._url || '';\n  }\n\n  set url(value: string) {\n    this._url = value;\n  }\n\n  clearElementaryStreamInfo() {\n    const { elementaryStreams } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\n\nexport interface MediaFragment extends Fragment {\n  sn: number;\n  ref: MediaFragmentRef;\n}\n\nexport type MediaFragmentRef = {\n  base: Base;\n  start: number;\n  duration: number;\n  sn: number;\n  programDateTime: number | null;\n};\n\nexport function isMediaFragment(frag: Fragment): frag is MediaFragment {\n  return frag.sn !== 'initSegment';\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nexport class Fragment extends BaseSegment {\n  private _decryptdata: LevelKey | null = null;\n  private _programDateTime: number | null = null;\n  private _ref: MediaFragmentRef | null = null;\n  // Approximate bit rate of the fragment expressed in bits per second (bps) as indicated by the last EXT-X-BITRATE (kbps) tag\n  private _bitrate?: number;\n\n  public rawProgramDateTime: string | null = null;\n  public tagList: Array<string[]> = [];\n\n  // EXTINF has to be present for a m3u8 to be considered valid\n  public duration: number = 0;\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n  public sn: number | 'initSegment' = 0;\n  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n  public levelkeys?: { [key: string]: LevelKey | undefined };\n  // A string representing the fragment type\n  public readonly type: PlaylistLevelType;\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n  public loader: Loader<FragmentLoaderContext> | null = null;\n  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n  public keyLoader: Loader<KeyLoaderContext> | null = null;\n  // The level/track index to which the fragment belongs\n  public level: number = -1;\n  // The continuity counter of the fragment\n  public cc: number = 0;\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  public startPTS?: number;\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  public endPTS?: number;\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  public startDTS?: number;\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  public endDTS?: number;\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n  public start: number = 0;\n  // The offset time (seconds) of the fragment from the start of the Playlist\n  public playlistOffset: number = 0;\n  // Set by `updateFragPTSDTS` in level-helper\n  public deltaPTS?: number;\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  public maxStartPTS?: number;\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  public minEndPTS?: number;\n  // Init Segment bytes (unset for media segments)\n  public data?: Uint8Array;\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n  public bitrateTest: boolean = false;\n  // #EXTINF  segment title\n  public title: string | null = null;\n  // The Media Initialization Section for this segment\n  public initSegment: Fragment | null = null;\n  // Fragment is the last fragment in the media playlist\n  public endList?: boolean;\n  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n  public gap?: boolean;\n  // Deprecated\n  public urlId: number = 0;\n\n  constructor(type: PlaylistLevelType, base: Base | string) {\n    super(base);\n    this.type = type;\n  }\n\n  get byteLength(): number | null {\n    if (this.hasStats) {\n      const total = this.stats.total;\n      if (total) {\n        return total;\n      }\n    }\n    if (this.byteRange.length) {\n      const start = this.byteRange[0];\n      const end = this.byteRange[1];\n      if (Number.isFinite(start) && Number.isFinite(end)) {\n        return (end as number) - (start as number);\n      }\n    }\n    return null;\n  }\n\n  get bitrate(): number | null {\n    if (this.byteLength) {\n      return (this.byteLength * 8) / this.duration;\n    }\n    if (this._bitrate) {\n      return this._bitrate;\n    }\n    return null;\n  }\n\n  set bitrate(value: number) {\n    this._bitrate = value;\n  }\n\n  get decryptdata(): LevelKey | null {\n    const { levelkeys } = this;\n\n    if (!levelkeys || levelkeys.NONE) {\n      return null;\n    }\n\n    if (levelkeys.identity) {\n      if (!this._decryptdata) {\n        this._decryptdata = levelkeys.identity.getDecryptData(this.sn);\n      }\n    } else if (!this._decryptdata?.keyId) {\n      const keyFormats = Object.keys(levelkeys);\n      if (keyFormats.length === 1) {\n        const levelKey = (this._decryptdata = levelkeys[keyFormats[0]] || null);\n        if (levelKey) {\n          this._decryptdata = levelKey.getDecryptData(this.sn, levelkeys);\n        }\n      } else {\n        // Multiple keys. key-loader to call Fragment.setKeyFormat based on selected key-system.\n      }\n    }\n\n    return this._decryptdata;\n  }\n\n  get end(): number {\n    return this.start + this.duration;\n  }\n\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n\n    const duration = !Number.isFinite(this.duration) ? 0 : this.duration;\n\n    return this.programDateTime + duration * 1000;\n  }\n\n  get encrypted() {\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if (this._decryptdata?.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || (len === 1 && this.levelkeys[keyFormats[0]]?.encrypted)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get programDateTime(): number | null {\n    if (this._programDateTime === null && this.rawProgramDateTime) {\n      this.programDateTime = Date.parse(this.rawProgramDateTime);\n    }\n    return this._programDateTime;\n  }\n\n  set programDateTime(value: number | null) {\n    if (!Number.isFinite(value)) {\n      this._programDateTime = this.rawProgramDateTime = null;\n      return;\n    }\n    this._programDateTime = value;\n  }\n\n  get ref(): MediaFragmentRef | null {\n    if (!isMediaFragment(this)) {\n      return null;\n    }\n    if (!this._ref) {\n      this._ref = {\n        base: this.base,\n        start: this.start,\n        duration: this.duration,\n        sn: this.sn,\n        programDateTime: this.programDateTime,\n      };\n    }\n    return this._ref;\n  }\n\n  addStart(value: number) {\n    this.setStart(this.start + value);\n  }\n\n  setStart(value: number) {\n    this.start = value;\n    if (this._ref) {\n      this._ref.start = value;\n    }\n  }\n\n  setDuration(value: number) {\n    this.duration = value;\n    if (this._ref) {\n      this._ref.duration = value;\n    }\n  }\n\n  setKeyFormat(keyFormat: KeySystemFormats) {\n    const levelkeys = this.levelkeys;\n    if (levelkeys) {\n      const key = levelkeys[keyFormat];\n      if (key && !this._decryptdata?.keyId) {\n        this._decryptdata = key.getDecryptData(this.sn, levelkeys);\n      }\n    }\n  }\n\n  abortRequests(): void {\n    this.loader?.abort();\n    this.keyLoader?.abort();\n  }\n\n  setElementaryStreamInfo(\n    type: ElementaryStreamTypes,\n    startPTS: number,\n    endPTS: number,\n    startDTS: number,\n    endDTS: number,\n    partial: boolean = false,\n  ) {\n    const { elementaryStreams } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial,\n      };\n      return;\n    }\n\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nexport class Part extends BaseSegment {\n  public readonly fragOffset: number = 0;\n  public readonly duration: number = 0;\n  public readonly gap: boolean = false;\n  public readonly independent: boolean = false;\n  public readonly relurl: string;\n  public readonly fragment: MediaFragment;\n  public readonly index: number;\n\n  constructor(\n    partAttrs: AttrList,\n    frag: MediaFragment,\n    base: Base | string,\n    index: number,\n    previous?: Part,\n  ) {\n    super(base);\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI') as string;\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n\n  get start(): number {\n    return this.fragment.start + this.fragOffset;\n  }\n\n  get end(): number {\n    return this.start + this.duration;\n  }\n\n  get loaded(): boolean {\n    const { elementaryStreams } = this;\n    return !!(\n      elementaryStreams.audio ||\n      elementaryStreams.video ||\n      elementaryStreams.audiovideo\n    );\n  }\n}\n\nfunction getOwnPropertyDescriptorFromPrototypeChain(\n  object: Object | undefined,\n  property: string,\n) {\n  const prototype = Object.getPrototypeOf(object);\n  if (prototype) {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(\n      prototype,\n      property,\n    );\n    if (propertyDescriptor) {\n      return propertyDescriptor;\n    }\n    return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);\n  }\n}\n\nfunction makeEnumerable(object: Object, property: string) {\n  const d = getOwnPropertyDescriptorFromPrototypeChain(object, property);\n  if (d) {\n    d.enumerable = true;\n    Object.defineProperty(object, property, d);\n  }\n}\n","import { utf8ArrayToStr } from '@svta/common-media-library/utils/utf8ArrayToStr';\nimport { arrayToHex } from './hex';\nimport { ElementaryStreamTypes } from '../loader/fragment';\nimport { logger } from '../utils/logger';\nimport type { KeySystemIds } from './mediakeys-helper';\nimport type { DecryptData } from '../loader/level-key';\nimport type { PassthroughTrack, UserdataSample } from '../types/demuxer';\nimport type { ILogger } from '../utils/logger';\n\ntype BoxDataOrUndefined = Uint8Array<ArrayBuffer> | undefined;\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nexport const RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4,\n};\n\nexport function bin2str(data: Uint8Array): string {\n  return String.fromCharCode.apply(null, data);\n}\n\nexport function readUint16(buffer: Uint8Array, offset: number): number {\n  const val = (buffer[offset] << 8) | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\n\nexport function readUint32(buffer: Uint8Array, offset: number): number {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\n\nexport function readUint64(buffer: Uint8Array, offset: number) {\n  let result = readUint32(buffer, offset);\n  result *= Math.pow(2, 32);\n  result += readUint32(buffer, offset + 4);\n  return result;\n}\n\nexport function readSint32(buffer: Uint8Array, offset: number): number {\n  return (\n    (buffer[offset] << 24) |\n    (buffer[offset + 1] << 16) |\n    (buffer[offset + 2] << 8) |\n    buffer[offset + 3]\n  );\n}\n\nexport function writeUint32(buffer: Uint8Array, offset: number, value: number) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = (value >> 16) & 0xff;\n  buffer[offset + 2] = (value >> 8) & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find \"moof\" box\nexport function hasMoofData(data: Uint8Array): boolean {\n  const end = data.byteLength;\n  for (let i = 0; i < end; ) {\n    const size = readUint32(data, i);\n    if (\n      size > 8 &&\n      data[i + 4] === 0x6d &&\n      data[i + 5] === 0x6f &&\n      data[i + 6] === 0x6f &&\n      data[i + 7] === 0x66\n    ) {\n      return true;\n    }\n    i = size > 1 ? i + size : end;\n  }\n  return false;\n}\n\n// Find the data for a box specified by its path\nexport function findBox(data: Uint8Array, path: string[]): Uint8Array[] {\n  const results = [] as Uint8Array[];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n\n  for (let i = 0; i < end; ) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\n\ntype SidxInfo = {\n  earliestPresentationTime: number;\n  timescale: number;\n  version: number;\n  referencesCount: number;\n  references: any[];\n};\n\nfunction parseSegmentIndex(sidx: Uint8Array): SidxInfo | null {\n  const references: any[] = [];\n\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n\n  const timescale = readUint32(sidx, index);\n  index += 4;\n\n  let earliestPresentationTime = 0;\n  let firstOffset = 0;\n\n  if (version === 0) {\n    earliestPresentationTime = readUint32(sidx, index);\n    firstOffset = readUint32(sidx, index + 4);\n    index += 8;\n  } else {\n    earliestPresentationTime = readUint64(sidx, index);\n    firstOffset = readUint64(sidx, index + 8);\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n\n  let startByte = sidx.length + firstOffset;\n\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n\n    references.push({\n      referenceSize,\n      subsegmentDuration, // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1,\n      },\n    });\n\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references,\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nexport interface InitDataTrack {\n  timescale: number;\n  id: number;\n  codec: string;\n  encrypted: boolean;\n  supplemental: string | undefined;\n}\n\ntype HdlrMetadata = 'meta';\ntype HdlrType =\n  | ElementaryStreamTypes.AUDIO\n  | ElementaryStreamTypes.VIDEO\n  | HdlrMetadata;\n\ntype StsdData = {\n  codec: string;\n  encrypted: boolean;\n  supplemental: string | undefined;\n};\n\nexport interface InitData extends Array<any> {\n  [index: number]:\n    | {\n        timescale: number;\n        type: HdlrType;\n        stsd: StsdData;\n        default?: {\n          duration: number;\n          flags: number;\n        };\n      }\n    | undefined;\n  audio?: InitDataTrack;\n  video?: InitDataTrack;\n  caption?: InitDataTrack;\n}\n\nexport function parseInitSegment(initSegment: Uint8Array): InitData {\n  const result: InitData = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd as any) {\n      let version = tkhd[0];\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd as any) {\n        version = mdhd[0];\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr as any) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type: HdlrType | undefined = {\n            soun: ElementaryStreamTypes.AUDIO as const,\n            vide: ElementaryStreamTypes.VIDEO as const,\n          }[hdlrType];\n          // Parse codec details\n          const stsdBox = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n          const stsd = parseStsd(stsdBox);\n          if (type) {\n            // Add 'audio', 'video', and 'audiovideo' track records that will map to SourceBuffers\n            result[trackId] = { timescale, type, stsd };\n            result[type] = { timescale, id: trackId, ...stsd };\n          } else {\n            // Add 'meta' and other track records\n            result[trackId] = {\n              timescale,\n              type: hdlrType as HdlrType,\n              stsd,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach((trex) => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20),\n      };\n    }\n  });\n\n  return result;\n}\n\nfunction parseStsd(stsd: Uint8Array): StsdData {\n  const sampleEntries = stsd.subarray(8);\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\n  let codec = fourCC;\n  let supplemental;\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\n  if (encrypted) {\n    const encBox = findBox(sampleEntries, [fourCC])[0];\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n    const sinfs = findBox(encBoxChildren, ['sinf']);\n    sinfs.forEach((sinf) => {\n      const schm = findBox(sinf, ['schm'])[0];\n      if (schm as any) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          const frma = findBox(sinf, ['frma'])[0];\n          if (frma as any) {\n            // for encrypted content codec fourCC will be in frma\n            codec = bin2str(frma);\n          }\n        }\n      }\n    });\n  }\n  const codecFourCC = codec;\n  switch (codec) {\n    case 'avc1':\n    case 'avc2':\n    case 'avc3':\n    case 'avc4': {\n      // extract profile + compatibility + level out of avcC box\n      const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n      if ((avcCBox as any) && avcCBox.length > 3) {\n        codec +=\n          '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n        supplemental = parseSupplementalDoViCodec(\n          codecFourCC === 'avc1' ? 'dva1' : 'dvav',\n          sampleEntriesEnd,\n        );\n      }\n      break;\n    }\n    case 'mp4a': {\n      const codecBox = findBox(sampleEntries, [fourCC])[0];\n      const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n      if ((esdsBox as any) && esdsBox.length > 7) {\n        let i = 4;\n        // ES Descriptor tag\n        if (esdsBox[i++] !== 0x03) {\n          break;\n        }\n        i = skipBERInteger(esdsBox, i);\n        i += 2; // skip es_id;\n        const flags = esdsBox[i++];\n        if (flags & 0x80) {\n          i += 2; // skip dependency es_id\n        }\n        if (flags & 0x40) {\n          i += esdsBox[i++]; // skip URL\n        }\n        // Decoder config descriptor\n        if (esdsBox[i++] !== 0x04) {\n          break;\n        }\n        i = skipBERInteger(esdsBox, i);\n        const objectType = esdsBox[i++];\n        if (objectType === 0x40) {\n          codec += '.' + toHex(objectType);\n        } else {\n          break;\n        }\n        i += 12;\n        // Decoder specific info\n        if (esdsBox[i++] !== 0x05) {\n          break;\n        }\n        i = skipBERInteger(esdsBox, i);\n        const firstByte = esdsBox[i++];\n        let audioObjectType = (firstByte & 0xf8) >> 3;\n        if (audioObjectType === 31) {\n          audioObjectType +=\n            1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n        }\n        codec += '.' + audioObjectType;\n      }\n      break;\n    }\n    case 'hvc1':\n    case 'hev1': {\n      const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n      if ((hvcCBox as any) && hvcCBox.length > 12) {\n        const profileByte = hvcCBox[1];\n        const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n        const generalProfileIdc = profileByte & 0x1f;\n        const profileCompat = readUint32(hvcCBox, 2);\n        const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n        const levelIDC = hvcCBox[12];\n        const constraintIndicator = hvcCBox.subarray(6, 12);\n        codec += '.' + profileSpace + generalProfileIdc;\n        codec +=\n          '.' + reverse32BitInt(profileCompat).toString(16).toUpperCase();\n        codec += '.' + tierFlag + levelIDC;\n        let constraintString = '';\n        for (let i = constraintIndicator.length; i--; ) {\n          const byte = constraintIndicator[i];\n          if (byte || constraintString) {\n            const encodedByte = byte.toString(16).toUpperCase();\n            constraintString = '.' + encodedByte + constraintString;\n          }\n        }\n        codec += constraintString;\n      }\n      supplemental = parseSupplementalDoViCodec(\n        codecFourCC == 'hev1' ? 'dvhe' : 'dvh1',\n        sampleEntriesEnd,\n      );\n      break;\n    }\n    case 'dvh1':\n    case 'dvhe':\n    case 'dvav':\n    case 'dva1':\n    case 'dav1': {\n      codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;\n      break;\n    }\n    case 'vp09': {\n      const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n      if ((vpcCBox as any) && vpcCBox.length > 6) {\n        const profile = vpcCBox[4];\n        const level = vpcCBox[5];\n        const bitDepth = (vpcCBox[6] >> 4) & 0x0f;\n        codec +=\n          '.' +\n          addLeadingZero(profile) +\n          '.' +\n          addLeadingZero(level) +\n          '.' +\n          addLeadingZero(bitDepth);\n      }\n      break;\n    }\n    case 'av01': {\n      const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n      if ((av1CBox as any) && av1CBox.length > 2) {\n        const profile = av1CBox[1] >>> 5;\n        const level = av1CBox[1] & 0x1f;\n        const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n        const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n        const twelveBit = (av1CBox[2] & 0x20) >> 5;\n        const bitDepth =\n          profile === 2 && highBitDepth\n            ? twelveBit\n              ? 12\n              : 10\n            : highBitDepth\n              ? 10\n              : 8;\n        const monochrome = (av1CBox[2] & 0x10) >> 4;\n        const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n        const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n        const chromaSamplePosition = av1CBox[2] & 0x03;\n        // TODO: parse color_description_present_flag\n        // default it to BT.709/limited range for now\n        // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n        const colorPrimaries = 1;\n        const transferCharacteristics = 1;\n        const matrixCoefficients = 1;\n        const videoFullRangeFlag = 0;\n        codec +=\n          '.' +\n          profile +\n          '.' +\n          addLeadingZero(level) +\n          tierFlag +\n          '.' +\n          addLeadingZero(bitDepth) +\n          '.' +\n          monochrome +\n          '.' +\n          chromaSubsamplingX +\n          chromaSubsamplingY +\n          chromaSamplePosition +\n          '.' +\n          addLeadingZero(colorPrimaries) +\n          '.' +\n          addLeadingZero(transferCharacteristics) +\n          '.' +\n          addLeadingZero(matrixCoefficients) +\n          '.' +\n          videoFullRangeFlag;\n        supplemental = parseSupplementalDoViCodec('dav1', sampleEntriesEnd);\n      }\n      break;\n    }\n    case 'ac-3':\n    case 'ec-3':\n    case 'alac':\n    case 'fLaC':\n    case 'Opus':\n    default:\n      break;\n  }\n  return { codec, encrypted, supplemental };\n}\n\nfunction parseSupplementalDoViCodec(\n  fourCC: string,\n  sampleEntriesEnd: Uint8Array,\n): string | undefined {\n  const dvvCResult = findBox(sampleEntriesEnd, ['dvvC']); // used by DoVi Profile 8 to 10\n  const dvXCBox = dvvCResult.length\n    ? dvvCResult[0]\n    : findBox(sampleEntriesEnd, ['dvcC'])[0]; // used by DoVi Profiles up to 7 and 20\n  if (dvXCBox as any) {\n    const doViProfile = (dvXCBox[2] >> 1) & 0x7f;\n    const doViLevel = ((dvXCBox[2] << 5) & 0x20) | ((dvXCBox[3] >> 3) & 0x1f);\n    return (\n      fourCC +\n      '.' +\n      addLeadingZero(doViProfile) +\n      '.' +\n      addLeadingZero(doViLevel)\n    );\n  }\n}\n\nfunction reverse32BitInt(val: number) {\n  let result = 0;\n  for (let i = 0; i < 32; i++) {\n    result |= ((val >> i) & 1) << (32 - 1 - i);\n  }\n  return result >>> 0;\n}\n\nfunction skipBERInteger(bytes: Uint8Array, i: number): number {\n  const limit = i + 5;\n  while (bytes[i++] & 0x80 && i < limit) {\n    /* do nothing */\n  }\n  return i;\n}\n\nfunction toHex(x: number): string {\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\n}\n\nfunction addLeadingZero(num: number): string {\n  return (num < 10 ? '0' : '') + num;\n}\n\nexport function patchEncyptionData(\n  initSegment: Uint8Array<ArrayBuffer> | undefined,\n  decryptdata: DecryptData | null,\n) {\n  if (!initSegment || !decryptdata) {\n    return;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    applyToTencBoxes(initSegment, (tenc, isAudio) => {\n      // Look for default key id (keyID offset is always 8 within the tenc box):\n      const tencKeyId = tenc.subarray(8, 24);\n      if (!tencKeyId.some((b) => b !== 0)) {\n        logger.log(\n          `[eme] Patching keyId in 'enc${\n            isAudio ? 'a' : 'v'\n          }>sinf>>tenc' box: ${arrayToHex(tencKeyId)} -> ${arrayToHex(keyId)}`,\n        );\n        tenc.set(keyId, 8);\n      }\n    });\n  }\n}\n\nexport function parseKeyIdsFromTenc(\n  initSegment: Uint8Array<ArrayBuffer>,\n): Uint8Array<ArrayBuffer>[] {\n  const keyIds: Uint8Array<ArrayBuffer>[] = [];\n  applyToTencBoxes(initSegment, (tenc) => keyIds.push(tenc.subarray(8, 24)));\n  return keyIds;\n}\n\nfunction applyToTencBoxes(\n  initSegment: Uint8Array<ArrayBuffer>,\n  predicate: (tenc: Uint8Array<ArrayBuffer>, isAudio: boolean) => void,\n) {\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  traks.forEach((trak) => {\n    const stsd = findBox(trak, [\n      'mdia',\n      'minf',\n      'stbl',\n      'stsd',\n    ])[0] as BoxDataOrUndefined;\n    if (!stsd) return;\n    const sampleEntries = stsd.subarray(8);\n    let encBoxes = findBox(sampleEntries, ['enca']);\n    const isAudio = encBoxes.length > 0;\n    if (!isAudio) {\n      encBoxes = findBox(sampleEntries, ['encv']);\n    }\n    encBoxes.forEach((enc) => {\n      const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n      const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n      sinfBoxes.forEach((sinf) => {\n        const tenc = parseSinf(sinf);\n        if (tenc) {\n          predicate(tenc, isAudio);\n        }\n      });\n    });\n  });\n}\n\nexport function parseSinf(sinf: Uint8Array): BoxDataOrUndefined {\n  const schm = findBox(sinf, ['schm'])[0] as BoxDataOrUndefined;\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      const tenc = findBox(sinf, ['schi', 'tenc'])[0] as BoxDataOrUndefined;\n      if (tenc) {\n        return tenc;\n      }\n    } else if (scheme === 'cbc2') {\n      /* no-op */\n    }\n  }\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(‘tfhd’, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nexport type TrackTimes = {\n  duration: number;\n  keyFrameIndex?: number;\n  keyFrameStart?: number;\n  start: number;\n  sampleCount: number;\n  timescale: number;\n  type: HdlrType;\n};\n\nexport function getSampleData(\n  data: Uint8Array,\n  initData: InitData,\n  logger: ILogger,\n): Record<number, TrackTimes> {\n  const tracks: Record<number, TrackTimes> = {};\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    (tracks[id] as any) ||= {\n      start: NaN,\n      duration: 0,\n      sampleCount: 0,\n      timescale: track.timescale,\n      type: track.type,\n    };\n    const trackTimes: TrackTimes = tracks[id];\n    // get start DTS\n    const tfdt = findBox(traf, ['tfdt'])[0];\n\n    if (tfdt as any) {\n      const version = tfdt[0];\n      let baseTime = readUint32(tfdt, 4);\n      if (version === 1) {\n        // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n        // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n        // https://github.com/video-dev/hls.js/issues/5303\n        if (baseTime === UINT32_MAX) {\n          logger.warn(\n            `[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`,\n          );\n        } else {\n          baseTime *= UINT32_MAX + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n      }\n      if (\n        Number.isFinite(baseTime) &&\n        (!Number.isFinite(trackTimes.start) || baseTime < trackTimes.start)\n      ) {\n        trackTimes.start = baseTime;\n      }\n    }\n\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | trackDefault?.flags!;\n    let defaultSampleDuration: number = trackDefault?.duration || 0;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        defaultSampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        defaultSampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    const truns = findBox(traf, ['trun']);\n    let sampleDTS = trackTimes.start || 0;\n    let rawDuration = 0;\n    let sampleDuration = defaultSampleDuration;\n    for (let j = 0; j < truns.length; j++) {\n      const trun = truns[j];\n      const sampleCount = readUint32(trun, 4);\n      const sampleIndex = trackTimes.sampleCount;\n      trackTimes.sampleCount += sampleCount;\n      // Get duration from samples\n      const dataOffsetPresent = trun[3] & 0x01;\n      const firstSampleFlagsPresent = trun[3] & 0x04;\n      const sampleDurationPresent = trun[2] & 0x01;\n      const sampleSizePresent = trun[2] & 0x02;\n      const sampleFlagsPresent = trun[2] & 0x04;\n      const sampleCompositionTimeOffsetPresent = trun[2] & 0x08;\n      let offset = 8;\n      let remaining = sampleCount;\n      if (dataOffsetPresent) {\n        offset += 4;\n      }\n      if (firstSampleFlagsPresent && sampleCount) {\n        const isNonSyncSample = trun[offset + 1] & 0x01;\n        if (!isNonSyncSample && trackTimes.keyFrameIndex === undefined) {\n          trackTimes.keyFrameIndex = sampleIndex;\n        }\n        offset += 4;\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n        remaining--;\n      }\n      while (remaining--) {\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          const isNonSyncSample = trun[offset + 1] & 0x01;\n          if (!isNonSyncSample) {\n            if (trackTimes.keyFrameIndex === undefined) {\n              trackTimes.keyFrameIndex =\n                trackTimes.sampleCount - (remaining + 1);\n              trackTimes.keyFrameStart = sampleDTS;\n            }\n          }\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n      }\n      if (!rawDuration && defaultSampleDuration) {\n        rawDuration += defaultSampleDuration * sampleCount;\n      }\n    }\n    trackTimes.duration += rawDuration;\n  }\n  if (!Object.keys(tracks).some((trackId) => tracks[trackId].duration)) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxMinStart = Infinity;\n    let sidxMaxEnd = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx?.references) {\n        sidxMinStart = Math.min(\n          sidxMinStart,\n          sidx.earliestPresentationTime / sidx.timescale,\n        );\n        const subSegmentDuration = sidx.references.reduce(\n          (dur, ref) => dur + ref.info.duration || 0,\n          0,\n        );\n        sidxMaxEnd = Math.max(\n          sidxMaxEnd,\n          subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale,\n        );\n      }\n    }\n    if (sidxMaxEnd && Number.isFinite(sidxMaxEnd)) {\n      Object.keys(tracks).forEach((trackId) => {\n        if (!tracks[trackId].duration) {\n          tracks[trackId].duration =\n            sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;\n        }\n      });\n    }\n  }\n  return tracks;\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nexport function segmentValidRange(\n  data: Uint8Array<ArrayBuffer>,\n): SegmentedRange {\n  const segmentedRange: SegmentedRange = {\n    valid: null,\n    remainder: null,\n  };\n\n  const moofs = findBox(data, ['moof']);\n  if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = data.slice(0, last.byteOffset - 8);\n  segmentedRange.remainder = data.slice(last.byteOffset - 8);\n  return segmentedRange;\n}\n\nexport interface SegmentedRange {\n  valid: Uint8Array<ArrayBuffer> | null;\n  remainder: Uint8Array<ArrayBuffer> | null;\n}\n\nexport function appendUint8Array(data1: Uint8Array, data2: Uint8Array) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\n\nexport interface IEmsgParsingData {\n  schemeIdUri: string;\n  value: string;\n  timeScale: number;\n  presentationTimeDelta?: number;\n  presentationTime?: number;\n  eventDuration: number;\n  id: number;\n  payload: Uint8Array;\n}\n\nexport function parseSamples(\n  timeOffset: number,\n  track: PassthroughTrack,\n): UserdataSample[] {\n  const seiSamples = [] as UserdataSample[];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map((moof) => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map((traf) => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map((tfdt) => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n\n      if ((baseTime as any) !== undefined) {\n        timeOffset = baseTime;\n      }\n\n      return findBox(traf, ['tfhd']).map((tfhd) => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n\n          findBox(traf, ['trun']).map((trun) => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n\n            let sampleOffset = dataOffset + moofOffset;\n\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(\n                      sampleOffset,\n                      sampleOffset + naluSize,\n                    );\n                    parseSEIMessageFromNALu(\n                      data,\n                      isHEVCFlavor ? 2 : 1,\n                      timeOffset + compositionOffset / timescale,\n                      seiSamples,\n                    );\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\n\nexport function isHEVC(codec: string | undefined) {\n  if (!codec) {\n    return false;\n  }\n  const baseCodec = codec.substring(0, 4);\n  return (\n    baseCodec === 'hvc1' ||\n    baseCodec === 'hev1' ||\n    // Dolby Vision\n    baseCodec === 'dvh1' ||\n    baseCodec === 'dvhe'\n  );\n}\n\nfunction isSEIMessage(isHEVCFlavor: boolean, naluHeader: number) {\n  if (isHEVCFlavor) {\n    const naluType = (naluHeader >> 1) & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\n\nexport function parseSEIMessageFromNALu(\n  unescapedData: Uint8Array,\n  headerSize: number,\n  pts: number,\n  samples: UserdataSample[],\n) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let b = 0;\n\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n\n    const leftOver = data.length - seiPtr;\n    // Create a variable to process the payload\n    let payPtr = seiPtr;\n\n    // Increment the seiPtr to the end of the payload\n    if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      // Some type of corruption has happened?\n      logger.error(\n        `Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`,\n      );\n      // We might be able to parse some data, but let's be safe and ignore it.\n      break;\n    }\n\n    if (payloadType === 4) {\n      const countryCode = data[payPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, payPtr);\n        payPtr += 2;\n\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, payPtr);\n          payPtr += 4;\n\n          if (userStructure === 0x47413934) {\n            const userDataType = data[payPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[payPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[payPtr++];\n                }\n              }\n\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray,\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5) {\n      if (payloadSize > 16) {\n        const uuidStrArray: Array<string> = [];\n        for (let i = 0; i < 16; i++) {\n          const b = data[payPtr++].toString(16);\n          uuidStrArray.push(b.length == 1 ? '0' + b : b);\n\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[payPtr++];\n        }\n\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes,\n        });\n      }\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nexport function discardEPB(data: Uint8Array): Uint8Array {\n  const length = data.byteLength;\n  const EPBPositions = [] as Array<number>;\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\n\nexport function parseEmsg(data: Uint8Array): IEmsgParsingData {\n  const version = data[0];\n  let schemeIdUri: string = '';\n  let value: string = '';\n  let timeScale: number = 0;\n  let presentationTimeDelta: number = 0;\n  let presentationTime: number = 0;\n  let eventDuration: number = 0;\n  let id: number = 0;\n  let offset: number = 0;\n\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn(\n        'Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box',\n      );\n    }\n\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload,\n  };\n}\n\nexport function mp4Box(type: ArrayLike<number>, ...payload: Uint8Array[]) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = (size >> 24) & 0xff;\n  result[1] = (size >> 16) & 0xff;\n  result[2] = (size >> 8) & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\n\nexport function mp4pssh(\n  systemId: Uint8Array,\n  keyids: Array<Uint8Array> | null,\n  data: Uint8Array,\n) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (let ix = 0; ix < keyids.length; ix++) {\n      const k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids!.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids!.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box(\n    [112, 115, 115, 104],\n    new Uint8Array([\n      version,\n      0x00,\n      0x00,\n      0x00, // Flags\n    ]),\n    systemId, // 16 bytes\n    kidCount,\n    kids,\n    dataSize,\n    data,\n  );\n}\n\nexport type PsshData = {\n  version: 0 | 1;\n  systemId: KeySystemIds;\n  kids: null | Uint8Array<ArrayBuffer>[];\n  data: null | Uint8Array<ArrayBuffer>;\n  offset: number;\n  size: number;\n};\n\nexport type PsshInvalidResult = {\n  systemId?: undefined;\n  kids?: undefined;\n  offset: number;\n  size: number;\n};\n\nexport function parseMultiPssh(\n  initData: ArrayBuffer,\n): (PsshData | PsshInvalidResult)[] {\n  const results: (PsshData | PsshInvalidResult)[] = [];\n  if (initData instanceof ArrayBuffer) {\n    const length = initData.byteLength;\n    let offset = 0;\n    while (offset + 32 < length) {\n      const view = new DataView(initData, offset);\n      const pssh = parsePssh(view);\n      results.push(pssh);\n      offset += pssh.size;\n    }\n  }\n  return results;\n}\n\nfunction parsePssh(view: DataView<ArrayBuffer>): PsshData | PsshInvalidResult {\n  const size = view.getUint32(0);\n  const offset = view.byteOffset;\n  const length = view.byteLength;\n  if (length < size) {\n    return {\n      offset,\n      size: length,\n    };\n  }\n  const type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return { offset, size };\n  }\n  const version = view.getUint32(8) >>> 24;\n  if (version !== 0 && version !== 1) {\n    return { offset, size };\n  }\n  const buffer = view.buffer;\n  const systemId = arrayToHex(\n    new Uint8Array(buffer, offset + 12, 16),\n  ) as KeySystemIds;\n\n  let kids: null | Uint8Array<ArrayBuffer>[] = null;\n  let data: null | Uint8Array<ArrayBuffer> = null;\n  let dataSizeOffset = 0;\n\n  if (version === 0) {\n    dataSizeOffset = 28;\n  } else {\n    const kidCounts = view.getUint32(28);\n    if (!kidCounts || length < 32 + kidCounts * 16) {\n      return { offset, size };\n    }\n    kids = [];\n    for (let i = 0; i < kidCounts; i++) {\n      kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));\n    }\n    dataSizeOffset = 32 + kidCounts * 16;\n  }\n\n  if (!dataSizeOffset) {\n    return { offset, size };\n  }\n\n  const dataSizeOrKidCount = view.getUint32(dataSizeOffset);\n  if (size - 32 < dataSizeOrKidCount) {\n    return { offset, size };\n  }\n  data = new Uint8Array(\n    buffer,\n    offset + dataSizeOffset + 4,\n    dataSizeOrKidCount,\n  );\n  return {\n    version,\n    systemId,\n    kids,\n    data,\n    offset,\n    size,\n  };\n}\n","import type { DemuxedTrack } from '../types/demuxer';\n\nexport function dummyTrack(type = '', inputTimeScale = 90000): DemuxedTrack {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0,\n  };\n}\n","import { canParseId3 } from '@svta/common-media-library/id3/canParseId3';\nimport { getId3Data } from '@svta/common-media-library/id3/getId3Data';\nimport { getId3Timestamp } from '@svta/common-media-library/id3/getId3Timestamp';\nimport {\n  type AudioFrame,\n  type DemuxedAudioTrack,\n  type DemuxedMetadataTrack,\n  type DemuxedUserdataTrack,\n  type DemuxedVideoTrackBase,\n  type Demuxer,\n  type DemuxerResult,\n  type KeyData,\n  MetadataSchema,\n} from '../../types/demuxer';\nimport { appendUint8Array } from '../../utils/mp4-tools';\nimport { dummyTrack } from '../dummy-demuxed-track';\nimport type {\n  RationalTimestamp,\n  TimestampOffset,\n} from '../../utils/timescale-conversion';\n\nclass BaseAudioDemuxer implements Demuxer {\n  protected _audioTrack?: DemuxedAudioTrack;\n  protected _id3Track?: DemuxedMetadataTrack;\n  protected frameIndex: number = 0;\n  protected cachedData: Uint8Array | null = null;\n  protected basePTS: number | null = null;\n  protected initPTS: TimestampOffset | null = null;\n  protected lastPTS: number | null = null;\n\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  ) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n    };\n  }\n\n  resetTimeStamp(deaultTimestamp: TimestampOffset | null) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n\n  resetContiguity(): void {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n\n  canParse(data: Uint8Array, offset: number): boolean {\n    return false;\n  }\n\n  appendFrame(\n    track: DemuxedAudioTrack,\n    data: Uint8Array,\n    offset: number,\n  ): AudioFrame | void {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data: Uint8Array, timeOffset: number): DemuxerResult {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n\n    let id3Data: Uint8Array | undefined = getId3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack as DemuxedAudioTrack;\n    const id3Track = this._id3Track as DemuxedMetadataTrack;\n    const timestamp = id3Data ? getId3Timestamp(id3Data) : undefined;\n    const length = data.length;\n\n    if (\n      this.basePTS === null ||\n      (this.frameIndex === 0 && Number.isFinite(timestamp))\n    ) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY,\n      });\n    }\n\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParseId3(data, offset)) {\n        // after a canParse, a call to getId3Data *should* always returns some data\n        id3Data = getId3Data(data, offset)!;\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY,\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = data.slice(lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack() as DemuxedVideoTrackBase,\n      id3Track,\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\n    };\n  }\n\n  demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number,\n  ): Promise<DemuxerResult> {\n    return Promise.reject(\n      new Error(\n        `[${this}] This demuxer does not support Sample-AES decryption`,\n      ),\n    );\n  }\n\n  flush(timeOffset: number): DemuxerResult {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n\n    return {\n      audioTrack: this._audioTrack as DemuxedAudioTrack,\n      videoTrack: dummyTrack() as DemuxedVideoTrackBase,\n      id3Track: this._id3Track as DemuxedMetadataTrack,\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\n    };\n  }\n\n  destroy() {\n    this.cachedData = null;\n    // @ts-ignore\n    this._audioTrack = this._id3Track = undefined;\n  }\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nexport const initPTSFn = (\n  timestamp: number | undefined,\n  timeOffset: number,\n  initPTS: RationalTimestamp | null,\n): number => {\n  if (Number.isFinite(timestamp as number)) {\n    return timestamp! * 90;\n  }\n  const init90kHz = initPTS\n    ? (initPTS.baseTime * 90000) / initPTS.timescale\n    : 0;\n  return timeOffset * 90000 + init90kHz;\n};\nexport default BaseAudioDemuxer;\n","/**\n *  MPEG parser helper\n */\nimport type { DemuxedAudioTrack } from '../../types/demuxer';\n\nlet chromeVersion: number | null = null;\n\nconst BitratesMap = [\n  32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56,\n  64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80,\n  96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144,\n  160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144,\n  160,\n];\n\nconst SamplingRateMap = [\n  44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000,\n];\n\nconst SamplesCoefficients = [\n  // MPEG 2.5\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n  // Reserved\n  [\n    0, // Reserved\n    0, // Layer3\n    0, // Layer2\n    0, // Layer1\n  ],\n  // MPEG 2\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n  // MPEG 1\n  [\n    0, // Reserved\n    144, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n];\n\nconst BytesInSlot = [\n  0, // Reserved\n  1, // Layer3\n  1, // Layer2\n  4, // Layer1\n];\n\nexport function appendFrame(\n  track: DemuxedAudioTrack,\n  data: Uint8Array,\n  offset: number,\n  pts: number,\n  frameIndex: number,\n) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = (header.samplesPerFrame * 90000) / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp,\n    };\n\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n\n    return { sample, length: header.frameLength, missing: 0 };\n  }\n}\n\nexport function parseHeader(data: Uint8Array, offset: number) {\n  const mpegVersion = (data[offset + 1] >> 3) & 3;\n  const mpegLayer = (data[offset + 1] >> 1) & 3;\n  const bitRateIndex = (data[offset + 2] >> 4) & 15;\n  const sampleRateIndex = (data[offset + 2] >> 2) & 3;\n  if (\n    mpegVersion !== 1 &&\n    bitRateIndex !== 0 &&\n    bitRateIndex !== 15 &&\n    sampleRateIndex !== 3\n  ) {\n    const paddingBit = (data[offset + 2] >> 1) & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates =\n      mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate =\n      BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates =\n      mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate =\n      SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength =\n      Math.floor((sampleCoefficient * bitRate) / sampleRate + paddingBit) *\n      bytesInSlot;\n\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion && chromeVersion <= 87;\n\n    if (\n      needChromeFix &&\n      mpegLayer === 2 &&\n      bitRate >= 224000 &&\n      channelMode === 0\n    ) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n\n    return { sampleRate, channelCount, frameLength, samplesPerFrame };\n  }\n}\n\nexport function isHeaderPattern(data: Uint8Array, offset: number): boolean {\n  return (\n    data[offset] === 0xff &&\n    (data[offset + 1] & 0xe0) === 0xe0 &&\n    (data[offset + 1] & 0x06) !== 0x00\n  );\n}\n\nexport function isHeader(data: Uint8Array, offset: number): boolean {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\n\nexport function canParse(data: Uint8Array, offset: number): boolean {\n  const headerSize = 4;\n\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\n\nexport function probe(data: Uint8Array, offset: number): boolean {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header?.frameLength) {\n      frameLength = header.frameLength;\n    }\n\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n","/**\n * AAC demuxer\n */\nimport { getId3Data } from '@svta/common-media-library/id3/getId3Data';\nimport * as ADTS from './adts';\nimport BaseAudioDemuxer from './base-audio-demuxer';\nimport * as MpegAudio from './mpegaudio';\nimport type { HlsConfig } from '../../config';\nimport type { HlsEventEmitter } from '../../events';\nimport type { DemuxedAudioTrack } from '../../types/demuxer';\nimport type { ILogger } from '../../utils/logger';\n\nclass AACDemuxer extends BaseAudioDemuxer {\n  private readonly observer: HlsEventEmitter;\n  private readonly config: HlsConfig;\n\n  constructor(observer: HlsEventEmitter, config) {\n    super();\n    this.observer = observer;\n    this.config = config;\n  }\n\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  ) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0,\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data: Uint8Array | undefined, logger: ILogger): boolean {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getId3Data(data, 0);\n    let offset = id3Data?.length || 0;\n\n    if (MpegAudio.probe(data, offset)) {\n      return false;\n    }\n\n    for (let length = data.length; offset < length; offset++) {\n      if (ADTS.probe(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n\n  canParse(data, offset) {\n    return ADTS.canParse(data, offset);\n  }\n\n  appendFrame(track: DemuxedAudioTrack, data: Uint8Array, offset: number) {\n    ADTS.initTrackConfig(\n      track,\n      this.observer,\n      data,\n      offset,\n      track.manifestCodec,\n    );\n    const frame = ADTS.appendFrame(\n      track,\n      data,\n      offset,\n      this.basePTS as number,\n      this.frameIndex,\n    );\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nexport default AACDemuxer;\n","export const getAudioBSID = (data: Uint8Array, offset: number): number => {\n  // check the bsid to confirm ac-3 | ec-3\n  let bsid = 0;\n  let numBits = 5;\n  offset += numBits;\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n  while (numBits > 0) {\n    byte[0] = data[offset];\n    // read remaining bits, upto 8 bits at a time\n    const bits = Math.min(numBits, 8);\n    const shift = 8 - bits;\n    mask[0] = (0xff000000 >>> (24 + shift)) << shift;\n    temp[0] = (byte[0] & mask[0]) >> shift;\n    bsid = !bsid ? temp[0] : (bsid << bits) | temp[0];\n    offset += 1;\n    numBits -= bits;\n  }\n  return bsid;\n};\n","import { getId3Data } from '@svta/common-media-library/id3/getId3Data';\nimport { getId3Timestamp } from '@svta/common-media-library/id3/getId3Timestamp';\nimport BaseAudioDemuxer from './base-audio-demuxer';\nimport { getAudioBSID } from './dolby';\nimport type { HlsEventEmitter } from '../../events';\nimport type { AudioFrame, DemuxedAudioTrack } from '../../types/demuxer';\n\nexport class AC3Demuxer extends BaseAudioDemuxer {\n  private readonly observer: HlsEventEmitter;\n\n  constructor(observer: HlsEventEmitter) {\n    super();\n    this.observer = observer;\n  }\n\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  ) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/ac-3',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'ac3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0,\n    };\n  }\n\n  canParse(data: Uint8Array, offset: number): boolean {\n    return offset + 64 < data.length;\n  }\n\n  appendFrame(\n    track: DemuxedAudioTrack,\n    data: Uint8Array,\n    offset: number,\n  ): AudioFrame | void {\n    const frameLength = appendFrame(\n      track,\n      data,\n      offset,\n      this.basePTS as number,\n      this.frameIndex,\n    );\n    if (frameLength !== -1) {\n      const sample = track.samples[track.samples.length - 1];\n      return { sample, length: frameLength, missing: 0 };\n    }\n  }\n\n  static probe(data: Uint8Array | undefined): boolean {\n    if (!data) {\n      return false;\n    }\n\n    const id3Data = getId3Data(data, 0);\n    if (!id3Data) {\n      return false;\n    }\n\n    // look for the ac-3 sync bytes\n    const offset = id3Data.length;\n    if (\n      data[offset] === 0x0b &&\n      data[offset + 1] === 0x77 &&\n      getId3Timestamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3\n      getAudioBSID(data, offset) < 16\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport function appendFrame(\n  track: DemuxedAudioTrack,\n  data: Uint8Array,\n  start: number,\n  pts: number,\n  frameIndex: number,\n): number {\n  if (start + 8 > data.length) {\n    return -1; // not enough bytes left\n  }\n\n  if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n    return -1; // invalid magic\n  }\n\n  // get sample rate\n  const samplingRateCode = data[start + 4] >> 6;\n  if (samplingRateCode >= 3) {\n    return -1; // invalid sampling rate\n  }\n\n  const samplingRateMap = [48000, 44100, 32000];\n  const sampleRate = samplingRateMap[samplingRateCode];\n\n  // get frame size\n  const frameSizeCode = data[start + 4] & 0x3f;\n  const frameSizeMap = [\n    64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105,\n    144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174,\n    240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244,\n    336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417,\n    576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558,\n    768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975,\n    1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728,\n    1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920,\n  ];\n\n  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n  if (start + frameLength > data.length) {\n    return -1;\n  }\n\n  // get channel count\n  const channelMode = data[start + 6] >> 5;\n  let skipCount = 0;\n  if (channelMode === 2) {\n    skipCount += 2;\n  } else {\n    if (channelMode & 1 && channelMode !== 1) {\n      skipCount += 2;\n    }\n    if (channelMode & 4) {\n      skipCount += 2;\n    }\n  }\n\n  const lfeon =\n    (((data[start + 6] << 8) | data[start + 7]) >> (12 - skipCount)) & 1;\n\n  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n  const channelCount = channelsMap[channelMode] + lfeon;\n\n  // build dac3 box\n  const bsid = data[start + 5] >> 3;\n  const bsmod = data[start + 5] & 7;\n\n  const config = new Uint8Array([\n    (samplingRateCode << 6) | (bsid << 1) | (bsmod >> 2),\n    ((bsmod & 3) << 6) |\n      (channelMode << 3) |\n      (lfeon << 2) |\n      (frameSizeCode >> 4),\n    (frameSizeCode << 4) & 0xe0,\n  ]);\n\n  const frameDuration = (1536 / sampleRate) * 90000;\n  const stamp = pts + frameIndex * frameDuration;\n  const unit = data.subarray(start, start + frameLength);\n\n  track.config = config;\n  track.channelCount = channelCount;\n  track.samplerate = sampleRate;\n  track.samples.push({ unit, pts: stamp });\n\n  return frameLength;\n}\n","/**\n * MP3 demuxer\n */\nimport { getId3Data } from '@svta/common-media-library/id3/getId3Data';\nimport { getId3Timestamp } from '@svta/common-media-library/id3/getId3Timestamp';\nimport BaseAudioDemuxer from './base-audio-demuxer';\nimport { getAudioBSID } from './dolby';\nimport * as MpegAudio from './mpegaudio';\nimport { logger } from '../../utils/logger';\n\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  ) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0,\n    };\n  }\n\n  static probe(data: Uint8Array | undefined): boolean {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getId3Data(data, 0);\n    let offset = id3Data?.length || 0;\n\n    // Check for ac-3|ec-3 sync bytes and return false if present\n    if (\n      id3Data &&\n      data[offset] === 0x0b &&\n      data[offset + 1] === 0x77 &&\n      getId3Timestamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3 or ec-3 (not mp3)\n      getAudioBSID(data, offset) <= 16\n    ) {\n      return false;\n    }\n\n    for (let length = data.length; offset < length; offset++) {\n      if (MpegAudio.probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n\n  canParse(data, offset) {\n    return MpegAudio.canParse(data, offset);\n  }\n\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return MpegAudio.appendFrame(\n      track,\n      data,\n      offset,\n      this.basePTS,\n      this.frameIndex,\n    );\n  }\n}\n\nexport default MP3Demuxer;\n","export const enum DecrypterAesMode {\n  cbc = 0,\n  ctr = 1,\n}\n","import { DecrypterAesMode } from './decrypter-aes-mode';\n\nexport default class AESCrypto {\n  private subtle: SubtleCrypto;\n  private aesIV: Uint8Array;\n  private aesMode: DecrypterAesMode;\n\n  constructor(subtle: SubtleCrypto, iv: Uint8Array, aesMode: DecrypterAesMode) {\n    this.subtle = subtle;\n    this.aesIV = iv;\n    this.aesMode = aesMode;\n  }\n\n  decrypt(data: ArrayBuffer, key: CryptoKey) {\n    switch (this.aesMode) {\n      case DecrypterAesMode.cbc:\n        return this.subtle.decrypt(\n          { name: 'AES-CBC', iv: this.aesIV },\n          key,\n          data,\n        );\n      case DecrypterAesMode.ctr:\n        return this.subtle.decrypt(\n          { name: 'AES-CTR', counter: this.aesIV, length: 64 }, //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block\n          key,\n          data,\n        );\n      default:\n        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);\n    }\n  }\n}\n","// PKCS7\nexport function removePadding(array: Uint8Array<ArrayBuffer>) {\n  const outputBytes = array.byteLength;\n  const paddingBytes =\n    outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return array.slice(0, outputBytes - paddingBytes);\n  }\n  return array;\n}\n\nexport default class AESDecryptor {\n  private rcon: Array<number> = [\n    0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n  ];\n  private subMix: Array<Uint32Array> = [\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n  ];\n  private invSubMix: Array<Uint32Array> = [\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n  ];\n  private sBox: Uint32Array = new Uint32Array(256);\n  private invSBox: Uint32Array = new Uint32Array(256);\n  private key: Uint32Array = new Uint32Array(0);\n\n  private ksRows: number = 0;\n  private keySize: number = 0;\n  private keySchedule!: Uint32Array;\n  private invKeySchedule!: Uint32Array;\n\n  constructor() {\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n\n    return newArray;\n  }\n\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = (i << 1) ^ 0x11b;\n      }\n    }\n\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n      sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n      subMix0[x] = (t << 24) | (t >>> 8);\n      subMix1[x] = (t << 16) | (t >>> 16);\n      subMix2[x] = (t << 8) | (t >>> 24);\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n      invSubMix0[sx] = (t << 24) | (t >>> 8);\n      invSubMix1[sx] = (t << 16) | (t >>> 16);\n      invSubMix2[sx] = (t << 8) | (t >>> 24);\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n\n  expandKey(keyBuffer: ArrayBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n\n    if (sameKey) {\n      return;\n    }\n\n    this.key = key;\n    const keySize = (this.keySize = key.length);\n\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n\n    const ksRows = (this.ksRows = (keySize + 6 + 1) * 4);\n    let ksRow;\n    let invKsRow;\n\n    const keySchedule = (this.keySchedule = new Uint32Array(ksRows));\n    const invKeySchedule = (this.invKeySchedule = new Uint32Array(ksRows));\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    let prev;\n    let t;\n\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = (t << 8) | (t >>> 24);\n\n        // Sub word\n        t =\n          (sbox[t >>> 24] << 24) |\n          (sbox[(t >>> 16) & 0xff] << 16) |\n          (sbox[(t >>> 8) & 0xff] << 8) |\n          sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[(ksRow / keySize) | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t =\n          (sbox[t >>> 24] << 24) |\n          (sbox[(t >>> 16) & 0xff] << 16) |\n          (sbox[(t >>> 8) & 0xff] << 8) |\n          sbox[t & 0xff];\n      }\n\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] =\n          invSubMix0[sbox[t >>> 24]] ^\n          invSubMix1[sbox[(t >>> 16) & 0xff]] ^\n          invSubMix2[sbox[(t >>> 8) & 0xff]] ^\n          invSubMix3[sbox[t & 0xff]];\n      }\n\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return (\n      (word << 24) |\n      ((word & 0xff00) << 8) |\n      ((word & 0xff0000) >> 8) |\n      (word >>> 24)\n    );\n  }\n\n  decrypt(\n    inputArrayBuffer: ArrayBufferLike,\n    offset: number,\n    aesIV: ArrayBuffer,\n  ) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 =\n          invSubMix0[s0 >>> 24] ^\n          invSubMix1[(s1 >> 16) & 0xff] ^\n          invSubMix2[(s2 >> 8) & 0xff] ^\n          invSubMix3[s3 & 0xff] ^\n          invKeySchedule[ksRow];\n        t1 =\n          invSubMix0[s1 >>> 24] ^\n          invSubMix1[(s2 >> 16) & 0xff] ^\n          invSubMix2[(s3 >> 8) & 0xff] ^\n          invSubMix3[s0 & 0xff] ^\n          invKeySchedule[ksRow + 1];\n        t2 =\n          invSubMix0[s2 >>> 24] ^\n          invSubMix1[(s3 >> 16) & 0xff] ^\n          invSubMix2[(s0 >> 8) & 0xff] ^\n          invSubMix3[s1 & 0xff] ^\n          invKeySchedule[ksRow + 2];\n        t3 =\n          invSubMix0[s3 >>> 24] ^\n          invSubMix1[(s0 >> 16) & 0xff] ^\n          invSubMix2[(s1 >> 8) & 0xff] ^\n          invSubMix3[s2 & 0xff] ^\n          invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 =\n        (invSBOX[s0 >>> 24] << 24) ^\n        (invSBOX[(s1 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s2 >> 8) & 0xff] << 8) ^\n        invSBOX[s3 & 0xff] ^\n        invKeySchedule[ksRow];\n      t1 =\n        (invSBOX[s1 >>> 24] << 24) ^\n        (invSBOX[(s2 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s3 >> 8) & 0xff] << 8) ^\n        invSBOX[s0 & 0xff] ^\n        invKeySchedule[ksRow + 1];\n      t2 =\n        (invSBOX[s2 >>> 24] << 24) ^\n        (invSBOX[(s3 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s0 >> 8) & 0xff] << 8) ^\n        invSBOX[s1 & 0xff] ^\n        invKeySchedule[ksRow + 2];\n      t3 =\n        (invSBOX[s3 >>> 24] << 24) ^\n        (invSBOX[(s0 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s1 >> 8) & 0xff] << 8) ^\n        invSBOX[s2 & 0xff] ^\n        invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n\n      offset = offset + 4;\n    }\n\n    return outputInt32.buffer;\n  }\n}\n","import { DecrypterAesMode } from './decrypter-aes-mode';\n\nexport default class FastAESKey {\n  private subtle: SubtleCrypto;\n  private key: ArrayBuffer;\n  private aesMode: DecrypterAesMode;\n\n  constructor(\n    subtle: SubtleCrypto,\n    key: ArrayBuffer,\n    aesMode: DecrypterAesMode,\n  ) {\n    this.subtle = subtle;\n    this.key = key;\n    this.aesMode = aesMode;\n  }\n\n  expandKey() {\n    const subtleAlgoName = getSubtleAlgoName(this.aesMode);\n    return this.subtle.importKey(\n      'raw',\n      this.key,\n      { name: subtleAlgoName },\n      false,\n      ['encrypt', 'decrypt'],\n    );\n  }\n}\n\nfunction getSubtleAlgoName(aesMode: DecrypterAesMode) {\n  switch (aesMode) {\n    case DecrypterAesMode.cbc:\n      return 'AES-CBC';\n    case DecrypterAesMode.ctr:\n      return 'AES-CTR';\n    default:\n      throw new Error(`[FastAESKey] invalid aes mode ${aesMode}`);\n  }\n}\n","import AESCrypto from './aes-crypto';\nimport AESDecryptor, { removePadding } from './aes-decryptor';\nimport { DecrypterAesMode } from './decrypter-aes-mode';\nimport FastAESKey from './fast-aes-key';\nimport { logger } from '../utils/logger';\nimport { appendUint8Array } from '../utils/mp4-tools';\nimport type { HlsConfig } from '../config';\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nexport default class Decrypter {\n  private logEnabled: boolean = true;\n  private removePKCS7Padding: boolean;\n  private subtle: SubtleCrypto | null = null;\n  private softwareDecrypter: AESDecryptor | null = null;\n  private key: ArrayBuffer | null = null;\n  private fastAesKey: FastAESKey | null = null;\n  private remainderData: Uint8Array<ArrayBuffer> | null = null;\n  private currentIV: ArrayBuffer | null = null;\n  private currentResult: ArrayBuffer | null = null;\n  private useSoftware: boolean;\n  private enableSoftwareAES: boolean;\n\n  constructor(config: HlsConfig, { removePKCS7Padding = true } = {}) {\n    this.enableSoftwareAES = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle =\n            browserCrypto.subtle ||\n            ((browserCrypto as any).webkitSubtle as SubtleCrypto);\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    this.useSoftware = !this.subtle;\n  }\n\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n\n  public isSync() {\n    return this.useSoftware;\n  }\n\n  public flush(): Uint8Array<ArrayBuffer> | null {\n    const { currentResult, remainderData } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n\n  public reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n\n  public decrypt(\n    data: Uint8Array | ArrayBuffer,\n    key: ArrayBuffer,\n    iv: ArrayBuffer,\n    aesMode: DecrypterAesMode,\n  ): Promise<ArrayBuffer> {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);\n        this.softwareDecrypt(dataView, key, iv, aesMode);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  public softwareDecrypt(\n    data: Uint8Array,\n    key: ArrayBuffer,\n    iv: ArrayBuffer,\n    aesMode: DecrypterAesMode,\n  ): ArrayBuffer | null {\n    const { currentIV, currentResult, remainderData } = this;\n    if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {\n      logger.warn('SoftwareDecrypt: can only handle AES-128-CBC');\n      return null;\n    }\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n\n    if (currentIV) {\n      iv = currentIV;\n    }\n\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n\n    const result = currentResult;\n\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = currentChunk.slice(-16).buffer;\n\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n\n  public webCryptoDecrypt(\n    data: Uint8Array<ArrayBuffer>,\n    key: ArrayBuffer,\n    iv: ArrayBuffer,\n    aesMode: DecrypterAesMode,\n  ): Promise<ArrayBuffer> {\n    if (this.key !== key || !this.fastAesKey) {\n      if (!this.subtle) {\n        return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));\n      }\n      this.key = key;\n      this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);\n    }\n    return this.fastAesKey\n      .expandKey()\n      .then((aesKey: CryptoKey) => {\n        // decrypt using web crypto\n        if (!this.subtle) {\n          return Promise.reject(new Error('web crypto not initialized'));\n        }\n        this.logOnce('WebCrypto AES decrypt');\n        const crypto = new AESCrypto(this.subtle, new Uint8Array(iv), aesMode);\n        return crypto.decrypt(data.buffer, aesKey);\n      })\n      .catch((err) => {\n        logger.warn(\n          `[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`,\n        );\n\n        return this.onWebCryptoError(data, key, iv, aesMode);\n      });\n  }\n\n  private onWebCryptoError(\n    data: Uint8Array,\n    key: ArrayBuffer,\n    iv: ArrayBuffer,\n    aesMode: DecrypterAesMode,\n  ): ArrayBuffer | never {\n    const enableSoftwareAES = this.enableSoftwareAES;\n    if (enableSoftwareAES) {\n      this.useSoftware = true;\n      this.logEnabled = true;\n      this.softwareDecrypt(data, key, iv, aesMode);\n      const decryptResult = this.flush();\n      if (decryptResult) {\n        return decryptResult.buffer;\n      }\n    }\n    throw new Error(\n      'WebCrypto' +\n        (enableSoftwareAES ? ' and softwareDecrypt' : '') +\n        ': failed to decrypt data',\n    );\n  }\n\n  private getValidChunk(data: Uint8Array): Uint8Array {\n    let currentChunk = data;\n    const splitPoint = data.length - (data.length % CHUNK_SIZE);\n    if (splitPoint !== data.length) {\n      currentChunk = data.slice(0, splitPoint);\n      this.remainderData = data.slice(splitPoint);\n    }\n    return currentChunk;\n  }\n\n  private logOnce(msg: string) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n","/**\n * MP4 demuxer\n */\nimport { dummyTrack } from './dummy-demuxed-track';\nimport {\n  type DemuxedAudioTrack,\n  type DemuxedMetadataTrack,\n  type DemuxedUserdataTrack,\n  type Demuxer,\n  type DemuxerResult,\n  type KeyData,\n  MetadataSchema,\n  type PassthroughTrack,\n} from '../types/demuxer';\nimport {\n  appendUint8Array,\n  findBox,\n  hasMoofData,\n  parseEmsg,\n  parseInitSegment,\n  parseSamples,\n  RemuxerTrackIdConfig,\n  segmentValidRange,\n} from '../utils/mp4-tools';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type { IEmsgParsingData } from '../utils/mp4-tools';\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\n\nclass MP4Demuxer implements Demuxer {\n  private remainderData: Uint8Array | null = null;\n  private timeOffset: number = 0;\n  private config: HlsConfig;\n  private videoTrack?: PassthroughTrack;\n  private audioTrack?: DemuxedAudioTrack;\n  private id3Track?: DemuxedMetadataTrack;\n  private txtTrack?: DemuxedUserdataTrack;\n\n  constructor(observer: HlsEventEmitter, config: HlsConfig) {\n    this.config = config;\n  }\n\n  public resetTimeStamp() {}\n\n  public resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n  ) {\n    const videoTrack = (this.videoTrack = dummyTrack(\n      'video',\n      1,\n    ) as PassthroughTrack);\n    const audioTrack = (this.audioTrack = dummyTrack(\n      'audio',\n      1,\n    ) as DemuxedAudioTrack);\n    const captionTrack = (this.txtTrack = dummyTrack(\n      'text',\n      1,\n    ) as DemuxedUserdataTrack);\n\n    this.id3Track = dummyTrack('id3', 1) as DemuxedMetadataTrack;\n    this.timeOffset = 0;\n\n    if (!initSegment?.byteLength) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n\n    if (initData.video) {\n      const { id, timescale, codec, supplemental } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n      videoTrack.supplemental = supplemental;\n    }\n\n    if (initData.audio) {\n      const { id, timescale, codec } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n\n  public resetContiguity(): void {\n    this.remainderData = null;\n  }\n\n  static probe(data: Uint8Array) {\n    return hasMoofData(data);\n  }\n\n  public demux(data: Uint8Array, timeOffset: number): DemuxerResult {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack as PassthroughTrack;\n    const textTrack = this.txtTrack as DemuxedUserdataTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack as DemuxedAudioTrack,\n      id3Track,\n      textTrack: this.txtTrack as DemuxedUserdataTrack,\n    };\n  }\n\n  public flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack as PassthroughTrack;\n    const textTrack = this.txtTrack as DemuxedUserdataTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n\n    return {\n      videoTrack,\n      audioTrack: dummyTrack() as DemuxedAudioTrack,\n      id3Track,\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\n    };\n  }\n\n  private extractID3Track(\n    videoTrack: PassthroughTrack,\n    timeOffset: number,\n  ): DemuxedMetadataTrack {\n    const id3Track = this.id3Track as DemuxedMetadataTrack;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach((data: Uint8Array) => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            let duration =\n              emsgInfo.eventDuration === 0xffffffff\n                ? Number.POSITIVE_INFINITY\n                : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration,\n            });\n          } else if (\n            this.config.enableEmsgKLVMetadata &&\n            emsgInfo.schemeIdUri.startsWith('urn:misb:KLV:bin:1910.1')\n          ) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            id3Track.samples.push({\n              data: emsgInfo.payload,\n              len: emsgInfo.payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.misbklv,\n              duration: Number.POSITIVE_INFINITY,\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n\n  demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number,\n  ): Promise<DemuxerResult> {\n    return Promise.reject(\n      new Error('The MP4 demuxer does not support SAMPLE-AES decryption'),\n    );\n  }\n\n  destroy() {\n    // @ts-ignore\n    this.config = null;\n    this.remainderData = null;\n    this.videoTrack =\n      this.audioTrack =\n      this.id3Track =\n      this.txtTrack =\n        undefined;\n  }\n}\n\nfunction getEmsgStartTime(\n  emsgInfo: IEmsgParsingData,\n  timeOffset: number,\n): number {\n  return Number.isFinite(emsgInfo.presentationTime)\n    ? (emsgInfo.presentationTime as number) / emsgInfo.timeScale\n    : timeOffset +\n        (emsgInfo.presentationTimeDelta as number) / emsgInfo.timeScale;\n}\n\nexport default MP4Demuxer;\n","/**\n * SAMPLE-AES decrypter\n */\n\nimport Decrypter from '../crypt/decrypter';\nimport { DecrypterAesMode } from '../crypt/decrypter-aes-mode';\nimport { discardEPB } from '../utils/mp4-tools';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type {\n  AACAudioSample,\n  DemuxedVideoTrackBase,\n  KeyData,\n  VideoSample,\n  VideoSampleUnit,\n} from '../types/demuxer';\n\nclass SampleAesDecrypter {\n  private keyData: KeyData;\n  private decrypter: Decrypter;\n\n  constructor(observer: HlsEventEmitter, config: HlsConfig, keyData: KeyData) {\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false,\n    });\n  }\n\n  decryptBuffer(encryptedData: Uint8Array | ArrayBuffer): Promise<ArrayBuffer> {\n    return this.decrypter.decrypt(\n      encryptedData,\n      this.keyData.key.buffer,\n      this.keyData.iv.buffer,\n      DecrypterAesMode.cbc,\n    );\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  private decryptAacSample(\n    samples: AACAudioSample[],\n    sampleIndex: number,\n    callback: () => void,\n  ) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(\n      16,\n      curUnit.length - (curUnit.length % 16),\n    );\n    const encryptedBuffer = encryptedData.buffer.slice(\n      encryptedData.byteOffset,\n      encryptedData.byteOffset + encryptedData.length,\n    );\n\n    this.decryptBuffer(encryptedBuffer)\n      .then((decryptedBuffer: ArrayBuffer) => {\n        const decryptedData = new Uint8Array(decryptedBuffer);\n        curUnit.set(decryptedData, 16);\n\n        if (!this.decrypter.isSync()) {\n          this.decryptAacSamples(samples, sampleIndex + 1, callback);\n        }\n      })\n      .catch(callback);\n  }\n\n  decryptAacSamples(\n    samples: AACAudioSample[],\n    sampleIndex: number,\n    callback: () => void,\n  ) {\n    for (; ; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n\n      this.decryptAacSample(samples, sampleIndex, callback);\n\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData: Uint8Array) {\n    const encryptedDataLen =\n      Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (\n      let inputPos = 32;\n      inputPos < decodedData.length - 16;\n      inputPos += 160, outputPos += 16\n    ) {\n      encryptedData.set(\n        decodedData.subarray(inputPos, inputPos + 16),\n        outputPos,\n      );\n    }\n\n    return encryptedData;\n  }\n\n  getAvcDecryptedUnit(decodedData: Uint8Array, decryptedData: ArrayBufferLike) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (\n      let outputPos = 32;\n      outputPos < decodedData.length - 16;\n      outputPos += 160, inputPos += 16\n    ) {\n      decodedData.set(\n        uint8DecryptedData.subarray(inputPos, inputPos + 16),\n        outputPos,\n      );\n    }\n\n    return decodedData;\n  }\n\n  decryptAvcSample(\n    samples: VideoSample[],\n    sampleIndex: number,\n    unitIndex: number,\n    callback: () => void,\n    curUnit: VideoSampleUnit,\n  ) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n\n    this.decryptBuffer(encryptedData.buffer)\n      .then((decryptedBuffer) => {\n        curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n\n        if (!this.decrypter.isSync()) {\n          this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n        }\n      })\n      .catch(callback);\n  }\n\n  decryptAvcSamples(\n    samples: DemuxedVideoTrackBase['samples'],\n    sampleIndex: number,\n    unitIndex: number,\n    callback: () => void,\n  ) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n\n    for (; ; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      const curUnits = samples[sampleIndex].units;\n      for (; ; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n\n        const curUnit = curUnits[unitIndex];\n        if (\n          curUnit.data.length <= 48 ||\n          (curUnit.type !== 1 && curUnit.type !== 5)\n        ) {\n          continue;\n        }\n\n        this.decryptAvcSample(\n          samples,\n          sampleIndex,\n          unitIndex,\n          callback,\n          curUnit,\n        );\n\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nexport default SampleAesDecrypter;\n","import { appendUint8Array } from '../../utils/mp4-tools';\nimport type {\n  DemuxedUserdataTrack,\n  DemuxedVideoTrack,\n  VideoSample,\n  VideoSampleUnit,\n} from '../../types/demuxer';\nimport type { ParsedVideoSample } from '../tsdemuxer';\nimport type { PES } from '../tsdemuxer';\n\nabstract class BaseVideoParser {\n  protected VideoSample: ParsedVideoSample | null = null;\n\n  protected createVideoSample(\n    key: boolean,\n    pts: number | undefined,\n    dts: number | undefined,\n  ): ParsedVideoSample {\n    return {\n      key,\n      frame: false,\n      pts,\n      dts,\n      units: [],\n      length: 0,\n    };\n  }\n\n  protected getLastNalUnit(\n    samples: VideoSample[],\n  ): VideoSampleUnit | undefined {\n    let VideoSample = this.VideoSample;\n    let lastUnit: VideoSampleUnit | undefined;\n    // try to fallback to previous sample if current one is empty\n    if (!VideoSample || VideoSample.units.length === 0) {\n      VideoSample = samples[samples.length - 1];\n    }\n    if (VideoSample?.units) {\n      const units = VideoSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n\n  protected pushAccessUnit(\n    VideoSample: ParsedVideoSample,\n    videoTrack: DemuxedVideoTrack,\n  ) {\n    if (VideoSample.units.length && VideoSample.frame) {\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n      if (VideoSample.pts === undefined) {\n        const samples = videoTrack.samples;\n        const nbSamples = samples.length;\n        if (nbSamples) {\n          const lastSample = samples[nbSamples - 1];\n          VideoSample.pts = lastSample.pts;\n          VideoSample.dts = lastSample.dts;\n        } else {\n          // dropping samples, no timestamp found\n          videoTrack.dropped++;\n          return;\n        }\n      }\n      videoTrack.samples.push(VideoSample as VideoSample);\n    }\n  }\n\n  abstract parsePES(\n    track: DemuxedVideoTrack,\n    textTrack: DemuxedUserdataTrack,\n    pes: PES,\n    last: boolean,\n  );\n\n  protected abstract getNALuType(data: Uint8Array, offset: number): number;\n\n  protected parseNALu(\n    track: DemuxedVideoTrack,\n    array: Uint8Array,\n    endOfSegment: boolean,\n  ): Array<{\n    data: Uint8Array;\n    type: number;\n    state?: number;\n  }> {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units: VideoSampleUnit[] = [];\n    let i = 0;\n    let value: number;\n    let overflow: number;\n    let unitType: number;\n    let lastUnitStart = -1;\n    let lastUnitType: number = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = this.getNALuType(array, 0);\n      state = 0;\n      i = 1;\n    }\n\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        overflow = i - state - 1;\n        if (lastUnitStart >= 0) {\n          const unit: VideoSampleUnit = {\n            data: array.subarray(lastUnitStart, overflow),\n            type: lastUnitType,\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(\n                  0,\n                  lastUnit.data.byteLength - lastState,\n                );\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              lastUnit.data = appendUint8Array(\n                lastUnit.data,\n                array.subarray(0, overflow),\n              );\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = this.getNALuType(array, i);\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit: VideoSampleUnit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state,\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n}\n\nexport default BaseVideoParser;\n","/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nimport { logger } from '../../utils/logger';\n\nclass ExpGolomb {\n  private data: Uint8Array;\n  public bytesAvailable: number;\n  private word: number;\n  private bitsAvailable: number;\n\n  constructor(data: Uint8Array) {\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord(): void {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count: number): void {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size: number): number {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> (32 - bits); // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return (valu << bits) | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ(): number {\n    let leadingZeroCount; // :uint\n    for (\n      leadingZeroCount = 0;\n      leadingZeroCount < this.bitsAvailable;\n      ++leadingZeroCount\n    ) {\n      if ((this.word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG(): void {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG(): void {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG(): number {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG(): number {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean(): boolean {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte(): number {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort(): number {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt(): number {\n    return this.readBits(32);\n  }\n}\n\nexport default ExpGolomb;\n","import BaseVideoParser from './base-video-parser';\nimport ExpGolomb from './exp-golomb';\nimport { parseSEIMessageFromNALu } from '../../utils/mp4-tools';\nimport type {\n  DemuxedUserdataTrack,\n  DemuxedVideoTrack,\n} from '../../types/demuxer';\nimport type { PES } from '../tsdemuxer';\n\nclass AvcVideoParser extends BaseVideoParser {\n  public parsePES(\n    track: DemuxedVideoTrack,\n    textTrack: DemuxedUserdataTrack,\n    pes: PES,\n    endOfSegment: boolean,\n  ) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push: boolean;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    (pes as any).data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(\n        false,\n        pes.pts,\n        pes.dts,\n      );\n    }\n\n    units.forEach((unit) => {\n      switch (unit.type) {\n        // NDR\n        case 1: {\n          let iskey = false;\n          push = true;\n          const data = unit.data;\n          // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n          if (spsfound && data.length > 4) {\n            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n            const sliceType = this.readSliceType(data);\n            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n            // if (sliceType === 2 || sliceType === 7) {\n            if (\n              sliceType === 2 ||\n              sliceType === 4 ||\n              sliceType === 7 ||\n              sliceType === 9\n            ) {\n              iskey = true;\n            }\n          }\n\n          if (iskey) {\n            // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n            if (VideoSample?.frame && !VideoSample.key) {\n              this.pushAccessUnit(VideoSample, track);\n              VideoSample = this.VideoSample = null;\n            }\n          }\n\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              true,\n              pes.pts,\n              pes.dts,\n            );\n          }\n          VideoSample.frame = true;\n          VideoSample.key = iskey;\n\n          break;\n          // IDR\n        }\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if (VideoSample?.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              true,\n              pes.pts,\n              pes.dts,\n            );\n          }\n\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n        // SEI\n        case 6: {\n          push = true;\n          parseSEIMessageFromNALu(\n            unit.data,\n            1,\n            pes.pts as number,\n            textTrack.samples,\n          );\n          break;\n          // SPS\n        }\n        case 7: {\n          push = true;\n          spsfound = true;\n          const sps = unit.data;\n          const config = this.readSPS(sps);\n          if (\n            !track.sps ||\n            track.width !== config.width ||\n            track.height !== config.height ||\n            track.pixelRatio?.[0] !== config.pixelRatio[0] ||\n            track.pixelRatio?.[1] !== config.pixelRatio[1]\n          ) {\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.sps = [sps];\n            const codecarray = sps.subarray(1, 4);\n            let codecstring = 'avc1.';\n            for (let i = 0; i < 3; i++) {\n              let h = codecarray[i].toString(16);\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n\n              codecstring += h;\n            }\n            track.codec = codecstring;\n          }\n          break;\n        }\n        // PPS\n        case 8:\n          push = true;\n\n          track.pps = [unit.data];\n\n          break;\n        // AUD\n        case 9:\n          push = true;\n          track.audFound = true;\n          if (VideoSample?.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              false,\n              pes.pts,\n              pes.dts,\n            );\n          }\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n\n  protected getNALuType(data: Uint8Array, offset: number): number {\n    return data[offset] & 0x1f;\n  }\n\n  readSliceType(data: Uint8Array) {\n    const eg = new ExpGolomb(data);\n    // skip NALu type\n    eg.readUByte();\n    // discard first_mb_in_slice\n    eg.readUEG();\n    // return slice_type\n    return eg.readUEG();\n  }\n\n  /**\n   * The scaling list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count: number, reader: ExpGolomb): void {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = reader.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS(sps: Uint8Array): {\n    width: number;\n    height: number;\n    pixelRatio: [number, number];\n  } {\n    const eg = new ExpGolomb(sps);\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = eg.readUByte.bind(eg);\n    const readBits = eg.readBits.bind(eg);\n    const readUEG = eg.readUEG.bind(eg);\n    const readBoolean = eg.readBoolean.bind(eg);\n    const skipBits = eg.skipBits.bind(eg);\n    const skipEG = eg.skipEG.bind(eg);\n    const skipUEG = eg.skipUEG.bind(eg);\n    const skipScalingList = this.skipScalingList.bind(this);\n\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (\n      profileIdc === 100 ||\n      profileIdc === 110 ||\n      profileIdc === 122 ||\n      profileIdc === 244 ||\n      profileIdc === 44 ||\n      profileIdc === 83 ||\n      profileIdc === 86 ||\n      profileIdc === 118 ||\n      profileIdc === 128\n    ) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, eg);\n            } else {\n              skipScalingList(64, eg);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio: [number, number] = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255: {\n            pixelRatio = [\n              (readUByte() << 8) | readUByte(),\n              (readUByte() << 8) | readUByte(),\n            ];\n            break;\n          }\n        }\n      }\n    }\n    return {\n      width: Math.ceil(\n        (picWidthInMbsMinus1 + 1) * 16 -\n          frameCropLeftOffset * 2 -\n          frameCropRightOffset * 2,\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) *\n          (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio,\n    };\n  }\n}\n\nexport default AvcVideoParser;\n","import BaseVideoParser from './base-video-parser';\nimport ExpGolomb from './exp-golomb';\nimport { parseSEIMessageFromNALu } from '../../utils/mp4-tools';\nimport type {\n  DemuxedUserdataTrack,\n  DemuxedVideoTrack,\n} from '../../types/demuxer';\nimport type { ParsedVideoSample } from '../tsdemuxer';\nimport type { PES } from '../tsdemuxer';\n\nclass HevcVideoParser extends BaseVideoParser {\n  protected initVPS: Uint8Array | null = null;\n\n  public parsePES(\n    track: DemuxedVideoTrack,\n    textTrack: DemuxedUserdataTrack,\n    pes: PES,\n    endOfSegment: boolean,\n  ) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push: boolean;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    (pes as any).data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(\n        false,\n        pes.pts,\n        pes.dts,\n      );\n    }\n\n    units.forEach((unit) => {\n      switch (unit.type) {\n        // NON-IDR, NON RANDOM ACCESS SLICE\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              false,\n              pes.pts,\n              pes.dts,\n            );\n          }\n          VideoSample.frame = true;\n          push = true;\n          break;\n\n        // CRA, BLA (random access picture)\n        case 16:\n        case 17:\n        case 18:\n        case 21:\n          push = true;\n          if (spsfound) {\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if (VideoSample?.frame && !VideoSample.key) {\n              this.pushAccessUnit(VideoSample, track);\n              VideoSample = this.VideoSample = null;\n            }\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              true,\n              pes.pts,\n              pes.dts,\n            );\n          }\n\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // IDR\n        case 19:\n        case 20:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if (VideoSample?.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              true,\n              pes.pts,\n              pes.dts,\n            );\n          }\n\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // SEI\n        case 39:\n          push = true;\n          parseSEIMessageFromNALu(\n            unit.data,\n            2, // NALu header size\n            pes.pts as number,\n            textTrack.samples,\n          );\n          break;\n\n        // VPS\n        case 32:\n          push = true;\n          if (!track.vps) {\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            track.params = Object.assign(track.params, this.readVPS(unit.data));\n            this.initVPS = unit.data;\n          }\n          track.vps = [unit.data];\n          break;\n\n        // SPS\n        case 33:\n          push = true;\n          spsfound = true;\n          if (\n            track.vps !== undefined &&\n            track.vps[0] !== this.initVPS &&\n            track.sps !== undefined &&\n            !this.matchSPS(track.sps[0], unit.data)\n          ) {\n            this.initVPS = track.vps[0];\n            track.sps = track.pps = undefined;\n          }\n          if (!track.sps) {\n            const config = this.readSPS(unit.data);\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.codec = config.codecString;\n            track.sps = [];\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            for (const prop in config.params) {\n              track.params[prop] = config.params[prop];\n            }\n          }\n          this.pushParameterSet(track.sps, unit.data, track.vps);\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              true,\n              pes.pts,\n              pes.dts,\n            );\n          }\n          VideoSample.key = true;\n          break;\n\n        // PPS\n        case 34:\n          push = true;\n          if (typeof track.params === 'object') {\n            if (!track.pps) {\n              track.pps = [];\n              const config = this.readPPS(unit.data);\n              for (const prop in config) {\n                track.params[prop] = config[prop];\n              }\n            }\n            this.pushParameterSet(track.pps, unit.data, track.vps);\n          }\n          break;\n\n        // ACCESS UNIT DELIMITER\n        case 35:\n          push = true;\n          track.audFound = true;\n          if (VideoSample?.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(\n              false,\n              pes.pts,\n              pes.dts,\n            );\n          }\n          break;\n\n        default:\n          push = false;\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n\n  private pushParameterSet(\n    parameterSets: Uint8Array[],\n    data: Uint8Array,\n    vps: Uint8Array[] | undefined,\n  ) {\n    if ((vps && vps[0] === this.initVPS) || (!vps && !parameterSets.length)) {\n      parameterSets.push(data);\n    }\n  }\n\n  protected getNALuType(data: Uint8Array, offset: number): number {\n    return (data[offset] & 0x7e) >>> 1;\n  }\n\n  protected ebsp2rbsp(arr: Uint8Array): Uint8Array {\n    const dst = new Uint8Array(arr.byteLength);\n    let dstIdx = 0;\n    for (let i = 0; i < arr.byteLength; i++) {\n      if (i >= 2) {\n        // Unescape: Skip 0x03 after 00 00\n        if (arr[i] === 0x03 && arr[i - 1] === 0x00 && arr[i - 2] === 0x00) {\n          continue;\n        }\n      }\n      dst[dstIdx] = arr[i];\n      dstIdx++;\n    }\n    return new Uint8Array(dst.buffer, 0, dstIdx);\n  }\n\n  protected pushAccessUnit(\n    VideoSample: ParsedVideoSample,\n    videoTrack: DemuxedVideoTrack,\n  ) {\n    super.pushAccessUnit(VideoSample, videoTrack);\n    if (this.initVPS) {\n      this.initVPS = null; // null initVPS to prevent possible track's sps/pps growth until next VPS\n    }\n  }\n\n  readVPS(vps: Uint8Array): {\n    numTemporalLayers: number;\n    temporalIdNested: boolean;\n  } {\n    const eg = new ExpGolomb(vps);\n    // remove header\n    eg.readUByte();\n    eg.readUByte();\n\n    eg.readBits(4); // video_parameter_set_id\n    eg.skipBits(2);\n    eg.readBits(6); // max_layers_minus1\n    const max_sub_layers_minus1 = eg.readBits(3);\n    const temporal_id_nesting_flag = eg.readBoolean();\n    // ...vui fps can be here, but empty fps value is not critical for metadata\n\n    return {\n      numTemporalLayers: max_sub_layers_minus1 + 1,\n      temporalIdNested: temporal_id_nesting_flag,\n    };\n  }\n\n  readSPS(sps: Uint8Array): {\n    codecString: string;\n    params: object;\n    width: number;\n    height: number;\n    pixelRatio: [number, number];\n  } {\n    const eg = new ExpGolomb(this.ebsp2rbsp(sps));\n    eg.readUByte();\n    eg.readUByte();\n\n    eg.readBits(4); //video_parameter_set_id\n    const max_sub_layers_minus1 = eg.readBits(3);\n    eg.readBoolean(); // temporal_id_nesting_flag\n\n    // profile_tier_level\n    const general_profile_space = eg.readBits(2);\n    const general_tier_flag = eg.readBoolean();\n    const general_profile_idc = eg.readBits(5);\n    const general_profile_compatibility_flags_1 = eg.readUByte();\n    const general_profile_compatibility_flags_2 = eg.readUByte();\n    const general_profile_compatibility_flags_3 = eg.readUByte();\n    const general_profile_compatibility_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_1 = eg.readUByte();\n    const general_constraint_indicator_flags_2 = eg.readUByte();\n    const general_constraint_indicator_flags_3 = eg.readUByte();\n    const general_constraint_indicator_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_5 = eg.readUByte();\n    const general_constraint_indicator_flags_6 = eg.readUByte();\n    const general_level_idc = eg.readUByte();\n    const sub_layer_profile_present_flags: boolean[] = [];\n    const sub_layer_level_present_flags: boolean[] = [];\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      sub_layer_profile_present_flags.push(eg.readBoolean());\n      sub_layer_level_present_flags.push(eg.readBoolean());\n    }\n    if (max_sub_layers_minus1 > 0) {\n      for (let i = max_sub_layers_minus1; i < 8; i++) {\n        eg.readBits(2);\n      }\n    }\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      if (sub_layer_profile_present_flags[i]) {\n        eg.readUByte(); // sub_layer_profile_space, sub_layer_tier_flag, sub_layer_profile_idc\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte(); // sub_layer_profile_compatibility_flag\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n      }\n      if (sub_layer_level_present_flags[i]) {\n        eg.readUByte();\n      }\n    }\n\n    eg.readUEG(); // seq_parameter_set_id\n    const chroma_format_idc = eg.readUEG();\n    if (chroma_format_idc == 3) {\n      eg.skipBits(1); //separate_colour_plane_flag\n    }\n    const pic_width_in_luma_samples = eg.readUEG();\n    const pic_height_in_luma_samples = eg.readUEG();\n    const conformance_window_flag = eg.readBoolean();\n    let pic_left_offset = 0,\n      pic_right_offset = 0,\n      pic_top_offset = 0,\n      pic_bottom_offset = 0;\n    if (conformance_window_flag) {\n      pic_left_offset += eg.readUEG();\n      pic_right_offset += eg.readUEG();\n      pic_top_offset += eg.readUEG();\n      pic_bottom_offset += eg.readUEG();\n    }\n    const bit_depth_luma_minus8 = eg.readUEG();\n    const bit_depth_chroma_minus8 = eg.readUEG();\n    const log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();\n    const sub_layer_ordering_info_present_flag = eg.readBoolean();\n    for (\n      let i = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1;\n      i <= max_sub_layers_minus1;\n      i++\n    ) {\n      eg.skipUEG(); // max_dec_pic_buffering_minus1[i]\n      eg.skipUEG(); // max_num_reorder_pics[i]\n      eg.skipUEG(); // max_latency_increase_plus1[i]\n    }\n    eg.skipUEG(); // log2_min_luma_coding_block_size_minus3\n    eg.skipUEG(); // log2_diff_max_min_luma_coding_block_size\n    eg.skipUEG(); // log2_min_transform_block_size_minus2\n    eg.skipUEG(); // log2_diff_max_min_transform_block_size\n    eg.skipUEG(); // max_transform_hierarchy_depth_inter\n    eg.skipUEG(); // max_transform_hierarchy_depth_intra\n    const scaling_list_enabled_flag = eg.readBoolean();\n    if (scaling_list_enabled_flag) {\n      const sps_scaling_list_data_present_flag = eg.readBoolean();\n      if (sps_scaling_list_data_present_flag) {\n        for (let sizeId = 0; sizeId < 4; sizeId++) {\n          for (\n            let matrixId = 0;\n            matrixId < (sizeId === 3 ? 2 : 6);\n            matrixId++\n          ) {\n            const scaling_list_pred_mode_flag = eg.readBoolean();\n            if (!scaling_list_pred_mode_flag) {\n              eg.readUEG(); // scaling_list_pred_matrix_id_delta\n            } else {\n              const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n              if (sizeId > 1) {\n                eg.readEG();\n              }\n              for (let i = 0; i < coefNum; i++) {\n                eg.readEG();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    eg.readBoolean(); // amp_enabled_flag\n    eg.readBoolean(); // sample_adaptive_offset_enabled_flag\n    const pcm_enabled_flag = eg.readBoolean();\n    if (pcm_enabled_flag) {\n      eg.readUByte();\n      eg.skipUEG();\n      eg.skipUEG();\n      eg.readBoolean();\n    }\n    const num_short_term_ref_pic_sets = eg.readUEG();\n    let num_delta_pocs = 0;\n    for (let i = 0; i < num_short_term_ref_pic_sets; i++) {\n      let inter_ref_pic_set_prediction_flag = false;\n      if (i !== 0) {\n        inter_ref_pic_set_prediction_flag = eg.readBoolean();\n      }\n      if (inter_ref_pic_set_prediction_flag) {\n        if (i === num_short_term_ref_pic_sets) {\n          eg.readUEG();\n        }\n        eg.readBoolean();\n        eg.readUEG();\n        let next_num_delta_pocs = 0;\n        for (let j = 0; j <= num_delta_pocs; j++) {\n          const used_by_curr_pic_flag = eg.readBoolean();\n          let use_delta_flag = false;\n          if (!used_by_curr_pic_flag) {\n            use_delta_flag = eg.readBoolean();\n          }\n          if (used_by_curr_pic_flag || use_delta_flag) {\n            next_num_delta_pocs++;\n          }\n        }\n        num_delta_pocs = next_num_delta_pocs;\n      } else {\n        const num_negative_pics = eg.readUEG();\n        const num_positive_pics = eg.readUEG();\n        num_delta_pocs = num_negative_pics + num_positive_pics;\n        for (let j = 0; j < num_negative_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n        for (let j = 0; j < num_positive_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n      }\n    }\n\n    const long_term_ref_pics_present_flag = eg.readBoolean();\n    if (long_term_ref_pics_present_flag) {\n      const num_long_term_ref_pics_sps = eg.readUEG();\n      for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n        for (let j = 0; j < log2_max_pic_order_cnt_lsb_minus4 + 4; j++) {\n          eg.readBits(1);\n        }\n        eg.readBits(1);\n      }\n    }\n\n    let min_spatial_segmentation_idc = 0;\n    let sar_width = 1,\n      sar_height = 1;\n    let fps_fixed = true,\n      fps_den = 1,\n      fps_num = 0;\n    eg.readBoolean(); // sps_temporal_mvp_enabled_flag\n    eg.readBoolean(); // strong_intra_smoothing_enabled_flag\n    let default_display_window_flag = false;\n    const vui_parameters_present_flag = eg.readBoolean();\n    if (vui_parameters_present_flag) {\n      const aspect_ratio_info_present_flag = eg.readBoolean();\n      if (aspect_ratio_info_present_flag) {\n        const aspect_ratio_idc = eg.readUByte();\n        const sar_width_table = [\n          1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2,\n        ];\n        const sar_height_table = [\n          1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1,\n        ];\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          sar_width = sar_width_table[aspect_ratio_idc - 1];\n          sar_height = sar_height_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          sar_width = eg.readBits(16);\n          sar_height = eg.readBits(16);\n        }\n      }\n      const overscan_info_present_flag = eg.readBoolean();\n      if (overscan_info_present_flag) {\n        eg.readBoolean();\n      }\n      const video_signal_type_present_flag = eg.readBoolean();\n      if (video_signal_type_present_flag) {\n        eg.readBits(3);\n        eg.readBoolean();\n        const colour_description_present_flag = eg.readBoolean();\n        if (colour_description_present_flag) {\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n        }\n      }\n      const chroma_loc_info_present_flag = eg.readBoolean();\n      if (chroma_loc_info_present_flag) {\n        eg.readUEG();\n        eg.readUEG();\n      }\n      eg.readBoolean(); // neutral_chroma_indication_flag\n      eg.readBoolean(); // field_seq_flag\n      eg.readBoolean(); // frame_field_info_present_flag\n      default_display_window_flag = eg.readBoolean();\n      if (default_display_window_flag) {\n        eg.skipUEG();\n        eg.skipUEG();\n        eg.skipUEG();\n        eg.skipUEG();\n      }\n      const vui_timing_info_present_flag = eg.readBoolean();\n      if (vui_timing_info_present_flag) {\n        fps_den = eg.readBits(32);\n        fps_num = eg.readBits(32);\n        const vui_poc_proportional_to_timing_flag = eg.readBoolean();\n        if (vui_poc_proportional_to_timing_flag) {\n          eg.readUEG();\n        }\n        const vui_hrd_parameters_present_flag = eg.readBoolean();\n        if (vui_hrd_parameters_present_flag) {\n          //const commonInfPresentFlag = true;\n          //if (commonInfPresentFlag) {\n          const nal_hrd_parameters_present_flag = eg.readBoolean();\n          const vcl_hrd_parameters_present_flag = eg.readBoolean();\n          let sub_pic_hrd_params_present_flag = false;\n          if (\n            nal_hrd_parameters_present_flag ||\n            vcl_hrd_parameters_present_flag\n          ) {\n            sub_pic_hrd_params_present_flag = eg.readBoolean();\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readUByte();\n              eg.readBits(5);\n              eg.readBoolean();\n              eg.readBits(5);\n            }\n            eg.readBits(4); // bit_rate_scale\n            eg.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readBits(4);\n            }\n            eg.readBits(5);\n            eg.readBits(5);\n            eg.readBits(5);\n          }\n          //}\n          for (let i = 0; i <= max_sub_layers_minus1; i++) {\n            fps_fixed = eg.readBoolean(); // fixed_pic_rate_general_flag\n            const fixed_pic_rate_within_cvs_flag =\n              fps_fixed || eg.readBoolean();\n            let low_delay_hrd_flag = false;\n            if (fixed_pic_rate_within_cvs_flag) {\n              eg.readEG();\n            } else {\n              low_delay_hrd_flag = eg.readBoolean();\n            }\n            const cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;\n            if (nal_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n            if (vcl_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n          }\n        }\n      }\n      const bitstream_restriction_flag = eg.readBoolean();\n      if (bitstream_restriction_flag) {\n        eg.readBoolean(); // tiles_fixed_structure_flag\n        eg.readBoolean(); // motion_vectors_over_pic_boundaries_flag\n        eg.readBoolean(); // restricted_ref_pic_lists_flag\n        min_spatial_segmentation_idc = eg.readUEG();\n      }\n    }\n\n    let width = pic_width_in_luma_samples,\n      height = pic_height_in_luma_samples;\n    if (conformance_window_flag) {\n      let chroma_scale_w = 1,\n        chroma_scale_h = 1;\n      if (chroma_format_idc === 1) {\n        // YUV 420\n        chroma_scale_w = chroma_scale_h = 2;\n      } else if (chroma_format_idc == 2) {\n        // YUV 422\n        chroma_scale_w = 2;\n      }\n      width =\n        pic_width_in_luma_samples -\n        chroma_scale_w * pic_right_offset -\n        chroma_scale_w * pic_left_offset;\n      height =\n        pic_height_in_luma_samples -\n        chroma_scale_h * pic_bottom_offset -\n        chroma_scale_h * pic_top_offset;\n    }\n\n    const profile_space_string = general_profile_space\n      ? ['A', 'B', 'C'][general_profile_space]\n      : '';\n    const profile_compatibility_buf =\n      (general_profile_compatibility_flags_1 << 24) |\n      (general_profile_compatibility_flags_2 << 16) |\n      (general_profile_compatibility_flags_3 << 8) |\n      general_profile_compatibility_flags_4;\n    let profile_compatibility_rev = 0;\n    for (let i = 0; i < 32; i++) {\n      profile_compatibility_rev =\n        (profile_compatibility_rev |\n          (((profile_compatibility_buf >> i) & 1) << (31 - i))) >>>\n        0; // reverse bit position (and cast as UInt32)\n    }\n    let profile_compatibility_flags_string =\n      profile_compatibility_rev.toString(16);\n    if (\n      general_profile_idc === 1 &&\n      profile_compatibility_flags_string === '2'\n    ) {\n      profile_compatibility_flags_string = '6';\n    }\n    const tier_flag_string = general_tier_flag ? 'H' : 'L';\n\n    return {\n      codecString: `hvc1.${profile_space_string}${general_profile_idc}.${profile_compatibility_flags_string}.${tier_flag_string}${general_level_idc}.B0`,\n      params: {\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_space,\n        general_profile_compatibility_flags: [\n          general_profile_compatibility_flags_1,\n          general_profile_compatibility_flags_2,\n          general_profile_compatibility_flags_3,\n          general_profile_compatibility_flags_4,\n        ],\n        general_constraint_indicator_flags: [\n          general_constraint_indicator_flags_1,\n          general_constraint_indicator_flags_2,\n          general_constraint_indicator_flags_3,\n          general_constraint_indicator_flags_4,\n          general_constraint_indicator_flags_5,\n          general_constraint_indicator_flags_6,\n        ],\n        general_level_idc,\n        bit_depth: bit_depth_luma_minus8 + 8,\n        bit_depth_luma_minus8,\n        bit_depth_chroma_minus8,\n        min_spatial_segmentation_idc,\n        chroma_format_idc: chroma_format_idc,\n        frame_rate: {\n          fixed: fps_fixed,\n          fps: fps_num / fps_den,\n        },\n      },\n      width,\n      height,\n      pixelRatio: [sar_width, sar_height],\n    };\n  }\n\n  readPPS(pps: Uint8Array): {\n    parallelismType: number;\n  } {\n    const eg = new ExpGolomb(this.ebsp2rbsp(pps));\n    eg.readUByte();\n    eg.readUByte();\n    eg.skipUEG(); // pic_parameter_set_id\n    eg.skipUEG(); // seq_parameter_set_id\n    eg.skipBits(2); // dependent_slice_segments_enabled_flag, output_flag_present_flag\n    eg.skipBits(3); // num_extra_slice_header_bits\n    eg.skipBits(2); // sign_data_hiding_enabled_flag, cabac_init_present_flag\n    eg.skipUEG();\n    eg.skipUEG();\n    eg.skipEG(); // init_qp_minus26\n    eg.skipBits(2); // constrained_intra_pred_flag, transform_skip_enabled_flag\n    const cu_qp_delta_enabled_flag = eg.readBoolean();\n    if (cu_qp_delta_enabled_flag) {\n      eg.skipUEG();\n    }\n    eg.skipEG(); // cb_qp_offset\n    eg.skipEG(); // cr_qp_offset\n    eg.skipBits(4); // pps_slice_chroma_qp_offsets_present_flag, weighted_pred_flag, weighted_bipred_flag, transquant_bypass_enabled_flag\n    const tiles_enabled_flag = eg.readBoolean();\n    const entropy_coding_sync_enabled_flag = eg.readBoolean();\n    let parallelismType = 1; // slice-based parallel decoding\n    if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {\n      parallelismType = 0; // mixed-type parallel decoding\n    } else if (entropy_coding_sync_enabled_flag) {\n      parallelismType = 3; // wavefront-based parallel decoding\n    } else if (tiles_enabled_flag) {\n      parallelismType = 2; // tile-based parallel decoding\n    }\n\n    return {\n      parallelismType,\n    };\n  }\n\n  matchSPS(sps1: Uint8Array, sps2: Uint8Array): boolean {\n    // compare without headers and VPS related params\n    return (\n      String.fromCharCode.apply(null, sps1).substr(3) ===\n      String.fromCharCode.apply(null, sps2).substr(3)\n    );\n  }\n}\n\nexport default HevcVideoParser;\n","/**\n * highly optimized TS demuxer:\n * parse PAT, PMT\n * extract PES packet from audio and video PIDs\n * extract AVC/H264 (or HEVC/H265) NAL units and AAC/ADTS samples from PES packet\n * trigger the remuxer upon parsing completion\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n * it also controls the remuxing process :\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n */\n\nimport * as AC3 from './audio/ac3-demuxer';\nimport * as ADTS from './audio/adts';\nimport * as MpegAudio from './audio/mpegaudio';\nimport SampleAesDecrypter from './sample-aes';\nimport AvcVideoParser from './video/avc-video-parser';\nimport HevcVideoParser from './video/hevc-video-parser';\nimport { ErrorDetails, ErrorTypes } from '../errors';\nimport { Events } from '../events';\nimport {\n  type DemuxedAudioTrack,\n  type DemuxedMetadataTrack,\n  type DemuxedTrack,\n  type DemuxedUserdataTrack,\n  type DemuxedVideoTrack,\n  type Demuxer,\n  type DemuxerResult,\n  type ElementaryStreamData,\n  type KeyData,\n  MetadataSchema,\n  type VideoSample,\n} from '../types/demuxer';\nimport { appendUint8Array, RemuxerTrackIdConfig } from '../utils/mp4-tools';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type BaseVideoParser from './video/base-video-parser';\nimport type { AudioFrame, DemuxedAAC } from '../types/demuxer';\nimport type { TypeSupported } from '../utils/codecs';\nimport type { ILogger } from '../utils/logger';\n\nexport type ParsedTimestamp = {\n  pts?: number;\n  dts?: number;\n};\n\nexport type PES = ParsedTimestamp & {\n  data: Uint8Array;\n  len: number;\n};\n\nexport type ParsedVideoSample = ParsedTimestamp &\n  Omit<VideoSample, 'pts' | 'dts'>;\n\nconst PACKET_LENGTH = 188;\n\nclass TSDemuxer implements Demuxer {\n  private readonly logger: ILogger;\n  private readonly observer: HlsEventEmitter;\n  private readonly config: HlsConfig;\n  private readonly typeSupported: TypeSupported;\n\n  private sampleAes: SampleAesDecrypter | null = null;\n  private pmtParsed: boolean = false;\n  private audioCodec?: string;\n  private videoCodec?: string;\n  private _pmtId: number = -1;\n\n  private _videoTrack?: DemuxedVideoTrack;\n  private _audioTrack?: DemuxedAudioTrack;\n  private _id3Track?: DemuxedMetadataTrack;\n  private _txtTrack?: DemuxedUserdataTrack;\n  private aacOverFlow: AudioFrame | null = null;\n  private remainderData: Uint8Array | null = null;\n  private videoParser: BaseVideoParser | null;\n\n  constructor(\n    observer: HlsEventEmitter,\n    config: HlsConfig,\n    typeSupported: TypeSupported,\n    logger: ILogger,\n  ) {\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.logger = logger;\n    this.videoParser = null;\n  }\n\n  static probe(data: Uint8Array, logger: ILogger) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(\n        `MPEG2-TS detected but first sync word found @ offset ${syncOffset}`,\n      );\n    }\n    return syncOffset !== -1;\n  }\n\n  static syncOffset(data: Uint8Array): number {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (\n          data[j] === 0x47 &&\n          (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)\n        ) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow =\n                Math.min(\n                  packetStart + PACKET_LENGTH * 99,\n                  data.length - PACKET_LENGTH,\n                ) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (\n            foundPat &&\n            tsPackets > 1 &&\n            ((packetStart === 0 && tsPackets > 2) ||\n              j + PACKET_LENGTH > scanwindow)\n          ) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(\n    type: 'audio' | 'video' | 'id3' | 'text',\n    duration?: number,\n  ): DemuxedTrack {\n    return {\n      container:\n        type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined,\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  public resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string,\n    videoCodec: string,\n    trackDuration: number,\n  ) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n\n    this._videoTrack = TSDemuxer.createTrack('video') as DemuxedVideoTrack;\n    this._videoTrack.duration = trackDuration;\n    this._audioTrack = TSDemuxer.createTrack(\n      'audio',\n      trackDuration,\n    ) as DemuxedAudioTrack;\n    this._id3Track = TSDemuxer.createTrack('id3') as DemuxedMetadataTrack;\n    this._txtTrack = TSDemuxer.createTrack('text') as DemuxedUserdataTrack;\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.videoParser = null;\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n  }\n\n  public resetTimeStamp() {}\n\n  public resetContiguity(): void {\n    const { _audioTrack, _videoTrack, _id3Track } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_videoTrack) {\n      _videoTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.remainderData = null;\n  }\n\n  public demux(\n    data: Uint8Array,\n    timeOffset: number,\n    isSampleAes = false,\n    flush = false,\n  ): DemuxerResult {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n\n    let pes: PES | null;\n\n    const videoTrack = this._videoTrack as DemuxedVideoTrack;\n    const audioTrack = this._audioTrack as DemuxedAudioTrack;\n    const id3Track = this._id3Track as DemuxedMetadataTrack;\n    const textTrack = this._txtTrack as DemuxedUserdataTrack;\n\n    let videoPid = videoTrack.pid;\n    let videoData = videoTrack.pesData;\n    let audioPid = audioTrack.pid;\n    let id3Pid = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID: number | null = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack,\n      };\n    }\n\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(\n        data.buffer,\n        len,\n        data.buffer.byteLength - len,\n      );\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset: number;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case videoPid:\n            if (stt) {\n              if (videoData && (pes = parsePES(videoData, this.logger))) {\n                this.readyVideoParser(videoTrack.segmentCodec);\n                if (this.videoParser !== null) {\n                  this.videoParser.parsePES(videoTrack, textTrack, pes, false);\n                }\n              }\n\n              videoData = { data: [], size: 0 };\n            }\n            if (videoData) {\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              videoData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioPid:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData, this.logger))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                  case 'ac3':\n                    if (__USE_M2TS_ADVANCED_CODECS__) {\n                      this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n                }\n              }\n              audioData = { data: [], size: 0 };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Pid:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n                this.parseID3PES(id3Track, pes);\n              }\n\n              id3Data = { data: [], size: 0 };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // this.logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId: {\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n\n            const parsedPIDs = parsePMT(\n              data,\n              offset,\n              this.typeSupported,\n              isSampleAes,\n              this.observer,\n              this.logger,\n            );\n\n            // only update track id if track PID found while parsing PMT\n            // this is to avoid resetting the PID to -1 in case\n            // track PID transiently disappears from the stream\n            // this could happen in case of transient missing audio samples for example\n            // NOTE this is only the PID of the track as found in TS,\n            // but we are not using this for MP4 track IDs.\n            videoPid = parsedPIDs.videoPid;\n            if (videoPid > 0) {\n              videoTrack.pid = videoPid;\n              videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n            }\n\n            audioPid = parsedPIDs.audioPid;\n            if (audioPid > 0) {\n              audioTrack.pid = audioPid;\n              audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n            }\n            id3Pid = parsedPIDs.id3Pid;\n            if (id3Pid > 0) {\n              id3Track.pid = id3Pid;\n            }\n\n            if (unknownPID !== null && !pmtParsed) {\n              this.logger.warn(\n                `MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`,\n              );\n              unknownPID = null;\n              // we set it to -188, the += 188 in the for loop will reset start to 0\n              start = syncOffset - 188;\n            }\n            pmtParsed = this.pmtParsed = true;\n            break;\n          }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n\n    if (tsPacketErrors > 0) {\n      emitParsingError(\n        this.observer,\n        new Error(\n          `Found ${tsPacketErrors} TS packet/s that do not start with 0x47`,\n        ),\n        undefined,\n        this.logger,\n      );\n    }\n\n    videoTrack.pesData = videoData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n\n    const demuxResult: DemuxerResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack,\n    };\n\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n\n    return demuxResult;\n  }\n\n  public flush(): DemuxerResult | Promise<DemuxerResult> {\n    const { remainderData } = this;\n    this.remainderData = null;\n    let result: DemuxerResult;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._videoTrack as DemuxedVideoTrack,\n        audioTrack: this._audioTrack as DemuxedAudioTrack,\n        id3Track: this._id3Track as DemuxedMetadataTrack,\n        textTrack: this._txtTrack as DemuxedUserdataTrack,\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n\n  private extractRemainingSamples(demuxResult: DemuxerResult) {\n    const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n    const videoData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes: PES | null;\n    if (videoData && (pes = parsePES(videoData, this.logger))) {\n      this.readyVideoParser(videoTrack.segmentCodec);\n      if (this.videoParser !== null) {\n        this.videoParser.parsePES(\n          videoTrack as DemuxedVideoTrack,\n          textTrack as DemuxedUserdataTrack,\n          pes,\n          true,\n        );\n        videoTrack.pesData = null;\n      }\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = videoData;\n    }\n\n    if (audioData && (pes = parsePES(audioData, this.logger))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n        case 'ac3':\n          if (__USE_M2TS_ADVANCED_CODECS__) {\n            this.parseAC3PES(audioTrack, pes);\n          }\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData?.size) {\n        this.logger.log(\n          'last AAC PES packet truncated,might overlap between fragments',\n        );\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n\n    if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n\n  public demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number,\n  ): Promise<DemuxerResult> {\n    const demuxResult = this.demux(\n      data,\n      timeOffset,\n      true,\n      !this.config.progressive,\n    );\n    const sampleAes = (this.sampleAes = new SampleAesDecrypter(\n      this.observer,\n      this.config,\n      keyData,\n    ));\n    return this.decrypt(demuxResult, sampleAes);\n  }\n\n  private readyVideoParser(codec: string | undefined) {\n    if (this.videoParser === null) {\n      if (codec === 'avc') {\n        this.videoParser = new AvcVideoParser();\n      } else if (__USE_M2TS_ADVANCED_CODECS__ && codec === 'hevc') {\n        this.videoParser = new HevcVideoParser();\n      }\n    }\n  }\n\n  private decrypt(\n    demuxResult: DemuxerResult,\n    sampleAes: SampleAesDecrypter,\n  ): Promise<DemuxerResult> {\n    return new Promise((resolve) => {\n      const { audioTrack, videoTrack } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(\n          (audioTrack as DemuxedAAC).samples,\n          0,\n          () => {\n            if (videoTrack.samples) {\n              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n                resolve(demuxResult);\n              });\n            } else {\n              resolve(demuxResult);\n            }\n          },\n        );\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n\n  public destroy() {\n    if (this.observer) {\n      this.observer.removeAllListeners();\n    }\n    // @ts-ignore\n    this.config = this.logger = this.observer = null;\n    this.aacOverFlow =\n      this.videoParser =\n      this.remainderData =\n      this.sampleAes =\n        null;\n    this._videoTrack =\n      this._audioTrack =\n      this._id3Track =\n      this._txtTrack =\n        undefined;\n  }\n\n  private parseAACPES(track: DemuxedAudioTrack, pes: PES) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(\n          data.subarray(0, frameMissingBytes),\n          frameOverflowBytes,\n        );\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset: number;\n    let len: number;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (ADTS.isHeader(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason: string;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      emitParsingError(\n        this.observer,\n        new Error(reason),\n        recoverable,\n        this.logger,\n      );\n      if (!recoverable) {\n        return;\n      }\n    }\n\n    ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n\n    let pts: number;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = ADTS.getFrameDuration(track.samplerate as number);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      this.logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (ADTS.isHeader(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n\n  private parseMPEGPES(track: DemuxedAudioTrack, pes: PES) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      this.logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n\n    while (offset < length) {\n      if (MpegAudio.isHeader(data, offset)) {\n        const frame = MpegAudio.appendFrame(\n          track,\n          data,\n          offset,\n          pts,\n          frameIndex,\n        );\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n\n  private parseAC3PES(track: DemuxedAudioTrack, pes: PES) {\n    if (__USE_M2TS_ADVANCED_CODECS__) {\n      const data = pes.data;\n      const pts = pes.pts;\n      if (pts === undefined) {\n        this.logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n        return;\n      }\n      const length = data.length;\n      let frameIndex = 0;\n      let offset = 0;\n      let parsed;\n\n      while (\n        offset < length &&\n        (parsed = AC3.appendFrame(track, data, offset, pts, frameIndex++)) > 0\n      ) {\n        offset += parsed;\n      }\n    }\n  }\n\n  private parseID3PES(id3Track: DemuxedMetadataTrack, pes: PES) {\n    if (pes.pts === undefined) {\n      this.logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = Object.assign({}, pes as Required<PES>, {\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY,\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\n\nfunction parsePID(data: Uint8Array, offset: number): number {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\n\nfunction parsePAT(data: Uint8Array, offset: number): number {\n  // skip the PSI header and parse the first PMT entry\n  return ((data[offset + 10] & 0x1f) << 8) | data[offset + 11];\n}\n\nfunction parsePMT(\n  data: Uint8Array,\n  offset: number,\n  typeSupported: TypeSupported,\n  isSampleAes: boolean,\n  observer: HlsEventEmitter,\n  logger: ILogger,\n) {\n  const result = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: 'avc' as 'avc' | 'hevc',\n    segmentAudioCodec: 'aac' as 'aac' | 'ac3' | 'mp3',\n  };\n  const sectionLength = ((data[offset + 1] & 0x0f) << 8) | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength =\n    ((data[offset + 10] & 0x0f) << 8) | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    const esInfoLength = ((data[offset + 3] & 0x0f) << 8) | data[offset + 4];\n    switch (data[offset]) {\n      case 0xcf: // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC', logger);\n          break;\n        }\n      /* falls through */\n      case 0x0f: // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audioPid === -1) {\n          result.audioPid = pid;\n        }\n\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3Pid === -1) {\n          result.id3Pid = pid;\n        }\n\n        break;\n\n      case 0xdb: // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('H.264', logger);\n          break;\n        }\n      /* falls through */\n      case 0x1b: // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.videoPid === -1) {\n          result.videoPid = pid;\n        }\n\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audioPid === -1) {\n          result.audioPid = pid;\n          result.segmentAudioCodec = 'mp3';\n        }\n        break;\n\n      case 0xc1: // SAMPLE-AES AC3\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3', logger);\n          break;\n        }\n      /* falls through */\n      case 0x81:\n        if (__USE_M2TS_ADVANCED_CODECS__) {\n          if (!typeSupported.ac3) {\n            logger.log('AC-3 audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'ac3';\n          }\n        } else {\n          logger.warn('AC-3 in M2TS support not included in build');\n        }\n        break;\n\n      case 0x06:\n        // stream_type 6 can mean a lot of different things in case of DVB.\n        // We need to look at the descriptors. Right now, we're only interested\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\n        // an audio PID yet.\n        if (result.audioPid === -1 && esInfoLength > 0) {\n          let parsePos = offset + 5;\n          let remaining = esInfoLength;\n\n          while (remaining > 2) {\n            const descriptorId = data[parsePos];\n\n            switch (descriptorId) {\n              case 0x6a: // DVB Descriptor for AC-3\n                if (__USE_M2TS_ADVANCED_CODECS__) {\n                  if (typeSupported.ac3 !== true) {\n                    logger.log(\n                      'AC-3 audio found, not supported in this browser for now',\n                    );\n                  } else {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = 'ac3';\n                  }\n                } else {\n                  logger.warn('AC-3 in M2TS support not included in build');\n                }\n                break;\n            }\n\n            const descriptorLen = data[parsePos + 1] + 2;\n            parsePos += descriptorLen;\n            remaining -= descriptorLen;\n          }\n        }\n        break;\n\n      case 0xc2: // SAMPLE-AES EC3\n      /* falls through */\n      case 0x87:\n        emitParsingError(\n          observer,\n          new Error('Unsupported EC-3 in M2TS found'),\n          undefined,\n          logger,\n        );\n        return result;\n\n      case 0x24: // ITU-T Rec. H.265 and ISO/IEC 23008-2 (HEVC)\n        if (__USE_M2TS_ADVANCED_CODECS__) {\n          if (result.videoPid === -1) {\n            result.videoPid = pid;\n            result.segmentVideoCodec = 'hevc';\n            logger.log('HEVC in M2TS found');\n          }\n        } else {\n          emitParsingError(\n            observer,\n            new Error('Unsupported HEVC in M2TS found'),\n            undefined,\n            logger,\n          );\n          return result;\n        }\n        break;\n\n      default:\n        // logger.log('unknown stream type:' + data[offset]);\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += esInfoLength + 5;\n  }\n  return result;\n}\n\nfunction emitParsingError(\n  observer: HlsEventEmitter,\n  error: Error,\n  levelRetry: boolean | undefined,\n  logger: ILogger,\n) {\n  logger.warn(`parsing error: ${error.message}`);\n  observer.emit(Events.ERROR, Events.ERROR, {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_PARSING_ERROR,\n    fatal: false,\n    levelRetry,\n    error,\n    reason: error.message,\n  });\n}\n\nfunction logEncryptedSamplesFoundInUnencryptedStream(\n  type: string,\n  logger: ILogger,\n) {\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\n\nfunction parsePES(stream: ElementaryStreamData, logger: ILogger): PES | null {\n  let i = 0;\n  let frag: Uint8Array;\n  let pesLen: number;\n  let pesHdrLen: number;\n  let pesPts: number | undefined;\n  let pesDts: number | undefined;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    data[0] = appendUint8Array(data[0], data[1]);\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts =\n        (frag[9] & 0x0e) * 536870912 + // 1 << 29\n        (frag[10] & 0xff) * 4194304 + // 1 << 22\n        (frag[11] & 0xfe) * 16384 + // 1 << 14\n        (frag[12] & 0xff) * 128 + // 1 << 7\n        (frag[13] & 0xfe) / 2;\n\n      if (pesFlags & 0x40) {\n        pesDts =\n          (frag[14] & 0x0e) * 536870912 + // 1 << 29\n          (frag[15] & 0xff) * 4194304 + // 1 << 22\n          (frag[16] & 0xfe) * 16384 + // 1 << 14\n          (frag[17] & 0xff) * 128 + // 1 << 7\n          (frag[18] & 0xfe) / 2;\n\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(\n            `${Math.round(\n              (pesPts - pesDts) / 90000,\n            )}s delta between PTS and DTS, align them`,\n          );\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\n  }\n  return null;\n}\n\nexport default TSDemuxer;\n","/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(\n    codec?: string,\n    channelCount?: number,\n  ): Uint8Array | undefined {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80,\n          ]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e,\n          ]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38,\n          ]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38,\n          ]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0,\n          ]);\n        }\n\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\nexport default AAC;\n","/**\n * Generate MP4 Box\n */\n\nimport { appendUint8Array } from '../utils/mp4-tools';\nimport type {\n  DemuxedAC3,\n  DemuxedAudioTrack,\n  DemuxedAVC1,\n  DemuxedHEVC,\n  DemuxedVideoTrack,\n} from '../types/demuxer';\nimport type {\n  Mp4SampleFlags,\n  RemuxedAudioTrackSamples,\n  RemuxedVideoTrackSamples,\n} from '../types/remuxer';\n\ntype MediaTrackType = DemuxedAudioTrack | DemuxedVideoTrack;\ntype RemuxedTrackType = RemuxedAudioTrackSamples | RemuxedVideoTrackSamples;\n\ntype HdlrTypes = {\n  video: Uint8Array;\n  audio: Uint8Array;\n};\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4 {\n  public static types: Record<string, number[]>;\n  private static HDLR_TYPES: HdlrTypes;\n  private static STTS: Uint8Array;\n  private static STSC: Uint8Array;\n  private static STCO: Uint8Array;\n  private static STSZ: Uint8Array;\n  private static VMHD: Uint8Array;\n  private static SMHD: Uint8Array;\n  private static STSD: Uint8Array;\n  private static FTYP: Uint8Array;\n  private static DINF: Uint8Array;\n\n  static init() {\n    MP4.types = {\n      avc1: [], // codingname\n      avcC: [],\n      hvc1: [],\n      hvcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      dac3: [],\n      'ac-3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: [],\n    };\n\n    let i: string;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [\n          i.charCodeAt(0),\n          i.charCodeAt(1),\n          i.charCodeAt(2),\n          i.charCodeAt(3),\n        ];\n      }\n    }\n\n    const videoHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x76,\n      0x69,\n      0x64,\n      0x65, // handler_type: 'vide'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x56,\n      0x69,\n      0x64,\n      0x65,\n      0x6f,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'VideoHandler'\n    ]);\n\n    const audioHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x73,\n      0x6f,\n      0x75,\n      0x6e, // handler_type: 'soun'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x53,\n      0x6f,\n      0x75,\n      0x6e,\n      0x64,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr,\n    };\n\n    const dref = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x01, // entry_count\n      0x00,\n      0x00,\n      0x00,\n      0x0c, // entry_size\n      0x75,\n      0x72,\n      0x6c,\n      0x20, // 'url' type\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x01, // entry_flags\n    ]);\n\n    const stco = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n    MP4.STSZ = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // sample_size\n      0x00,\n      0x00,\n      0x00,\n      0x00, // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x01, // flags\n      0x00,\n      0x00, // graphicsmode\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00, // balance\n      0x00,\n      0x00, // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x01,\n    ]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n    MP4.FTYP = MP4.box(\n      MP4.types.ftyp,\n      majorBrand,\n      minorVersion,\n      majorBrand,\n      avc1Brand,\n    );\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n\n  static box(type: number[], ...payload: Uint8Array[]) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    const result = new Uint8Array(size);\n    result[0] = (size >> 24) & 0xff;\n    result[1] = (size >> 16) & 0xff;\n    result[2] = (size >> 8) & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n\n  static hdlr(type: keyof HdlrTypes) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n\n  static mdat(data: Uint8Array) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n\n  static mdhd(timescale: number, duration: number) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(\n      MP4.types.mdhd,\n      new Uint8Array([\n        0x01, // version 1\n        0x00,\n        0x00,\n        0x00, // flags\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x02, // creation_time\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x03, // modification_time\n        (timescale >> 24) & 0xff,\n        (timescale >> 16) & 0xff,\n        (timescale >> 8) & 0xff,\n        timescale & 0xff, // timescale\n        upperWordDuration >> 24,\n        (upperWordDuration >> 16) & 0xff,\n        (upperWordDuration >> 8) & 0xff,\n        upperWordDuration & 0xff,\n        lowerWordDuration >> 24,\n        (lowerWordDuration >> 16) & 0xff,\n        (lowerWordDuration >> 8) & 0xff,\n        lowerWordDuration & 0xff,\n        0x55,\n        0xc4, // 'und' language (undetermined)\n        0x00,\n        0x00,\n      ]),\n    );\n  }\n\n  static mdia(track: MediaTrackType) {\n    return MP4.box(\n      MP4.types.mdia,\n      MP4.mdhd(track.timescale || 0, track.duration || 0),\n      MP4.hdlr(track.type),\n      MP4.minf(track),\n    );\n  }\n\n  static mfhd(sequenceNumber: number) {\n    return MP4.box(\n      MP4.types.mfhd,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00,\n        0x00, // flags\n        sequenceNumber >> 24,\n        (sequenceNumber >> 16) & 0xff,\n        (sequenceNumber >> 8) & 0xff,\n        sequenceNumber & 0xff, // sequence_number\n      ]),\n    );\n  }\n\n  static minf(track: MediaTrackType) {\n    if (track.type === 'audio') {\n      return MP4.box(\n        MP4.types.minf,\n        MP4.box(MP4.types.smhd, MP4.SMHD),\n        MP4.DINF,\n        MP4.stbl(track),\n      );\n    } else {\n      return MP4.box(\n        MP4.types.minf,\n        MP4.box(MP4.types.vmhd, MP4.VMHD),\n        MP4.DINF,\n        MP4.stbl(track),\n      );\n    }\n  }\n\n  static moof(\n    sn: number,\n    baseMediaDecodeTime: number,\n    track: RemuxedTrackType,\n  ) {\n    return MP4.box(\n      MP4.types.moof,\n      MP4.mfhd(sn),\n      MP4.traf(track, baseMediaDecodeTime),\n    );\n  }\n\n  static moov(tracks: MediaTrackType[]) {\n    let i = tracks.length;\n    const boxes: Uint8Array[] = [];\n\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n\n    return MP4.box.apply(\n      null,\n      [\n        MP4.types.moov,\n        MP4.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0),\n      ]\n        .concat(boxes)\n        .concat(MP4.mvex(tracks)),\n    );\n  }\n\n  static mvex(tracks: MediaTrackType[]) {\n    let i = tracks.length;\n    const boxes: Uint8Array[] = [];\n\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n\n  static mvhd(timescale: number, duration: number) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([\n      0x01, // version 1\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x02, // creation_time\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x03, // modification_time\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      upperWordDuration >> 24,\n      (upperWordDuration >> 16) & 0xff,\n      (upperWordDuration >> 8) & 0xff,\n      upperWordDuration & 0xff,\n      lowerWordDuration >> 24,\n      (lowerWordDuration >> 16) & 0xff,\n      (lowerWordDuration >> 8) & 0xff,\n      lowerWordDuration & 0xff,\n      0x00,\n      0x01,\n      0x00,\n      0x00, // 1.0 rate\n      0x01,\n      0x00, // 1.0 volume\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x40,\n      0x00,\n      0x00,\n      0x00, // transformation: unity matrix\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0xff,\n      0xff,\n      0xff,\n      0xff, // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n\n  static sdtp(track: RemuxedTrackType) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i: number;\n    let flags: Mp4SampleFlags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] =\n        (flags.dependsOn << 4) |\n        (flags.isDependedOn << 2) |\n        flags.hasRedundancy;\n    }\n\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n\n  static stbl(track: MediaTrackType) {\n    return MP4.box(\n      MP4.types.stbl,\n      MP4.stsd(track),\n      MP4.box(MP4.types.stts, MP4.STTS),\n      MP4.box(MP4.types.stsc, MP4.STSC),\n      MP4.box(MP4.types.stsz, MP4.STSZ),\n      MP4.box(MP4.types.stco, MP4.STCO),\n    );\n  }\n\n  static avc1(track: DemuxedAVC1) {\n    let sps: number[] = [];\n    let pps: number[] = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push((len >>> 8) & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push((len >>> 8) & 0xff);\n      pps.push(len & 0xff);\n\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    const avcc = MP4.box(\n      MP4.types.avcC,\n      new Uint8Array(\n        [\n          0x01, // version\n          sps[3], // profile\n          sps[4], // profile compat\n          sps[5], // level\n          0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n          0xe0 | track.sps.length, // 3bit reserved (111) + numOfSequenceParameterSets\n        ]\n          .concat(sps)\n          .concat([\n            track.pps.length, // numOfPictureParameterSets\n          ])\n          .concat(pps),\n      ),\n    ); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n\n    return MP4.box(\n      MP4.types.avc1,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00, // pre_defined\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // pre_defined\n        (width >> 8) & 0xff,\n        width & 0xff, // width\n        (height >> 8) & 0xff,\n        height & 0xff, // height\n        0x00,\n        0x48,\n        0x00,\n        0x00, // horizresolution\n        0x00,\n        0x48,\n        0x00,\n        0x00, // vertresolution\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // frame_count\n        0x12,\n        0x64,\n        0x61,\n        0x69,\n        0x6c, // dailymotion/hls.js\n        0x79,\n        0x6d,\n        0x6f,\n        0x74,\n        0x69,\n        0x6f,\n        0x6e,\n        0x2f,\n        0x68,\n        0x6c,\n        0x73,\n        0x2e,\n        0x6a,\n        0x73,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // compressorname\n        0x00,\n        0x18, // depth = 24\n        0x11,\n        0x11,\n      ]), // pre_defined = -1\n      avcc,\n      MP4.box(\n        MP4.types.btrt,\n        new Uint8Array([\n          0x00,\n          0x1c,\n          0x9c,\n          0x80, // bufferSizeDB\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0, // maxBitrate\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0,\n        ]),\n      ), // avgBitrate\n      MP4.box(\n        MP4.types.pasp,\n        new Uint8Array([\n          hSpacing >> 24, // hSpacing\n          (hSpacing >> 16) & 0xff,\n          (hSpacing >> 8) & 0xff,\n          hSpacing & 0xff,\n          vSpacing >> 24, // vSpacing\n          (vSpacing >> 16) & 0xff,\n          (vSpacing >> 8) & 0xff,\n          vSpacing & 0xff,\n        ]),\n      ),\n    );\n  }\n\n  static esds(track: DemuxedAudioTrack) {\n    const config = track.config as [number, number];\n    return new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n\n      0x03, // descriptor_type\n      0x19, // length\n\n      0x00,\n      0x01, // es_id\n\n      0x00, // stream_priority\n\n      0x04, // descriptor_type\n      0x11, // length\n      0x40, // codec : mpeg4_audio\n      0x15, // stream_type\n      0x00,\n      0x00,\n      0x00, // buffer_size\n      0x00,\n      0x00,\n      0x00,\n      0x00, // maxBitrate\n      0x00,\n      0x00,\n      0x00,\n      0x00, // avgBitrate\n\n      0x05, // descriptor_type\n      0x02, // length\n      ...config,\n      0x06,\n      0x01,\n      0x02, // GASpecificConfig)); // length + audio config descriptor\n    ]);\n  }\n\n  static audioStsd(track: DemuxedAudioTrack) {\n    const samplerate = track.samplerate || 0;\n    return new Uint8Array([\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x01, // data_reference_index\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      track.channelCount || 0, // channelcount\n      0x00,\n      0x10, // sampleSize:16bits\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved2\n      (samplerate >> 8) & 0xff,\n      samplerate & 0xff, //\n      0x00,\n      0x00,\n    ]);\n  }\n\n  static mp4a(track: DemuxedAudioTrack) {\n    return MP4.box(\n      MP4.types.mp4a,\n      MP4.audioStsd(track),\n      MP4.box(MP4.types.esds, MP4.esds(track)),\n    );\n  }\n\n  static mp3(track: DemuxedAudioTrack) {\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n  }\n\n  static ac3(track: DemuxedAudioTrack) {\n    return MP4.box(\n      MP4.types['ac-3'],\n      MP4.audioStsd(track),\n      MP4.box(MP4.types.dac3, track.config as Uint8Array),\n    );\n  }\n\n  static stsd(track: MediaTrackType | DemuxedAC3): Uint8Array {\n    const { segmentCodec } = track;\n    if (track.type === 'audio') {\n      if (segmentCodec === 'aac') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      }\n      if (\n        __USE_M2TS_ADVANCED_CODECS__ &&\n        segmentCodec === 'ac3' &&\n        track.config\n      ) {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n      }\n      if (segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n    } else {\n      if (track.pps && track.sps) {\n        if (segmentCodec === 'avc') {\n          return MP4.box(\n            MP4.types.stsd,\n            MP4.STSD,\n            MP4.avc1(track as DemuxedAVC1),\n          );\n        }\n        if (\n          __USE_M2TS_ADVANCED_CODECS__ &&\n          segmentCodec === 'hevc' &&\n          track.vps\n        ) {\n          return MP4.box(\n            MP4.types.stsd,\n            MP4.STSD,\n            MP4.hvc1(track as DemuxedHEVC),\n          );\n        }\n      } else {\n        throw new Error(`video track missing pps or sps`);\n      }\n    }\n\n    throw new Error(\n      `unsupported ${track.type} segment codec (${segmentCodec}/${track.codec})`,\n    );\n  }\n\n  static tkhd(track: MediaTrackType) {\n    const id = track.id;\n    const duration = (track.duration || 0) * (track.timescale || 0);\n    const width = (track as any).width || 0;\n    const height = (track as any).height || 0;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(\n      MP4.types.tkhd,\n      new Uint8Array([\n        0x01, // version 1\n        0x00,\n        0x00,\n        0x07, // flags\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x02, // creation_time\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x03, // modification_time\n        (id >> 24) & 0xff,\n        (id >> 16) & 0xff,\n        (id >> 8) & 0xff,\n        id & 0xff, // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        upperWordDuration >> 24,\n        (upperWordDuration >> 16) & 0xff,\n        (upperWordDuration >> 8) & 0xff,\n        upperWordDuration & 0xff,\n        lowerWordDuration >> 24,\n        (lowerWordDuration >> 16) & 0xff,\n        (lowerWordDuration >> 8) & 0xff,\n        lowerWordDuration & 0xff,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00, // layer\n        0x00,\n        0x00, // alternate_group\n        0x00,\n        0x00, // non-audio track volume\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x40,\n        0x00,\n        0x00,\n        0x00, // transformation: unity matrix\n        (width >> 8) & 0xff,\n        width & 0xff,\n        0x00,\n        0x00, // width\n        (height >> 8) & 0xff,\n        height & 0xff,\n        0x00,\n        0x00, // height\n      ]),\n    );\n  }\n\n  static traf(track: RemuxedTrackType, baseMediaDecodeTime: number) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(\n      baseMediaDecodeTime / (UINT32_MAX + 1),\n    );\n    const lowerWordBaseMediaDecodeTime = Math.floor(\n      baseMediaDecodeTime % (UINT32_MAX + 1),\n    );\n    return MP4.box(\n      MP4.types.traf,\n      MP4.box(\n        MP4.types.tfhd,\n        new Uint8Array([\n          0x00, // version 0\n          0x00,\n          0x00,\n          0x00, // flags\n          id >> 24,\n          (id >> 16) & 0xff,\n          (id >> 8) & 0xff,\n          id & 0xff, // track_ID\n        ]),\n      ),\n      MP4.box(\n        MP4.types.tfdt,\n        new Uint8Array([\n          0x01, // version 1\n          0x00,\n          0x00,\n          0x00, // flags\n          upperWordBaseMediaDecodeTime >> 24,\n          (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n          (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n          upperWordBaseMediaDecodeTime & 0xff,\n          lowerWordBaseMediaDecodeTime >> 24,\n          (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n          (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n          lowerWordBaseMediaDecodeTime & 0xff,\n        ]),\n      ),\n      MP4.trun(\n        track,\n        sampleDependencyTable.length +\n          16 + // tfhd\n          20 + // tfdt\n          8 + // traf header\n          16 + // mfhd\n          8 + // moof header\n          8,\n      ), // mdat header\n      sampleDependencyTable,\n    );\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track: MediaTrackType) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n\n  static trex(track: MediaTrackType) {\n    const id = track.id;\n    return MP4.box(\n      MP4.types.trex,\n      new Uint8Array([\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x00, // flags\n        id >> 24,\n        (id >> 16) & 0xff,\n        (id >> 8) & 0xff,\n        id & 0xff, // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x01, // default_sample_description_index\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_duration\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_size\n        0x00,\n        0x01,\n        0x00,\n        0x01, // default_sample_flags\n      ]),\n    );\n  }\n\n  static trun(track: MediaTrackType, offset: number) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set(\n      [\n        track.type === 'video' ? 0x01 : 0x00, // version 1 for video with signed-int sample_composition_time_offset\n        0x00,\n        0x0f,\n        0x01, // flags\n        (len >>> 24) & 0xff,\n        (len >>> 16) & 0xff,\n        (len >>> 8) & 0xff,\n        len & 0xff, // sample_count\n        (offset >>> 24) & 0xff,\n        (offset >>> 16) & 0xff,\n        (offset >>> 8) & 0xff,\n        offset & 0xff, // data_offset\n      ],\n      0,\n    );\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set(\n        [\n          (duration >>> 24) & 0xff,\n          (duration >>> 16) & 0xff,\n          (duration >>> 8) & 0xff,\n          duration & 0xff, // sample_duration\n          (size >>> 24) & 0xff,\n          (size >>> 16) & 0xff,\n          (size >>> 8) & 0xff,\n          size & 0xff, // sample_size\n          (flags.isLeading << 2) | flags.dependsOn,\n          (flags.isDependedOn << 6) |\n            (flags.hasRedundancy << 4) |\n            (flags.paddingValue << 1) |\n            flags.isNonSync,\n          flags.degradPrio & (0xf0 << 8),\n          flags.degradPrio & 0x0f, // sample_flags\n          (cts >>> 24) & 0xff,\n          (cts >>> 16) & 0xff,\n          (cts >>> 8) & 0xff,\n          cts & 0xff, // sample_composition_time_offset\n        ],\n        12 + 16 * i,\n      );\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n\n  static initSegment(tracks: MediaTrackType[]) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n\n    const movie = MP4.moov(tracks);\n    const result = appendUint8Array(MP4.FTYP, movie);\n    return result;\n  }\n\n  static hvc1(track: DemuxedHEVC) {\n    if (!__USE_M2TS_ADVANCED_CODECS__) {\n      return new Uint8Array();\n    }\n    const ps = track.params;\n    const units: Uint8Array[][] = [track.vps, track.sps, track.pps];\n    const NALuLengthSize = 4;\n    const config = new Uint8Array([\n      0x01,\n      (ps.general_profile_space << 6) |\n        (ps.general_tier_flag ? 32 : 0) |\n        ps.general_profile_idc,\n      ps.general_profile_compatibility_flags[0],\n      ps.general_profile_compatibility_flags[1],\n      ps.general_profile_compatibility_flags[2],\n      ps.general_profile_compatibility_flags[3],\n      ps.general_constraint_indicator_flags[0],\n      ps.general_constraint_indicator_flags[1],\n      ps.general_constraint_indicator_flags[2],\n      ps.general_constraint_indicator_flags[3],\n      ps.general_constraint_indicator_flags[4],\n      ps.general_constraint_indicator_flags[5],\n      ps.general_level_idc,\n      240 | (ps.min_spatial_segmentation_idc >> 8),\n      255 & ps.min_spatial_segmentation_idc,\n      252 | ps.parallelismType,\n      252 | ps.chroma_format_idc,\n      248 | ps.bit_depth_luma_minus8,\n      248 | ps.bit_depth_chroma_minus8,\n      0x00,\n      parseInt(ps.frame_rate.fps),\n      (NALuLengthSize - 1) |\n        (ps.temporal_id_nested << 2) |\n        (ps.num_temporal_layers << 3) |\n        (ps.frame_rate.fixed ? 64 : 0),\n      units.length,\n    ]);\n\n    // compute hvcC size in bytes\n    let length = config.length;\n    for (let i = 0; i < units.length; i += 1) {\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        length += 2 + units[i][j].length;\n      }\n    }\n\n    const hvcC = new Uint8Array(length);\n    hvcC.set(config, 0);\n    length = config.length;\n    // append parameter set units: one vps, one or more sps and pps\n    const iMax = units.length - 1;\n    for (let i = 0; i < units.length; i += 1) {\n      hvcC.set(\n        new Uint8Array([\n          (32 + i) | (i === iMax ? 128 : 0),\n          0x00,\n          units[i].length,\n        ]),\n        length,\n      );\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        hvcC.set(\n          new Uint8Array([units[i][j].length >> 8, units[i][j].length & 255]),\n          length,\n        );\n        length += 2;\n        hvcC.set(units[i][j], length);\n        length += units[i][j].length;\n      }\n    }\n    const hvcc = MP4.box(MP4.types.hvcC, hvcC);\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n\n    return MP4.box(\n      MP4.types.hvc1,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00, // pre_defined\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // pre_defined\n        (width >> 8) & 0xff,\n        width & 0xff, // width\n        (height >> 8) & 0xff,\n        height & 0xff, // height\n        0x00,\n        0x48,\n        0x00,\n        0x00, // horizresolution\n        0x00,\n        0x48,\n        0x00,\n        0x00, // vertresolution\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // frame_count\n        0x12,\n        0x64,\n        0x61,\n        0x69,\n        0x6c, // dailymotion/hls.js\n        0x79,\n        0x6d,\n        0x6f,\n        0x74,\n        0x69,\n        0x6f,\n        0x6e,\n        0x2f,\n        0x68,\n        0x6c,\n        0x73,\n        0x2e,\n        0x6a,\n        0x73,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // compressorname\n        0x00,\n        0x18, // depth = 24\n        0x11,\n        0x11,\n      ]), // pre_defined = -1\n      hvcc,\n      MP4.box(\n        MP4.types.btrt,\n        new Uint8Array([\n          0x00,\n          0x1c,\n          0x9c,\n          0x80, // bufferSizeDB\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0, // maxBitrate\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0,\n        ]),\n      ), // avgBitrate\n      MP4.box(\n        MP4.types.pasp,\n        new Uint8Array([\n          hSpacing >> 24, // hSpacing\n          (hSpacing >> 16) & 0xff,\n          (hSpacing >> 8) & 0xff,\n          hSpacing & 0xff,\n          vSpacing >> 24, // vSpacing\n          (vSpacing >> 16) & 0xff,\n          (vSpacing >> 8) & 0xff,\n          vSpacing & 0xff,\n        ]),\n      ),\n    );\n  }\n}\n\nexport default MP4;\n","import type { LoaderConfig } from '../config';\nimport type { HlsUrlParameters, Level } from './level';\nimport type { MediaPlaylist } from './media-playlist';\nimport type { Fragment } from '../loader/fragment';\nimport type { Part } from '../loader/fragment';\nimport type { KeyLoaderInfo } from '../loader/key-loader';\nimport type { LevelDetails } from '../loader/level-details';\n\nexport interface LoaderContext {\n  // target URL\n  url: string;\n  // loader response type (arraybuffer or default response type for playlist)\n  responseType: string;\n  // headers\n  headers?: Record<string, string>;\n  // start byte range offset\n  rangeStart?: number;\n  // end byte range offset\n  rangeEnd?: number;\n  // true if onProgress should report partial chunk of loaded content\n  progressData?: boolean;\n}\n\nexport interface FragmentLoaderContext extends LoaderContext {\n  frag: Fragment;\n  part: Part | null;\n  resetIV?: boolean;\n}\n\nexport interface KeyLoaderContext extends LoaderContext {\n  keyInfo: KeyLoaderInfo;\n  frag: Fragment;\n}\n\nexport interface LoaderConfiguration {\n  // LoaderConfig policy that overrides required settings\n  loadPolicy: LoaderConfig;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxNumRetry\n   */\n  // Max number of load retries\n  maxRetry: number;\n  /**\n   * @deprecated use LoaderConfig maxTimeToFirstByteMs and maxLoadTimeMs\n   */\n  // Timeout after which `onTimeOut` callback will be triggered\n  //  when loading has not finished after that delay\n  timeout: number;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry retryDelayMs\n   */\n  // Delay between an I/O error and following connection retry (ms).\n  // This to avoid spamming the server\n  retryDelay: number;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxRetryDelayMs\n   */\n  // max connection retry delay (ms)\n  maxRetryDelay: number;\n  // When streaming progressively, this is the minimum chunk size required to emit a PROGRESS event\n  highWaterMark?: number;\n}\n\nexport interface LoaderResponse {\n  url: string;\n  data?: string | ArrayBuffer | Object;\n  // Errors can include HTTP status code and error message\n  // Successful responses should include status code 200\n  code?: number;\n  text?: string;\n}\n\nexport interface LoaderStats {\n  aborted: boolean;\n  loaded: number;\n  retry: number;\n  total: number;\n  chunkCount: number;\n  bwEstimate: number;\n  loading: HlsProgressivePerformanceTiming;\n  parsing: HlsPerformanceTiming;\n  buffering: HlsProgressivePerformanceTiming;\n}\n\nexport interface HlsPerformanceTiming {\n  start: number;\n  end: number;\n}\n\nexport interface HlsChunkPerformanceTiming extends HlsPerformanceTiming {\n  executeStart: number;\n  executeEnd: number;\n}\n\nexport interface HlsProgressivePerformanceTiming extends HlsPerformanceTiming {\n  first: number;\n}\n\nexport type LoaderOnSuccess<T extends LoaderContext> = (\n  response: LoaderResponse,\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any,\n) => void;\n\nexport type LoaderOnProgress<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  data: string | ArrayBuffer,\n  networkDetails: any,\n) => void;\n\nexport type LoaderOnError<T extends LoaderContext> = (\n  error: {\n    // error status code\n    code: number;\n    // error description\n    text: string;\n  },\n  context: T,\n  networkDetails: any,\n  stats: LoaderStats,\n) => void;\n\nexport type LoaderOnTimeout<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any,\n) => void;\n\nexport type LoaderOnAbort<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any,\n) => void;\n\nexport interface LoaderCallbacks<T extends LoaderContext> {\n  onSuccess: LoaderOnSuccess<T>;\n  onError: LoaderOnError<T>;\n  onTimeout: LoaderOnTimeout<T>;\n  onAbort?: LoaderOnAbort<T>;\n  onProgress?: LoaderOnProgress<T>;\n}\n\nexport interface Loader<T extends LoaderContext> {\n  destroy(): void;\n  abort(): void;\n  load(\n    context: T,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<T>,\n  ): void;\n  /**\n   * `getCacheAge()` is called by hls.js to get the duration that a given object\n   * has been sitting in a cache proxy when playing live.  If implemented,\n   * this should return a value in seconds.\n   *\n   * For HTTP based loaders, this should return the contents of the \"age\" header.\n   *\n   * @returns time object being lodaded\n   */\n  getCacheAge?: () => number | null;\n  getResponseHeader?: (name: string) => string | null;\n  context: T | null;\n  stats: LoaderStats;\n}\n\nexport const enum PlaylistContextType {\n  MANIFEST = 'manifest',\n  LEVEL = 'level',\n  AUDIO_TRACK = 'audioTrack',\n  SUBTITLE_TRACK = 'subtitleTrack',\n}\n\nexport const enum PlaylistLevelType {\n  MAIN = 'main',\n  AUDIO = 'audio',\n  SUBTITLE = 'subtitle',\n}\n\nexport interface PlaylistLoaderContext extends LoaderContext {\n  type: PlaylistContextType;\n  // the level index to load\n  level: number | null;\n  // level or track id from LevelLoadingData / TrackLoadingData\n  id: number | null;\n  // Media Playlist Group ID\n  groupId?: string;\n  // Content Steering Pathway ID (or undefined for default Pathway \".\")\n  pathwayId?: string;\n  // internal representation of a parsed m3u8 level playlist\n  levelDetails?: LevelDetails;\n  // Blocking playlist request delivery directives (or null id none were added to playlist url\n  deliveryDirectives: HlsUrlParameters | null;\n  // Reference to level or track object in hls.levels, hls.allAudioTracks, or hls.allSubtitleTracks (null when loading MVP)\n  levelOrTrack: Level | MediaPlaylist | null;\n}\n","const MPEG_TS_CLOCK_FREQ_HZ = 90000;\n\nexport type RationalTimestamp = {\n  baseTime: number; // ticks\n  timescale: number; // ticks per second\n};\n\nexport type TimestampOffset = RationalTimestamp & { trackId: number };\n\nexport function toTimescaleFromBase(\n  baseTime: number,\n  destScale: number,\n  srcBase: number = 1,\n  round: boolean = false,\n): number {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\n\nexport function toTimescaleFromScale(\n  baseTime: number,\n  destScale: number,\n  srcScale: number = 1,\n  round: boolean = false,\n): number {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\n\nexport function toMsFromMpegTsClock(\n  baseTime: number,\n  round: boolean = false,\n): number {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\n\nexport function toMpegTsClockFromTimescale(\n  baseTime: number,\n  srcScale: number = 1,\n): number {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nexport function timestampToString(timestamp: TimestampOffset): string {\n  const { baseTime, timescale, trackId } = timestamp;\n  return `${baseTime / timescale} (${baseTime}/${timescale}) trackId: ${trackId}`;\n}\n","import AAC from './aac-helper';\nimport MP4 from './mp4-generator';\nimport { ErrorDetails, ErrorTypes } from '../errors';\nimport { Events } from '../events';\nimport { PlaylistLevelType } from '../types/loader';\nimport { type ILogger, Logger } from '../utils/logger';\nimport {\n  timestampToString,\n  toMsFromMpegTsClock,\n} from '../utils/timescale-conversion';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type { SourceBufferName } from '../types/buffer';\nimport type {\n  AudioSample,\n  DemuxedAudioTrack,\n  DemuxedMetadataTrack,\n  DemuxedUserdataTrack,\n  DemuxedVideoTrack,\n  VideoSample,\n} from '../types/demuxer';\nimport type {\n  InitSegmentData,\n  Mp4Sample,\n  RemuxedMetadata,\n  RemuxedTrack,\n  RemuxedUserdata,\n  Remuxer,\n  RemuxerResult,\n} from '../types/remuxer';\nimport type { TrackSet } from '../types/track';\nimport type { TypeSupported } from '../utils/codecs';\nimport type {\n  RationalTimestamp,\n  TimestampOffset,\n} from '../utils/timescale-conversion';\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\n\nlet chromeVersion: number | null = null;\nlet safariWebkitVersion: number | null = null;\n\nfunction createMp4Sample(\n  isKeyframe: boolean,\n  duration: number,\n  size: number,\n  cts: number,\n): Mp4Sample {\n  return {\n    duration,\n    size,\n    cts,\n    flags: {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1,\n    },\n  };\n}\nexport default class MP4Remuxer extends Logger implements Remuxer {\n  private readonly observer: HlsEventEmitter;\n  private readonly config: HlsConfig;\n  private readonly typeSupported: TypeSupported;\n  private ISGenerated: boolean = false;\n  private _initPTS: TimestampOffset | null = null;\n  private _initDTS: TimestampOffset | null = null;\n  private nextVideoTs: number | null = null;\n  private nextAudioTs: number | null = null;\n  private videoSampleDuration: number | null = null;\n  private isAudioContiguous: boolean = false;\n  private isVideoContiguous: boolean = false;\n  private videoTrackConfig?: {\n    width?: number;\n    height?: number;\n    pixelRatio?: [number, number];\n  };\n\n  constructor(\n    observer: HlsEventEmitter,\n    config: HlsConfig,\n    typeSupported: TypeSupported,\n    logger: ILogger,\n  ) {\n    super('mp4-remuxer', logger);\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n\n  destroy() {\n    // @ts-ignore\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n\n  resetTimeStamp(defaultTimeStamp: TimestampOffset | null) {\n    const initPTS = this._initPTS;\n    if (\n      !initPTS ||\n      !defaultTimeStamp ||\n      defaultTimeStamp.trackId !== initPTS.trackId ||\n      defaultTimeStamp.baseTime !== initPTS.baseTime ||\n      defaultTimeStamp.timescale !== initPTS.timescale\n    ) {\n      this.log(\n        `Reset initPTS: ${initPTS ? timestampToString(initPTS) : initPTS} > ${defaultTimeStamp ? timestampToString(defaultTimeStamp) : defaultTimeStamp}`,\n      );\n    }\n\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n\n  resetNextTimestamp() {\n    this.log('reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n\n  resetInitSegment() {\n    this.log('ISGenerated flag reset');\n    this.ISGenerated = false;\n    this.videoTrackConfig = undefined;\n  }\n\n  getVideoStartPts(videoSamples: VideoSample[]) {\n    // Get the minimum PTS value relative to the first sample's PTS, normalized for 33-bit wrapping\n    let rolloverDetected = false;\n    const firstPts = videoSamples[0].pts;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      let pts = sample.pts;\n      let delta = pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        pts = normalizePts(pts, firstPts);\n        delta = pts - minPTS;\n      }\n      if (delta > 0) {\n        return minPTS;\n      }\n      return pts;\n    }, firstPts);\n    if (rolloverDetected) {\n      this.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n\n  remux(\n    audioTrack: DemuxedAudioTrack,\n    videoTrack: DemuxedVideoTrack,\n    id3Track: DemuxedMetadataTrack,\n    textTrack: DemuxedUserdataTrack,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    flush: boolean,\n    playlistType: PlaylistLevelType,\n  ): RemuxerResult {\n    let video: RemuxedTrack | undefined;\n    let audio: RemuxedTrack | undefined;\n    let initSegment: InitSegmentData | undefined;\n    let text: RemuxedUserdata | undefined;\n    let id3: RemuxedMetadata | undefined;\n    let independent: boolean | undefined;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = (flush && length > 0) || length > 1;\n    const canRemuxAvc =\n      ((!hasAudio || enoughAudioSamples) &&\n        (!hasVideo || enoughVideoSamples)) ||\n      this.ISGenerated ||\n      flush;\n\n    if (canRemuxAvc) {\n      if (this.ISGenerated) {\n        const config = this.videoTrackConfig;\n        if (\n          (config &&\n            (videoTrack.width !== config.width ||\n              videoTrack.height !== config.height ||\n              videoTrack.pixelRatio?.[0] !== config.pixelRatio?.[0] ||\n              videoTrack.pixelRatio?.[1] !== config.pixelRatio?.[1])) ||\n          (!config && enoughVideoSamples) ||\n          (this.nextAudioTs === null && enoughAudioSamples)\n        ) {\n          this.resetInitSegment();\n        }\n      }\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(\n          audioTrack,\n          videoTrack,\n          timeOffset,\n          accurateTimeOffset,\n        );\n      }\n\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            this.warn(\n              `Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`,\n            );\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset +=\n              (videoTrack.samples[0].pts - startPTS) /\n              videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            this.warn(`No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta =\n            normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            this.warn('regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(\n              audioTrack,\n              videoTrack,\n              timeOffset,\n              accurateTimeOffset,\n            );\n          }\n          audio = this.remuxAudio(\n            audioTrack,\n            audioTimeOffset,\n            this.isAudioContiguous,\n            accurateTimeOffset,\n            hasVideo ||\n              enoughVideoSamples ||\n              playlistType === PlaylistLevelType.AUDIO\n              ? videoTimeOffset\n              : undefined,\n          );\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              this.warn('regenerate InitSegment as video detected');\n              initSegment = this.generateIS(\n                audioTrack,\n                videoTrack,\n                timeOffset,\n                accurateTimeOffset,\n              );\n            }\n            video = this.remuxVideo(\n              videoTrack,\n              videoTimeOffset,\n              isVideoContiguous,\n              audioTrackLength,\n            );\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(\n            videoTrack,\n            videoTimeOffset,\n            isVideoContiguous,\n            0,\n          );\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(\n          id3Track,\n          timeOffset,\n          this._initPTS,\n          this._initDTS,\n        );\n      }\n\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(\n          textTrack,\n          timeOffset,\n          this._initPTS,\n        );\n      }\n    }\n\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3,\n    };\n  }\n\n  computeInitPts(\n    basetime: number,\n    timescale: number,\n    presentationTime: number,\n    type: 'audio' | 'video',\n  ): number {\n    const offset = Math.round(presentationTime * timescale);\n    let timestamp = normalizePts(basetime, offset);\n    if (timestamp < offset + timescale) {\n      this.log(\n        `Adjusting PTS for rollover in timeline near ${(offset - timestamp) / timescale} ${type}`,\n      );\n      while (timestamp < offset + timescale) {\n        timestamp += 8589934592;\n      }\n    }\n    return timestamp - offset;\n  }\n\n  generateIS(\n    audioTrack: DemuxedAudioTrack,\n    videoTrack: DemuxedVideoTrack,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n  ): InitSegmentData | undefined {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks: TrackSet = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS: number | undefined;\n    let initDTS: number | undefined;\n    let timescale: number | undefined;\n    let trackId: number = -1;\n\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n\n        case 'ac3':\n          audioTrack.codec = 'ac-3';\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment:\n          audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg\n            ? new Uint8Array(0)\n            : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount,\n        },\n      };\n      if (computePTSDTS) {\n        trackId = audioTrack.id;\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = this.computeInitPts(\n            audioSamples[0].pts,\n            timescale,\n            timeOffset,\n            'audio',\n          );\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height,\n        },\n      };\n      if (computePTSDTS) {\n        trackId = videoTrack.id;\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const basePTS = this.getVideoStartPts(videoSamples);\n          const baseDTS = normalizePts(videoSamples[0].dts, basePTS);\n          const videoInitDTS = this.computeInitPts(\n            baseDTS,\n            timescale,\n            timeOffset,\n            'video',\n          );\n          const videoInitPTS = this.computeInitPts(\n            basePTS,\n            timescale,\n            timeOffset,\n            'video',\n          );\n          initDTS = Math.min(initDTS as number, videoInitDTS);\n          initPTS = Math.min(initPTS as number, videoInitPTS);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n      this.videoTrackConfig = {\n        width: videoTrack.width,\n        height: videoTrack.height,\n        pixelRatio: videoTrack.pixelRatio,\n      };\n    }\n\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        if (_initPTS) {\n          this.warn(\n            `Timestamps at playlist time: ${accurateTimeOffset ? '' : '~'}${timeOffset} ${initPTS! / timescale!} != initPTS: ${_initPTS.baseTime / _initPTS.timescale} (${_initPTS.baseTime}/${_initPTS.timescale}) trackId: ${_initPTS.trackId}`,\n          );\n        }\n        this.log(\n          `Found initPTS at playlist time: ${timeOffset} offset: ${initPTS! / timescale!} (${initPTS}/${timescale}) trackId: ${trackId}`,\n        );\n        this._initPTS = {\n          baseTime: initPTS as number,\n          timescale: timescale as number,\n          trackId: trackId as number,\n        };\n        this._initDTS = {\n          baseTime: initDTS as number,\n          timescale: timescale as number,\n          trackId: trackId as number,\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n\n      return {\n        tracks,\n        initPTS,\n        timescale,\n        trackId,\n      };\n    }\n  }\n\n  remuxVideo(\n    track: DemuxedVideoTrack,\n    timeOffset: number,\n    contiguous: boolean,\n    audioTrackLength: number,\n  ): RemuxedTrack | undefined {\n    const timeScale: number = track.inputTimeScale;\n    const inputSamples: Array<VideoSample> = track.samples;\n    const outputSamples: Array<Mp4Sample> = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS as RationalTimestamp;\n    const initTime = (initPTS.baseTime * timeScale) / initPTS.timescale;\n    let nextVideoTs = this.nextVideoTs;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS: number = Number.POSITIVE_INFINITY;\n    let maxPTS: number = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextVideoTs === null) {\n      const pts = initTime + timeOffset * timeScale;\n      const cts =\n        inputSamples[0].pts -\n        normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      if (\n        chromeVersion &&\n        nextVideoTs !== null &&\n        Math.abs(pts - cts - (nextVideoTs + initTime)) < 15000\n      ) {\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n        contiguous = true;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextVideoTs = pts - cts - initTime;\n      }\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const nextVideoPts = nextVideoTs + initTime;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts, nextVideoPts);\n      sample.dts = normalizePts(sample.dts, nextVideoPts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration\n      ? Math.round(inputDuration / (nbSamples - 1))\n      : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextVideoPts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          this.warn(\n            `${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(\n              delta,\n              true,\n            )} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(\n              3,\n            )}`,\n          );\n        } else {\n          this.warn(\n            `${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(\n              -delta,\n              true,\n            )} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(\n              3,\n            )}`,\n          );\n        }\n        if (\n          !foundOverlap ||\n          nextVideoPts >= inputSamples[0].pts ||\n          chromeVersion\n        ) {\n          firstDTS = nextVideoPts;\n          const firstPTS = inputSamples[0].pts - delta;\n          if (foundHole) {\n            inputSamples[0].dts = firstDTS;\n            inputSamples[0].pts = firstPTS;\n          } else {\n            let isPTSOrderRetained = true;\n            for (let i = 0; i < inputSamples.length; i++) {\n              if (inputSamples[i].dts > firstPTS && isPTSOrderRetained) {\n                break;\n              }\n\n              const prevPTS = inputSamples[i].pts;\n              inputSamples[i].dts -= delta;\n              inputSamples[i].pts -= delta;\n\n              // check to see if this sample's PTS order has changed\n              // relative to the next one\n              if (i < inputSamples.length - 1) {\n                const nextSamplePTS = inputSamples[i + 1].pts;\n                const currentSamplePTS = inputSamples[i].pts;\n\n                const currentOrder = nextSamplePTS <= currentSamplePTS;\n                const prevOrder = nextSamplePTS <= prevPTS;\n\n                isPTSOrderRetained = currentOrder == prevOrder;\n              }\n            }\n          }\n          this.log(\n            `Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(\n              firstPTS,\n              true,\n            )}/${toMsFromMpegTsClock(\n              firstDTS,\n              true,\n            )}, delta: ${toMsFromMpegTsClock(delta, true)} ms`,\n          );\n        }\n      }\n    }\n\n    firstDTS = Math.max(0, firstDTS);\n\n    let nbNalu = 0;\n    let naluLen = 0;\n    let dtsStep = firstDTS;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      if (sample.dts < dtsStep) {\n        sample.dts = dtsStep;\n        dtsStep += (averageSampleDuration / 4) | 0 || 1;\n      } else {\n        dtsStep = sample.dts;\n      }\n\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`,\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const VideoSample = inputSamples[i];\n      const VideoSampleUnits = VideoSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\n        const unit = VideoSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration =\n          i > 0\n            ? VideoSample.dts - inputSamples[i - 1].dts\n            : averageSampleDuration;\n        ptsDelta =\n          i > 0\n            ? VideoSample.pts - inputSamples[i - 1].pts\n            : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioTs !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd =\n            (audioTrackLength\n              ? minPTS + audioTrackLength * timeScale\n              : this.nextAudioTs + initTime) - VideoSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            this.log(\n              `It is approximately ${\n                deltaToFrameEnd / 90\n              } ms to the next segment; using duration ${\n                mp4SampleDuration / 90\n              } ms for the last video frame.`,\n            );\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(\n        VideoSample.pts - VideoSample.dts,\n      );\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n\n      outputSamples.push(\n        createMp4Sample(\n          VideoSample.key,\n          mp4SampleDuration,\n          mp4SampleLength,\n          compositionTimeOffset,\n        ),\n      );\n    }\n\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (\n          maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta &&\n          averageSampleDuration / maxDtsDelta < 0.025 &&\n          outputSamples[0].cts === 0\n        ) {\n          this.warn(\n            'Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.',\n          );\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i\n                ? outputSamples[i - 1].duration\n                : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC/HEVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration =\n      stretchedLastFrame || !mp4SampleDuration\n        ? averageSampleDuration\n        : mp4SampleDuration;\n    const endDTS = lastDTS + mp4SampleDuration;\n    this.nextVideoTs = nextVideoTs = endDTS - initTime;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(\n      track.sequenceNumber++,\n      firstDTS,\n      Object.assign(track, {\n        samples: outputSamples,\n      }),\n    );\n    const type: SourceBufferName = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: (minPTS - initTime) / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration - initTime) / timeScale,\n      startDTS: (firstDTS - initTime) / timeScale,\n      endDTS: nextVideoTs / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped,\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n\n  getSamplesPerFrame(track: DemuxedAudioTrack) {\n    switch (track.segmentCodec) {\n      case 'mp3':\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\n      case 'ac3':\n        return AC3_SAMPLES_PER_FRAME;\n      default:\n        return AAC_SAMPLES_PER_FRAME;\n    }\n  }\n\n  remuxAudio(\n    track: DemuxedAudioTrack,\n    timeOffset: number,\n    contiguous: boolean,\n    accurateTimeOffset: boolean,\n    videoTimeOffset?: number,\n  ): RemuxedTrack | undefined {\n    const inputTimeScale: number = track.inputTimeScale;\n    const mp4timeScale: number = track.samplerate\n      ? track.samplerate\n      : inputTimeScale;\n    const scaleFactor: number = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration: number = this.getSamplesPerFrame(track);\n    const inputSampleDuration: number = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS as RationalTimestamp;\n    const rawMPEG: boolean =\n      track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples: Array<Mp4Sample> = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n\n    let inputSamples: Array<AudioSample> = track.samples;\n    let offset: number = rawMPEG ? 0 : 8;\n    let nextAudioTs: number = this.nextAudioTs || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const initTime = (initPTS.baseTime * inputTimeScale) / initPTS.timescale;\n    const timeOffsetMpegTS = initTime + timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous =\n      contiguous ||\n      ((inputSamples.length &&\n        nextAudioTs > 0 &&\n        ((accurateTimeOffset &&\n          Math.abs(timeOffsetMpegTS - (nextAudioTs + initTime)) < 9000) ||\n          Math.abs(\n            normalizePts(inputSamples[0].pts, timeOffsetMpegTS) -\n              (nextAudioTs + initTime),\n          ) <\n            20 * inputSampleDuration)) as boolean);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts, timeOffsetMpegTS);\n    });\n\n    if (!contiguous || nextAudioTs < 0) {\n      const sampleCount = inputSamples.length;\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter((sample) => sample.pts >= 0);\n\n      if (sampleCount !== inputSamples.length) {\n        this.warn(\n          `Removed ${inputSamples.length - sampleCount} of ${sampleCount} samples (initPTS ${initTime} / ${inputTimeScale})`,\n        );\n      }\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n\n      if (videoTimeOffset === 0) {\n        // Set the start to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioTs = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioTs = Math.max(0, timeOffsetMpegTS - initTime);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioTs = inputSamples[0].pts - initTime;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (\n        let i = 0, nextPts = nextAudioTs + initTime;\n        i < inputSamples.length;\n        i++\n      ) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs((1000 * delta) / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (\n          delta <= -maxAudioFramesDrift * inputSampleDuration &&\n          alignedWithVideo\n        ) {\n          if (i === 0) {\n            this.warn(\n              `Audio frame @ ${(pts / inputTimeScale).toFixed(\n                3,\n              )}s overlaps marker by ${Math.round(\n                (1000 * delta) / inputTimeScale,\n              )} ms.`,\n            );\n            this.nextAudioTs = nextAudioTs = pts - initTime;\n            nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (\n          delta >= maxAudioFramesDrift * inputSampleDuration &&\n          duration < MAX_SILENT_FRAME_DURATION &&\n          alignedWithVideo\n        ) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          while (nextPts < 0 && missing && inputSampleDuration) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioTs = nextAudioTs = nextPts - initTime;\n          }\n          this.warn(\n            `Injecting ${missing} audio frames @ ${(\n              (nextPts - initTime) /\n              inputTimeScale\n            ).toFixed(3)}s due to ${Math.round(\n              (1000 * delta) / inputTimeScale,\n            )} ms gap.`,\n          );\n          for (let j = 0; j < missing; j++) {\n            let fillFrame = AAC.getSilentFrame(\n              track.parsedCodec || track.manifestCodec || track.codec,\n              track.channelCount,\n            );\n            if (!fillFrame) {\n              this.log(\n                'Unable to get silent frame for given audio codec; duplicating last frame instead.',\n              );\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: nextPts,\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS: number | null = null;\n    let lastPTS: number | null = null;\n    let mdat: any;\n    let mdatSize: number = 0;\n    let sampleLength: number = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioTs + initTime;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`,\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    nextAudioTs = (lastPTS as number) - initTime;\n    this.nextAudioTs = nextAudioTs + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG\n      ? new Uint8Array(0)\n      : MP4.moof(\n          track.sequenceNumber++,\n          firstPTS! / scaleFactor,\n          Object.assign({}, track, { samples: outputSamples }),\n        );\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = (firstPTS! - initTime) / inputTimeScale;\n    const end = nextAudioTs / inputTimeScale;\n    const type: SourceBufferName = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples,\n    };\n\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n}\n\nexport function normalizePts(value: number, reference: number | null): number {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n\n  return value;\n}\n\nfunction findKeyframeIndex(samples: Array<VideoSample>): number {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function flushTextTrackMetadataCueSamples(\n  track: DemuxedMetadataTrack,\n  timeOffset: number,\n  initPTS: TimestampOffset,\n  initDTS: TimestampOffset,\n): RemuxedMetadata | undefined {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts =\n      normalizePts(\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\n        timeOffset * inputTimeScale,\n      ) / inputTimeScale;\n    sample.dts =\n      normalizePts(\n        sample.dts - (initDTS.baseTime * inputTimeScale) / initDTS.timescale,\n        timeOffset * inputTimeScale,\n      ) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples,\n  };\n}\n\nexport function flushTextTrackUserdataCueSamples(\n  track: DemuxedUserdataTrack,\n  timeOffset: number,\n  initPTS: RationalTimestamp,\n): RemuxedUserdata | undefined {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts =\n      normalizePts(\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\n        timeOffset * inputTimeScale,\n      ) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples,\n  };\n}\n","import type { BaseTrackSet } from '../types/buffer';\n\nexport function getMediaSource(\n  preferManagedMediaSource = true,\n): typeof MediaSource | undefined {\n  if (typeof self === 'undefined') return undefined;\n  const mms =\n    (preferManagedMediaSource || !self.MediaSource) &&\n    ((self as any).ManagedMediaSource as undefined | typeof MediaSource);\n  return (\n    mms ||\n    self.MediaSource ||\n    ((self as any).WebKitMediaSource as typeof MediaSource)\n  );\n}\n\nexport function isManagedMediaSource(source: typeof MediaSource | undefined) {\n  return (\n    typeof self !== 'undefined' && source === (self as any).ManagedMediaSource\n  );\n}\n\nexport function isCompatibleTrackChange(\n  currentTracks: BaseTrackSet,\n  requiredTracks: BaseTrackSet,\n): boolean {\n  const trackNames = Object.keys(currentTracks);\n  const requiredTrackNames = Object.keys(requiredTracks);\n  const trackCount = trackNames.length;\n  const requiredTrackCount = requiredTrackNames.length;\n  return (\n    !trackCount ||\n    !requiredTrackCount ||\n    (trackCount === requiredTrackCount &&\n      !trackNames.some((name) => requiredTrackNames.indexOf(name) === -1))\n  );\n}\n","import { getMediaSource } from './mediasource-helper';\nimport { isHEVC } from './mp4-tools';\n\nexport const userAgentHevcSupportIsInaccurate = () => {\n  return /\\(Windows.+Firefox\\//i.test(navigator.userAgent);\n};\n\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nexport const sampleEntryCodesISO = {\n  audio: {\n    a3ds: 1,\n    'ac-3': 0.95,\n    'ac-4': 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    'dts+': 1,\n    'dts-': 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    'ec-3': 0.9,\n    enca: 1,\n    fLaC: 0.9, // MP4-RA listed codec entry for FLAC\n    flac: 0.9, // legacy browser codec name for FLAC\n    FLAC: 0.9, // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    'raw ': 1,\n    Opus: 1,\n    opus: 1, // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1,\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    dav1: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    'vc-1': 1,\n    vp08: 1,\n    vp09: 0.9,\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1,\n  },\n} as const;\n\nexport type CodecType = 'audio' | 'video';\n\nexport function isCodecType(codec: string, type: CodecType): boolean {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\n\nexport function areCodecsMediaSourceSupported(\n  codecs: string,\n  type: CodecType,\n  preferManagedMediaSource = true,\n): boolean {\n  return !codecs\n    .split(',')\n    .some(\n      (codec) =>\n        !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource),\n    );\n}\n\nfunction isCodecMediaSourceSupported(\n  codec: string,\n  type: CodecType,\n  preferManagedMediaSource = true,\n): boolean {\n  const MediaSource = getMediaSource(preferManagedMediaSource);\n  return MediaSource?.isTypeSupported(mimeTypeForCodec(codec, type)) ?? false;\n}\n\nexport function mimeTypeForCodec(codec: string, type: CodecType): string {\n  return `${type}/mp4;codecs=${codec}`;\n}\n\nexport function videoCodecPreferenceValue(\n  videoCodec: string | undefined,\n): number {\n  if (videoCodec) {\n    const fourCC = videoCodec.substring(0, 4);\n    return sampleEntryCodesISO.video[fourCC];\n  }\n  return 2;\n}\n\nexport function codecsSetSelectionPreferenceValue(codecSet: string): number {\n  const limitedHevcSupport = userAgentHevcSupportIsInaccurate();\n  return codecSet.split(',').reduce((num, fourCC) => {\n    const lowerPriority = limitedHevcSupport && isHEVC(fourCC);\n    const preferenceValue = lowerPriority\n      ? 9\n      : sampleEntryCodesISO.video[fourCC];\n    if (preferenceValue) {\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\n    }\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n  }, 0);\n}\n\ninterface CodecNameCache {\n  flac?: string;\n  opus?: string;\n}\n\nconst CODEC_COMPATIBLE_NAMES: CodecNameCache = {};\n\ntype LowerCaseCodecType = 'flac' | 'opus';\n\nfunction getCodecCompatibleNameLower(\n  lowerCaseCodec: LowerCaseCodecType,\n  preferManagedMediaSource = true,\n): string {\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec]!;\n  }\n\n  const codecsToCheck = {\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    flac: ['flac', 'fLaC', 'FLAC'],\n    opus: ['opus', 'Opus'],\n    // Replace audio codec info if browser does not support mp4a.40.34,\n    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs=\"mp3\"'\n    'mp4a.40.34': ['mp3'],\n  }[lowerCaseCodec];\n\n  for (let i = 0; i < codecsToCheck.length; i++) {\n    if (\n      isCodecMediaSourceSupported(\n        codecsToCheck[i],\n        'audio',\n        preferManagedMediaSource,\n      )\n    ) {\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n      return codecsToCheck[i];\n    } else if (\n      codecsToCheck[i] === 'mp3' &&\n      getMediaSource(preferManagedMediaSource)?.isTypeSupported('audio/mpeg')\n    ) {\n      return '';\n    }\n  }\n\n  return lowerCaseCodec;\n}\n\nconst AUDIO_CODEC_REGEXP = /flac|opus|mp4a\\.40\\.34/i;\nexport function getCodecCompatibleName(\n  codec: string,\n  preferManagedMediaSource = true,\n): string {\n  return codec.replace(AUDIO_CODEC_REGEXP, (m) =>\n    getCodecCompatibleNameLower(\n      m.toLowerCase() as LowerCaseCodecType,\n      preferManagedMediaSource,\n    ),\n  );\n}\n\nexport function replaceVideoCodec(\n  originalCodecs: string | undefined,\n  newVideoCodec: string | undefined,\n): string | undefined {\n  const codecs: string[] = [];\n  if (originalCodecs) {\n    const allCodecs = originalCodecs.split(',');\n    for (let i = 0; i < allCodecs.length; i++) {\n      if (!isCodecType(allCodecs[i], 'video')) {\n        codecs.push(allCodecs[i]);\n      }\n    }\n  }\n  if (newVideoCodec) {\n    codecs.push(newVideoCodec);\n  }\n  return codecs.join(',');\n}\n\nexport function pickMostCompleteCodecName(\n  parsedCodec: string | undefined,\n  levelCodec: string | undefined,\n): string | undefined {\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n  // so use level codec is parsed codec is unavailable or incomplete\n  if (\n    parsedCodec &&\n    (parsedCodec.length > 4 ||\n      ['ac-3', 'ec-3', 'alac', 'fLaC', 'Opus'].indexOf(parsedCodec) !== -1)\n  ) {\n    if (\n      isCodecSupportedAsType(parsedCodec, 'audio') ||\n      isCodecSupportedAsType(parsedCodec, 'video')\n    ) {\n      return parsedCodec;\n    }\n  }\n  if (levelCodec) {\n    const levelCodecs = levelCodec.split(',');\n    if (levelCodecs.length > 1) {\n      if (parsedCodec) {\n        for (let i = levelCodecs.length; i--; ) {\n          if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {\n            return levelCodecs[i];\n          }\n        }\n      }\n      return levelCodecs[0];\n    }\n  }\n  return levelCodec || parsedCodec;\n}\n\nfunction isCodecSupportedAsType(codec: string, type: CodecType): boolean {\n  return isCodecType(codec, type) && isCodecMediaSourceSupported(codec, type);\n}\n\nexport function convertAVC1ToAVCOTI(videoCodecs: string): string {\n  // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n  // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n  const codecs = videoCodecs.split(',');\n  for (let i = 0; i < codecs.length; i++) {\n    const avcdata = codecs[i].split('.');\n    // only convert codec strings starting with avc1 (Examples: avc1.64001f,dvh1.05.07)\n    if (avcdata.length > 2 && avcdata[0] === 'avc1') {\n      codecs[i] = `avc1.${parseInt(avcdata[1]).toString(16)}${(\n        '000' + parseInt(avcdata[2]).toString(16)\n      ).slice(-4)}`;\n    }\n  }\n  return codecs.join(',');\n}\n\nexport function fillInMissingAV01Params(videoCodec: string): string {\n  // Used to fill in incomplete AV1 playlist CODECS strings for mediaCapabilities.decodingInfo queries\n  if (videoCodec.startsWith('av01.')) {\n    const av1params = videoCodec.split('.');\n    const placeholders = ['0', '111', '01', '01', '01', '0'];\n    for (let i = av1params.length; i > 4 && i < 10; i++) {\n      av1params[i] = placeholders[i - 4];\n    }\n    return av1params.join('.');\n  }\n  return videoCodec;\n}\n\nexport interface TypeSupported {\n  mpeg: boolean;\n  mp3: boolean;\n  ac3: boolean;\n}\n\nexport function getM2TSSupportedAudioTypes(\n  preferManagedMediaSource: boolean,\n): TypeSupported {\n  const MediaSource = getMediaSource(preferManagedMediaSource) || {\n    isTypeSupported: () => false,\n  };\n  return {\n    mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n    mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n    ac3: __USE_M2TS_ADVANCED_CODECS__\n      ? MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"')\n      : false,\n  };\n}\n\nexport function getCodecsForMimeType(mimeType: string): string {\n  return mimeType.replace(/^.+codecs=[\"']?([^\"']+).*$/, '$1');\n}\n","import {\n  flushTextTrackMetadataCueSamples,\n  flushTextTrackUserdataCueSamples,\n} from './mp4-remuxer';\nimport { ElementaryStreamTypes } from '../loader/fragment';\nimport { getCodecCompatibleName } from '../utils/codecs';\nimport { type ILogger, Logger } from '../utils/logger';\nimport { patchEncyptionData } from '../utils/mp4-tools';\nimport { getSampleData, parseInitSegment } from '../utils/mp4-tools';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type { DecryptData } from '../loader/level-key';\nimport type {\n  DemuxedAudioTrack,\n  DemuxedMetadataTrack,\n  DemuxedUserdataTrack,\n  PassthroughTrack,\n} from '../types/demuxer';\nimport type {\n  InitSegmentData,\n  RemuxedTrack,\n  Remuxer,\n  RemuxerResult,\n} from '../types/remuxer';\nimport type { TrackSet } from '../types/track';\nimport type { TypeSupported } from '../utils/codecs';\nimport type { InitData, InitDataTrack, TrackTimes } from '../utils/mp4-tools';\nimport type { TimestampOffset } from '../utils/timescale-conversion';\n\nclass PassThroughRemuxer extends Logger implements Remuxer {\n  private emitInitSegment: boolean = false;\n  private audioCodec?: string;\n  private videoCodec?: string;\n  private initData?: InitData;\n  private initPTS: TimestampOffset | null = null;\n  private initTracks?: TrackSet;\n  private lastEndTime: number | null = null;\n  private isVideoContiguous: boolean = false;\n\n  constructor(\n    observer: HlsEventEmitter,\n    config: HlsConfig,\n    typeSupported: TypeSupported,\n    logger: ILogger,\n  ) {\n    super('passthrough-remuxer', logger);\n  }\n\n  public destroy() {}\n\n  public resetTimeStamp(defaultInitPTS: TimestampOffset | null) {\n    this.lastEndTime = null;\n    const initPTS = this.initPTS;\n    if (initPTS && defaultInitPTS) {\n      if (\n        initPTS.baseTime === defaultInitPTS.baseTime &&\n        initPTS.timescale === defaultInitPTS.timescale\n      ) {\n        return;\n      }\n    }\n    this.initPTS = defaultInitPTS;\n  }\n\n  public resetNextTimestamp() {\n    this.isVideoContiguous = false;\n    this.lastEndTime = null;\n  }\n\n  public resetInitSegment(\n    initSegment: Uint8Array<ArrayBuffer> | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    decryptdata: DecryptData | null,\n  ) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(initSegment, decryptdata);\n    this.emitInitSegment = true;\n  }\n\n  private generateInitSegment(\n    initSegment: Uint8Array<ArrayBuffer> | undefined,\n    decryptdata?: DecryptData | null,\n  ) {\n    let { audioCodec, videoCodec } = this;\n    if (!initSegment?.byteLength) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const { audio, video } = (this.initData = parseInitSegment(initSegment));\n\n    if (decryptdata) {\n      patchEncyptionData(initSegment, decryptdata);\n    } else {\n      const eitherTrack = audio || video;\n      if (eitherTrack?.encrypted) {\n        this.warn(\n          `Init segment with encrypted track with has no key (\"${eitherTrack.codec}\")!`,\n        );\n      }\n    }\n\n    // Get codec from initSegment\n    if (audio) {\n      audioCodec = getParsedTrackCodec(\n        audio,\n        ElementaryStreamTypes.AUDIO,\n        this,\n      );\n    }\n\n    if (video) {\n      videoCodec = getParsedTrackCodec(\n        video,\n        ElementaryStreamTypes.VIDEO,\n        this,\n      );\n    }\n\n    const tracks: TrackSet = {};\n    if (audio && video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        supplemental: video.supplemental,\n        encrypted: video.encrypted,\n        initSegment,\n        id: 'main',\n      };\n    } else if (audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        encrypted: audio.encrypted,\n        initSegment,\n        id: 'audio',\n      };\n    } else if (video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        supplemental: video.supplemental,\n        encrypted: video.encrypted,\n        initSegment,\n        id: 'main',\n      };\n    } else {\n      this.warn('initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n\n  public remux(\n    audioTrack: DemuxedAudioTrack,\n    videoTrack: PassthroughTrack,\n    id3Track: DemuxedMetadataTrack,\n    textTrack: DemuxedUserdataTrack,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n  ): RemuxerResult {\n    let { initPTS, lastEndTime } = this;\n    const result: RemuxerResult = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined,\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!Number.isFinite(lastEndTime!)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!data.length) {\n      return result;\n    }\n\n    const initSegment: InitSegmentData = {\n      initPTS: undefined,\n      timescale: undefined,\n      trackId: undefined,\n    };\n    let initData = this.initData;\n    if (!initData?.length) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!initData?.length) {\n      // We can't remux if the initSegment could not be generated\n      this.warn('Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n\n    const trackSampleData = getSampleData(data, initData, this);\n    const audioSampleTimestamps = initData.audio\n      ? trackSampleData[initData.audio.id]\n      : null;\n    const videoSampleTimestamps = initData.video\n      ? trackSampleData[initData.video.id]\n      : null;\n\n    const videoStartTime = toStartEndOrDefault(videoSampleTimestamps, Infinity);\n    const audioStartTime = toStartEndOrDefault(audioSampleTimestamps, Infinity);\n    const videoEndTime = toStartEndOrDefault(videoSampleTimestamps, 0, true);\n    const audioEndTime = toStartEndOrDefault(audioSampleTimestamps, 0, true);\n\n    let decodeTime = timeOffset;\n    let duration = 0;\n\n    const syncOnAudio =\n      audioSampleTimestamps &&\n      (!videoSampleTimestamps ||\n        (!initPTS && audioStartTime < videoStartTime) ||\n        (initPTS && initPTS.trackId === initData.audio!.id));\n    const baseOffsetSamples = syncOnAudio\n      ? audioSampleTimestamps\n      : videoSampleTimestamps;\n\n    if (baseOffsetSamples) {\n      const timescale = baseOffsetSamples.timescale;\n      const baseTime = baseOffsetSamples.start - timeOffset * timescale;\n      const trackId = syncOnAudio ? initData.audio!.id : initData.video!.id;\n\n      decodeTime = baseOffsetSamples.start / timescale;\n      duration = syncOnAudio\n        ? audioEndTime - audioStartTime\n        : videoEndTime - videoStartTime;\n\n      if (\n        (accurateTimeOffset || !initPTS) &&\n        (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) ||\n          timescale !== initPTS.timescale)\n      ) {\n        if (initPTS) {\n          this.warn(\n            `Timestamps at playlist time: ${accurateTimeOffset ? '' : '~'}${timeOffset} ${baseTime / timescale} != initPTS: ${initPTS.baseTime / initPTS.timescale} (${initPTS.baseTime}/${initPTS.timescale}) trackId: ${initPTS.trackId}`,\n          );\n        }\n        this.log(\n          `Found initPTS at playlist time: ${timeOffset} offset: ${decodeTime - timeOffset} (${baseTime}/${timescale}) trackId: ${trackId}`,\n        );\n        initPTS = null;\n        initSegment.initPTS = baseTime;\n        initSegment.timescale = timescale;\n        initSegment.trackId = trackId;\n      }\n    } else {\n      this.warn(\n        `No audio or video samples found for initPTS at playlist time: ${timeOffset}`,\n      );\n    }\n    if (!initPTS) {\n      if (\n        !initSegment.timescale ||\n        initSegment.trackId === undefined ||\n        initSegment.initPTS === undefined\n      ) {\n        this.warn('Could not set initPTS');\n        initSegment.initPTS = decodeTime;\n        initSegment.timescale = 1;\n        initSegment.trackId = -1;\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: initSegment.timescale,\n        trackId: initSegment.trackId,\n      };\n    } else {\n      initSegment.initPTS = initPTS.baseTime;\n      initSegment.timescale = initPTS.timescale;\n      initSegment.trackId = initPTS.trackId;\n    }\n\n    const startTime = decodeTime - initPTS.baseTime / initPTS.timescale;\n    const endTime = startTime + duration;\n\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      this.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n\n    let type: any = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n\n    if (hasVideo) {\n      type += 'video';\n    }\n\n    const encrypted =\n      (initData.audio ? initData.audio.encrypted : false) ||\n      (initData.video ? initData.video.encrypted : false);\n\n    const track: RemuxedTrack = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0,\n      encrypted,\n    };\n\n    result.audio = hasAudio && !hasVideo ? track : undefined;\n    result.video = hasVideo ? track : undefined;\n    const videoSampleCount = videoSampleTimestamps?.sampleCount;\n    if (videoSampleCount) {\n      const firstKeyFrame = videoSampleTimestamps.keyFrameIndex;\n      const independent = firstKeyFrame !== -1;\n      track.nb = videoSampleCount;\n      track.dropped =\n        firstKeyFrame === 0 || this.isVideoContiguous\n          ? 0\n          : independent\n            ? firstKeyFrame\n            : videoSampleCount;\n      track.independent = independent;\n      track.firstKeyFrame = firstKeyFrame;\n      if (independent && videoSampleTimestamps.keyFrameStart) {\n        track.firstKeyFramePTS =\n          (videoSampleTimestamps.keyFrameStart - initPTS.baseTime) /\n          initPTS.timescale;\n      }\n      if (!this.isVideoContiguous) {\n        result.independent = independent;\n      }\n      this.isVideoContiguous ||= independent;\n      if (track.dropped) {\n        this.warn(\n          `fmp4 does not start with IDR: firstIDR ${firstKeyFrame}/${videoSampleCount} dropped: ${track.dropped} start: ${track.firstKeyFramePTS || 'NA'}`,\n        );\n      }\n    }\n\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(\n      id3Track,\n      timeOffset,\n      initPTS,\n      initPTS,\n    );\n\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(\n        textTrack,\n        timeOffset,\n        initPTS,\n      );\n    }\n\n    return result;\n  }\n}\n\nfunction toStartEndOrDefault(\n  trackTimes: TrackTimes | null,\n  defaultValue: number,\n  end: boolean = false,\n): number {\n  return trackTimes?.start !== undefined\n    ? (trackTimes.start + (end ? trackTimes.duration : 0)) /\n        trackTimes.timescale\n    : defaultValue;\n}\n\nfunction isInvalidInitPts(\n  initPTS: TimestampOffset | null,\n  startDTS: number,\n  timeOffset: number,\n  duration: number,\n): initPTS is null {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\n\nfunction getParsedTrackCodec(\n  track: InitDataTrack,\n  type: ElementaryStreamTypes.AUDIO | ElementaryStreamTypes.VIDEO,\n  logger: ILogger,\n): string {\n  const parsedCodec = track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  if (type === ElementaryStreamTypes.AUDIO) {\n    if (\n      parsedCodec === 'ec-3' ||\n      parsedCodec === 'ac-3' ||\n      parsedCodec === 'alac'\n    ) {\n      return parsedCodec;\n    }\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n      const preferManagedMediaSource = false;\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n    }\n\n    logger.warn(`Unhandled audio codec \"${parsedCodec}\" in mp4 MAP`);\n    return parsedCodec || 'mp4a';\n  }\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  logger.warn(`Unhandled video codec \"${parsedCodec}\" in mp4 MAP`);\n  return parsedCodec || 'avc1';\n}\nexport default PassThroughRemuxer;\n","import AACDemuxer from './audio/aacdemuxer';\nimport { AC3Demuxer } from './audio/ac3-demuxer';\nimport MP3Demuxer from './audio/mp3demuxer';\nimport Decrypter from '../crypt/decrypter';\nimport MP4Demuxer from '../demux/mp4demuxer';\nimport TSDemuxer from '../demux/tsdemuxer';\nimport { ErrorDetails, ErrorTypes } from '../errors';\nimport { Events } from '../events';\nimport MP4Remuxer from '../remux/mp4-remuxer';\nimport PassThroughRemuxer from '../remux/passthrough-remuxer';\nimport { PlaylistLevelType } from '../types/loader';\nimport {\n  getAesModeFromFullSegmentMethod,\n  isFullSegmentEncryption,\n} from '../utils/encryption-methods-util';\nimport type { HlsConfig } from '../config';\nimport type { HlsEventEmitter } from '../events';\nimport type { DecryptData } from '../loader/level-key';\nimport type { Demuxer, DemuxerResult, KeyData } from '../types/demuxer';\nimport type { Remuxer } from '../types/remuxer';\nimport type { ChunkMetadata, TransmuxerResult } from '../types/transmuxer';\nimport type { TypeSupported } from '../utils/codecs';\nimport type { ILogger } from '../utils/logger';\nimport type { TimestampOffset } from '../utils/timescale-conversion';\n\nlet now: () => number;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  now = Date.now;\n}\n\ntype MuxConfig =\n  | { demux: typeof MP4Demuxer; remux: typeof PassThroughRemuxer }\n  | { demux: typeof TSDemuxer; remux: typeof MP4Remuxer }\n  | { demux: typeof AC3Demuxer; remux: typeof MP4Remuxer }\n  | { demux: typeof AACDemuxer; remux: typeof MP4Remuxer }\n  | { demux: typeof MP3Demuxer; remux: typeof MP4Remuxer };\n\nconst muxConfig: MuxConfig[] = [\n  { demux: MP4Demuxer, remux: PassThroughRemuxer },\n  { demux: TSDemuxer, remux: MP4Remuxer },\n  { demux: AACDemuxer, remux: MP4Remuxer },\n  { demux: MP3Demuxer, remux: MP4Remuxer },\n];\n\nif (__USE_M2TS_ADVANCED_CODECS__) {\n  muxConfig.splice(2, 0, { demux: AC3Demuxer, remux: MP4Remuxer });\n}\n\nexport default class Transmuxer {\n  private asyncResult: boolean = false;\n  private logger: ILogger;\n  private observer: HlsEventEmitter;\n  private typeSupported: TypeSupported;\n  private config: HlsConfig;\n  private id: PlaylistLevelType;\n  private demuxer?: Demuxer;\n  private remuxer?: Remuxer;\n  private decrypter?: Decrypter;\n  private probe!: Function;\n  private decryptionPromise: Promise<TransmuxerResult> | null = null;\n  private transmuxConfig!: TransmuxConfig;\n  private currentTransmuxState!: TransmuxState;\n\n  constructor(\n    observer: HlsEventEmitter,\n    typeSupported: TypeSupported,\n    config: HlsConfig,\n    vendor: string,\n    id: PlaylistLevelType,\n    logger: ILogger,\n  ) {\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.id = id;\n    this.logger = logger;\n  }\n\n  configure(transmuxConfig: TransmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n\n  push(\n    data: ArrayBuffer,\n    decryptdata: DecryptData | null,\n    chunkMeta: ChunkMetadata,\n    state?: TransmuxState,\n  ): TransmuxerResult | Promise<TransmuxerResult> {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n\n    let uintData: Uint8Array<ArrayBuffer> = new Uint8Array(data);\n    const { currentTransmuxState, transmuxConfig } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange,\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData,\n    } = transmuxConfig;\n\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && isFullSegmentEncryption(keyData.method)) {\n      const decrypter = this.getDecrypter();\n      const aesMode = getAesModeFromFullSegmentMethod(keyData.method);\n\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(\n          uintData,\n          keyData.key.buffer,\n          keyData.iv.buffer,\n          aesMode,\n        );\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          const data = decrypter.flush();\n          decryptedData = data ? data.buffer : data;\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.asyncResult = true;\n        this.decryptionPromise = decrypter\n          .webCryptoDecrypt(\n            uintData,\n            keyData.key.buffer,\n            keyData.iv.buffer,\n            aesMode,\n          )\n          .then((decryptedData): TransmuxerResult => {\n            // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n            // the decrypted data has been transmuxed\n            const result = this.push(\n              decryptedData,\n              null,\n              chunkMeta,\n            ) as TransmuxerResult;\n            this.decryptionPromise = null;\n            return result;\n          });\n        return this.decryptionPromise;\n      }\n    }\n\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        this.logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message,\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(\n        initSegmentData,\n        audioCodec,\n        videoCodec,\n        duration,\n        decryptdata,\n      );\n    }\n\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n\n    const result = this.transmux(\n      uintData,\n      keyData,\n      timeOffset,\n      accurateTimeOffset,\n      chunkMeta,\n    );\n    this.asyncResult = isPromise(result);\n\n    const currentState = this.currentTransmuxState;\n\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(\n    chunkMeta: ChunkMetadata,\n  ): TransmuxerResult[] | Promise<TransmuxerResult[]> {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n\n    const { decrypter, currentTransmuxState, decryptionPromise } = this;\n\n    if (decryptionPromise) {\n      this.asyncResult = true;\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n\n    const transmuxResults: TransmuxerResult[] = [];\n    const { timeOffset } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(\n          this.push(decryptedData.buffer, null, chunkMeta) as TransmuxerResult,\n        );\n      }\n    }\n\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      const emptyResults = [emptyResult(chunkMeta)];\n      if (this.asyncResult) {\n        return Promise.resolve(emptyResults);\n      }\n      return emptyResults;\n    }\n\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      this.asyncResult = true;\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then((demuxResult) => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    if (this.asyncResult) {\n      return Promise.resolve(transmuxResults);\n    }\n    return transmuxResults;\n  }\n\n  private flushRemux(\n    transmuxResults: TransmuxerResult[],\n    demuxResult: DemuxerResult,\n    chunkMeta: ChunkMetadata,\n  ) {\n    const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n    const { accurateTimeOffset, timeOffset } = this.currentTransmuxState;\n    this.logger.log(\n      `[transmuxer.ts]: Flushed ${this.id} sn: ${chunkMeta.sn}${\n        chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : ''\n      } of ${this.id === PlaylistLevelType.MAIN ? 'level' : 'track'} ${chunkMeta.level}`,\n    );\n    const remuxResult = this.remuxer!.remux(\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack,\n      timeOffset,\n      accurateTimeOffset,\n      true,\n      this.id,\n    );\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta,\n    });\n\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n\n  resetInitialTimestamp(defaultInitPts: TimestampOffset | null) {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n\n  resetContiguity() {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n\n  resetInitSegment(\n    initSegmentData: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n    decryptdata: DecryptData | null,\n  ) {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(\n      initSegmentData,\n      audioCodec,\n      videoCodec,\n      trackDuration,\n    );\n    remuxer.resetInitSegment(\n      initSegmentData,\n      audioCodec,\n      videoCodec,\n      decryptdata,\n    );\n  }\n\n  destroy(): void {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n\n  private transmux(\n    data: Uint8Array,\n    keyData: KeyData | null,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata,\n  ): TransmuxerResult | Promise<TransmuxerResult> {\n    let result: TransmuxerResult | Promise<TransmuxerResult>;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(\n        data,\n        keyData,\n        timeOffset,\n        accurateTimeOffset,\n        chunkMeta,\n      );\n    } else {\n      result = this.transmuxUnencrypted(\n        data,\n        timeOffset,\n        accurateTimeOffset,\n        chunkMeta,\n      );\n    }\n    return result;\n  }\n\n  private transmuxUnencrypted(\n    data: Uint8Array,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata,\n  ): TransmuxerResult {\n    const { audioTrack, videoTrack, id3Track, textTrack } = (\n      this.demuxer as Demuxer\n    ).demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer!.remux(\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack,\n      timeOffset,\n      accurateTimeOffset,\n      false,\n      this.id,\n    );\n    return {\n      remuxResult,\n      chunkMeta,\n    };\n  }\n\n  private transmuxSampleAes(\n    data: Uint8Array,\n    decryptData: KeyData,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata,\n  ): Promise<TransmuxerResult> {\n    return (this.demuxer as Demuxer)\n      .demuxSampleAes(data, decryptData, timeOffset)\n      .then((demuxResult) => {\n        const remuxResult = this.remuxer!.remux(\n          demuxResult.audioTrack,\n          demuxResult.videoTrack,\n          demuxResult.id3Track,\n          demuxResult.textTrack,\n          timeOffset,\n          accurateTimeOffset,\n          false,\n          this.id,\n        );\n        return {\n          remuxResult,\n          chunkMeta,\n        };\n      });\n  }\n\n  private configureTransmuxer(data: Uint8Array): void | Error {\n    const { config, observer, typeSupported } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux?.probe(data, this.logger)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer: MuxConfig['remux'] = mux.remux;\n    const Demuxer: MuxConfig['demux'] = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, this.logger);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported, this.logger);\n      this.probe = Demuxer.probe;\n    }\n  }\n\n  private needsProbing(discontinuity: boolean, trackSwitch: boolean): boolean {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n\n  private getDecrypter(): Decrypter {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\n\nfunction getEncryptionType(\n  data: Uint8Array,\n  decryptData: DecryptData | null,\n): KeyData | null {\n  let encryptionType: KeyData | null = null;\n  if (\n    data.byteLength > 0 &&\n    decryptData?.key != null &&\n    decryptData.iv !== null &&\n    decryptData.method != null\n  ) {\n    encryptionType = decryptData as KeyData;\n  }\n  return encryptionType;\n}\n\nconst emptyResult = (chunkMeta): TransmuxerResult => ({\n  remuxResult: {},\n  chunkMeta,\n});\n\nexport function isPromise<T>(p: Promise<T> | any): p is Promise<T> {\n  return 'then' in p && p.then instanceof Function;\n}\n\nexport class TransmuxConfig {\n  public audioCodec?: string;\n  public videoCodec?: string;\n  public initSegmentData?: Uint8Array;\n  public duration: number;\n  public defaultInitPts: TimestampOffset | null;\n\n  constructor(\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    initSegmentData: Uint8Array | undefined,\n    duration: number,\n    defaultInitPts?: TimestampOffset,\n  ) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\n\nexport class TransmuxState {\n  public discontinuity: boolean;\n  public contiguous: boolean;\n  public accurateTimeOffset: boolean;\n  public trackSwitch: boolean;\n  public timeOffset: number;\n  public initSegmentChange: boolean;\n\n  constructor(\n    discontinuity: boolean,\n    contiguous: boolean,\n    accurateTimeOffset: boolean,\n    trackSwitch: boolean,\n    timeOffset: number,\n    initSegmentChange: boolean,\n  ) {\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n","import { DecrypterAesMode } from '../crypt/decrypter-aes-mode';\n\nexport function isFullSegmentEncryption(method: string): boolean {\n  return (\n    method === 'AES-128' || method === 'AES-256' || method === 'AES-256-CTR'\n  );\n}\n\nexport function getAesModeFromFullSegmentMethod(\n  method: string,\n): DecrypterAesMode {\n  switch (method) {\n    case 'AES-128':\n    case 'AES-256':\n      return DecrypterAesMode.cbc;\n    case 'AES-256-CTR':\n      return DecrypterAesMode.ctr;\n    default:\n      throw new Error(`invalid full segment method ${method}`);\n  }\n}\n","import { EventEmitter } from 'eventemitter3';\nimport Transmuxer, { isPromise } from '../demux/transmuxer';\nimport { ErrorDetails, ErrorTypes } from '../errors';\nimport { Events } from '../events';\nimport { enableLogs, type ILogger } from '../utils/logger';\nimport type { RemuxedTrack, RemuxerResult } from '../types/remuxer';\nimport type { ChunkMetadata, TransmuxerResult } from '../types/transmuxer';\n\nconst transmuxers: (Transmuxer | undefined)[] = [];\n\nif (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n  startWorker();\n}\n\nfunction startWorker() {\n  self.addEventListener('message', (ev) => {\n    const data = ev.data;\n    const instanceNo = data.instanceNo;\n    if (instanceNo === undefined) {\n      return;\n    }\n    const transmuxer = transmuxers[instanceNo];\n    if (data.cmd === 'reset') {\n      delete transmuxers[data.resetNo];\n      if (transmuxer) {\n        transmuxer.destroy();\n      }\n      data.cmd = 'init';\n    }\n    if (data.cmd === 'init') {\n      const config = JSON.parse(data.config);\n      const observer = new EventEmitter();\n      observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n      observer.on(Events.ERROR, forwardMessage);\n      const logger = enableLogs(config.debug, data.id);\n      forwardWorkerLogs(logger, instanceNo);\n      transmuxers[instanceNo] = new Transmuxer(\n        observer,\n        data.typeSupported,\n        config,\n        '',\n        data.id,\n        logger,\n      );\n      forwardMessage('init', null, instanceNo);\n      return;\n    }\n    if (!transmuxer) {\n      return;\n    }\n    switch (data.cmd) {\n      case 'configure': {\n        transmuxer.configure(data.config);\n        break;\n      }\n      case 'demux': {\n        const transmuxResult: TransmuxerResult | Promise<TransmuxerResult> =\n          transmuxer.push(\n            data.data,\n            data.decryptdata,\n            data.chunkMeta,\n            data.state,\n          );\n        if (isPromise(transmuxResult)) {\n          transmuxResult\n            .then((data) => {\n              emitTransmuxComplete(self, data, instanceNo);\n            })\n            .catch((error) => {\n              forwardMessage(\n                Events.ERROR,\n                {\n                  instanceNo,\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error,\n                  err: error,\n                  reason: `transmuxer-worker push error`,\n                },\n                instanceNo,\n              );\n            });\n        } else {\n          emitTransmuxComplete(self, transmuxResult, instanceNo);\n        }\n        break;\n      }\n      case 'flush': {\n        const chunkMeta = data.chunkMeta as ChunkMetadata;\n        const transmuxResult = transmuxer.flush(chunkMeta);\n        if (isPromise(transmuxResult)) {\n          transmuxResult\n            .then((results: Array<TransmuxerResult>) => {\n              handleFlushResult(\n                self,\n                results as Array<TransmuxerResult>,\n                chunkMeta,\n                instanceNo,\n              );\n            })\n            .catch((error) => {\n              forwardMessage(\n                Events.ERROR,\n                {\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error,\n                  err: error,\n                  reason: `transmuxer-worker flush error`,\n                },\n                instanceNo,\n              );\n            });\n        } else {\n          handleFlushResult(\n            self,\n            transmuxResult as Array<TransmuxerResult>,\n            chunkMeta,\n            instanceNo,\n          );\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  });\n}\n\nfunction emitTransmuxComplete(\n  self: any,\n  transmuxResult: TransmuxerResult,\n  instanceNo: number,\n): boolean {\n  if (isEmptyResult(transmuxResult.remuxResult)) {\n    return false;\n  }\n  const transferable: Array<ArrayBuffer> = [];\n  const { audio, video } = transmuxResult.remuxResult;\n  if (audio) {\n    addToTransferable(transferable, audio);\n  }\n  if (video) {\n    addToTransferable(transferable, video);\n  }\n  self.postMessage(\n    { event: 'transmuxComplete', data: transmuxResult, instanceNo },\n    transferable,\n  );\n  return true;\n}\n\n// Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n// in order to minimize message passing overhead\nfunction addToTransferable(\n  transferable: Array<ArrayBuffer>,\n  track: RemuxedTrack,\n) {\n  if (track.data1) {\n    transferable.push(track.data1.buffer);\n  }\n  if (track.data2) {\n    transferable.push(track.data2.buffer);\n  }\n}\n\nfunction handleFlushResult(\n  self: any,\n  results: Array<TransmuxerResult>,\n  chunkMeta: ChunkMetadata,\n  instanceNo: number,\n) {\n  const parsed = results.reduce(\n    (parsed, result) =>\n      emitTransmuxComplete(self, result, instanceNo) || parsed,\n    false,\n  );\n  if (!parsed) {\n    // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n    self.postMessage({\n      event: 'transmuxComplete',\n      data: results[0],\n      instanceNo,\n    });\n  }\n  self.postMessage({ event: 'flush', data: chunkMeta, instanceNo });\n}\n\nfunction forwardMessage(event, data, instanceNo) {\n  self.postMessage({ event, data, instanceNo });\n}\n\nfunction forwardWorkerLogs(logger: ILogger, instanceNo: number) {\n  for (const logFn in logger) {\n    logger[logFn] = function () {\n      const message = Array.prototype.join.call(arguments, ' ');\n      forwardMessage(\n        'workerLog',\n        {\n          logType: logFn,\n          message,\n        },\n        instanceNo,\n      );\n    };\n  }\n}\n\nfunction isEmptyResult(remuxResult: RemuxerResult) {\n  return (\n    !remuxResult.audio &&\n    !remuxResult.video &&\n    !remuxResult.text &&\n    !remuxResult.id3 &&\n    !remuxResult.initSegment\n  );\n}\n"],"names":["has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","event","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","concat","listeners","handlers","i","l","length","ee","Array","listenerCount","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","module","isId3Footer","data","offset","isId3Header","readId3Size","size","getId3Data","front","subarray","ErrorTypes","ErrorDetails","Logger","label","logger","trace","debug","log","warn","info","error","lb","noop","bind","fakeLogger","createLogger","_extends","getLoggerFn","key","debugConfig","id","type","func","self","console","exportedLogger","isHeaderPattern","getHeaderLength","getFullFrameLength","isHeader","probe","headerLength","frameLength","newOffset","initTrackConfig","track","observer","audioCodec","samplerate","config","manifestCodec","byte2","adtsSamplingIndex","adtsObjectType","channelCount","codec","aacSampleIndex","parsedCodec","Error","ERROR","MEDIA_ERROR","details","FRAG_PARSING_ERROR","fatal","reason","message","getAudioConfig","getFrameDuration","appendFrame","pts","frameIndex","unit","stamp","header","parseFrameHeader","missing","Math","max","Uint8Array","set","sample","samples","isFiniteNumber","Number","isFinite","value","isSafeInteger","abs","MAX_SAFE_INTEGER","canParseId3","utf8ArrayToStr","array","exitOnNull","TextDecoder","decoded","decode","idx","indexOf","substring","replace","c","char2","char3","out","String","fromCharCode","toUint8","Infinity","Type","buffer","view","ArrayBuffer","unsafeGetArrayBuffer","bytesPerElement","BYTES_PER_ELEMENT","dataOffset","obj","byteLength","byteOffset","dataEnd","rawStart","start","floor","min","end","decodeId3ImageFrame","frame","metadataFrame","description","mimeType","pictureType","mimeTypeEndIndex","descriptionEndIndex","toArrayBuffer","decodeId3Frame","owner","privateData","decodeId3PrivFrame","index","url","decodeId3UrlFrame","text","decodeId3TextFrame","getId3FrameData","HEADER_FOOTER_SIZE","FRAME_SIZE","isId3TimestampFrame","readId3Timestamp","timeStampFrame","pts33Bit","timestamp","round","getId3Timestamp","frames","id3Data","frameData","getId3Frames","MetadataSchema","arrayToHex","str","h","toString","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","opts","trim","alwaysNormalize","basePartsForNormalise","parseURL","path","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","pathParts","exec","builtParts","params","query","fragment","baseURLPath","newPath","lastIndexOf","parts","split","reverse","join","ElementaryStreamTypes","UINT32_MAX","pow","RemuxerTrackIdConfig","video","audio","id3","bin2str","readUint16","val","readUint32","readSint32","readUint64","result","findBox","results","endbox","subresults","parseSegmentIndex","sidx","references","version","timescale","earliestPresentationTime","firstOffset","startByte","referencesCount","referenceIndex","referenceInfo","referenceSize","subsegmentDuration","duration","parseInitSegment","initSegment","traks","trak","tkhd","trackId","mdhd","hdlr","hdlrType","soun","vide","stsd","parseStsd","_objectSpread","forEach","trex","default","flags","supplemental","sampleEntries","sampleEntriesEnd","fourCC","encrypted","encBox","sinf","schm","frma","codecFourCC","avcCBox","toHex","parseSupplementalDoViCodec","codecBox","esdsBox","skipBERInteger","objectType","firstByte","audioObjectType","hvcCBox","profileByte","profileSpace","generalProfileIdc","profileCompat","tierFlag","levelIDC","constraintIndicator","reverse32BitInt","toUpperCase","constraintString","byte","vpcCBox","profile","level","bitDepth","addLeadingZero","av1CBox","highBitDepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","dvvCResult","dvXCBox","doViProfile","doViLevel","bytes","limit","x","num","patchEncyptionData","decryptdata","keyId","isCommonEncryption","predicate","encBoxes","isAudio","enc","tenc","parseSinf","applyToTencBoxes","tencKeyId","some","b","appendUint8Array","data1","data2","temp","parseSamples","timeOffset","seiSamples","videoData","isHEVCFlavor","map","moof","moofOffset","traf","baseTime","tfdt","tfhd","tfhdFlags","defaultSampleDuration","defaultSampleSizePresent","defaultSampleSize","defaultSampleFlagsPresent","tfhdOffset","baseCodec","isHEVC","trun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleDuration","sampleSizePresent","sampleSize","sampleFlagsPresent","sampleCompositionOffsetsPresent","compositionOffset","sampleCount","trunOffset","sampleOffset","ix","naluTotalSize","naluSize","isSEIMessage","parseSEIMessageFromNALu","naluHeader","naluType","unescapedData","headerSize","discardEPB","seiPtr","payloadType","payloadSize","leftOver","payPtr","providerCode","userStructure","userDataType","enabled","totalBytes","byteArray","uuidStrArray","userDataBytes","uuid","userData","EPBPositions","newLength","newData","sourceIndex","shift","dummyTrack","inputTimeScale","pid","sequenceNumber","dropped","BaseAudioDemuxer","_audioTrack","_id3Track","cachedData","basePTS","initPTS","lastPTS","_proto","resetInitSegment","videoCodec","trackDuration","resetTimeStamp","deaultTimestamp","resetContiguity","canParse","demux","lastDataIndex","id3Track","_isFiniteNumber","initPTSFn","dts","audioId3","POSITIVE_INFINITY","partialData","audioTrack","videoTrack","textTrack","demuxSampleAes","keyData","Promise","reject","flush","destroy","_isFiniteNumber2","chromeVersion","BitratesMap","SamplingRateMap","SamplesCoefficients","BytesInSlot","parseHeader","samplesPerFrame","sampleRate","mpegVersion","mpegLayer","bitRateIndex","sampleRateIndex","paddingBit","channelMode","bitRate","sampleCoefficient","bytesInSlot","navigator","userAgent","match","parseInt","AACDemuxer","_BaseAudioDemuxer","_this","_inheritsLoose","container","segmentCodec","MpegAudio","ADTS","canGetFrameLength","getAudioBSID","bsid","numBits","Uint32Array","mask","bits","AC3Demuxer","samplingRateCode","frameSizeCode","skipCount","lfeon","bsmod","MP3Demuxer","DecrypterAesMode","AESCrypto","subtle","iv","aesMode","aesIV","decrypt","counter","AESDecryptor","rcon","subMix","invSubMix","sBox","invSBox","ksRows","keySize","keySchedule","invKeySchedule","initTable","uint8ArrayToUint32Array_","arrayBuffer","DataView","newArray","getUint32","subMix0","subMix1","subMix2","subMix3","invSubMix0","invSubMix1","invSubMix2","invSubMix3","d","xi","sx","x2","x4","x8","t","expandKey","keyBuffer","sameKey","ksRow","invKsRow","prev","sbox","networkToHostOrderSwap","word","inputArrayBuffer","t0","t1","t2","t3","s0","s1","s2","s3","inputWords0","inputWords1","inputWords2","inputWords3","nRounds","invSBOX","initVector","initVector0","initVector1","initVector2","initVector3","inputInt32","Int32Array","outputInt32","swapWord","FastAESKey","subtleAlgoName","getSubtleAlgoName","importKey","Decrypter","_temp","_ref$removePKCS7Paddi","removePKCS7Padding","logEnabled","softwareDecrypter","fastAesKey","remainderData","currentIV","currentResult","useSoftware","enableSoftwareAES","browserCrypto","crypto","webkitSubtle","e","isSync","reset","outputBytes","paddingBytes","getUint8","resolve","dataView","isView","softwareDecrypt","decryptResult","webCryptoDecrypt","logOnce","currentChunk","getValidChunk","_this2","onWebCryptoError","then","aesKey","catch","err","splitPoint","msg","emsgSchemePattern","MP4Demuxer","txtTrack","captionTrack","initData","_initData$video","_initData$audio","hasMoofData","videoSamples","progressive","segmentedData","segmentedRange","valid","remainder","moofs","last","segmentValidRange","extractID3Track","emsgs","emsgInfo","schemeIdUri","timeScale","presentationTimeDelta","presentationTime","eventDuration","leftPresentationTime","rightPresentationTime","_isSafeInteger","payload","parseEmsg","test","getEmsgStartTime","emsg","enableEmsgKLVMetadata","startsWith","misbklv","SampleAesDecrypter","decrypter","decryptBuffer","encryptedData","decryptAacSample","sampleIndex","callback","curUnit","encryptedBuffer","decryptedBuffer","decryptedData","decryptAacSamples","getAvcEncryptedData","decodedData","encryptedDataLen","Int8Array","outputPos","inputPos","getAvcDecryptedUnit","uint8DecryptedData","decryptAvcSample","unitIndex","decryptAvcSamples","curUnits","units","BaseVideoParser","VideoSample","createVideoSample","getLastNalUnit","_VideoSample","lastUnit","pushAccessUnit","nbSamples","lastSample","parseNALu","endOfSegment","overflow","state","naluState","lastState","lastUnitStart","lastUnitType","getNALuType","ExpGolomb","bytesAvailable","bitsAvailable","loadWord","position","workingBytes","availableBytes","skipBits","count","skipBytes","readBits","valu","skipLZ","leadingZeroCount","skipUEG","skipEG","readUEG","clz","readEG","readBoolean","readUByte","readUShort","readUInt","AvcVideoParser","_BaseVideoParser","parsePES","pes","spsfound","audFound","_VideoSample2","_VideoSample3","iskey","sliceType","readSliceType","_track$pixelRatio","_track$pixelRatio2","sps","readSPS","width","height","pixelRatio","codecarray","codecstring","pps","eg","skipScalingList","reader","lastScale","nextScale","numRefFramesInPicOrderCntCycle","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","profileIdc","chromaFormatIdc","picOrderCntType","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","ceil","HevcVideoParser","_len","_key","initVPS","vps","readVPS","matchSPS","prop","codecString","pushParameterSet","readPPS","parameterSets","ebsp2rbsp","arr","dst","dstIdx","numTemporalLayers","temporalIdNested","max_sub_layers_minus1","general_profile_space","general_tier_flag","general_profile_idc","general_profile_compatibility_flags_1","general_profile_compatibility_flags_2","general_profile_compatibility_flags_3","general_profile_compatibility_flags_4","general_constraint_indicator_flags_1","general_constraint_indicator_flags_2","general_constraint_indicator_flags_3","general_constraint_indicator_flags_4","general_constraint_indicator_flags_5","general_constraint_indicator_flags_6","general_level_idc","sub_layer_profile_present_flags","sub_layer_level_present_flags","chroma_format_idc","pic_width_in_luma_samples","pic_height_in_luma_samples","conformance_window_flag","pic_left_offset","pic_right_offset","pic_top_offset","pic_bottom_offset","bit_depth_luma_minus8","bit_depth_chroma_minus8","log2_max_pic_order_cnt_lsb_minus4","sizeId","matrixId","coefNum","num_short_term_ref_pic_sets","num_delta_pocs","inter_ref_pic_set_prediction_flag","next_num_delta_pocs","used_by_curr_pic_flag","use_delta_flag","num_negative_pics","num_positive_pics","num_long_term_ref_pics_sps","min_spatial_segmentation_idc","sar_width","sar_height","fps_fixed","fps_den","fps_num","aspect_ratio_idc","nal_hrd_parameters_present_flag","vcl_hrd_parameters_present_flag","sub_pic_hrd_params_present_flag","low_delay_hrd_flag","cpb_cnt","chroma_scale_w","chroma_scale_h","profile_space_string","profile_compatibility_buf","profile_compatibility_rev","profile_compatibility_flags_string","general_profile_compatibility_flags","general_constraint_indicator_flags","bit_depth","frame_rate","fixed","fps","tiles_enabled_flag","entropy_coding_sync_enabled_flag","parallelismType","sps1","sps2","substr","PACKET_LENGTH","TSDemuxer","typeSupported","sampleAes","pmtParsed","_pmtId","_videoTrack","_txtTrack","aacOverFlow","videoParser","syncOffset","scanwindow","foundPat","packetStart","tsPackets","parsePID","createTrack","pesData","isSampleAes","videoPid","audioPid","id3Pid","audioData","unknownPID","pmtId","tsPacketErrors","stt","readyVideoParser","parseAACPES","parseMPEGPES","parseAC3PES","parseID3PES","parsePAT","parsedPIDs","parsePMT","segmentVideoCodec","segmentAudioCodec","emitParsingError","demuxResult","extractRemainingSamples","startOffset","frameMissingBytes","sampleLength","frameOverflowBytes","recoverable","frameDuration","parsed","AC3","id3Sample","tableEnd","esInfoLength","logEncryptedSamplesFoundInUnencryptedStream","mpeg","mp3","ac3","parsePos","remaining","descriptorLen","levelRetry","stream","frag","pesLen","pesHdrLen","pesPts","pesDts","splice","pesFlags","payloadStartOffset","dataLen","AAC","getSilentFrame","MP4","init","types","avc1","avcC","hvc1","hvcC","btrt","dinf","dref","esds","ftyp","mdat","mdia","mfhd","minf","moov","mp4a","dac3","mvex","mvhd","pasp","sdtp","stbl","stco","stsc","stsz","stts","vmhd","smhd","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","minorVersion","FTYP","box","DINF","upperWordDuration","lowerWordDuration","sn","baseMediaDecodeTime","tracks","boxes","dependsOn","isDependedOn","hasRedundancy","avcc","hSpacing","vSpacing","audioStsd","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","cts","arraylen","isLeading","paddingValue","isNonSync","degradPrio","movie","ps","NALuLengthSize","temporal_id_nested","num_temporal_layers","iMax","hvcc","PlaylistLevelType","toMsFromMpegTsClock","destScale","srcBase","toTimescaleFromBase","timestampToString","safariWebkitVersion","createMp4Sample","isKeyframe","MP4Remuxer","_Logger","ISGenerated","_initPTS","_initDTS","nextVideoTs","nextAudioTs","videoSampleDuration","isAudioContiguous","isVideoContiguous","videoTrackConfig","defaultTimeStamp","resetNextTimestamp","getVideoStartPts","rolloverDetected","firstPts","startPTS","reduce","minPTS","delta","normalizePts","remux","accurateTimeOffset","playlistType","independent","audioTimeOffset","videoTimeOffset","hasAudio","hasVideo","enoughAudioSamples","enoughVideoSamples","_videoTrack$pixelRati","_config$pixelRatio","_videoTrack$pixelRati2","_config$pixelRatio2","generateIS","firstKeyFramePTS","firstKeyFrameIndex","findKeyframeIndex","forceKeyFrameOnDiscontinuity","audiovideoTimestampDelta","remuxAudio","audioTrackLength","endPTS","remuxVideo","firstKeyFrame","flushTextTrackMetadataCueSamples","flushTextTrackUserdataCueSamples","computeInitPts","basetime","initDTS","audioSamples","computePTSDTS","metadata","baseDTS","videoInitDTS","videoInitPTS","keys","contiguous","firstDTS","lastDTS","inputSamples","outputSamples","initTime","mp4SampleDuration","maxPTS","NEGATIVE_INFINITY","sortSamples","nextVideoPts","sort","a","deltadts","deltapts","inputDuration","averageSampleDuration","foundHole","foundOverlap","toFixed","firstPTS","isPTSOrderRetained","prevPTS","nextSamplePTS","nbNalu","naluLen","dtsStep","nbUnits","sampleLen","mdatSize","MUX_ERROR","REMUX_ALLOC_ERROR","setUint32","stretchedLastFrame","minDtsDelta","minPtsDelta","maxDtsDelta","maxPtsDelta","VideoSampleUnits","mp4SampleLength","unitData","unitDataLen","ptsDelta","lastFrameDuration","stretchShortVideoTrack","gapTolerance","maxBufferHole","deltaToFrameEnd","compositionTimeOffset","nextDts","nextPts","endDTS","startDTS","nb","getSamplesPerFrame","scaleFactor","inputSampleDuration","rawMPEG","alignedWithVideo","timeOffsetMpegTS","filter","maxAudioFramesDrift","fillFrame","audioSample","unitLen","reference","getMediaSource","preferManagedMediaSource","MediaSource","ManagedMediaSource","WebKitMediaSource","isCodecMediaSourceSupported","_MediaSource$isTypeSu","isTypeSupported","mimeTypeForCodec","CODEC_COMPATIBLE_NAMES","AUDIO_CODEC_REGEXP","getCodecCompatibleName","m","lowerCaseCodec","codecsToCheck","flac","opus","_getMediaSource","getCodecCompatibleNameLower","toLowerCase","now","PassThroughRemuxer","emitInitSegment","initTracks","lastEndTime","defaultInitPTS","generateInitSegment","_this$initData","eitherTrack","getParsedTrackCodec","audiovideo","_initData","_initData2","trackSampleData","trafs","NaN","trackTimes","trackDefault","truns","sampleDTS","rawDuration","sampleCompositionTimeOffsetPresent","keyFrameIndex","keyFrameStart","sidxMinStart","sidxMaxEnd","sidxs","subSegmentDuration","dur","ref","_isFiniteNumber3","getSampleData","audioSampleTimestamps","videoSampleTimestamps","videoStartTime","toStartEndOrDefault","audioStartTime","videoEndTime","audioEndTime","decodeTime","syncOnAudio","baseOffsetSamples","minDuration","startTime","isInvalidInitPts","endTime","videoSampleCount","defaultValue","performance","Date","muxConfig","Transmuxer","vendor","asyncResult","demuxer","remuxer","decryptionPromise","transmuxConfig","currentTransmuxState","configure","chunkMeta","stats","transmuxing","executeStart","uintData","method","_ref","discontinuity","trackSwitch","initSegmentChange","defaultInitPts","initSegmentData","decryptData","encryptionType","getEncryptionType","getDecrypter","getAesModeFromFullSegmentMethod","part","executeEnd","emptyResult","resetMuxers","needsProbing","configureTransmuxer","resetInitialTimestamp","transmux","isPromise","currentState","transmuxResults","emptyResults","demuxResultOrPromise","flushRemux","_this$currentTransmux","remuxResult","transmuxSampleAes","transmuxUnencrypted","_demux","_this3","mux","_muxConfig$i$demux","Remuxer","Demuxer","p","Function","transmuxers","emitTransmuxComplete","transmuxResult","instanceNo","transferable","_transmuxResult$remux","addToTransferable","postMessage","handleFlushResult","forwardMessage","addEventListener","ev","transmuxer","cmd","resetNo","JSON","parse","FRAG_DECRYPTED","newLogger","enableLogs","_loop","logFn","logType","forwardWorkerLogs"],"mappings":"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ACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGF2xB,EAAIiC,WAAa,CACfnsB,MAAOisB,EACPhsB,MAAOisB,GAGT,IAAMvB,EAAO,IAAIpyB,WAAW,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,EACA,EACA,EACA,IAGImzB,EAAO,IAAInzB,WAAW,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGF2xB,EAAIkC,KAAOlC,EAAImC,KAAOnC,EAAIoC,KAAOZ,EAEjCxB,EAAIqC,KAAO,IAAIh0B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEF2xB,EAAIsC,KAAO,IAAIj0B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEF2xB,EAAIuC,KAAO,IAAIl0B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGF2xB,EAAIwC,KAAO,IAAIn0B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGF,IAAMo0B,EAAa,IAAIp0B,WAAW,CAAC,IAAK,IAAK,IAAK,MAC5Cq0B,EAAY,IAAIr0B,WAAW,CAAC,GAAI,IAAK,GAAI,KACzCs0B,EAAe,IAAIt0B,WAAW,CAAC,EAAG,EAAG,EAAG,IAE9C2xB,EAAI4C,KAAO5C,EAAI6C,IACb7C,EAAIE,MAAMS,KACV8B,EACAE,EACAF,EACAC,GAEF1C,EAAI8C,KAAO9C,EAAI6C,IAAI7C,EAAIE,MAAMM,KAAMR,EAAI6C,IAAI7C,EAAIE,MAAMO,KAAMA,GAC7D,EAAAT,EAEO6C,IAAP,SAAWv3B,GACG,IAAZ,IAAIzB,EAAO,EAACqsB,EAAAptB,UAAAZ,OADgB8mB,MAAO5mB,MAAA8tB,E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CAAG+2B,EAAIE,MAAMiB,MAAIt5B,OAAKu7B,GACjD,EAAApD,EAEOoB,KAAP,SAAYpqB,EAAmBS,GAC7BA,GAAYT,EACZ,IAAM+rB,EAAoB50B,KAAK8C,MAAMwG,GAAY9B,GAAa,IACxDqtB,EAAoB70B,KAAK8C,MAAMwG,GAAY9B,GAAa,IACxDgG,EAAQ,IAAItN,WAAW,CAC3B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACC2I,GAAa,GAAM,IACnBA,GAAa,GAAM,IACnBA,GAAa,EAAK,IACP,IAAZA,EACA+rB,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACAC,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,MAEF,OAAOhD,EAAI6C,IAAI7C,EAAIE,MAAMkB,KAAMzlB,EACjC,EAAAqkB,EAEOsB,KAAP,SAAYl1B,GACV,IAEIpE,EACA2Q,EAHEnK,EAAUpC,EAAMoC,SAAW,GAC3BmN,EAAQ,IAAItN,WAAW,EAAIG,EAAQtG,QAKzC,IAAKF,EAAI,EAAGA,EAAIwG,EAAQtG,OAAQF,IAC9B2Q,EAAQnK,EAAQxG,GAAG2Q,MACnBgD,EAAM3T,EAAI,GACP2Q,EAAM0qB,WAAa,EACnB1qB,EAAM2qB,cAAgB,EACvB3qB,EAAM4qB,cAGV,OAAOvD,EAAI6C,IAAI7C,EAAIE,MAAMoB,KAAM3lB,EACjC,EAAAqkB,EAEOuB,KAAP,SAAYn1B,GACV,OAAO4zB,EAAI6C,IACT7C,EAAIE,MAAMqB,KACVvB,EAAI3nB,KAAKjM,GACT4zB,EAAI6C,IAAI7C,EAAIE,MAAMyB,KAAM3B,EAAIkC,MAC5BlC,EAAI6C,IAAI7C,EAAIE,MAAMuB,KAAMzB,EAAImC,MAC5BnC,EAAI6C,IAAI7C,EAAIE,MAAMwB,KAAM1B,EAAIqC,MAC5BrC,EAAI6C,IAAI7C,EAAIE,MAAMsB,KAAMxB,EAAIoC,MAEhC,EAAApC,EAEOG,KAAP,SAAY/zB,GACV,IAEIpE,EACAyB,EACAZ,EAJA0rB,EAAgB,GAChBO,EAAgB,GAMpB,IAAK9sB,EAAI,EAAGA,EAAIoE,EAAMmoB,IAAIrsB,OAAQF,IAEhCa,GADAY,EAAO2C,EAAMmoB,IAAIvsB,IACN4I,WACX2jB,EAAIvtB,KAAM6B,IAAQ,EAAK,KACvB0rB,EAAIvtB,KAAW,IAAN6B,GAGT0rB,EAAMA,EAAI1sB,OAAOO,MAAMpC,UAAU2B,MAAMD,KAAK+B,IAI9C,IAAKzB,EAAI,EAAGA,EAAIoE,EAAM0oB,IAAI5sB,OAAQF,IAEhCa,GADAY,EAAO2C,EAAM0oB,IAAI9sB,IACN4I,WACXkkB,EAAI9tB,KAAM6B,IAAQ,EAAK,KACvBisB,EAAI9tB,KAAW,IAAN6B,GAETisB,EAAMA,EAAIjtB,OAAOO,MAAMpC,UAAU2B,MAAMD,KAAK+B,IAG9C,IAAM+5B,EAAOxD,EAAI6C,IACf7C,EAAIE,MAAME,KACV,IAAI/xB,WACF,CACE,EACAkmB,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAOnoB,EAAMmoB,IAAIrsB,QAEhBL,OAAO0sB,GACP1sB,OAAO,CACNuE,EAAM0oB,IAAI5sB,SAEXL,OAAOitB,KAGRL,EAAQroB,EAAMqoB,MACdC,EAAStoB,EAAMsoB,OACf+O,EAAWr3B,EAAMuoB,WAAW,GAC5B+O,EAAWt3B,EAAMuoB,WAAW,GAElC,OAAOqL,EAAI6C,IACT7C,EAAIE,MAAMC,KACV,IAAI9xB,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACComB,GAAS,EAAK,IACP,IAARA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEF8O,EACAxD,EAAI6C,IACF7C,EAAIE,MAAMK,KACV,IAAIlyB,WAAW,CACb,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGJ2xB,EAAI6C,IACF7C,EAAIE,MAAMmB,KACV,IAAIhzB,WAAW,CACbo1B,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,EACAC,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,KAIR,EAAA1D,EAEOU,KAAP,SAAYt0B,GACV,IAAMI,EAASJ,EAAMI,OACrB,OAAO,IAAI6B,WAAU,CACnB,EACA,EACA,EACA,EAEA,EACA,GAEA,EACA,EAEA,EAEA,EACA,GACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,GAAIxG,OACD2E,EAAM,CACT,EACA,EACA,IAEJ,EAAAwzB,EAEO2D,UAAP,SAAiBv3B,GACf,IAAMG,EAAaH,EAAMG,YAAc,EACvC,OAAO,IAAI8B,WAAW,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAjC,EAAMS,cAAgB,EACtB,EACA,GACA,EACA,EACA,EACA,EACCN,GAAc,EAAK,IACP,IAAbA,EACA,EACA,GAEJ,EAAAyzB,EAEOiB,KAAP,SAAY70B,GACV,OAAO4zB,EAAI6C,IACT7C,EAAIE,MAAMe,KACVjB,EAAI2D,UAAUv3B,GACd4zB,EAAI6C,IAAI7C,EAAIE,MAAMQ,KAAMV,EAAIU,KAAKt0B,IAErC,EAAA4zB,EAEOlB,IAAP,SAAW1yB,GACT,OAAO4zB,EAAI6C,IAAI7C,EAAIE,MAAM,QAASF,EAAI2D,UAAUv3B,GAClD,EAAA4zB,EAEOjB,IAAP,SAAW3yB,GACT,OAAO4zB,EAAI6C,IACT7C,EAAIE,MAAM,QACVF,EAAI2D,UAAUv3B,GACd4zB,EAAI6C,IAAI7C,EAAIE,MAAMgB,KAAM90B,EAAMI,QAElC,EAAAwzB,EAEO3nB,KAAP,SAAYjM,GACV,IAAQ6Y,EAAiB7Y,EAAjB6Y,aACR,GAAmB,UAAf7Y,EAAMd,KAAkB,CAC1B,GAAqB,QAAjB2Z,EACF,OAAO+a,EAAI6C,IAAI7C,EAAIE,MAAM7nB,KAAM2nB,EAAIwC,KAAMxC,EAAIiB,KAAK70B,IAEpD,GAEmB,QAAjB6Y,GACA7Y,EAAMI,OAEN,OAAOwzB,EAAI6C,IAAI7C,EAAIE,MAAM7nB,KAAM2nB,EAAIwC,KAAMxC,EAAIjB,IAAI3yB,IAEnD,GAAqB,QAAjB6Y,GAA0C,QAAhB7Y,EAAMU,MAClC,OAAOkzB,EAAI6C,IAAI7C,EAAIE,MAAM7nB,KAAM2nB,EAAIwC,KAAMxC,EAAIlB,IAAI1yB,GAErD,KAAO,CACL,IAAIA,EAAM0oB,MAAO1oB,EAAMmoB,IAoBrB,MAAM,IAAItnB,MAAK,kCAnBf,GAAqB,QAAjBgY,EACF,OAAO+a,EAAI6C,IACT7C,EAAIE,MAAM7nB,KACV2nB,EAAIwC,KACJxC,EAAIG,KAAK/zB,IAGb,GAEmB,SAAjB6Y,GACA7Y,EAAMiqB,IAEN,OAAO2J,EAAI6C,IACT7C,EAAIE,MAAM7nB,KACV2nB,EAAIwC,KACJxC,EAAIK,KAAKj0B,GAMjB,CAEA,MAAM,IAAIa,MAAK,eACEb,EAAMd,KAAI,mBAAmB2Z,EAAY,IAAI7Y,EAAMU,UAEtE,EAAAkzB,EAEOloB,KAAP,SAAY1L,GACV,IAAMf,EAAKe,EAAMf,GACXoM,GAAYrL,EAAMqL,UAAY,IAAMrL,EAAM4K,WAAa,GACvDyd,EAASroB,EAAcqoB,OAAS,EAChCC,EAAUtoB,EAAcsoB,QAAU,EAClCqO,EAAoB50B,KAAK8C,MAAMwG,GAAY9B,GAAa,IACxDqtB,EAAoB70B,KAAK8C,MAAMwG,GAAY9B,GAAa,IAC9D,OAAOqqB,EAAI6C,IACT7C,EAAIE,MAAMpoB,KACV,IAAIzJ,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACChD,GAAM,GAAM,IACZA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EACA,EACA,EACA,EACA03B,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACAC,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACCvO,GAAS,EAAK,IACP,IAARA,EACA,EACA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,IAGN,EAAAsL,EAEOviB,KAAP,SAAYrR,EAAyB82B,GACnC,IAAMU,EAAwB5D,EAAIsB,KAAKl1B,GACjCf,EAAKe,EAAMf,GACXw4B,EAA+B11B,KAAK8C,MACxCiyB,GAAuBvtB,GAAa,IAEhCmuB,EAA+B31B,KAAK8C,MACxCiyB,GAAuBvtB,GAAa,IAEtC,OAAOqqB,EAAI6C,IACT7C,EAAIE,MAAMziB,KACVuiB,EAAI6C,IACF7C,EAAIE,MAAMtiB,KACV,IAAIvP,WAAW,CACb,EACA,EACA,EACA,EACAhD,GAAM,GACLA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,KAGJ20B,EAAI6C,IACF7C,EAAIE,MAAMviB,KACV,IAAItP,WAAW,CACb,EACA,EACA,EACA,EACAw1B,GAAgC,GAC/BA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACP,IAA/BA,EACAC,GAAgC,GAC/BA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACP,IAA/BA,KAGJ9D,EAAI3hB,KACFjS,EACAw3B,EAAsB17B,OACpB,GACA,GACA,EACA,GACA,EACA,GAEJ07B,EAEJ,EAEA5D,EAIOnoB,KAAP,SAAYzL,GAEV,OADAA,EAAMqL,SAAWrL,EAAMqL,UAAY,WAC5BuoB,EAAI6C,IAAI7C,EAAIE,MAAMroB,KAAMmoB,EAAIloB,KAAK1L,GAAQ4zB,EAAIa,KAAKz0B,GAC3D,EAAA4zB,EAEOvnB,KAAP,SAAYrM,GACV,IAAMf,EAAKe,EAAMf,GACjB,OAAO20B,EAAI6C,IACT7C,EAAIE,MAAMznB,KACV,IAAIpK,WAAW,CACb,EACA,EACA,EACA,EACAhD,GAAM,GACLA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGN,EAAA20B,EAEO3hB,KAAP,SAAYjS,EAAuB1C,GACjC,IAII1B,EACAuG,EACAkJ,EACA5N,EACA8O,EACAorB,EATEv1B,EAAUpC,EAAMoC,SAAW,GAC3B3F,EAAM2F,EAAQtG,OACd87B,EAAW,GAAK,GAAKn7B,EACrBqG,EAAQ,IAAIb,WAAW21B,GAyB7B,IAlBAt6B,GAAU,EAAIs6B,EACd90B,EAAMZ,IACJ,CACiB,UAAflC,EAAMd,KAAmB,EAAO,EAChC,EACA,GACA,EACCzC,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,EACCa,IAAW,GAAM,IACjBA,IAAW,GAAM,IACjBA,IAAW,EAAK,IACR,IAATA,GAEF,GAEG1B,EAAI,EAAGA,EAAIa,EAAKb,IAEnByP,GADAlJ,EAASC,EAAQxG,IACCyP,SAClB5N,EAAO0E,EAAO1E,KACd8O,EAAQpK,EAAOoK,MACforB,EAAMx1B,EAAOw1B,IACb70B,EAAMZ,IACJ,CACGmJ,IAAa,GAAM,IACnBA,IAAa,GAAM,IACnBA,IAAa,EAAK,IACR,IAAXA,EACC5N,IAAS,GAAM,IACfA,IAAS,GAAM,IACfA,IAAS,EAAK,IACR,IAAPA,EACC8O,EAAMsrB,WAAa,EAAKtrB,EAAM0qB,UAC9B1qB,EAAM2qB,cAAgB,EACpB3qB,EAAM4qB,eAAiB,EACvB5qB,EAAMurB,cAAgB,EACvBvrB,EAAMwrB,UACY,MAApBxrB,EAAMyrB,WACa,GAAnBzrB,EAAMyrB,WACLL,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,GAEF,GAAK,GAAK/7B,GAGd,OAAOg4B,EAAI6C,IAAI7C,EAAIE,MAAM7hB,KAAMnP,EACjC,EAAA8wB,EAEOroB,YAAP,SAAmBwrB,GACZnD,EAAIE,OACPF,EAAIC,OAGN,IAAMoE,EAAQrE,EAAIgB,KAAKmC,GAEvB,OADetmB,GAAiBmjB,EAAI4C,KAAMyB,EAE5C,EAAArE,EAEOK,KAAP,SAAYj0B,GAwCV,IApCA,IAAMk4B,EAAKl4B,EAAM4I,OACXgc,EAAwB,CAAC5kB,EAAMiqB,IAAKjqB,EAAMmoB,IAAKnoB,EAAM0oB,KAErDtoB,EAAS,IAAI6B,WAAW,CAC5B,EACCi2B,EAAGlN,uBAAyB,GAC1BkN,EAAGjN,kBAAoB,GAAK,GAC7BiN,EAAGhN,oBACLgN,EAAGzJ,oCAAoC,GACvCyJ,EAAGzJ,oCAAoC,GACvCyJ,EAAGzJ,oCAAoC,GACvCyJ,EAAGzJ,oCAAoC,GACvCyJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGxJ,mCAAmC,GACtCwJ,EAAGrM,kBACH,IAAOqM,EAAG3K,8BAAgC,EAC1C,IAAM2K,EAAG3K,6BACT,IAAM2K,EAAGjJ,gBACT,IAAMiJ,EAAGlM,kBACT,IAAMkM,EAAG1L,sBACT,IAAM0L,EAAGzL,wBACT,EACAlU,SAAS2f,EAAGtJ,WAAWE,KACtBqJ,EACED,EAAGE,oBAAsB,EACzBF,EAAGG,qBAAuB,GAC1BH,EAAGtJ,WAAWC,MAAQ,GAAK,GAC9BjK,EAAM9oB,SAIJA,EAASsE,EAAOtE,OACXF,EAAI,EAAGA,EAAIgpB,EAAM9oB,OAAQF,GAAK,EAAG,CACxCE,GAAU,EACV,IAAK,IAAIgB,EAAI,EAAGA,EAAI8nB,EAAMhpB,GAAGE,OAAQgB,GAAK,EACxChB,GAAU,EAAI8oB,EAAMhpB,GAAGkB,GAAGhB,MAE9B,CAEA,IAAMo4B,EAAO,IAAIjyB,WAAWnG,GAC5Bo4B,EAAKhyB,IAAI9B,EAAQ,GACjBtE,EAASsE,EAAOtE,OAGhB,IADA,IAAMw8B,EAAO1T,EAAM9oB,OAAS,EACnBF,EAAI,EAAGA,EAAIgpB,EAAM9oB,OAAQF,GAAK,EAAG,CACxCs4B,EAAKhyB,IACH,IAAID,WAAW,CACZ,GAAKrG,GAAMA,IAAM08B,EAAO,IAAM,GAC/B,EACA1T,EAAMhpB,GAAGE,SAEXA,GAEFA,GAAU,EACV,IAAK,IAAIgB,EAAI,EAAGA,EAAI8nB,EAAMhpB,GAAGE,OAAQgB,GAAK,EACxCo3B,EAAKhyB,IACH,IAAID,WAAW,CAAC2iB,EAAMhpB,GAAGkB,GAAGhB,QAAU,EAAwB,IAArB8oB,EAAMhpB,GAAGkB,GAAGhB,SACrDA,GAEFA,GAAU,EACVo4B,EAAKhyB,IAAI0iB,EAAMhpB,GAAGkB,GAAIhB,GACtBA,GAAU8oB,EAAMhpB,GAAGkB,GAAGhB,MAE1B,CACA,IAAMy8B,EAAO3E,EAAI6C,IAAI7C,EAAIE,MAAMI,KAAMA,GAC/B7L,EAAQroB,EAAMqoB,MACdC,EAAStoB,EAAMsoB,OACf+O,EAAWr3B,EAAMuoB,WAAW,GAC5B+O,EAAWt3B,EAAMuoB,WAAW,GAElC,OAAOqL,EAAI6C,IACT7C,EAAIE,MAAMG,KACV,IAAIhyB,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACComB,GAAS,EAAK,IACP,IAARA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEFiQ,EACA3E,EAAI6C,IACF7C,EAAIE,MAAMK,KACV,IAAIlyB,WAAW,CACb,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGJ2xB,EAAI6C,IACF7C,EAAIE,MAAMmB,KACV,IAAIhzB,WAAW,CACbo1B,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,EACAC,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,KAIR,EAAA1D,CAAA,CAp0CO,GAAHA,GACUE,WAAK,EADfF,GAEWiC,gBAAU,EAFrBjC,GAGWkC,UAAI,EAHflC,GAIWmC,UAAI,EAJfnC,GAKWoC,UAAI,EALfpC,GAMWqC,UAAI,EANfrC,GAOWsC,UAAI,EAPftC,GAQWuC,UAAI,EARfvC,GASWwC,UAAI,EATfxC,GAUW4C,UAAI,EAVf5C,GAWW8C,UAAI,ECuIrB,IAAkB8B,GAAiB,OAAjBA,GAAiB,QClJ5B,SAASC,GACdnnB,EACA5K,GAEA,OAvBK,SACL4K,EACAonB,EACAC,EACAjyB,GAEA,IAAMyD,EAASmH,EAAWonB,EAAYC,EACtC,OAAe52B,KAAK2E,MAAMyD,EAC5B,CAeSyuB,CAAoBtnB,EAAU,IAAM,EAhCf,IAiC9B,CASO,SAASunB,GAAkBpyB,GAChC,IAAQ6K,EAAiC7K,EAAjC6K,SAAU1G,EAAuBnE,EAAvBmE,UAClB,OAAU0G,EAA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","x_google_ignoreList":[0,1,2,3,4,10,11,12,13,14,15,16,17,18,19,20,21,22,23,26]}