{"version":3,"file":"eta.module.mjs","sources":["../src/err.ts","../src/polyfills.ts","../src/utils.ts","../src/parse.ts","../src/compile-string.ts","../src/storage.ts","../src/containers.ts","../src/config.ts","../src/compile.ts","../src/file-utils.ts","../src/file-handlers.ts","../src/file-helpers.ts","../src/render.ts","../src/index.ts"],"sourcesContent":["function setPrototypeOf(obj: any, proto: any) {\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(obj, proto);\n  } else {\n    obj.__proto__ = proto;\n  }\n}\n\n// This is pretty much the only way to get nice, extended Errors\n// without using ES6\n\n/**\n * This returns a new Error with a custom prototype. Note that it's _not_ a constructor\n *\n * @param message Error message\n *\n * **Example**\n *\n * ```js\n * throw EtaErr(\"template not found\")\n * ```\n */\n\nexport default function EtaErr(message: string): Error {\n  const err = new Error(message);\n  setPrototypeOf(err, EtaErr.prototype);\n  return err as Error;\n}\n\nEtaErr.prototype = Object.create(Error.prototype, {\n  name: { value: \"Eta Error\", enumerable: false },\n});\n\n/**\n * Throws an EtaErr with a nicely formatted error and message showing where in the template the error occurred.\n */\n\nexport function ParseErr(message: string, str: string, indx: number): void {\n  const whitespace = str.slice(0, indx).split(/\\n/);\n\n  const lineNo = whitespace.length;\n  const colNo = whitespace[lineNo - 1].length + 1;\n  message +=\n    \" at line \" +\n    lineNo +\n    \" col \" +\n    colNo +\n    \":\\n\\n\" +\n    \"  \" +\n    str.split(/\\n/)[lineNo - 1] +\n    \"\\n\" +\n    \"  \" +\n    Array(colNo).join(\" \") +\n    \"^\";\n  throw EtaErr(message);\n}\n","import EtaErr from \"./err.js\";\n\n/**\n * @returns The global Promise function\n */\n\nexport const promiseImpl: PromiseConstructor = new Function(\"return this\")().Promise;\n\n/**\n * @returns A new AsyncFunction constuctor\n */\n\nexport function getAsyncFunctionConstructor(): Function {\n  try {\n    return new Function(\"return (async function(){}).constructor\")();\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw EtaErr(\"This environment doesn't support async/await\");\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * str.trimLeft polyfill\n *\n * @param str - Input string\n * @returns The string with left whitespace removed\n *\n */\n\nexport function trimLeft(str: string): string {\n  // eslint-disable-next-line no-extra-boolean-cast\n  if (!!String.prototype.trimLeft) {\n    return str.trimLeft();\n  } else {\n    return str.replace(/^\\s+/, \"\");\n  }\n}\n\n/**\n * str.trimRight polyfill\n *\n * @param str - Input string\n * @returns The string with right whitespace removed\n *\n */\n\nexport function trimRight(str: string): string {\n  // eslint-disable-next-line no-extra-boolean-cast\n  if (!!String.prototype.trimRight) {\n    return str.trimRight();\n  } else {\n    return str.replace(/\\s+$/, \"\"); // TODO: do we really need to replace BOM's?\n  }\n}\n","// TODO: allow '-' to trim up until newline. Use [^\\S\\n\\r] instead of \\s\n// TODO: only include trimLeft polyfill if not in ES6\n\nimport { trimLeft, trimRight } from \"./polyfills.js\";\n\n/* TYPES */\n\nimport type { EtaConfig } from \"./config.js\";\n\ninterface EscapeMap {\n  \"&\": \"&amp;\";\n  \"<\": \"&lt;\";\n  \">\": \"&gt;\";\n  '\"': \"&quot;\";\n  \"'\": \"&#39;\";\n  [index: string]: string;\n}\n\n/* END TYPES */\n\nexport function hasOwnProp(obj: object, prop: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function copyProps<T>(toObj: T, fromObj: T): T {\n  for (const key in fromObj) {\n    if (hasOwnProp(fromObj as unknown as object, key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj;\n}\n\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */\n\nfunction trimWS(\n  str: string,\n  config: EtaConfig,\n  wsLeft: string | false,\n  wsRight?: string | false\n): string {\n  let leftTrim;\n  let rightTrim;\n\n  if (Array.isArray(config.autoTrim)) {\n    // kinda confusing\n    // but _}} will trim the left side of the following string\n    leftTrim = config.autoTrim[1];\n    rightTrim = config.autoTrim[0];\n  } else {\n    leftTrim = rightTrim = config.autoTrim;\n  }\n\n  if (wsLeft || wsLeft === false) {\n    leftTrim = wsLeft;\n  }\n\n  if (wsRight || wsRight === false) {\n    rightTrim = wsRight;\n  }\n\n  if (!rightTrim && !leftTrim) {\n    return str;\n  }\n\n  if (leftTrim === \"slurp\" && rightTrim === \"slurp\") {\n    return str.trim();\n  }\n\n  if (leftTrim === \"_\" || leftTrim === \"slurp\") {\n    // console.log('trimming left' + leftTrim)\n    // full slurp\n\n    str = trimLeft(str);\n  } else if (leftTrim === \"-\" || leftTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, \"\");\n  }\n\n  if (rightTrim === \"_\" || rightTrim === \"slurp\") {\n    // full slurp\n    str = trimRight(str);\n  } else if (rightTrim === \"-\" || rightTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, \"\"); // TODO: make sure this gets \\r\\n\n  }\n\n  return str;\n}\n\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */\n\nconst escMap: EscapeMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nfunction replaceChar(s: string): string {\n  return escMap[s];\n}\n\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */\n\nfunction XMLEscape(str: any): string {\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n  const newStr = String(str);\n  if (/[&<>\"']/.test(newStr)) {\n    return newStr.replace(/[&<>\"']/g, replaceChar);\n  } else {\n    return newStr;\n  }\n}\n\nexport { trimWS, XMLEscape };\n","import { ParseErr } from \"./err.js\";\nimport { trimWS } from \"./utils.js\";\n\n/* TYPES */\n\nimport type { EtaConfig } from \"./config.js\";\n\nexport type TagType = \"r\" | \"e\" | \"i\" | \"\";\n\nexport interface TemplateObject {\n  t: TagType;\n  val: string;\n}\n\nexport type AstObject = string | TemplateObject;\n\n/* END TYPES */\n\nconst templateLitReg = /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g;\n\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g;\n\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g;\n\n/** Escape special regular expression characters inside a string */\n\nfunction escapeRegExp(string: string) {\n  // From MDN\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\nexport default function parse(str: string, config: EtaConfig): Array<AstObject> {\n  let buffer: Array<AstObject> = [];\n  let trimLeftOfNextStr: string | false = false;\n  let lastIndex = 0;\n  const parseOptions = config.parse;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processTemplate) {\n        str = plugin.processTemplate(str, config);\n      }\n    }\n  }\n\n  /* Adding for EJS compatibility */\n  if (config.rmWhitespace) {\n    // Code taken directly from EJS\n    // Have to use two separate replaces here as `^` and `$` operators don't\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\n    // Essentially, this replaces the whitespace at the beginning and end of\n    // each line and removes multiple newlines.\n    str = str.replace(/[\\r\\n]+/g, \"\\n\").replace(/^\\s+|\\s+$/gm, \"\");\n  }\n  /* End rmWhitespace option */\n\n  templateLitReg.lastIndex = 0;\n  singleQuoteReg.lastIndex = 0;\n  doubleQuoteReg.lastIndex = 0;\n\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\n    if (strng) {\n      // if string is truthy it must be of type 'string'\n\n      strng = trimWS(\n        strng,\n        config,\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n        shouldTrimRightOfString\n      );\n\n      if (strng) {\n        // replace \\ with \\\\, ' with \\'\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\n\n        strng = strng.replace(/\\\\|'/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\");\n\n        buffer.push(strng);\n      }\n    }\n  }\n\n  const prefixes = [parseOptions.exec, parseOptions.interpolate, parseOptions.raw].reduce(function (\n    accumulator,\n    prefix\n  ) {\n    if (accumulator && prefix) {\n      return accumulator + \"|\" + escapeRegExp(prefix);\n    } else if (prefix) {\n      // accumulator is falsy\n      return escapeRegExp(prefix);\n    } else {\n      // prefix and accumulator are both falsy\n      return accumulator;\n    }\n  },\n  \"\");\n\n  const parseOpenReg = new RegExp(\n    escapeRegExp(config.tags[0]) + \"(-|_)?\\\\s*(\" + prefixes + \")?\\\\s*\",\n    \"g\"\n  );\n\n  const parseCloseReg = new RegExp(\n    \"'|\\\"|`|\\\\/\\\\*|(\\\\s*(-|_)?\" + escapeRegExp(config.tags[1]) + \")\",\n    \"g\"\n  );\n  // TODO: benchmark having the \\s* on either side vs using str.trim()\n\n  let m;\n\n  while ((m = parseOpenReg.exec(str))) {\n    const precedingString = str.slice(lastIndex, m.index);\n\n    lastIndex = m[0].length + m.index;\n\n    const wsLeft = m[1];\n    const prefix = m[2] || \"\"; // by default either ~, =, or empty\n\n    pushString(precedingString, wsLeft);\n\n    parseCloseReg.lastIndex = lastIndex;\n    let closeTag;\n    let currentObj: AstObject | false = false;\n\n    while ((closeTag = parseCloseReg.exec(str))) {\n      if (closeTag[1]) {\n        const content = str.slice(lastIndex, closeTag.index);\n\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;\n\n        trimLeftOfNextStr = closeTag[2];\n\n        const currentType: TagType =\n          prefix === parseOptions.exec\n            ? \"e\"\n            : prefix === parseOptions.raw\n            ? \"r\"\n            : prefix === parseOptions.interpolate\n            ? \"i\"\n            : \"\";\n\n        currentObj = { t: currentType, val: content };\n        break;\n      } else {\n        const char = closeTag[0];\n        if (char === \"/*\") {\n          const commentCloseInd = str.indexOf(\"*/\", parseCloseReg.lastIndex);\n\n          if (commentCloseInd === -1) {\n            ParseErr(\"unclosed comment\", str, closeTag.index);\n          }\n          parseCloseReg.lastIndex = commentCloseInd;\n        } else if (char === \"'\") {\n          singleQuoteReg.lastIndex = closeTag.index;\n\n          const singleQuoteMatch = singleQuoteReg.exec(str);\n          if (singleQuoteMatch) {\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === '\"') {\n          doubleQuoteReg.lastIndex = closeTag.index;\n          const doubleQuoteMatch = doubleQuoteReg.exec(str);\n\n          if (doubleQuoteMatch) {\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === \"`\") {\n          templateLitReg.lastIndex = closeTag.index;\n          const templateLitMatch = templateLitReg.exec(str);\n          if (templateLitMatch) {\n            parseCloseReg.lastIndex = templateLitReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        }\n      }\n    }\n    if (currentObj) {\n      buffer.push(currentObj);\n    } else {\n      ParseErr(\"unclosed tag\", str, m.index + precedingString.length);\n    }\n  }\n\n  pushString(str.slice(lastIndex, str.length), false);\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processAST) {\n        buffer = plugin.processAST(buffer, config);\n      }\n    }\n  }\n\n  return buffer;\n}\n","import Parse from \"./parse.js\";\n\n/* TYPES */\n\nimport type { EtaConfig } from \"./config.js\";\nimport type { AstObject } from \"./parse.js\";\n\n/* END TYPES */\n\n/**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n *\n * **Example**\n *\n * ```js\n * compileToString(\"Hi <%= it.user %>\", eta.config)\n * // \"var tR='',include=E.include.bind(E),includeFile=E.includeFile.bind(E);tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\"\n * ```\n */\n\nexport default function compileToString(str: string, config: EtaConfig): string {\n  const buffer: Array<AstObject> = Parse(str, config);\n\n  let res =\n    \"var tR='',__l,__lP\" +\n    (config.include ? \",include=E.include.bind(E)\" : \"\") +\n    (config.includeFile ? \",includeFile=E.includeFile.bind(E)\" : \"\") +\n    \"\\nfunction layout(p,d){__l=p;__lP=d}\\n\" +\n    (config.useWith ? \"with(\" + config.varName + \"||{}){\" : \"\") +\n    compileScope(buffer, config) +\n    (config.includeFile\n      ? \"if(__l)tR=\" +\n        (config.async ? \"await \" : \"\") +\n        `includeFile(__l,Object.assign(${config.varName},{body:tR},__lP))\\n`\n      : config.include\n      ? \"if(__l)tR=\" +\n        (config.async ? \"await \" : \"\") +\n        `include(__l,Object.assign(${config.varName},{body:tR},__lP))\\n`\n      : \"\") +\n    \"if(cb){cb(null,tR)} return tR\" +\n    (config.useWith ? \"}\" : \"\");\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processFnString) {\n        res = plugin.processFnString(res, config);\n      }\n    }\n  }\n\n  return res;\n}\n\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * // AST version of 'Hi <%= it.user %>'\n * let templateAST = ['Hi ', { val: 'it.user', t: 'i' }]\n * compileScope(templateAST, eta.config)\n * // \"tR+='Hi ';tR+=E.e(it.user);\"\n * ```\n */\n\nfunction compileScope(buff: Array<AstObject>, config: EtaConfig) {\n  let i = 0;\n  const buffLength = buff.length;\n  let returnStr = \"\";\n\n  for (i; i < buffLength; i++) {\n    const currentBlock = buff[i];\n    if (typeof currentBlock === \"string\") {\n      const str = currentBlock;\n\n      // we know string exists\n      returnStr += \"tR+='\" + str + \"'\\n\";\n    } else {\n      const type = currentBlock.t; // ~, s, !, ?, r\n      let content = currentBlock.val || \"\";\n\n      if (type === \"r\") {\n        // raw\n\n        if (config.filter) {\n          content = \"E.filter(\" + content + \")\";\n        }\n\n        returnStr += \"tR+=\" + content + \"\\n\";\n      } else if (type === \"i\") {\n        // interpolate\n\n        if (config.filter) {\n          content = \"E.filter(\" + content + \")\";\n        }\n\n        if (config.autoEscape) {\n          content = \"E.e(\" + content + \")\";\n        }\n        returnStr += \"tR+=\" + content + \"\\n\";\n        // reference\n      } else if (type === \"e\") {\n        // execute\n        returnStr += content + \"\\n\"; // you need a \\n in case you have <% } %>\n      }\n    }\n  }\n\n  return returnStr;\n}\n","import { copyProps } from \"./utils.js\";\n\n/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */\nclass Cacher<T> {\n  constructor(private cache: Record<string, T>) {}\n  define(key: string, val: T): void {\n    this.cache[key] = val;\n  }\n  get(key: string): T {\n    // string | array.\n    // TODO: allow array of keys to look down\n    // TODO: create plugin to allow referencing helpers, filters with dot notation\n    return this.cache[key];\n  }\n  remove(key: string): void {\n    delete this.cache[key];\n  }\n  reset(): void {\n    this.cache = {};\n  }\n  load(cacheObj: Record<string, T>): void {\n    copyProps(this.cache, cacheObj);\n  }\n}\n\nexport { Cacher };\n","import { Cacher } from \"./storage.js\";\n\n/* TYPES */\n\nimport type { TemplateFunction } from \"./compile.js\";\n\n/* END TYPES */\n\n/**\n * Eta's template storage\n *\n * Stores partials and cached templates\n */\n\nconst templates = new Cacher<TemplateFunction>({});\n\nexport { templates };\n","import { templates } from \"./containers.js\";\nimport { copyProps, XMLEscape } from \"./utils.js\";\nimport EtaErr from \"./err.js\";\n\n/* TYPES */\n\nimport type { TemplateFunction } from \"./compile.js\";\nimport type { Cacher } from \"./storage.js\";\n\ntype trimConfig = \"nl\" | \"slurp\" | false;\n\nexport interface EtaConfig {\n  /** Whether or not to automatically XML-escape interpolations. Default true */\n  autoEscape: boolean;\n\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\n  autoTrim: trimConfig | [trimConfig, trimConfig];\n\n  /** Compile to async function */\n  async: boolean;\n\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  cache: boolean;\n\n  /** XML-escaping function */\n  e: (str: string) => string;\n\n  /** Parsing options. NOTE: \"-\" and \"_\" may not be used, since they are reserved for whitespace trimming. */\n  parse: {\n    /** Which prefix to use for evaluation. Default `\"\"` */\n    exec: string;\n\n    /** Which prefix to use for interpolation. Default `\"=\"` */\n    interpolate: string;\n\n    /** Which prefix to use for raw interpolation. Default `\"~\"` */\n    raw: string;\n  };\n\n  /** Array of plugins */\n  plugins: Array<{ processFnString?: Function; processAST?: Function; processTemplate?: Function }>;\n\n  /** Remove all safe-to-remove whitespace */\n  rmWhitespace: boolean;\n\n  /** Delimiters: by default `['<%', '%>']` */\n  tags: [string, string];\n\n  /** Holds template cache */\n  templates: Cacher<TemplateFunction>;\n\n  /** Name of the data object. Default `it` */\n  varName: string;\n\n  /** Absolute path to template file */\n  filename?: string;\n\n  /** Holds cache of resolved filepaths. Set to `false` to disable */\n  filepathCache?: Record<string, string> | false;\n\n  /** A filter function applied to every interpolation or raw interpolation */\n  filter?: Function;\n\n  /** Function to include templates by name */\n  include?: Function;\n\n  /** Function to include templates by filepath */\n  includeFile?: Function;\n\n  /** Name of template */\n  name?: string;\n\n  /** Where should absolute paths begin? Default '/' */\n  root?: string;\n\n  /** Make data available on the global object instead of varName */\n  useWith?: boolean;\n\n  /** Whether or not to cache templates if `name` or `filename` is passed: duplicate of `cache` */\n  \"view cache\"?: boolean;\n\n  /** Directory or directories that contain templates */\n  views?: string | Array<string>;\n\n  [index: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport interface EtaConfigWithFilename extends EtaConfig {\n  filename: string;\n}\n\nexport type PartialConfig = Partial<EtaConfig>;\nexport type PartialAsyncConfig = PartialConfig & { async: true };\n\n/* END TYPES */\n\n/**\n * Include a template based on its name (or filepath, if it's already been cached).\n *\n * Called like `include(templateNameOrPath, data)`\n */\n\nfunction includeHelper(this: EtaConfig, templateNameOrPath: string, data: object): string {\n  const template = this.templates.get(templateNameOrPath);\n  if (!template) {\n    throw EtaErr('Could not fetch template \"' + templateNameOrPath + '\"');\n  }\n  return template(data, this);\n}\n\n/** Eta's base (global) configuration */\nconst config: EtaConfig = {\n  async: false,\n  autoEscape: true,\n  autoTrim: [false, \"nl\"],\n  cache: false,\n  e: XMLEscape,\n  include: includeHelper,\n  parse: {\n    exec: \"\",\n    interpolate: \"=\",\n    raw: \"~\",\n  },\n  plugins: [],\n  rmWhitespace: false,\n  tags: [\"<%\", \"%>\"],\n  templates: templates,\n  useWith: false,\n  varName: \"it\",\n};\n\n/**\n * Takes one or two partial (not necessarily complete) configuration objects, merges them 1 layer deep into eta.config, and returns the result\n *\n * @param override Partial configuration object\n * @param baseConfig Partial configuration object to merge before `override`\n *\n * **Example**\n *\n * ```js\n * let customConfig = getConfig({tags: ['!#', '#!']})\n * ```\n */\n\nfunction getConfig(override: PartialConfig, baseConfig?: EtaConfig): EtaConfig {\n  // TODO: run more tests on this\n\n  const res: PartialConfig = {}; // Linked\n  copyProps(res, config); // Creates deep clone of eta.config, 1 layer deep\n\n  if (baseConfig) {\n    copyProps(res, baseConfig);\n  }\n\n  if (override) {\n    copyProps(res, override);\n  }\n\n  return res as EtaConfig;\n}\n\n/** Update Eta's base config */\n\nfunction configure(options: PartialConfig): Partial<EtaConfig> {\n  return copyProps(config, options);\n}\n\nexport { config, getConfig, configure };\n","import compileToString from \"./compile-string.js\";\nimport { getConfig } from \"./config.js\";\nimport EtaErr from \"./err.js\";\n\n/* TYPES */\n\nimport type { EtaConfig, PartialConfig } from \"./config.js\";\nimport type { CallbackFn } from \"./file-handlers.js\";\nimport { getAsyncFunctionConstructor } from \"./polyfills.js\";\nexport type TemplateFunction = (data: object, config: EtaConfig, cb?: CallbackFn) => string;\n\n/* END TYPES */\n\n/**\n * Takes a template string and returns a template function that can be called with (data, config, [cb])\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n *\n * **Example**\n *\n * ```js\n * let compiledFn = eta.compile(\"Hi <%= it.user %>\")\n * // function anonymous()\n * let compiledFnStr = compiledFn.toString()\n * // \"function anonymous(it,E,cb\\n) {\\nvar tR='',include=E.include.bind(E),includeFile=E.includeFile.bind(E);tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\\n}\"\n * ```\n */\n\nexport default function compile(str: string, config?: PartialConfig): TemplateFunction {\n  const options: EtaConfig = getConfig(config || {});\n\n  /* ASYNC HANDLING */\n  // The below code is modified from mde/ejs. All credit should go to them.\n  const ctor = options.async ? (getAsyncFunctionConstructor() as FunctionConstructor) : Function;\n  /* END ASYNC HANDLING */\n\n  try {\n    return new ctor(\n      options.varName,\n      \"E\", // EtaConfig\n      \"cb\", // optional callback\n      compileToString(str, options)\n    ) as TemplateFunction; // eslint-disable-line no-new-func\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw EtaErr(\n        \"Bad template syntax\\n\\n\" +\n          e.message +\n          \"\\n\" +\n          Array(e.message.length + 1).join(\"=\") +\n          \"\\n\" +\n          compileToString(str, options) +\n          \"\\n\" // This will put an extra newline before the callstack for extra readability\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n","import { path, existsSync, readFileSync } from \"./file-methods.js\";\nconst _BOM = /^\\uFEFF/;\n\n// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.js\";\n\n/* TYPES */\n\nimport type { EtaConfig } from \"./config.js\";\n\n/* END TYPES */\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * If `name` does not have an extension, it will default to `.eta`\n *\n * @param name specified path\n * @param parentfile parent file path\n * @param isDirectory whether parentfile is a directory\n * @return absolute path to template\n */\n\nfunction getWholeFilePath(name: string, parentfile: string, isDirectory?: boolean): string {\n  const includePath =\n    path.resolve(\n      isDirectory ? parentfile : path.dirname(parentfile), // returns directory the parent file is in\n      name // file\n    ) + (path.extname(name) ? \"\" : \".eta\");\n  return includePath;\n}\n\n/**\n * Get the absolute path to an included template\n *\n * If this is called with an absolute path (for example, starting with '/' or 'C:\\')\n * then Eta will attempt to resolve the absolute path within options.views. If it cannot,\n * Eta will fallback to options.root or '/'\n *\n * If this is called with a relative path, Eta will:\n * - Look relative to the current template (if the current template has the `filename` property)\n * - Look inside each directory in options.views\n *\n * Note: if Eta is unable to find a template using path and options, it will throw an error.\n *\n * @param path    specified path\n * @param options compilation options\n * @return absolute path to template\n */\n\nfunction getPath(path: string, options: EtaConfig): string {\n  let includePath: string | false = false;\n  const views = options.views;\n  const searchedPaths: Array<string> = [];\n\n  // If these four values are the same,\n  // getPath() will return the same result every time.\n  // We can cache the result to avoid expensive\n  // file operations.\n  const pathOptions = JSON.stringify({\n    filename: options.filename, // filename of the template which called includeFile()\n    path: path,\n    root: options.root,\n    views: options.views,\n  });\n\n  if (options.cache && options.filepathCache && options.filepathCache[pathOptions]) {\n    // Use the cached filepath\n    return options.filepathCache[pathOptions];\n  }\n\n  /** Add a filepath to the list of paths we've checked for a template */\n  function addPathToSearched(pathSearched: string) {\n    if (!searchedPaths.includes(pathSearched)) {\n      searchedPaths.push(pathSearched);\n    }\n  }\n\n  /**\n   * Take a filepath (like 'partials/mypartial.eta'). Attempt to find the template file inside `views`;\n   * return the resulting template file path, or `false` to indicate that the template was not found.\n   *\n   * @param views the filepath that holds templates, or an array of filepaths that hold templates\n   * @param path the path to the template\n   */\n\n  function searchViews(views: Array<string> | string | undefined, path: string): string | false {\n    let filePath;\n\n    // If views is an array, then loop through each directory\n    // And attempt to find the template\n    if (\n      Array.isArray(views) &&\n      views.some(function (v) {\n        filePath = getWholeFilePath(path, v, true);\n\n        addPathToSearched(filePath);\n\n        return existsSync(filePath);\n      })\n    ) {\n      // If the above returned true, we know that the filePath was just set to a path\n      // That exists (Array.some() returns as soon as it finds a valid element)\n      return filePath as unknown as string;\n    } else if (typeof views === \"string\") {\n      // Search for the file if views is a single directory\n      filePath = getWholeFilePath(path, views, true);\n\n      addPathToSearched(filePath);\n\n      if (existsSync(filePath)) {\n        return filePath;\n      }\n    }\n\n    // Unable to find a file\n    return false;\n  }\n\n  // Path starts with '/', 'C:\\', etc.\n  const match = /^[A-Za-z]+:\\\\|^\\//.exec(path);\n\n  // Absolute path, like /partials/partial.eta\n  if (match && match.length) {\n    // We have to trim the beginning '/' off the path, or else\n    // path.resolve(dir, path) will always resolve to just path\n    const formattedPath = path.replace(/^\\/*/, \"\");\n\n    // First, try to resolve the path within options.views\n    includePath = searchViews(views, formattedPath);\n    if (!includePath) {\n      // If that fails, searchViews will return false. Try to find the path\n      // inside options.root (by default '/', the base of the filesystem)\n      const pathFromRoot = getWholeFilePath(formattedPath, options.root || \"/\", true);\n\n      addPathToSearched(pathFromRoot);\n\n      includePath = pathFromRoot;\n    }\n  } else {\n    // Relative paths\n    // Look relative to a passed filename first\n    if (options.filename) {\n      const filePath = getWholeFilePath(path, options.filename);\n\n      addPathToSearched(filePath);\n\n      if (existsSync(filePath)) {\n        includePath = filePath;\n      }\n    }\n    // Then look for the template in options.views\n    if (!includePath) {\n      includePath = searchViews(views, path);\n    }\n    if (!includePath) {\n      throw EtaErr('Could not find the template \"' + path + '\". Paths tried: ' + searchedPaths);\n    }\n  }\n\n  // If caching and filepathCache are enabled,\n  // cache the input & output of this function.\n  if (options.cache && options.filepathCache) {\n    options.filepathCache[pathOptions] = includePath;\n  }\n\n  return includePath;\n}\n\n/**\n * Reads a file synchronously\n */\n\nfunction readFile(filePath: string): string {\n  try {\n    return readFileSync(filePath).toString().replace(_BOM, \"\"); // TODO: is replacing BOM's necessary?\n  } catch {\n    throw EtaErr(\"Failed to read template at '\" + filePath + \"'\");\n  }\n}\n\nexport { getPath, readFile };\n","// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from \"./err.js\";\nimport compile from \"./compile.js\";\nimport { getConfig } from \"./config.js\";\nimport { getPath, readFile } from \"./file-utils.js\";\nimport { promiseImpl } from \"./polyfills.js\";\n\n/* TYPES */\n\nimport type { EtaConfig, PartialConfig, EtaConfigWithFilename } from \"./config.js\";\nimport type { TemplateFunction } from \"./compile.js\";\n\nexport type CallbackFn = (err: Error | null, str?: string) => void;\n\ninterface DataObj {\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string;\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean\n): TemplateFunction {\n  const config = getConfig(options);\n  const template = readFile(filePath);\n  try {\n    const compiledTemplate = compile(template, config);\n    if (!noCache) {\n      config.templates.define((config as EtaConfigWithFilename).filename, compiledTemplate);\n    }\n    return compiledTemplate;\n  } catch (e) {\n    throw EtaErr(\"Loading file: \" + filePath + \" failed:\\n\\n\" + (e as Error).message);\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  const filename = options.filename;\n\n  if (options.cache) {\n    const func = options.templates.get(filename);\n    if (func) {\n      return func;\n    }\n\n    return loadFile(filename, options);\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true);\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(data: object, options: EtaConfigWithFilename, cb: CallbackFn | undefined) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      const templateFn = handleCache(options);\n      templateFn(data, options, cb);\n    } catch (err) {\n      return cb(err as Error);\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === \"function\") {\n      return new promiseImpl<string>(function (resolve: Function, reject: Function) {\n        try {\n          const templateFn = handleCache(options);\n          const result = templateFn(data, options);\n          resolve(result);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    } else {\n      throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\");\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(path: string, options: EtaConfig): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  const newFileOptions = getConfig({ filename: getPath(path, options) }, options);\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions];\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFile(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFile(filename: string, data: DataObj, config: PartialConfig, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFile(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFile(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  Express will call renderFile with (filename, data, cb)\n  We also want to make (filename, data, options, cb) available\n  */\n\n  let renderConfig: EtaConfigWithFilename;\n  let callback: CallbackFn | undefined;\n  data = data || {};\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === \"function\") {\n    // The 4th argument is the callback\n    callback = cb;\n  } else if (typeof config === \"function\") {\n    // The 3rd arg is the callback\n    callback = config;\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === \"object\") {\n    renderConfig = getConfig((config as PartialConfig) || {}) as EtaConfigWithFilename;\n  } else {\n    // Otherwise, get the default config\n    renderConfig = getConfig({}) as EtaConfigWithFilename;\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig);\n\n  return tryHandleCache(data, renderConfig, callback);\n}\n\n/**\n * Render a template from a filepath asynchronously.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, data, [cb])`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * ```\n */\n\nfunction renderFileAsync(filename: string, data: DataObj, config?: PartialConfig): Promise<string>;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config: PartialConfig,\n  cb: CallbackFn\n): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void;\n\nfunction renderFileAsync(filename: string, data: DataObj, cb: CallbackFn): void;\n\nfunction renderFileAsync(\n  filename: string,\n  data: DataObj,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): Promise<string> | void {\n  return renderFile(\n    filename,\n    typeof config === \"function\" ? { ...data, async: true } : data,\n    typeof config === \"object\" ? { ...config, async: true } : config,\n    cb\n  );\n}\n\nexport { includeFile, renderFile, renderFileAsync };\n","import { includeFile } from \"./file-handlers.js\";\n\n/* TYPES */\n\nimport type { EtaConfig } from \"./config.js\";\n\ninterface GenericData {\n  [index: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/* END TYPES */\n\n/**\n * Called with `includeFile(path, data)`\n */\n\nexport function includeFileHelper(this: EtaConfig, path: string, data: GenericData): string {\n  const templateAndConfig = includeFile(path, this);\n  return templateAndConfig[0](data, templateAndConfig[1]);\n}\n","import compile from \"./compile.js\";\nimport { getConfig } from \"./config.js\";\nimport { promiseImpl } from \"./polyfills.js\";\nimport EtaErr from \"./err.js\";\n\n/* TYPES */\n\nimport type { EtaConfig, PartialConfig, PartialAsyncConfig } from \"./config.js\";\nimport type { TemplateFunction } from \"./compile.js\";\nimport type { CallbackFn } from \"./file-handlers.js\";\n\n/* END TYPES */\n\nfunction handleCache(template: string | TemplateFunction, options: EtaConfig): TemplateFunction {\n  if (options.cache && options.name && options.templates.get(options.name)) {\n    return options.templates.get(options.name);\n  }\n\n  const templateFunc = typeof template === \"function\" ? template : compile(template, options);\n\n  // Note that we don't have to check if it already exists in the cache;\n  // it would have returned earlier if it had\n  if (options.cache && options.name) {\n    options.templates.define(options.name, templateFunc);\n  }\n\n  return templateFunc;\n}\n\n/**\n * Render a template\n *\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\n * If `template` is a template function, Eta will call it with the provided data.\n *\n * If `config.async` is `false`, Eta will return the rendered template.\n *\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template.\n *\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n * @param cb Callback function\n */\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config: PartialAsyncConfig,\n  cb: CallbackFn\n): void;\n\n/**\n * Render a template\n *\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\n * If `template` is a template function, Eta will call it with the provided data.\n *\n * If `config.async` is `false`, Eta will return the rendered template.\n *\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template.\n *\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n */\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config: PartialAsyncConfig\n): Promise<string>;\n\n/**\n * Render a template\n *\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\n * If `template` is a template function, Eta will call it with the provided data.\n *\n * If `config.async` is `false`, Eta will return the rendered template.\n *\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template.\n *\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n */\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig\n): string;\n\n/**\n * Render a template\n *\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\n * If `template` is a template function, Eta will call it with the provided data.\n *\n * If `config.async` is `false`, Eta will return the rendered template.\n *\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template.\n *\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n * @param cb Callback function\n */\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): string | Promise<string> | void;\n\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): string | Promise<string> | void {\n  const options = getConfig(config || {});\n\n  if (options.async) {\n    if (cb) {\n      // If user passes callback\n      try {\n        // Note: if there is an error while rendering the template,\n        // It will bubble up and be caught here\n        const templateFn = handleCache(template, options);\n        templateFn(data, options, cb);\n      } catch (err) {\n        return cb(err as Error);\n      }\n    } else {\n      // No callback, try returning a promise\n      if (typeof promiseImpl === \"function\") {\n        return new promiseImpl(function (resolve: Function, reject: Function) {\n          try {\n            resolve(handleCache(template, options)(data, options));\n          } catch (err) {\n            reject(err);\n          }\n        });\n      } else {\n        throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\");\n      }\n    }\n  } else {\n    return handleCache(template, options)(data, options);\n  }\n}\n\n/**\n * Render a template asynchronously\n *\n * If `template` is a string, Eta will compile it to a function and call it with the provided data.\n * If `template` is a function, Eta will call it with the provided data.\n *\n * If there is a callback function, Eta will call it with `(err, renderedTemplate)`.\n * If there is not a callback function, Eta will return a Promise that resolves to the rendered template\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n */\nexport function renderAsync(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig\n): Promise<string>;\n\n/**\n * Render a template asynchronously\n *\n * If `template` is a string, Eta will compile it to a function and call it with the provided data.\n * If `template` is a function, Eta will call it with the provided data.\n *\n * If there is a callback function, Eta will call it with `(err, renderedTemplate)`.\n * If there is not a callback function, Eta will return a Promise that resolves to the rendered template\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n * @param cb Callback function\n */\nexport function renderAsync(\n  template: string | TemplateFunction,\n  data: object,\n  config: PartialConfig,\n  cb: CallbackFn\n): void;\n\n/**\n * Render a template asynchronously\n *\n * If `template` is a string, Eta will compile it to a function and call it with the provided data.\n * If `template` is a function, Eta will call it with the provided data.\n *\n * If there is a callback function, Eta will call it with `(err, renderedTemplate)`.\n * If there is not a callback function, Eta will return a Promise that resolves to the rendered template\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n * @param cb Callback function\n */\nexport function renderAsync(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): string | Promise<string> | void;\n\nexport function renderAsync(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): string | Promise<string> | void {\n  // Using Object.assign to lower bundle size, using spread operator makes it larger because of typescript injected polyfills\n  return render(template, data, Object.assign({}, config, { async: true }), cb);\n}\n","// @denoify-ignore\n\n/* Export file stuff */\nimport { includeFileHelper } from \"./file-helpers.js\";\nimport { config } from \"./config.js\";\n\nconfig.includeFile = includeFileHelper;\nconfig.filepathCache = {};\n\nexport { loadFile, renderFile, renderFileAsync, renderFile as __express } from \"./file-handlers.js\";\n\n/* End file stuff */\n\nexport { default as compileToString } from \"./compile-string.js\";\nexport { default as compile } from \"./compile.js\";\nexport { default as parse } from \"./parse.js\";\nexport { default as render, renderAsync } from \"./render.js\";\nexport { templates } from \"./containers.js\";\nexport { config, config as defaultConfig, getConfig, configure } from \"./config.js\";\nexport type EtaConfig = typeof config;\n"],"names":["setPrototypeOf","obj","proto","Object","__proto__","EtaErr","message","err","Error","prototype","create","name","value","enumerable","ParseErr","str","indx","whitespace","slice","split","lineNo","length","colNo","Array","join","promiseImpl","Function","Promise","getAsyncFunctionConstructor","e","SyntaxError","trimLeft","String","replace","trimRight","hasOwnProp","prop","hasOwnProperty","call","copyProps","toObj","fromObj","key","trimWS","config","wsLeft","wsRight","leftTrim","rightTrim","isArray","autoTrim","trim","escMap","replaceChar","s","XMLEscape","newStr","test","templateLitReg","singleQuoteReg","doubleQuoteReg","escapeRegExp","string","parse","buffer","trimLeftOfNextStr","lastIndex","parseOptions","plugins","i","plugin","processTemplate","rmWhitespace","pushString","strng","shouldTrimRightOfString","push","prefixes","exec","interpolate","raw","reduce","accumulator","prefix","parseOpenReg","RegExp","tags","parseCloseReg","m","precedingString","index","closeTag","currentObj","content","currentType","t","val","char","commentCloseInd","indexOf","singleQuoteMatch","doubleQuoteMatch","templateLitMatch","processAST","compileToString","Parse","res","include","includeFile","useWith","varName","compileScope","async","processFnString","buff","buffLength","returnStr","currentBlock","type","filter","autoEscape","Cacher","constructor","cache","define","get","remove","reset","load","cacheObj","templates","includeHelper","templateNameOrPath","data","template","getConfig","override","baseConfig","configure","options","compile","ctor","_BOM","getWholeFilePath","parentfile","isDirectory","includePath","path","resolve","dirname","extname","getPath","views","searchedPaths","pathOptions","JSON","stringify","filename","root","filepathCache","addPathToSearched","pathSearched","includes","searchViews","filePath","some","v","existsSync","match","formattedPath","pathFromRoot","readFile","readFileSync","toString","loadFile","noCache","compiledTemplate","handleCache","func","tryHandleCache","cb","templateFn","reject","result","newFileOptions","renderFile","renderConfig","callback","renderFileAsync","includeFileHelper","templateAndConfig","templateFunc","render","renderAsync","assign"],"mappings":"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"}