{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/observable/common/platformObservableUtils.ts","vs/platform/observable/common/platformObservableUtils.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,eAAe,EAAe,MAAM,mCAAmC,CAAC;AACjF,OAAO,EAAE,aAAa,EAAE,WAAW,EAAwB,uBAAuB,EAAE,MAAM,oCAAoC,CAAC;AAI/H,qEAAqE;AACrE,MAAM,UAAU,qBAAqB,CACpC,GAAW,EACX,YAAe,EACf,oBAA2C,EAC3C,aAAa,GAAG,aAAa,CAAC,QAAQ,EAAE;IAExC,OAAO,uBAAuB,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,sBAAsB,GAAG,GAAG,GAAG,EAChF,CAAC,YAAY,EAAE,EAAE,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE;QACnE,IAAI,CAAC,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAE,CAAC;YACjC,YAAY,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;IACF,CAAC,CAAC,EACF,GAAG,EAAE,CAAC,oBAAoB,CAAC,QAAQ,CAAI,GAAG,CAAC,IAAI,YAAY,EAC3D,aAAa,CACb,CAAC;AACH,CAAC;AAED,0EAA0E;AAC1E,MAAM,UAAU,cAAc,CAC7B,GAAqB,EACrB,OAA2B,EAC3B,YAAoC,EACpC,aAAa,GAAG,aAAa,CAAC,QAAQ,EAAE;IAExC,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACrC,MAAM,KAAK,GAAG,IAAI,eAAe,EAAE,CAAC;IACpC,WAAW,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,oBAAoB,GAAG,CAAC,GAAG,GAAG,EAAE,EAAE,MAAM,CAAC,EAAE;QACzE,MAAM,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;QACnC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACpB,OAAO,KAAK,CAAC;IACd,CAAC,EAAE,aAAa,CAAC,CAAC,6BAA6B,CAAC,KAAK,CAAC,CAAC;IACvD,OAAO,KAAK,CAAC;AACd,CAAC","file":"platformObservableUtils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, IDisposable } from '../../../base/common/lifecycle.js';\nimport { DebugLocation, derivedOpts, IObservable, IReader, observableFromEventOpts } from '../../../base/common/observable.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ContextKeyValue, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\n\n/** Creates an observable update when a configuration key updates. */\nexport function observableConfigValue<T>(\n\tkey: string,\n\tdefaultValue: T,\n\tconfigurationService: IConfigurationService,\n\tdebugLocation = DebugLocation.ofCaller(),\n): IObservable<T> {\n\treturn observableFromEventOpts({ debugName: () => `Configuration Key \"${key}\"`, },\n\t\t(handleChange) => configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(key)) {\n\t\t\t\thandleChange(e);\n\t\t\t}\n\t\t}),\n\t\t() => configurationService.getValue<T>(key) ?? defaultValue,\n\t\tdebugLocation,\n\t);\n}\n\n/** Update the configuration key with a value derived from observables. */\nexport function bindContextKey<T extends ContextKeyValue>(\n\tkey: RawContextKey<T>,\n\tservice: IContextKeyService,\n\tcomputeValue: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller(),\n): IDisposable {\n\tconst boundKey = key.bindTo(service);\n\tconst store = new DisposableStore();\n\tderivedOpts({ debugName: () => `Set Context Key \"${key.key}\"` }, reader => {\n\t\tconst value = computeValue(reader);\n\t\tboundKey.set(value);\n\t\treturn value;\n\t}, debugLocation).recomputeInitiallyAndOnChange(store);\n\treturn store;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, IDisposable } from '../../../base/common/lifecycle.js';\nimport { DebugLocation, derivedOpts, IObservable, IReader, observableFromEventOpts } from '../../../base/common/observable.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { ContextKeyValue, IContextKeyService, RawContextKey } from '../../contextkey/common/contextkey.js';\n\n/** Creates an observable update when a configuration key updates. */\nexport function observableConfigValue<T>(\n\tkey: string,\n\tdefaultValue: T,\n\tconfigurationService: IConfigurationService,\n\tdebugLocation = DebugLocation.ofCaller(),\n): IObservable<T> {\n\treturn observableFromEventOpts({ debugName: () => `Configuration Key \"${key}\"`, },\n\t\t(handleChange) => configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration(key)) {\n\t\t\t\thandleChange(e);\n\t\t\t}\n\t\t}),\n\t\t() => configurationService.getValue<T>(key) ?? defaultValue,\n\t\tdebugLocation,\n\t);\n}\n\n/** Update the configuration key with a value derived from observables. */\nexport function bindContextKey<T extends ContextKeyValue>(\n\tkey: RawContextKey<T>,\n\tservice: IContextKeyService,\n\tcomputeValue: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller(),\n): IDisposable {\n\tconst boundKey = key.bindTo(service);\n\tconst store = new DisposableStore();\n\tderivedOpts({ debugName: () => `Set Context Key \"${key.key}\"` }, reader => {\n\t\tconst value = computeValue(reader);\n\t\tboundKey.set(value);\n\t\treturn value;\n\t}, debugLocation).recomputeInitiallyAndOnChange(store);\n\treturn store;\n}\n"]}