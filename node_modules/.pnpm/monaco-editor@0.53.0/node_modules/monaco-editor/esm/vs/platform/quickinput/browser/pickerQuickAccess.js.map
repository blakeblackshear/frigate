{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/quickinput/browser/pickerQuickAccess.ts","vs/platform/quickinput/browser/pickerQuickAccess.ts"],"names":[],"mappings":"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","file":"pickerQuickAccess.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IKeyMods, IQuickPickDidAcceptEvent, IQuickPickSeparator, IQuickPick, IQuickPickItem, IQuickInputButton } from '../common/quickInput.js';\nimport { IQuickAccessProvider, IQuickAccessProviderRunOptions } from '../common/quickAccess.js';\nimport { isFunction } from '../../../base/common/types.js';\n\nexport enum TriggerAction {\n\n\t/**\n\t * Do nothing after the button was clicked.\n\t */\n\tNO_ACTION,\n\n\t/**\n\t * Close the picker.\n\t */\n\tCLOSE_PICKER,\n\n\t/**\n\t * Update the results of the picker.\n\t */\n\tREFRESH_PICKER,\n\n\t/**\n\t * Remove the item from the picker.\n\t */\n\tREMOVE_ITEM\n}\n\nexport interface IPickerQuickAccessItem extends IQuickPickItem {\n\n\t/**\n\t* A method that will be executed when the pick item is accepted from\n\t* the picker. The picker will close automatically before running this.\n\t*\n\t* @param keyMods the state of modifier keys when the item was accepted.\n\t* @param event the underlying event that caused the accept to trigger.\n\t*/\n\taccept?(keyMods: IKeyMods, event: IQuickPickDidAcceptEvent): void;\n\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(buttonIndex: number, keyMods: IKeyMods): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessSeparator extends IQuickPickSeparator {\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(buttonIndex: number, keyMods: IKeyMods): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessProviderOptions<T extends IPickerQuickAccessItem> {\n\n\t/**\n\t * Enables support for opening picks in the background via gesture.\n\t */\n\treadonly canAcceptInBackground?: boolean;\n\n\t/**\n\t * Enables to show a pick entry when no results are returned from a search.\n\t */\n\treadonly noResultsPick?: T | ((filter: string) => T);\n\n\t/** Whether to skip trimming the pick filter string */\n\treadonly shouldSkipTrimPickFilter?: boolean;\n}\n\nexport type Pick<T> = T | IQuickPickSeparator;\nexport type PicksWithActive<T> = { items: readonly Pick<T>[]; active?: T };\nexport type Picks<T> = readonly Pick<T>[] | PicksWithActive<T>;\nexport type FastAndSlowPicks<T> = {\n\n\t/**\n\t * Picks that will show instantly or after a short delay\n\t * based on the `mergeDelay` property to reduce flicker.\n\t */\n\treadonly picks: Picks<T>;\n\n\t/**\n\t * Picks that will show after they have been resolved.\n\t */\n\treadonly additionalPicks: Promise<Picks<T>>;\n\n\t/**\n\t * A delay in milliseconds to wait before showing the\n\t * `picks` to give a chance to merge with `additionalPicks`\n\t * for reduced flicker.\n\t */\n\treadonly mergeDelay?: number;\n};\n\nfunction isPicksWithActive<T>(obj: unknown): obj is PicksWithActive<T> {\n\tconst candidate = obj as PicksWithActive<T>;\n\n\treturn Array.isArray(candidate.items);\n}\n\nfunction isFastAndSlowPicks<T>(obj: unknown): obj is FastAndSlowPicks<T> {\n\tconst candidate = obj as FastAndSlowPicks<T>;\n\n\treturn !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\n\nexport abstract class PickerQuickAccessProvider<T extends IPickerQuickAccessItem> extends Disposable implements IQuickAccessProvider {\n\n\tconstructor(private prefix: string, protected options?: IPickerQuickAccessProviderOptions<T>) {\n\t\tsuper();\n\t}\n\n\tprovide(picker: IQuickPick<T, { useSeparators: true }>, token: CancellationToken, runOptions?: IQuickAccessProviderRunOptions): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Apply options if any\n\t\tpicker.canAcceptInBackground = !!this.options?.canAcceptInBackground;\n\n\t\t// Disable filtering & sorting, we control the results\n\t\tpicker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n\n\t\t// Set initial picks and update on type\n\t\tlet picksCts: CancellationTokenSource | undefined = undefined;\n\t\tconst picksDisposable = disposables.add(new MutableDisposable());\n\t\tconst updatePickerItems = async () => {\n\t\t\t// Cancel any previous ask for picks and busy\n\t\t\tpicksCts?.dispose(true);\n\t\t\tpicker.busy = false;\n\n\t\t\t// Setting the .value will call dispose() on the previous value, so we need to do this AFTER cancelling with dispose(true).\n\t\t\tconst picksDisposables = picksDisposable.value = new DisposableStore();\n\n\t\t\t// Create new cancellation source for this run\n\t\t\tpicksCts = picksDisposables.add(new CancellationTokenSource(token));\n\n\t\t\t// Collect picks and support both long running and short or combined\n\t\t\tconst picksToken = picksCts.token;\n\t\t\tlet picksFilter = picker.value.substring(this.prefix.length);\n\n\t\t\tif (!this.options?.shouldSkipTrimPickFilter) {\n\t\t\t\tpicksFilter = picksFilter.trim();\n\t\t\t}\n\n\t\t\tconst providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);\n\n\t\t\tconst applyPicks = (picks: Picks<T>, skipEmpty?: boolean): boolean => {\n\t\t\t\tlet items: readonly Pick<T>[];\n\t\t\t\tlet activeItem: T | undefined = undefined;\n\n\t\t\t\tif (isPicksWithActive(picks)) {\n\t\t\t\t\titems = picks.items;\n\t\t\t\t\tactiveItem = picks.active;\n\t\t\t\t} else {\n\t\t\t\t\titems = picks;\n\t\t\t\t}\n\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\tif (skipEmpty) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We show the no results pick if we have no input to prevent completely empty pickers #172613\n\t\t\t\t\tif ((picksFilter.length > 0 || picker.hideInput) && this.options?.noResultsPick) {\n\t\t\t\t\t\tif (isFunction(this.options.noResultsPick)) {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick(picksFilter)];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpicker.items = items;\n\t\t\t\tif (activeItem) {\n\t\t\t\t\tpicker.activeItems = [activeItem];\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tconst applyFastAndSlowPicks = async (fastAndSlowPicks: FastAndSlowPicks<T>): Promise<void> => {\n\t\t\t\tlet fastPicksApplied = false;\n\t\t\t\tlet slowPicksApplied = false;\n\n\t\t\t\tawait Promise.all([\n\n\t\t\t\t\t// Fast Picks: if `mergeDelay` is configured, in order to reduce\n\t\t\t\t\t// amount of flicker, we race against the slow picks over some delay\n\t\t\t\t\t// and then set the fast picks.\n\t\t\t\t\t// If the slow picks are faster, we reduce the flicker by only\n\t\t\t\t\t// setting the items once.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tif (typeof fastAndSlowPicks.mergeDelay === 'number') {\n\t\t\t\t\t\t\tawait timeout(fastAndSlowPicks.mergeDelay);\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!slowPicksApplied) {\n\t\t\t\t\t\t\tfastPicksApplied = applyPicks(fastAndSlowPicks.picks, true /* skip over empty to reduce flicker */);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\n\t\t\t\t\t// Slow Picks: we await the slow picks and then set them at\n\t\t\t\t\t// once together with the fast picks, but only if we actually\n\t\t\t\t\t// have additional results.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tpicker.busy = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst awaitedAdditionalPicks = await fastAndSlowPicks.additionalPicks;\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet picks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet activePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(fastAndSlowPicks.picks)) {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks.items;\n\t\t\t\t\t\t\t\tactivePick = fastAndSlowPicks.picks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet additionalPicks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet additionalActivePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(awaitedAdditionalPicks)) {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks.items;\n\t\t\t\t\t\t\t\tadditionalActivePick = awaitedAdditionalPicks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (additionalPicks.length > 0 || !fastPicksApplied) {\n\t\t\t\t\t\t\t\t// If we do not have any activePick or additionalActivePick\n\t\t\t\t\t\t\t\t// we try to preserve the currently active pick from the\n\t\t\t\t\t\t\t\t// fast results. This fixes an issue where the user might\n\t\t\t\t\t\t\t\t// have made a pick active before the additional results\n\t\t\t\t\t\t\t\t// kick in.\n\t\t\t\t\t\t\t\t// See https://github.com/microsoft/vscode/issues/102480\n\t\t\t\t\t\t\t\tlet fallbackActivePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\t\tif (!activePick && !additionalActivePick) {\n\t\t\t\t\t\t\t\t\tconst fallbackActivePickCandidate = picker.activeItems[0];\n\t\t\t\t\t\t\t\t\tif (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n\t\t\t\t\t\t\t\t\t\tfallbackActivePick = fallbackActivePickCandidate;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tapplyPicks({\n\t\t\t\t\t\t\t\t\titems: [...picks, ...additionalPicks],\n\t\t\t\t\t\t\t\t\tactive: activePick || additionalActivePick || fallbackActivePick\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tslowPicksApplied = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t})()\n\t\t\t\t]);\n\t\t\t};\n\n\t\t\t// No Picks\n\t\t\tif (providedPicks === null) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\t// Fast and Slow Picks\n\t\t\telse if (isFastAndSlowPicks(providedPicks)) {\n\t\t\t\tawait applyFastAndSlowPicks(providedPicks);\n\t\t\t}\n\n\t\t\t// Fast Picks\n\t\t\telse if (!(providedPicks instanceof Promise)) {\n\t\t\t\tapplyPicks(providedPicks);\n\t\t\t}\n\n\t\t\t// Slow Picks\n\t\t\telse {\n\t\t\t\tpicker.busy = true;\n\t\t\t\ttry {\n\t\t\t\t\tconst awaitedPicks = await providedPicks;\n\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isFastAndSlowPicks(awaitedPicks)) {\n\t\t\t\t\t\tawait applyFastAndSlowPicks(awaitedPicks);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyPicks(awaitedPicks);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdisposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n\t\tupdatePickerItems();\n\n\t\t// Accept the pick on accept and hide picker\n\t\tdisposables.add(picker.onDidAccept(event => {\n\t\t\tif (runOptions?.handleAccept) {\n\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t}\n\t\t\t\trunOptions.handleAccept?.(picker.activeItems[0], event.inBackground);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [item] = picker.selectedItems;\n\t\t\tif (typeof item?.accept === 'function') {\n\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t}\n\n\t\t\t\titem.accept(picker.keyMods, event);\n\t\t\t}\n\t\t}));\n\n\t\tconst buttonTrigger = async (button: IQuickInputButton, item: T | IPickerQuickAccessSeparator) => {\n\t\t\tif (typeof item.trigger !== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonIndex = item.buttons?.indexOf(button) ?? -1;\n\t\t\tif (buttonIndex >= 0) {\n\t\t\t\tconst result = item.trigger(buttonIndex, picker.keyMods);\n\t\t\t\tconst action = (typeof result === 'number') ? result : await result;\n\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase TriggerAction.NO_ACTION:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.CLOSE_PICKER:\n\t\t\t\t\t\tpicker.hide();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REFRESH_PICKER:\n\t\t\t\t\t\tupdatePickerItems();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REMOVE_ITEM: {\n\t\t\t\t\t\tconst index = picker.items.indexOf(item);\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tconst items = picker.items.slice();\n\t\t\t\t\t\t\tconst removed = items.splice(index, 1);\n\t\t\t\t\t\t\tconst activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);\n\t\t\t\t\t\t\tconst keepScrollPositionBefore = picker.keepScrollPosition;\n\t\t\t\t\t\t\tpicker.keepScrollPosition = true;\n\t\t\t\t\t\t\tpicker.items = items;\n\t\t\t\t\t\t\tif (activeItems) {\n\t\t\t\t\t\t\t\tpicker.activeItems = activeItems;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpicker.keepScrollPosition = keepScrollPositionBefore;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Trigger the pick with button index if button triggered\n\t\tdisposables.add(picker.onDidTriggerItemButton(({ button, item }) => buttonTrigger(button, item)));\n\t\tdisposables.add(picker.onDidTriggerSeparatorButton(({ button, separator }) => buttonTrigger(button, separator)));\n\n\t\treturn disposables;\n\t}\n\n\t/**\n\t * Returns an array of picks and separators as needed. If the picks are resolved\n\t * long running, the provided cancellation token should be used to cancel the\n\t * operation when the token signals this.\n\t *\n\t * The implementor is responsible for filtering and sorting the picks given the\n\t * provided `filter`.\n\t *\n\t * @param filter a filter to apply to the picks.\n\t * @param disposables can be used to register disposables that should be cleaned\n\t * up when the picker closes.\n\t * @param token for long running tasks, implementors need to check on cancellation\n\t * through this token.\n\t * @returns the picks either directly, as promise or combined fast and slow results.\n\t * Pickers can return `null` to signal that no change in picks is needed.\n\t */\n\tprotected abstract _getPicks(filter: string, disposables: DisposableStore, token: CancellationToken, runOptions?: IQuickAccessProviderRunOptions): Picks<T> | Promise<Picks<T> | FastAndSlowPicks<T>> | FastAndSlowPicks<T> | null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IKeyMods, IQuickPickDidAcceptEvent, IQuickPickSeparator, IQuickPick, IQuickPickItem, IQuickInputButton } from '../common/quickInput.js';\nimport { IQuickAccessProvider, IQuickAccessProviderRunOptions } from '../common/quickAccess.js';\nimport { isFunction } from '../../../base/common/types.js';\n\nexport enum TriggerAction {\n\n\t/**\n\t * Do nothing after the button was clicked.\n\t */\n\tNO_ACTION,\n\n\t/**\n\t * Close the picker.\n\t */\n\tCLOSE_PICKER,\n\n\t/**\n\t * Update the results of the picker.\n\t */\n\tREFRESH_PICKER,\n\n\t/**\n\t * Remove the item from the picker.\n\t */\n\tREMOVE_ITEM\n}\n\nexport interface IPickerQuickAccessItem extends IQuickPickItem {\n\n\t/**\n\t* A method that will be executed when the pick item is accepted from\n\t* the picker. The picker will close automatically before running this.\n\t*\n\t* @param keyMods the state of modifier keys when the item was accepted.\n\t* @param event the underlying event that caused the accept to trigger.\n\t*/\n\taccept?(keyMods: IKeyMods, event: IQuickPickDidAcceptEvent): void;\n\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(buttonIndex: number, keyMods: IKeyMods): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessSeparator extends IQuickPickSeparator {\n\t/**\n\t * A method that will be executed when a button of the pick item was\n\t * clicked on.\n\t *\n\t * @param buttonIndex index of the button of the item that\n\t * was clicked.\n\t *\n\t * @param the state of modifier keys when the button was triggered.\n\t *\n\t * @returns a value that indicates what should happen after the trigger\n\t * which can be a `Promise` for long running operations.\n\t */\n\ttrigger?(buttonIndex: number, keyMods: IKeyMods): TriggerAction | Promise<TriggerAction>;\n}\n\nexport interface IPickerQuickAccessProviderOptions<T extends IPickerQuickAccessItem> {\n\n\t/**\n\t * Enables support for opening picks in the background via gesture.\n\t */\n\treadonly canAcceptInBackground?: boolean;\n\n\t/**\n\t * Enables to show a pick entry when no results are returned from a search.\n\t */\n\treadonly noResultsPick?: T | ((filter: string) => T);\n\n\t/** Whether to skip trimming the pick filter string */\n\treadonly shouldSkipTrimPickFilter?: boolean;\n}\n\nexport type Pick<T> = T | IQuickPickSeparator;\nexport type PicksWithActive<T> = { items: readonly Pick<T>[]; active?: T };\nexport type Picks<T> = readonly Pick<T>[] | PicksWithActive<T>;\nexport type FastAndSlowPicks<T> = {\n\n\t/**\n\t * Picks that will show instantly or after a short delay\n\t * based on the `mergeDelay` property to reduce flicker.\n\t */\n\treadonly picks: Picks<T>;\n\n\t/**\n\t * Picks that will show after they have been resolved.\n\t */\n\treadonly additionalPicks: Promise<Picks<T>>;\n\n\t/**\n\t * A delay in milliseconds to wait before showing the\n\t * `picks` to give a chance to merge with `additionalPicks`\n\t * for reduced flicker.\n\t */\n\treadonly mergeDelay?: number;\n};\n\nfunction isPicksWithActive<T>(obj: unknown): obj is PicksWithActive<T> {\n\tconst candidate = obj as PicksWithActive<T>;\n\n\treturn Array.isArray(candidate.items);\n}\n\nfunction isFastAndSlowPicks<T>(obj: unknown): obj is FastAndSlowPicks<T> {\n\tconst candidate = obj as FastAndSlowPicks<T>;\n\n\treturn !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\n\nexport abstract class PickerQuickAccessProvider<T extends IPickerQuickAccessItem> extends Disposable implements IQuickAccessProvider {\n\n\tconstructor(private prefix: string, protected options?: IPickerQuickAccessProviderOptions<T>) {\n\t\tsuper();\n\t}\n\n\tprovide(picker: IQuickPick<T, { useSeparators: true }>, token: CancellationToken, runOptions?: IQuickAccessProviderRunOptions): IDisposable {\n\t\tconst disposables = new DisposableStore();\n\n\t\t// Apply options if any\n\t\tpicker.canAcceptInBackground = !!this.options?.canAcceptInBackground;\n\n\t\t// Disable filtering & sorting, we control the results\n\t\tpicker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n\n\t\t// Set initial picks and update on type\n\t\tlet picksCts: CancellationTokenSource | undefined = undefined;\n\t\tconst picksDisposable = disposables.add(new MutableDisposable());\n\t\tconst updatePickerItems = async () => {\n\t\t\t// Cancel any previous ask for picks and busy\n\t\t\tpicksCts?.dispose(true);\n\t\t\tpicker.busy = false;\n\n\t\t\t// Setting the .value will call dispose() on the previous value, so we need to do this AFTER cancelling with dispose(true).\n\t\t\tconst picksDisposables = picksDisposable.value = new DisposableStore();\n\n\t\t\t// Create new cancellation source for this run\n\t\t\tpicksCts = picksDisposables.add(new CancellationTokenSource(token));\n\n\t\t\t// Collect picks and support both long running and short or combined\n\t\t\tconst picksToken = picksCts.token;\n\t\t\tlet picksFilter = picker.value.substring(this.prefix.length);\n\n\t\t\tif (!this.options?.shouldSkipTrimPickFilter) {\n\t\t\t\tpicksFilter = picksFilter.trim();\n\t\t\t}\n\n\t\t\tconst providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);\n\n\t\t\tconst applyPicks = (picks: Picks<T>, skipEmpty?: boolean): boolean => {\n\t\t\t\tlet items: readonly Pick<T>[];\n\t\t\t\tlet activeItem: T | undefined = undefined;\n\n\t\t\t\tif (isPicksWithActive(picks)) {\n\t\t\t\t\titems = picks.items;\n\t\t\t\t\tactiveItem = picks.active;\n\t\t\t\t} else {\n\t\t\t\t\titems = picks;\n\t\t\t\t}\n\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\tif (skipEmpty) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We show the no results pick if we have no input to prevent completely empty pickers #172613\n\t\t\t\t\tif ((picksFilter.length > 0 || picker.hideInput) && this.options?.noResultsPick) {\n\t\t\t\t\t\tif (isFunction(this.options.noResultsPick)) {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick(picksFilter)];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titems = [this.options.noResultsPick];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpicker.items = items;\n\t\t\t\tif (activeItem) {\n\t\t\t\t\tpicker.activeItems = [activeItem];\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tconst applyFastAndSlowPicks = async (fastAndSlowPicks: FastAndSlowPicks<T>): Promise<void> => {\n\t\t\t\tlet fastPicksApplied = false;\n\t\t\t\tlet slowPicksApplied = false;\n\n\t\t\t\tawait Promise.all([\n\n\t\t\t\t\t// Fast Picks: if `mergeDelay` is configured, in order to reduce\n\t\t\t\t\t// amount of flicker, we race against the slow picks over some delay\n\t\t\t\t\t// and then set the fast picks.\n\t\t\t\t\t// If the slow picks are faster, we reduce the flicker by only\n\t\t\t\t\t// setting the items once.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tif (typeof fastAndSlowPicks.mergeDelay === 'number') {\n\t\t\t\t\t\t\tawait timeout(fastAndSlowPicks.mergeDelay);\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!slowPicksApplied) {\n\t\t\t\t\t\t\tfastPicksApplied = applyPicks(fastAndSlowPicks.picks, true /* skip over empty to reduce flicker */);\n\t\t\t\t\t\t}\n\t\t\t\t\t})(),\n\n\t\t\t\t\t// Slow Picks: we await the slow picks and then set them at\n\t\t\t\t\t// once together with the fast picks, but only if we actually\n\t\t\t\t\t// have additional results.\n\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\tpicker.busy = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst awaitedAdditionalPicks = await fastAndSlowPicks.additionalPicks;\n\t\t\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet picks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet activePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(fastAndSlowPicks.picks)) {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks.items;\n\t\t\t\t\t\t\t\tactivePick = fastAndSlowPicks.picks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpicks = fastAndSlowPicks.picks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet additionalPicks: readonly Pick<T>[];\n\t\t\t\t\t\t\tlet additionalActivePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\tif (isPicksWithActive(awaitedAdditionalPicks)) {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks.items;\n\t\t\t\t\t\t\t\tadditionalActivePick = awaitedAdditionalPicks.active;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tadditionalPicks = awaitedAdditionalPicks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (additionalPicks.length > 0 || !fastPicksApplied) {\n\t\t\t\t\t\t\t\t// If we do not have any activePick or additionalActivePick\n\t\t\t\t\t\t\t\t// we try to preserve the currently active pick from the\n\t\t\t\t\t\t\t\t// fast results. This fixes an issue where the user might\n\t\t\t\t\t\t\t\t// have made a pick active before the additional results\n\t\t\t\t\t\t\t\t// kick in.\n\t\t\t\t\t\t\t\t// See https://github.com/microsoft/vscode/issues/102480\n\t\t\t\t\t\t\t\tlet fallbackActivePick: Pick<T> | undefined = undefined;\n\t\t\t\t\t\t\t\tif (!activePick && !additionalActivePick) {\n\t\t\t\t\t\t\t\t\tconst fallbackActivePickCandidate = picker.activeItems[0];\n\t\t\t\t\t\t\t\t\tif (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n\t\t\t\t\t\t\t\t\t\tfallbackActivePick = fallbackActivePickCandidate;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tapplyPicks({\n\t\t\t\t\t\t\t\t\titems: [...picks, ...additionalPicks],\n\t\t\t\t\t\t\t\t\tactive: activePick || additionalActivePick || fallbackActivePick\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tslowPicksApplied = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t})()\n\t\t\t\t]);\n\t\t\t};\n\n\t\t\t// No Picks\n\t\t\tif (providedPicks === null) {\n\t\t\t\t// Ignore\n\t\t\t}\n\n\t\t\t// Fast and Slow Picks\n\t\t\telse if (isFastAndSlowPicks(providedPicks)) {\n\t\t\t\tawait applyFastAndSlowPicks(providedPicks);\n\t\t\t}\n\n\t\t\t// Fast Picks\n\t\t\telse if (!(providedPicks instanceof Promise)) {\n\t\t\t\tapplyPicks(providedPicks);\n\t\t\t}\n\n\t\t\t// Slow Picks\n\t\t\telse {\n\t\t\t\tpicker.busy = true;\n\t\t\t\ttry {\n\t\t\t\t\tconst awaitedPicks = await providedPicks;\n\t\t\t\t\tif (picksToken.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isFastAndSlowPicks(awaitedPicks)) {\n\t\t\t\t\t\tawait applyFastAndSlowPicks(awaitedPicks);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyPicks(awaitedPicks);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (!picksToken.isCancellationRequested) {\n\t\t\t\t\t\tpicker.busy = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdisposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n\t\tupdatePickerItems();\n\n\t\t// Accept the pick on accept and hide picker\n\t\tdisposables.add(picker.onDidAccept(event => {\n\t\t\tif (runOptions?.handleAccept) {\n\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t}\n\t\t\t\trunOptions.handleAccept?.(picker.activeItems[0], event.inBackground);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [item] = picker.selectedItems;\n\t\t\tif (typeof item?.accept === 'function') {\n\t\t\t\tif (!event.inBackground) {\n\t\t\t\t\tpicker.hide(); // hide picker unless we accept in background\n\t\t\t\t}\n\n\t\t\t\titem.accept(picker.keyMods, event);\n\t\t\t}\n\t\t}));\n\n\t\tconst buttonTrigger = async (button: IQuickInputButton, item: T | IPickerQuickAccessSeparator) => {\n\t\t\tif (typeof item.trigger !== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonIndex = item.buttons?.indexOf(button) ?? -1;\n\t\t\tif (buttonIndex >= 0) {\n\t\t\t\tconst result = item.trigger(buttonIndex, picker.keyMods);\n\t\t\t\tconst action = (typeof result === 'number') ? result : await result;\n\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase TriggerAction.NO_ACTION:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.CLOSE_PICKER:\n\t\t\t\t\t\tpicker.hide();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REFRESH_PICKER:\n\t\t\t\t\t\tupdatePickerItems();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TriggerAction.REMOVE_ITEM: {\n\t\t\t\t\t\tconst index = picker.items.indexOf(item);\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tconst items = picker.items.slice();\n\t\t\t\t\t\t\tconst removed = items.splice(index, 1);\n\t\t\t\t\t\t\tconst activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);\n\t\t\t\t\t\t\tconst keepScrollPositionBefore = picker.keepScrollPosition;\n\t\t\t\t\t\t\tpicker.keepScrollPosition = true;\n\t\t\t\t\t\t\tpicker.items = items;\n\t\t\t\t\t\t\tif (activeItems) {\n\t\t\t\t\t\t\t\tpicker.activeItems = activeItems;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpicker.keepScrollPosition = keepScrollPositionBefore;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Trigger the pick with button index if button triggered\n\t\tdisposables.add(picker.onDidTriggerItemButton(({ button, item }) => buttonTrigger(button, item)));\n\t\tdisposables.add(picker.onDidTriggerSeparatorButton(({ button, separator }) => buttonTrigger(button, separator)));\n\n\t\treturn disposables;\n\t}\n\n\t/**\n\t * Returns an array of picks and separators as needed. If the picks are resolved\n\t * long running, the provided cancellation token should be used to cancel the\n\t * operation when the token signals this.\n\t *\n\t * The implementor is responsible for filtering and sorting the picks given the\n\t * provided `filter`.\n\t *\n\t * @param filter a filter to apply to the picks.\n\t * @param disposables can be used to register disposables that should be cleaned\n\t * up when the picker closes.\n\t * @param token for long running tasks, implementors need to check on cancellation\n\t * through this token.\n\t * @returns the picks either directly, as promise or combined fast and slow results.\n\t * Pickers can return `null` to signal that no change in picks is needed.\n\t */\n\tprotected abstract _getPicks(filter: string, disposables: DisposableStore, token: CancellationToken, runOptions?: IQuickAccessProviderRunOptions): Picks<T> | Promise<Picks<T> | FastAndSlowPicks<T>> | FastAndSlowPicks<T> | null;\n}\n"]}