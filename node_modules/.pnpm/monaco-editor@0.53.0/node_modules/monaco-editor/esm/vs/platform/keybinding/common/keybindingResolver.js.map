{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/keybinding/common/keybindingResolver.ts","vs/platform/keybinding/common/keybindingResolver.ts"],"names":[],"mappings":"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","file":"keybindingResolver.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { implies, ContextKeyExpression, ContextKeyExprType, IContext, IContextKeyService, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nimport { ResolvedKeybindingItem } from './resolvedKeybindingItem.js';\n\n//#region resolution-result\n\nexport const enum ResultKind {\n\t/** No keybinding found this sequence of chords */\n\tNoMatchingKb,\n\n\t/** There're several keybindings that have the given sequence of chords as a prefix */\n\tMoreChordsNeeded,\n\n\t/** A single keybinding found to be dispatched/invoked */\n\tKbFound\n}\n\nexport type ResolutionResult =\n\t| { kind: ResultKind.NoMatchingKb }\n\t| { kind: ResultKind.MoreChordsNeeded }\n\t| { kind: ResultKind.KbFound; commandId: string | null; commandArgs: any; isBubble: boolean };\n\n\n// util definitions to make working with the above types easier within this module:\n\nexport const NoMatchingKb: ResolutionResult = { kind: ResultKind.NoMatchingKb };\nconst MoreChordsNeeded: ResolutionResult = { kind: ResultKind.MoreChordsNeeded };\nfunction KbFound(commandId: string | null, commandArgs: any, isBubble: boolean): ResolutionResult {\n\treturn { kind: ResultKind.KbFound, commandId, commandArgs, isBubble };\n}\n\n//#endregion\n\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n\tprivate readonly _log: (str: string) => void;\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map</* commandId */ string, boolean>;\n\tprivate readonly _map: Map</* 1st chord's keypress */ string, ResolvedKeybindingItem[]>;\n\tprivate readonly _lookupMap: Map</* commandId */ string, ResolvedKeybindingItem[]>;\n\n\tconstructor(\n\t\t/** built-in and extension-provided keybindings */\n\t\tdefaultKeybindings: ResolvedKeybindingItem[],\n\t\t/** user's keybindings */\n\t\toverrides: ResolvedKeybindingItem[],\n\t\tlog: (str: string) => void\n\t) {\n\t\tthis._log = log;\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (const defaultKeybinding of defaultKeybindings) {\n\t\t\tconst command = defaultKeybinding.command;\n\t\t\tif (command && command.charAt(0) !== '-') {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.handleRemovals(([] as ResolvedKeybindingItem[]).concat(defaultKeybindings).concat(overrides));\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tconst k = this._keybindings[i];\n\t\t\tif (k.chords.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n\t\t\tconst when = k.when?.substituteConstants();\n\n\t\t\tif (when && when.type === ContextKeyExprType.False) {\n\t\t\t\t// when condition is false\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addKeyPress(k.chords[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(defaultKb: ResolvedKeybindingItem, keypress: string[] | null, when: ContextKeyExpression | undefined): boolean {\n\t\tif (keypress) {\n\t\t\tfor (let i = 0; i < keypress.length; i++) {\n\t\t\t\tif (keypress[i] !== defaultKb.chords[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// `true` means always, as does `undefined`\n\t\t// so we will treat `true` === `undefined`\n\t\tif (when && when.type !== ContextKeyExprType.True) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Looks for rules containing \"-commandId\" and removes them.\n\t */\n\tpublic static handleRemovals(rules: ResolvedKeybindingItem[]): ResolvedKeybindingItem[] {\n\t\t// Do a first pass and construct a hash-map for removals\n\t\tconst removals = new Map</* commandId */ string, ResolvedKeybindingItem[]>();\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tif (rule.command && rule.command.charAt(0) === '-') {\n\t\t\t\tconst command = rule.command.substring(1);\n\t\t\t\tif (!removals.has(command)) {\n\t\t\t\t\tremovals.set(command, [rule]);\n\t\t\t\t} else {\n\t\t\t\t\tremovals.get(command)!.push(rule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (removals.size === 0) {\n\t\t\t// There are no removals\n\t\t\treturn rules;\n\t\t}\n\n\t\t// Do a second pass and keep only non-removed keybindings\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\n\t\t\tif (!rule.command || rule.command.length === 0) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rule.command.charAt(0) === '-') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst commandRemovals = removals.get(rule.command);\n\t\t\tif (!commandRemovals || !rule.isDefault) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet isRemoved = false;\n\t\t\tfor (const commandRemoval of commandRemovals) {\n\t\t\t\tconst when = commandRemoval.when;\n\t\t\t\tif (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n\t\t\t\t\tisRemoved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRemoved) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === 'undefined') {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tconst conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Test if the shorter keybinding is a prefix of the longer one.\n\t\t\t// If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n\t\t\tlet isShorterKbPrefix = true;\n\t\t\tfor (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n\t\t\t\tif (conflict.chords[i] !== item.chords[i]) {\n\t\t\t\t\t// The ith step does not conflict\n\t\t\t\t\tisShorterKbPrefix = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isShorterKbPrefix) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t */\n\tpublic static whenIsEntirelyIncluded(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!b || b.type === ContextKeyExprType.True) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || a.type === ContextKeyExprType.True) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn implies(a, b);\n\t}\n\n\tpublic getKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupPrimaryKeybinding(commandId: string, context: IContextKeyService, enforceContextCheck = false): ResolvedKeybindingItem | null {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (items.length === 1 && !enforceContextCheck) {\n\t\t\treturn items[0];\n\t\t}\n\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tconst item = items[i];\n\t\t\tif (context.contextMatchesRules(item.when)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\tif (enforceContextCheck) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\t/**\n\t * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n\t *\n\t * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n\t * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n\t */\n\tpublic resolve(context: IContext, currentChords: string[], keypress: string): ResolutionResult {\n\n\t\tconst pressedChords = [...currentChords, keypress];\n\n\t\tthis._log(`| Resolving ${pressedChords}`);\n\n\t\tconst kbCandidates = this._map.get(pressedChords[0]);\n\t\tif (kbCandidates === undefined) {\n\t\t\t// No bindings with such 0-th chord\n\t\t\tthis._log(`\\\\ No keybinding entries.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (pressedChords.length < 2) {\n\t\t\tlookupMap = kbCandidates;\n\t\t} else {\n\t\t\t// Fetch all chord bindings for `currentChords`\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = kbCandidates.length; i < len; i++) {\n\n\t\t\t\tconst candidate = kbCandidates[i];\n\n\t\t\t\tif (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prefixMatches = true;\n\t\t\t\tfor (let i = 1; i < pressedChords.length; i++) {\n\t\t\t\t\tif (candidate.chords[i] !== pressedChords[i]) {\n\t\t\t\t\t\tprefixMatches = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prefixMatches) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check there's a keybinding with a matching when clause\n\t\tconst result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\t// check we got all chords necessary to be sure a particular keybinding needs to be invoked\n\t\tif (pressedChords.length < result.chords.length) {\n\t\t\t// The chord sequence is not complete\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\t\t\treturn MoreChordsNeeded;\n\t\t}\n\n\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n\t\treturn KbFound(result.command, result.commandArgs, result.bubble);\n\t}\n\n\tprivate _findCommand(context: IContext, matches: ResolvedKeybindingItem[]): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tconst k = matches[i];\n\n\t\t\tif (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _contextMatchesRules(context: IContext, rules: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n}\n\nfunction printWhenExplanation(when: ContextKeyExpression | undefined): string {\n\tif (!when) {\n\t\treturn `no when condition`;\n\t}\n\treturn `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb: ResolvedKeybindingItem): string {\n\treturn (\n\t\tkb.extensionId\n\t\t\t? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n\t\t\t: (kb.isDefault ? `built-in` : `user`)\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { implies, ContextKeyExpression, ContextKeyExprType, IContext, IContextKeyService, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nimport { ResolvedKeybindingItem } from './resolvedKeybindingItem.js';\n\n//#region resolution-result\n\nexport const enum ResultKind {\n\t/** No keybinding found this sequence of chords */\n\tNoMatchingKb,\n\n\t/** There're several keybindings that have the given sequence of chords as a prefix */\n\tMoreChordsNeeded,\n\n\t/** A single keybinding found to be dispatched/invoked */\n\tKbFound\n}\n\nexport type ResolutionResult =\n\t| { kind: ResultKind.NoMatchingKb }\n\t| { kind: ResultKind.MoreChordsNeeded }\n\t| { kind: ResultKind.KbFound; commandId: string | null; commandArgs: any; isBubble: boolean };\n\n\n// util definitions to make working with the above types easier within this module:\n\nexport const NoMatchingKb: ResolutionResult = { kind: ResultKind.NoMatchingKb };\nconst MoreChordsNeeded: ResolutionResult = { kind: ResultKind.MoreChordsNeeded };\nfunction KbFound(commandId: string | null, commandArgs: any, isBubble: boolean): ResolutionResult {\n\treturn { kind: ResultKind.KbFound, commandId, commandArgs, isBubble };\n}\n\n//#endregion\n\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n\tprivate readonly _log: (str: string) => void;\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map</* commandId */ string, boolean>;\n\tprivate readonly _map: Map</* 1st chord's keypress */ string, ResolvedKeybindingItem[]>;\n\tprivate readonly _lookupMap: Map</* commandId */ string, ResolvedKeybindingItem[]>;\n\n\tconstructor(\n\t\t/** built-in and extension-provided keybindings */\n\t\tdefaultKeybindings: ResolvedKeybindingItem[],\n\t\t/** user's keybindings */\n\t\toverrides: ResolvedKeybindingItem[],\n\t\tlog: (str: string) => void\n\t) {\n\t\tthis._log = log;\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (const defaultKeybinding of defaultKeybindings) {\n\t\t\tconst command = defaultKeybinding.command;\n\t\t\tif (command && command.charAt(0) !== '-') {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.handleRemovals(([] as ResolvedKeybindingItem[]).concat(defaultKeybindings).concat(overrides));\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tconst k = this._keybindings[i];\n\t\t\tif (k.chords.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n\t\t\tconst when = k.when?.substituteConstants();\n\n\t\t\tif (when && when.type === ContextKeyExprType.False) {\n\t\t\t\t// when condition is false\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addKeyPress(k.chords[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(defaultKb: ResolvedKeybindingItem, keypress: string[] | null, when: ContextKeyExpression | undefined): boolean {\n\t\tif (keypress) {\n\t\t\tfor (let i = 0; i < keypress.length; i++) {\n\t\t\t\tif (keypress[i] !== defaultKb.chords[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// `true` means always, as does `undefined`\n\t\t// so we will treat `true` === `undefined`\n\t\tif (when && when.type !== ContextKeyExprType.True) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Looks for rules containing \"-commandId\" and removes them.\n\t */\n\tpublic static handleRemovals(rules: ResolvedKeybindingItem[]): ResolvedKeybindingItem[] {\n\t\t// Do a first pass and construct a hash-map for removals\n\t\tconst removals = new Map</* commandId */ string, ResolvedKeybindingItem[]>();\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tif (rule.command && rule.command.charAt(0) === '-') {\n\t\t\t\tconst command = rule.command.substring(1);\n\t\t\t\tif (!removals.has(command)) {\n\t\t\t\t\tremovals.set(command, [rule]);\n\t\t\t\t} else {\n\t\t\t\t\tremovals.get(command)!.push(rule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (removals.size === 0) {\n\t\t\t// There are no removals\n\t\t\treturn rules;\n\t\t}\n\n\t\t// Do a second pass and keep only non-removed keybindings\n\t\tconst result: ResolvedKeybindingItem[] = [];\n\t\tfor (let i = 0, len = rules.length; i < len; i++) {\n\t\t\tconst rule = rules[i];\n\n\t\t\tif (!rule.command || rule.command.length === 0) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rule.command.charAt(0) === '-') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst commandRemovals = removals.get(rule.command);\n\t\t\tif (!commandRemovals || !rule.isDefault) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet isRemoved = false;\n\t\t\tfor (const commandRemoval of commandRemovals) {\n\t\t\t\tconst when = commandRemoval.when;\n\t\t\t\tif (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n\t\t\t\t\tisRemoved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRemoved) {\n\t\t\t\tresult.push(rule);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === 'undefined') {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tconst conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Test if the shorter keybinding is a prefix of the longer one.\n\t\t\t// If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n\t\t\tlet isShorterKbPrefix = true;\n\t\t\tfor (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n\t\t\t\tif (conflict.chords[i] !== item.chords[i]) {\n\t\t\t\t\t// The ith step does not conflict\n\t\t\t\t\tisShorterKbPrefix = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isShorterKbPrefix) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t */\n\tpublic static whenIsEntirelyIncluded(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!b || b.type === ContextKeyExprType.True) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || a.type === ContextKeyExprType.True) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn implies(a, b);\n\t}\n\n\tpublic getKeybindings(): readonly ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupPrimaryKeybinding(commandId: string, context: IContextKeyService, enforceContextCheck = false): ResolvedKeybindingItem | null {\n\t\tconst items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (items.length === 1 && !enforceContextCheck) {\n\t\t\treturn items[0];\n\t\t}\n\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tconst item = items[i];\n\t\t\tif (context.contextMatchesRules(item.when)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\tif (enforceContextCheck) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\t/**\n\t * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n\t *\n\t * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n\t * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n\t */\n\tpublic resolve(context: IContext, currentChords: string[], keypress: string): ResolutionResult {\n\n\t\tconst pressedChords = [...currentChords, keypress];\n\n\t\tthis._log(`| Resolving ${pressedChords}`);\n\n\t\tconst kbCandidates = this._map.get(pressedChords[0]);\n\t\tif (kbCandidates === undefined) {\n\t\t\t// No bindings with such 0-th chord\n\t\t\tthis._log(`\\\\ No keybinding entries.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (pressedChords.length < 2) {\n\t\t\tlookupMap = kbCandidates;\n\t\t} else {\n\t\t\t// Fetch all chord bindings for `currentChords`\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = kbCandidates.length; i < len; i++) {\n\n\t\t\t\tconst candidate = kbCandidates[i];\n\n\t\t\t\tif (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prefixMatches = true;\n\t\t\t\tfor (let i = 1; i < pressedChords.length; i++) {\n\t\t\t\t\tif (candidate.chords[i] !== pressedChords[i]) {\n\t\t\t\t\t\tprefixMatches = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prefixMatches) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check there's a keybinding with a matching when clause\n\t\tconst result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\t\t\treturn NoMatchingKb;\n\t\t}\n\n\t\t// check we got all chords necessary to be sure a particular keybinding needs to be invoked\n\t\tif (pressedChords.length < result.chords.length) {\n\t\t\t// The chord sequence is not complete\n\t\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\t\t\treturn MoreChordsNeeded;\n\t\t}\n\n\t\tthis._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n\t\treturn KbFound(result.command, result.commandArgs, result.bubble);\n\t}\n\n\tprivate _findCommand(context: IContext, matches: ResolvedKeybindingItem[]): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tconst k = matches[i];\n\n\t\t\tif (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _contextMatchesRules(context: IContext, rules: ContextKeyExpression | null | undefined): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n}\n\nfunction printWhenExplanation(when: ContextKeyExpression | undefined): string {\n\tif (!when) {\n\t\treturn `no when condition`;\n\t}\n\treturn `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb: ResolvedKeybindingItem): string {\n\treturn (\n\t\tkb.extensionId\n\t\t\t? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n\t\t\t: (kb.isDefault ? `built-in` : `user`)\n\t);\n}\n"]}