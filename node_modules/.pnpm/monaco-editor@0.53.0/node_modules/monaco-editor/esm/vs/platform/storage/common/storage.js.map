{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/storage/common/storage.ts","vs/platform/storage/common/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises, RunOnceScheduler, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { Emitter, Event, PauseableEmitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isUndefinedOrNull } from '../../../base/common/types.js';\nimport { InMemoryStorageDatabase, IStorage, IStorageChangeEvent, Storage, StorageHint, StorageValue } from '../../../base/parts/storage/common/storage.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const TARGET_KEY = '__$__targetStorageMarker';\n\nexport const IStorageService = createDecorator<IStorageService>('storageService');\n\nexport enum WillSaveStateReason {\n\n\t/**\n\t * No specific reason to save state.\n\t */\n\tNONE,\n\n\t/**\n\t * A hint that the workbench is about to shutdown.\n\t */\n\tSHUTDOWN\n}\n\nexport interface IWillSaveStateEvent {\n\treadonly reason: WillSaveStateReason;\n}\n\nexport interface IWorkspaceStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IProfileStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IApplicationStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IStorageService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted on the given\n\t * scope and optional key.\n\t *\n\t * @param scope the `StorageScope` to listen to changes\n\t * @param key the optional key to filter for or all keys of\n\t * the scope if `undefined`\n\t */\n\tonDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope, key: string | undefined, disposable: DisposableStore): Event<IStorageValueChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t *\n\t * Note: this event may be fired many times, not only on shutdown to prevent\n\t * loss of state in situations where the shutdown is not sufficient to\n\t * persist the data properly.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `boolean`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `number` using `parseInt` with a\n\t * base of `10`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be\n\t * converted to a `string`. Storing either `undefined` or `null` will\n\t * remove the entry under the key.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t *\n\t * @param target allows to define the target of the storage operation\n\t * to either the current machine or user.\n\t */\n\tstore(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only, all workspaces\n\t * or all profiles.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n}\n\nexport const enum StorageScope {\n\n\t/**\n\t * The stored data will be scoped to all workspaces across all profiles.\n\t */\n\tAPPLICATION = -1,\n\n\t/**\n\t * The stored data will be scoped to all workspaces of the same profile.\n\t */\n\tPROFILE = 0,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE = 1\n}\n\nexport const enum StorageTarget {\n\n\t/**\n\t * The stored data is user specific and applies across machines.\n\t */\n\tUSER,\n\n\t/**\n\t * The stored data is machine specific.\n\t */\n\tMACHINE\n}\n\nexport interface IStorageValueChangeEvent {\n\n\t/**\n\t * The scope for the storage entry that changed\n\t * or was removed.\n\t */\n\treadonly scope: StorageScope;\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * The `target` can be `undefined` if a key is being\n\t * removed.\n\t */\n\treadonly target: StorageTarget | undefined;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport interface IStorageTargetChangeEvent {\n\n\t/**\n\t * The scope for the target that changed. Listeners\n\t * should use `keys(scope, target)` to get an updated\n\t * list of keys for the given `scope` and `target`.\n\t */\n\treadonly scope: StorageScope;\n}\n\ninterface IKeyTargets {\n\t[key: string]: StorageTarget;\n}\n\nexport interface IStorageServiceOptions {\n\treadonly flushInterval: number;\n}\n\nexport function loadKeyTargets(storage: IStorage): IKeyTargets {\n\tconst keysRaw = storage.get(TARGET_KEY);\n\tif (keysRaw) {\n\t\ttry {\n\t\t\treturn JSON.parse(keysRaw);\n\t\t} catch (error) {\n\t\t\t// Fail gracefully\n\t\t}\n\t}\n\n\treturn Object.create(null);\n}\n\nexport abstract class AbstractStorageService extends Disposable implements IStorageService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\n\n\tprivate readonly _onDidChangeValue = this._register(new PauseableEmitter<IStorageValueChangeEvent>());\n\n\tprivate readonly _onDidChangeTarget = this._register(new PauseableEmitter<IStorageTargetChangeEvent>());\n\n\tprivate readonly _onWillSaveState = this._register(new Emitter<IWillSaveStateEvent>());\n\treadonly onWillSaveState = this._onWillSaveState.event;\n\n\tprivate readonly flushWhenIdleScheduler: RunOnceScheduler;\n\tprivate readonly runFlushWhenIdle = this._register(new MutableDisposable());\n\n\tconstructor(options: IStorageServiceOptions = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n\t\tsuper();\n\n\t\tthis.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), options.flushInterval));\n\t}\n\n\tonDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope, key: string | undefined, disposable: DisposableStore): Event<IStorageValueChangeEvent> {\n\t\treturn Event.filter(this._onDidChangeValue.event, e => e.scope === scope && (key === undefined || e.key === key), disposable);\n\t}\n\n\tprivate doFlushWhenIdle(): void {\n\t\tthis.runFlushWhenIdle.value = runWhenGlobalIdle(() => {\n\t\t\tif (this.shouldFlushWhenIdle()) {\n\t\t\t\tthis.flush();\n\t\t\t}\n\n\t\t\t// repeat\n\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t});\n\t}\n\n\tprotected shouldFlushWhenIdle(): boolean {\n\t\treturn true;\n\t}\n\n\tprotected emitDidChangeValue(scope: StorageScope, event: IStorageChangeEvent): void {\n\t\tconst { key, external } = event;\n\n\t\t// Specially handle `TARGET_KEY`\n\t\tif (key === TARGET_KEY) {\n\n\t\t\t// Clear our cached version which is now out of date\n\t\t\tswitch (scope) {\n\t\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\t\tthis._applicationKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.PROFILE:\n\t\t\t\t\tthis._profileKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.WORKSPACE:\n\t\t\t\t\tthis._workspaceKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Emit as `didChangeTarget` event\n\t\t\tthis._onDidChangeTarget.fire({ scope });\n\t\t}\n\n\t\t// Emit any other key to outside\n\t\telse {\n\t\t\tthis._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });\n\t\t}\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope): string | undefined;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined {\n\t\treturn this.getStorage(scope)?.get(key, fallbackValue);\n\t}\n\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope): boolean | undefined;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined {\n\t\treturn this.getStorage(scope)?.getBoolean(key, fallbackValue);\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope): number | undefined;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined {\n\t\treturn this.getStorage(scope)?.getNumber(key, fallbackValue);\n\t}\n\n\tstore(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget, external = false): void {\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tthis.remove(key, scope, external);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, target);\n\n\t\t\t// Store actual value\n\t\t\tthis.getStorage(scope)?.set(key, value, external);\n\t\t});\n\t}\n\n\tremove(key: string, scope: StorageScope, external = false): void {\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, undefined);\n\n\t\t\t// Remove actual key\n\t\t\tthis.getStorage(scope)?.delete(key, external);\n\t\t});\n\t}\n\n\tprivate withPausedEmitters(fn: Function): void {\n\n\t\t// Pause emitters\n\t\tthis._onDidChangeValue.pause();\n\t\tthis._onDidChangeTarget.pause();\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\n\t\t\t// Resume emitters\n\t\t\tthis._onDidChangeValue.resume();\n\t\t\tthis._onDidChangeTarget.resume();\n\t\t}\n\t}\n\n\tprivate updateKeyTarget(key: string, scope: StorageScope, target: StorageTarget | undefined, external = false): void {\n\n\t\t// Add\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tif (typeof target === 'number') {\n\t\t\tif (keyTargets[key] !== target) {\n\t\t\t\tkeyTargets[key] = target;\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);\n\t\t\t}\n\t\t}\n\n\t\t// Remove\n\t\telse {\n\t\t\tif (typeof keyTargets[key] === 'number') {\n\t\t\t\tdelete keyTargets[key];\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _workspaceKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get workspaceKeyTargets(): IKeyTargets {\n\t\tif (!this._workspaceKeyTargets) {\n\t\t\tthis._workspaceKeyTargets = this.loadKeyTargets(StorageScope.WORKSPACE);\n\t\t}\n\n\t\treturn this._workspaceKeyTargets;\n\t}\n\n\tprivate _profileKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get profileKeyTargets(): IKeyTargets {\n\t\tif (!this._profileKeyTargets) {\n\t\t\tthis._profileKeyTargets = this.loadKeyTargets(StorageScope.PROFILE);\n\t\t}\n\n\t\treturn this._profileKeyTargets;\n\t}\n\n\tprivate _applicationKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get applicationKeyTargets(): IKeyTargets {\n\t\tif (!this._applicationKeyTargets) {\n\t\t\tthis._applicationKeyTargets = this.loadKeyTargets(StorageScope.APPLICATION);\n\t\t}\n\n\t\treturn this._applicationKeyTargets;\n\t}\n\n\tprivate getKeyTargets(scope: StorageScope): IKeyTargets {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationKeyTargets;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileKeyTargets;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceKeyTargets;\n\t\t}\n\t}\n\n\tprivate loadKeyTargets(scope: StorageScope): { [key: string]: StorageTarget } {\n\t\tconst storage = this.getStorage(scope);\n\n\t\treturn storage ? loadKeyTargets(storage) : Object.create(null);\n\t}\n\n\tasync flush(reason = WillSaveStateReason.NONE): Promise<void> {\n\n\t\t// Signal event to collect changes\n\t\tthis._onWillSaveState.fire({ reason });\n\n\t\tconst applicationStorage = this.getStorage(StorageScope.APPLICATION);\n\t\tconst profileStorage = this.getStorage(StorageScope.PROFILE);\n\t\tconst workspaceStorage = this.getStorage(StorageScope.WORKSPACE);\n\n\t\tswitch (reason) {\n\n\t\t\t// Unspecific reason: just wait when data is flushed\n\t\t\tcase WillSaveStateReason.NONE:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.whenFlushed() ?? Promise.resolve()\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Shutdown: we want to flush as soon as possible\n\t\t\t// and not hit any delays that might be there\n\t\t\tcase WillSaveStateReason.SHUTDOWN:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.flush(0) ?? Promise.resolve()\n\t\t\t\t]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprotected abstract getStorage(scope: StorageScope): IStorage | undefined;\n}\n\nexport class InMemoryStorageService extends AbstractStorageService {\n\n\tprivate readonly applicationStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\tprivate readonly profileStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\tprivate readonly workspaceStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.WORKSPACE, e)));\n\t\tthis._register(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\t\tthis._register(this.applicationStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.APPLICATION, e)));\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\treturn false;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Promises, RunOnceScheduler, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { Emitter, Event, PauseableEmitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isUndefinedOrNull } from '../../../base/common/types.js';\nimport { InMemoryStorageDatabase, IStorage, IStorageChangeEvent, Storage, StorageHint, StorageValue } from '../../../base/parts/storage/common/storage.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const TARGET_KEY = '__$__targetStorageMarker';\n\nexport const IStorageService = createDecorator<IStorageService>('storageService');\n\nexport enum WillSaveStateReason {\n\n\t/**\n\t * No specific reason to save state.\n\t */\n\tNONE,\n\n\t/**\n\t * A hint that the workbench is about to shutdown.\n\t */\n\tSHUTDOWN\n}\n\nexport interface IWillSaveStateEvent {\n\treadonly reason: WillSaveStateReason;\n}\n\nexport interface IWorkspaceStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IProfileStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IApplicationStorageValueChangeEvent extends IStorageValueChangeEvent {\n}\n\nexport interface IStorageService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted on the given\n\t * scope and optional key.\n\t *\n\t * @param scope the `StorageScope` to listen to changes\n\t * @param key the optional key to filter for or all keys of\n\t * the scope if `undefined`\n\t */\n\tonDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope, key: string | undefined, disposable: DisposableStore): Event<IStorageValueChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t *\n\t * Note: this event may be fired many times, not only on shutdown to prevent\n\t * loss of state in situations where the shutdown is not sufficient to\n\t * persist the data properly.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `boolean`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `number` using `parseInt` with a\n\t * base of `10`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be\n\t * converted to a `string`. Storing either `undefined` or `null` will\n\t * remove the entry under the key.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only, all workspaces or all profiles.\n\t *\n\t * @param target allows to define the target of the storage operation\n\t * to either the current machine or user.\n\t */\n\tstore(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only, all workspaces\n\t * or all profiles.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n}\n\nexport const enum StorageScope {\n\n\t/**\n\t * The stored data will be scoped to all workspaces across all profiles.\n\t */\n\tAPPLICATION = -1,\n\n\t/**\n\t * The stored data will be scoped to all workspaces of the same profile.\n\t */\n\tPROFILE = 0,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE = 1\n}\n\nexport const enum StorageTarget {\n\n\t/**\n\t * The stored data is user specific and applies across machines.\n\t */\n\tUSER,\n\n\t/**\n\t * The stored data is machine specific.\n\t */\n\tMACHINE\n}\n\nexport interface IStorageValueChangeEvent {\n\n\t/**\n\t * The scope for the storage entry that changed\n\t * or was removed.\n\t */\n\treadonly scope: StorageScope;\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * The `target` can be `undefined` if a key is being\n\t * removed.\n\t */\n\treadonly target: StorageTarget | undefined;\n\n\t/**\n\t * A hint how the storage change event was triggered. If\n\t * `true`, the storage change was triggered by an external\n\t * source, such as:\n\t * - another process (for example another window)\n\t * - operations such as settings sync or profiles change\n\t */\n\treadonly external?: boolean;\n}\n\nexport interface IStorageTargetChangeEvent {\n\n\t/**\n\t * The scope for the target that changed. Listeners\n\t * should use `keys(scope, target)` to get an updated\n\t * list of keys for the given `scope` and `target`.\n\t */\n\treadonly scope: StorageScope;\n}\n\ninterface IKeyTargets {\n\t[key: string]: StorageTarget;\n}\n\nexport interface IStorageServiceOptions {\n\treadonly flushInterval: number;\n}\n\nexport function loadKeyTargets(storage: IStorage): IKeyTargets {\n\tconst keysRaw = storage.get(TARGET_KEY);\n\tif (keysRaw) {\n\t\ttry {\n\t\t\treturn JSON.parse(keysRaw);\n\t\t} catch (error) {\n\t\t\t// Fail gracefully\n\t\t}\n\t}\n\n\treturn Object.create(null);\n}\n\nexport abstract class AbstractStorageService extends Disposable implements IStorageService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\n\n\tprivate readonly _onDidChangeValue = this._register(new PauseableEmitter<IStorageValueChangeEvent>());\n\n\tprivate readonly _onDidChangeTarget = this._register(new PauseableEmitter<IStorageTargetChangeEvent>());\n\n\tprivate readonly _onWillSaveState = this._register(new Emitter<IWillSaveStateEvent>());\n\treadonly onWillSaveState = this._onWillSaveState.event;\n\n\tprivate readonly flushWhenIdleScheduler: RunOnceScheduler;\n\tprivate readonly runFlushWhenIdle = this._register(new MutableDisposable());\n\n\tconstructor(options: IStorageServiceOptions = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n\t\tsuper();\n\n\t\tthis.flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), options.flushInterval));\n\t}\n\n\tonDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;\n\tonDidChangeValue(scope: StorageScope, key: string | undefined, disposable: DisposableStore): Event<IStorageValueChangeEvent> {\n\t\treturn Event.filter(this._onDidChangeValue.event, e => e.scope === scope && (key === undefined || e.key === key), disposable);\n\t}\n\n\tprivate doFlushWhenIdle(): void {\n\t\tthis.runFlushWhenIdle.value = runWhenGlobalIdle(() => {\n\t\t\tif (this.shouldFlushWhenIdle()) {\n\t\t\t\tthis.flush();\n\t\t\t}\n\n\t\t\t// repeat\n\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t});\n\t}\n\n\tprotected shouldFlushWhenIdle(): boolean {\n\t\treturn true;\n\t}\n\n\tprotected emitDidChangeValue(scope: StorageScope, event: IStorageChangeEvent): void {\n\t\tconst { key, external } = event;\n\n\t\t// Specially handle `TARGET_KEY`\n\t\tif (key === TARGET_KEY) {\n\n\t\t\t// Clear our cached version which is now out of date\n\t\t\tswitch (scope) {\n\t\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\t\tthis._applicationKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.PROFILE:\n\t\t\t\t\tthis._profileKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase StorageScope.WORKSPACE:\n\t\t\t\t\tthis._workspaceKeyTargets = undefined;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Emit as `didChangeTarget` event\n\t\t\tthis._onDidChangeTarget.fire({ scope });\n\t\t}\n\n\t\t// Emit any other key to outside\n\t\telse {\n\t\t\tthis._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });\n\t\t}\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope): string | undefined;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined {\n\t\treturn this.getStorage(scope)?.get(key, fallbackValue);\n\t}\n\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope): boolean | undefined;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined {\n\t\treturn this.getStorage(scope)?.getBoolean(key, fallbackValue);\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope): number | undefined;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined {\n\t\treturn this.getStorage(scope)?.getNumber(key, fallbackValue);\n\t}\n\n\tstore(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget, external = false): void {\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tthis.remove(key, scope, external);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, target);\n\n\t\t\t// Store actual value\n\t\t\tthis.getStorage(scope)?.set(key, value, external);\n\t\t});\n\t}\n\n\tremove(key: string, scope: StorageScope, external = false): void {\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, undefined);\n\n\t\t\t// Remove actual key\n\t\t\tthis.getStorage(scope)?.delete(key, external);\n\t\t});\n\t}\n\n\tprivate withPausedEmitters(fn: Function): void {\n\n\t\t// Pause emitters\n\t\tthis._onDidChangeValue.pause();\n\t\tthis._onDidChangeTarget.pause();\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\n\t\t\t// Resume emitters\n\t\t\tthis._onDidChangeValue.resume();\n\t\t\tthis._onDidChangeTarget.resume();\n\t\t}\n\t}\n\n\tprivate updateKeyTarget(key: string, scope: StorageScope, target: StorageTarget | undefined, external = false): void {\n\n\t\t// Add\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tif (typeof target === 'number') {\n\t\t\tif (keyTargets[key] !== target) {\n\t\t\t\tkeyTargets[key] = target;\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);\n\t\t\t}\n\t\t}\n\n\t\t// Remove\n\t\telse {\n\t\t\tif (typeof keyTargets[key] === 'number') {\n\t\t\t\tdelete keyTargets[key];\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets), external);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _workspaceKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get workspaceKeyTargets(): IKeyTargets {\n\t\tif (!this._workspaceKeyTargets) {\n\t\t\tthis._workspaceKeyTargets = this.loadKeyTargets(StorageScope.WORKSPACE);\n\t\t}\n\n\t\treturn this._workspaceKeyTargets;\n\t}\n\n\tprivate _profileKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get profileKeyTargets(): IKeyTargets {\n\t\tif (!this._profileKeyTargets) {\n\t\t\tthis._profileKeyTargets = this.loadKeyTargets(StorageScope.PROFILE);\n\t\t}\n\n\t\treturn this._profileKeyTargets;\n\t}\n\n\tprivate _applicationKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get applicationKeyTargets(): IKeyTargets {\n\t\tif (!this._applicationKeyTargets) {\n\t\t\tthis._applicationKeyTargets = this.loadKeyTargets(StorageScope.APPLICATION);\n\t\t}\n\n\t\treturn this._applicationKeyTargets;\n\t}\n\n\tprivate getKeyTargets(scope: StorageScope): IKeyTargets {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationKeyTargets;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileKeyTargets;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceKeyTargets;\n\t\t}\n\t}\n\n\tprivate loadKeyTargets(scope: StorageScope): { [key: string]: StorageTarget } {\n\t\tconst storage = this.getStorage(scope);\n\n\t\treturn storage ? loadKeyTargets(storage) : Object.create(null);\n\t}\n\n\tasync flush(reason = WillSaveStateReason.NONE): Promise<void> {\n\n\t\t// Signal event to collect changes\n\t\tthis._onWillSaveState.fire({ reason });\n\n\t\tconst applicationStorage = this.getStorage(StorageScope.APPLICATION);\n\t\tconst profileStorage = this.getStorage(StorageScope.PROFILE);\n\t\tconst workspaceStorage = this.getStorage(StorageScope.WORKSPACE);\n\n\t\tswitch (reason) {\n\n\t\t\t// Unspecific reason: just wait when data is flushed\n\t\t\tcase WillSaveStateReason.NONE:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.whenFlushed() ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.whenFlushed() ?? Promise.resolve()\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Shutdown: we want to flush as soon as possible\n\t\t\t// and not hit any delays that might be there\n\t\t\tcase WillSaveStateReason.SHUTDOWN:\n\t\t\t\tawait Promises.settled([\n\t\t\t\t\tapplicationStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tprofileStorage?.flush(0) ?? Promise.resolve(),\n\t\t\t\t\tworkspaceStorage?.flush(0) ?? Promise.resolve()\n\t\t\t\t]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprotected abstract getStorage(scope: StorageScope): IStorage | undefined;\n}\n\nexport class InMemoryStorageService extends AbstractStorageService {\n\n\tprivate readonly applicationStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\tprivate readonly profileStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\tprivate readonly workspaceStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.WORKSPACE, e)));\n\t\tthis._register(this.profileStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.PROFILE, e)));\n\t\tthis._register(this.applicationStorage.onDidChangeStorage(e => this.emitDidChangeValue(StorageScope.APPLICATION, e)));\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage {\n\t\tswitch (scope) {\n\t\t\tcase StorageScope.APPLICATION:\n\t\t\t\treturn this.applicationStorage;\n\t\t\tcase StorageScope.PROFILE:\n\t\t\t\treturn this.profileStorage;\n\t\t\tdefault:\n\t\t\t\treturn this.workspaceStorage;\n\t\t}\n\t}\n\n\tprotected override shouldFlushWhenIdle(): boolean {\n\t\treturn false;\n\t}\n}\n"]}