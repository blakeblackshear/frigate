{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/platform/instantiation/common/instantiation.ts","vs/platform/instantiation/common/instantiation.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAMhG,uBAAuB;AAEvB,MAAM,KAAW,KAAK,CAUrB;AAVD,WAAiB,KAAK;IAER,gBAAU,GAAG,IAAI,GAAG,EAAkC,CAAC;IAEvD,eAAS,GAAG,YAAY,CAAC;IACzB,qBAAe,GAAG,kBAAkB,CAAC;IAElD,SAAgB,sBAAsB,CAAC,IAAS;QAC/C,OAAO,IAAI,CAAC,MAAA,eAAe,CAAC,IAAI,EAAE,CAAC;IACpC,CAAC;IAFe,4BAAsB,yBAErC,CAAA;AACF,CAAC,EAVgB,KAAK,KAAL,KAAK,QAUrB;AAeD,MAAM,CAAC,MAAM,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;AAuDpG,SAAS,sBAAsB,CAAC,EAAY,EAAE,MAAgB,EAAE,KAAa;IAC5E,IAAK,MAAc,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,MAAM,EAAE,CAAC;QAChD,MAAc,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;IAC5D,CAAC;SAAM,CAAC;QACN,MAAc,CAAC,KAAK,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QACxD,MAAc,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC;IAC3C,CAAC;AACF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe,CAAI,SAAiB;IAEnD,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;QACrC,OAAO,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC;IACzC,CAAC;IAED,MAAM,EAAE,GAAQ,UAAU,MAAgB,EAAE,GAAW,EAAE,KAAa;QACrE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAC;QACrF,CAAC;QACD,sBAAsB,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAC3C,CAAC,CAAC;IAEF,EAAE,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC;IAE9B,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;IACpC,OAAO,EAAE,CAAC;AACX,CAAC","file":"instantiation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as descriptors from './descriptors.js';\nimport { ServiceCollection } from './serviceCollection.js';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tgetIfExists<T>(id: ServiceIdentifier<T>): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t *\n\t * NOTE that the returned child is `disposable` and should be disposed when not used\n\t * anymore. This will also dispose all the services that this service has created.\n\t */\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService;\n\n\t/**\n\t * Disposes this instantiation service.\n\t *\n\t * - Will dispose all services that this instantiation service has created.\n\t * - Will dispose all its children but not its parent.\n\t * - Will NOT dispose services-instances that this service has been created with\n\t * - Will NOT dispose consumer-instances this service has created\n\t */\n\tdispose(): void;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as descriptors from './descriptors.js';\nimport { ServiceCollection } from './serviceCollection.js';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tgetIfExists<T>(id: ServiceIdentifier<T>): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => unknown, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t *\n\t * NOTE that the returned child is `disposable` and should be disposed when not used\n\t * anymore. This will also dispose all the services that this service has created.\n\t */\n\tcreateChild(services: ServiceCollection, store?: DisposableStore): IInstantiationService;\n\n\t/**\n\t * Disposes this instantiation service.\n\t *\n\t * - Will dispose all services that this instantiation service has created.\n\t * - Will dispose all its children but not its parent.\n\t * - Will NOT dispose services-instances that this service has been created with\n\t * - Will NOT dispose consumer-instances this service has created\n\t */\n\tdispose(): void;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n"]}