{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/ui/tree/asyncDataTree.ts","vs/base/browser/ui/tree/asyncDataTree.ts"],"names":[],"mappings":"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","file":"asyncDataTree.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd.js';\nimport { IIdentityProvider, IKeyboardNavigationLabelProvider, IListDragAndDrop, IListDragOverReaction, IListVirtualDelegate } from '../list/list.js';\nimport { ElementsDragAndDropData, ListViewTargetSector } from '../list/listView.js';\nimport { IListStyles } from '../list/listWidget.js';\nimport { ComposedTreeDelegate, TreeFindMode as TreeFindMode, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, TreeFindMatchType, LabelFuzzyScore, FindFilter, FindController, IFindControllerOptions } from './abstractTree.js';\nimport { ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ICompressibleKeyboardNavigationLabelProvider, ICompressibleObjectTreeOptions, ICompressibleTreeRenderer, IObjectTreeOptions, IObjectTreeSetChildrenOptions, ObjectTree } from './objectTree.js';\nimport { IAsyncDataSource, ICollapseStateChangeEvent, IObjectTreeElement, ITreeDragAndDrop, ITreeElementRenderDetails, ITreeEvent, ITreeFilter, ITreeMouseEvent, ITreeNode, ITreeRenderer, ITreeSorter, ObjectTreeElementCollapseState, TreeError, TreeFilterResult, TreeVisibility, WeakMapper } from './tree.js';\nimport { CancelablePromise, createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { ScrollEvent } from '../../../common/scrollable.js';\nimport { isIterable } from '../../../common/types.js';\nimport { IContextViewProvider } from '../contextview/contextview.js';\nimport { FuzzyScore } from '../../../common/filters.js';\nimport { splice } from '../../../common/arrays.js';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\trefreshPromise: CancelablePromise<void> | undefined;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n\tforceExpanded: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\trefreshPromise: undefined,\n\t\tstale: true,\n\t\tslow: false,\n\t\tforceExpanded: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\ntype AsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>, ITreeNode<TInput | T, TFilterData>>;\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass AsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\n\tconstructor(\n\t\tprotected renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e!.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\ttarget: e.target\n\t};\n}\n\nclass AsyncDataTreeElementsDragAndDropData<TInput, T, TContext> extends ElementsDragAndDropData<T, TContext> {\n\n\tconstructor(private data: ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>, TContext>) {\n\t\tsuper(data.elements.map(node => node.element as T));\n\t}\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\treturn new AsyncDataTreeElementsDragAndDropData(data);\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[], originalEvent: DragEvent): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T), originalEvent);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tonDragEnd(originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragEnd?.(originalEvent);\n\t}\n\n\tdispose(): void {\n\t\tthis.dnd.dispose();\n\t}\n}\n\nexport interface IAsyncFindResult<T> {\n\tmatchCount: number;\n\tisMatch(element: T): boolean;\n}\n\nexport interface IAsyncFindProvider<T> {\n\n\t/**\n\t * `isVisible` is called to check if an element should be visible.\n\t * For an element to be visible, all its ancestors must also be visible and the label must match the find pattern.\n\t */\n\tisVisible?(element: T): boolean;\n\n\t/**\n\t * End Session is called when the user either closes the find widget or has an empty find input.\n\t * This can be used to deallocate any state that was allocated.\n\t */\n\tendSession?(): Promise<void>;\n}\n\nclass AsyncFindFilter<T> extends FindFilter<T> {\n\n\tpublic isFindSessionActive = false;\n\n\tconstructor(\n\t\tpublic readonly findProvider: IAsyncFindProvider<T>, // remove public\n\t\tkeyboardNavigationLabelProvider: IKeyboardNavigationLabelProvider<T>,\n\t\tfilter: ITreeFilter<T, FuzzyScore>\n\t) {\n\t\tsuper(keyboardNavigationLabelProvider, filter);\n\t}\n\n\toverride filter(element: T, parentVisibility: TreeVisibility): TreeFilterResult<FuzzyScore | LabelFuzzyScore> {\n\t\tconst filterResult = super.filter(element, parentVisibility);\n\n\t\tif (!this.isFindSessionActive || this.findMode === TreeFindMode.Highlight || !this.findProvider.isVisible) {\n\t\t\treturn filterResult;\n\t\t}\n\n\t\tconst visibility = isFilterResult(filterResult) ? filterResult.visibility : filterResult;\n\t\tif (getVisibleState(visibility) === TreeVisibility.Hidden) {\n\t\t\treturn TreeVisibility.Hidden;\n\t\t}\n\n\t\treturn this.findProvider.isVisible(element) ? filterResult : TreeVisibility.Hidden;\n\t}\n\n}\n\n// TODO Fix types\nclass AsyncFindController<TInput, T, TFilterData> extends FindController<T, TFilterData> {\n\tprivate activeFindMetadata: IAsyncFindResult<T> | undefined;\n\tprivate activeSession = false;\n\tprivate asyncWorkInProgress = false;\n\n\tconstructor(\n\t\ttree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t\tprivate readonly findProvider: IAsyncFindProvider<T>,\n\t\tprotected override filter: AsyncFindFilter<T>,\n\t\tcontextViewProvider: IContextViewProvider,\n\t\toptions: IAbstractTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t) {\n\t\tsuper(tree as any, filter, contextViewProvider, options);\n\t\t// Always make sure to end the session before disposing\n\t\tthis.disposables.add(toDisposable(async () => {\n\t\t\tif (this.activeSession) {\n\t\t\t\tawait this.findProvider.endSession?.();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected override render(): void {\n\t\tif (this.asyncWorkInProgress || !this.activeFindMetadata) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst showNotFound = this.activeFindMetadata.matchCount === 0 && this.pattern.length > 0;\n\t\tthis.renderMessage(showNotFound);\n\n\t\tif (this.pattern.length) {\n\t\t\tthis.alertResults(this.activeFindMetadata.matchCount);\n\t\t}\n\t}\n\n\toverride shouldAllowFocus(node: ITreeNode<T, TFilterData>): boolean {\n\t\treturn this.shouldFocusWhenNavigating(node as ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>);\n\t}\n\n\tshouldFocusWhenNavigating(node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>): boolean {\n\t\tif (!this.activeSession || !this.activeFindMetadata) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst element = node.element?.element as T | undefined;\n\t\tif (element && this.activeFindMetadata.isMatch(element)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !FuzzyScore.isDefault(node.filterData as any as FuzzyScore);\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\t...options.accessibilityProvider,\n\t\t\tgetPosInSet: undefined,\n\t\t\tgetSetSize: undefined,\n\t\t\tgetRole: options.accessibilityProvider.getRole ? (el) => {\n\t\t\t\treturn options.accessibilityProvider!.getRole!(el.element as T);\n\t\t\t} : () => 'treeitem',\n\t\t\tisChecked: options.accessibilityProvider.isChecked ? (e) => {\n\t\t\t\treturn !!(options.accessibilityProvider?.isChecked!(e.element as T));\n\t\t\t} : undefined,\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t},\n\t\t\tgetWidgetAriaLabel() {\n\t\t\t\treturn options.accessibilityProvider!.getWidgetAriaLabel();\n\t\t\t},\n\t\t\tgetWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider!.getWidgetRole!() : () => 'tree',\n\t\t\tgetAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLevel!(node.element as T);\n\t\t\t}),\n\t\t\tgetActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getActiveDescendantId!(node.element as T);\n\t\t\t})\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\t...options.keyboardNavigationLabelProvider,\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tdefaultFindVisibility: e => {\n\t\t\tif (e.hasChildren && e.stale) {\n\t\t\t\treturn TreeVisibility.Visible;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'number') {\n\t\t\t\treturn options.defaultFindVisibility;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'undefined') {\n\t\t\t\treturn TreeVisibility.Recurse;\n\t\t\t} else {\n\t\t\t\treturn (options.defaultFindVisibility as ((e: T) => TreeVisibility))(e.element as T);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\nexport interface IAsyncDataTreeUpdateChildrenOptions<T> extends IObjectTreeSetChildrenOptions<T> { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, Pick<IAbstractTreeOptions<T, TFilterData>, Exclude<keyof IAbstractTreeOptions<T, TFilterData>, 'collapseByDefault'>> {\n\treadonly collapseByDefault?: { (e: T): boolean };\n\treadonly identityProvider?: IIdentityProvider<T>;\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly autoExpandSingleChildren?: boolean;\n\treadonly findProvider?: IAsyncFindProvider<T>;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprotected readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\tprivate readonly findController?: AsyncFindController<TInput, T, TFilterData>;\n\tprivate readonly getDefaultCollapseState: { (e: T): undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded };\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<Iterable<T>>>();\n\n\tprotected readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprotected readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n\n\tprotected readonly disposables = new DisposableStore();\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onPointer(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\n\t/**\n\t * To be used internally only!\n\t * @deprecated\n\t */\n\tget onDidChangeModel(): Event<void> { return this.tree.onDidChangeModel; }\n\tget onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, TFilterData>> { return this.tree.onDidChangeCollapseState; }\n\n\tprivate focusNavigationFilter: ((node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) => boolean) | undefined;\n\n\treadonly onDidChangeFindOpenState: Event<boolean>;\n\tget onDidChangeStickyScrollFocused(): Event<boolean> { return this.tree.onDidChangeStickyScrollFocused; }\n\treadonly onDidChangeFindMode: Event<TreeFindMode>;\n\treadonly onDidChangeFindMatchType: Event<TreeFindMatchType>;\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tprotected user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\t\tthis.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n\n\t\tlet asyncFindEnabled = false;\n\t\tlet findFilter: AsyncFindFilter<T> | undefined;\n\t\tif (options.findProvider && (options.findWidgetEnabled ?? true) && options.keyboardNavigationLabelProvider && options.contextViewProvider) {\n\t\t\tasyncFindEnabled = true;\n\t\t\tfindFilter = new AsyncFindFilter<T>(options.findProvider, options.keyboardNavigationLabelProvider, options.filter as ITreeFilter<T, FuzzyScore>);\n\t\t}\n\n\t\tthis.tree = this.createTree(user, container, delegate, renderers, { ...options, findWidgetEnabled: !asyncFindEnabled, filter: findFilter as ITreeFilter<T, TFilterData> ?? options.filter });\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true,\n\t\t\tdefaultCollapseState: undefined\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\n\t\tif (asyncFindEnabled) {\n\t\t\tconst findOptions: IFindControllerOptions = {\n\t\t\t\tstyles: options.findWidgetStyles,\n\t\t\t\tshowNotFoundMessage: options.showNotFoundMessage,\n\t\t\t\tdefaultFindMatchType: options.defaultFindMatchType,\n\t\t\t\tdefaultFindMode: options.defaultFindMode,\n\t\t\t};\n\t\t\tthis.findController = this.disposables.add(new AsyncFindController(this.tree, options.findProvider!, findFilter!, this.tree.options.contextViewProvider!, findOptions));\n\n\t\t\tthis.focusNavigationFilter = node => this.findController!.shouldFocusWhenNavigating(node);\n\t\t\tthis.onDidChangeFindOpenState = this.findController!.onDidChangeOpenState;\n\t\t\tthis.onDidChangeFindMode = this.findController!.onDidChangeMode;\n\t\t\tthis.onDidChangeFindMatchType = this.findController!.onDidChangeMatchType;\n\t\t} else {\n\t\t\tthis.onDidChangeFindOpenState = this.tree.onDidChangeFindOpenState;\n\t\t\tthis.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n\t\t\tthis.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n\t\t}\n\t}\n\n\tprotected createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tupdateOptions(optionsUpdate: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tif (this.findController) {\n\t\t\tif (optionsUpdate.defaultFindMode !== undefined) {\n\t\t\t\tthis.findController.mode = optionsUpdate.defaultFindMode;\n\t\t\t}\n\n\t\t\tif (optionsUpdate.defaultFindMatchType !== undefined) {\n\t\t\t\tthis.findController.matchType = optionsUpdate.defaultFindMatchType;\n\t\t\t}\n\t\t}\n\n\t\tthis.tree.updateOptions(optionsUpdate);\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.cancelAllRefreshPromises();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext: IAsyncDataTreeViewStateContext<TInput, T> | undefined = viewState && { viewState, focus: [], selection: [] };\n\n\t\tawait this._updateChildren(input, true, false, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tcancelAllRefreshPromises(includeSubTrees: boolean = false): void {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tif (includeSubTrees) {\n\t\t\tthis.subTreeRefreshPromises.forEach(promise => promise.cancel());\n\t\t\tthis.subTreeRefreshPromises.clear();\n\t\t}\n\t}\n\n\tprivate async _updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tawait this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n\t\tif (rerender) {\n\t\t\ttry {\n\t\t\t\tthis.tree.rerender(node);\n\t\t\t} catch {\n\t\t\t\t// missing nodes are fine, this could've resulted from\n\t\t\t\t// parallel refresh calls, removing `node` altogether\n\t\t\t}\n\t\t}\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined || element === this.root.element) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn this.nodeMapper.map(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait node.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tif (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait node.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprotected getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tconst nodeIdentity = this.identityProvider?.getId(element as T).toString();\n\t\t\tthrow new TreeError(this.user, `Data tree node not found${nodeIdentity ? `: ${nodeIdentity}` : ''}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh, again (#228211)\n\t\t}\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh (#199264)\n\t\t}\n\t\tthis.render(node, viewStateContext, options);\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\n\t\t\tif (treeNode.collapsed) {\n\t\t\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\t\t\t\tnode.stale = true;\n\t\t\t\tthis.setChildren(node, [], recursive, viewStateContext);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn this.doRefreshSubTree(node, recursive, viewStateContext);\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tconst cancelablePromise = createCancelablePromise(async () => {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t});\n\n\t\tnode.refreshPromise = cancelablePromise;\n\t\tthis.subTreeRefreshPromises.set(node, cancelablePromise);\n\n\t\tcancelablePromise.finally(() => {\n\t\t\tnode.refreshPromise = undefined;\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t});\n\n\t\treturn cancelablePromise;\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n\t\tlet childrenPromise: Promise<Iterable<T>>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve(Iterable.empty());\n\t\t} else {\n\t\t\tconst children = this.doGetChildren(node);\n\t\t\tif (isIterable(children)) {\n\t\t\t\tchildrenPromise = Promise.resolve(children);\n\t\t\t} else {\n\t\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\t\tslowTimeout.then(() => {\n\t\t\t\t\tnode.slow = true;\n\t\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t\t}, _ => null);\n\n\t\t\t\tchildrenPromise = children.finally(() => slowTimeout.cancel());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root && this.tree.hasElement(node)) {\n\t\t\t\tthis.tree.collapse(node);\n\t\t\t}\n\n\t\t\tif (isCancellationError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<Iterable<T>> | Iterable<T> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tconst children = this.dataSource.getChildren(node.element);\n\t\tif (isIterable(children)) {\n\t\t\treturn this.processChildren(children);\n\t\t} else {\n\t\t\tresult = createCancelablePromise(async () => this.processChildren(await children));\n\t\t\tthis.refreshPromises.set(node, result);\n\t\t\treturn result.finally(() => { this.refreshPromises.delete(node); });\n\t\t}\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, any>): void {\n\t\tif (node.element === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElementsIterable: Iterable<T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\tconst childrenElements = [...childrenElementsIterable];\n\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, { node: IAsyncDataTreeNode<TInput, T>; collapsed: boolean }>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tconst hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\tif (!this.identityProvider) {\n\t\t\t\tconst asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\t\tif (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst result = childrenTreeNodesById.get(id);\n\n\t\t\tif (result) {\n\t\t\t\tconst asyncDataTreeNode = result.node;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = hasChildren;\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (result.collapsed) {\n\t\t\t\t\t\tasyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element as T)));\n\t\t\t\t\t\tasyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n\t\t\t\t\t\tasyncDataTreeNode.stale = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t} else if (hasChildren && !result.collapsed) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t} else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of nodesToForget.values()) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tsplice(node.children, 0, node.children.length, children);\n\n\t\t// TODO@joao this doesn't take filter into account\n\t\tif (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n\t\t\tchildren[0].forceExpanded = true;\n\t\t\tchildrenToRefresh.push(children[0]);\n\t\t}\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprotected render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tconst children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n\t\tconst objectTreeOptions: IObjectTreeSetChildrenOptions<IAsyncDataTreeNode<TInput, T>> | undefined = options && {\n\t\t\t...options,\n\t\t\tdiffIdentityProvider: options.diffIdentityProvider && {\n\t\t\t\tgetId(node: IAsyncDataTreeNode<TInput, T>): { toString(): string } {\n\t\t\t\t\treturn options.diffIdentityProvider!.getId(node.element as T);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n\t\tif (node !== this.root) {\n\t\t\tthis.tree.setCollapsible(node, node.hasChildren);\n\t\t}\n\n\t\tthis._onDidRender.fire();\n\t}\n\n\tprotected asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IObjectTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\tif (node.stale) {\n\t\t\treturn {\n\t\t\t\telement: node,\n\t\t\t\tcollapsible: node.hasChildren,\n\t\t\t\tcollapsed: true\n\t\t\t};\n\t\t}\n\n\t\tlet collapsed: boolean | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded | undefined;\n\n\t\tif (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n\t\t\tcollapsed = false;\n\t\t} else if (node.forceExpanded) {\n\t\t\tcollapsed = false;\n\t\t\tnode.forceExpanded = false;\n\t\t} else {\n\t\t\tcollapsed = node.defaultCollapseState;\n\t\t}\n\n\t\treturn {\n\t\t\telement: node,\n\t\t\tchildren: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n\t\t\tcollapsible: node.hasChildren,\n\t\t\tcollapsed\n\t\t};\n\t}\n\n\tprotected processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.sorter) {\n\t\t\tchildren = [...children].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn children;\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t\tthis.tree.dispose();\n\t}\n}\n\ntype CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>>;\n\nclass CompressibleAsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData> {\n\n\tget element(): ICompressedTreeNode<TInput | T> {\n\t\treturn {\n\t\t\telements: this.node.element.elements.map(e => e.element),\n\t\t\tincompressible: this.node.element.incompressible\n\t\t};\n\t}\n\n\tget children(): ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>[] { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>) { }\n}\n\nclass CompressibleAsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ICompressibleTreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprotected renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\tprivate compressibleNodeMapperProvider: () => CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nexport interface ITreeCompressionDelegate<T> {\n\tisIncompressible(element: T): boolean;\n}\n\nfunction asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options?: ICompressibleAsyncDataTreeOptions<T, TFilterData>): ICompressibleObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\tconst objectTreeOptions = options && asObjectTreeOptions(options);\n\n\treturn objectTreeOptions && {\n\t\t...objectTreeOptions,\n\t\tkeyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n\t\t\t...objectTreeOptions.keyboardNavigationLabelProvider,\n\t\t\tgetCompressedNodeKeyboardNavigationLabel(els) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element as T));\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptions<T, TFilterData> {\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nexport interface ICompressibleAsyncDataTreeOptionsUpdate extends IAsyncDataTreeOptionsUpdate {\n}\n\nexport class CompressibleAsyncDataTree<TInput, T, TFilterData = void> extends AsyncDataTree<TInput, T, TFilterData> {\n\n\tprotected declare readonly tree: CompressibleObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly compressibleNodeMapper: CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tvirtualDelegate: IListVirtualDelegate<T>,\n\t\tprivate compressionDelegate: ITreeCompressionDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\tdataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, virtualDelegate, renderers, dataSource, options);\n\t\tthis.filter = options.filter;\n\t}\n\n\tprotected override createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tprotected override asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ICompressedTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\treturn {\n\t\t\tincompressible: this.compressionDelegate.isIncompressible(node.element as T),\n\t\t\t...super.asTreeElement(node, viewStateContext)\n\t\t};\n\t}\n\n\tprotected override render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tif (!this.identityProvider) {\n\t\t\treturn super.render(node, viewStateContext);\n\t\t}\n\n\t\t// Preserve traits across compressions. Hacky but does the trick.\n\t\t// This is hard to fix properly since it requires rewriting the traits\n\t\t// across trees and lists. Let's just keep it this way for now.\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst getUncompressedIds = (nodes: IAsyncDataTreeNode<TInput, T>[]): Set<string> => {\n\t\t\tconst result = new Set<string>();\n\n\t\t\tfor (const node of nodes) {\n\t\t\t\tconst compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n\t\t\t\tif (!compressedNode.element) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (const node of compressedNode.element.elements) {\n\t\t\t\t\tresult.add(getId(node.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst oldSelection = getUncompressedIds(this.tree.getSelection() as IAsyncDataTreeNode<TInput, T>[]);\n\t\tconst oldFocus = getUncompressedIds(this.tree.getFocus() as IAsyncDataTreeNode<TInput, T>[]);\n\n\t\tsuper.render(node, viewStateContext, options);\n\n\t\tconst selection = this.getSelection();\n\t\tlet didChangeSelection = false;\n\n\t\tconst focus = this.getFocus();\n\t\tlet didChangeFocus = false;\n\n\t\tconst visit = (node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>> | null, TFilterData>) => {\n\t\t\tconst compressedNode = node.element;\n\n\t\t\tif (compressedNode) {\n\t\t\t\tfor (let i = 0; i < compressedNode.elements.length; i++) {\n\t\t\t\t\tconst id = getId(compressedNode.elements[i].element as T);\n\t\t\t\t\tconst element = compressedNode.elements[compressedNode.elements.length - 1].element as T;\n\n\t\t\t\t\t// github.com/microsoft/vscode/issues/85938\n\t\t\t\t\tif (oldSelection.has(id) && selection.indexOf(element) === -1) {\n\t\t\t\t\t\tselection.push(element);\n\t\t\t\t\t\tdidChangeSelection = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (oldFocus.has(id) && focus.indexOf(element) === -1) {\n\t\t\t\t\t\tfocus.push(element);\n\t\t\t\t\t\tdidChangeFocus = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.children.forEach(visit);\n\t\t};\n\n\t\tvisit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n\t\tif (didChangeSelection) {\n\t\t\tthis.setSelection(selection);\n\t\t}\n\n\t\tif (didChangeFocus) {\n\t\t\tthis.setFocus(focus);\n\t\t}\n\t}\n\n\t// For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n\t// and we have to filter everything beforehand\n\t// Related to #85193 and #85835\n\tprotected override processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.filter) {\n\t\t\tchildren = Iterable.filter(children, e => {\n\t\t\t\tconst result = this.filter!.filter(e, TreeVisibility.Visible);\n\t\t\t\tconst visibility = getVisibility(result);\n\n\t\t\t\tif (visibility === TreeVisibility.Recurse) {\n\t\t\t\t\tthrow new Error('Recursive tree visibility not supported in async data compressed trees');\n\t\t\t\t}\n\n\t\t\t\treturn visibility === TreeVisibility.Visible;\n\t\t\t});\n\t\t}\n\n\t\treturn super.processChildren(children);\n\t}\n}\n\nfunction getVisibility<TFilterData>(filterResult: TreeFilterResult<TFilterData>): TreeVisibility {\n\tif (typeof filterResult === 'boolean') {\n\t\treturn filterResult ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t} else if (isFilterResult(filterResult)) {\n\t\treturn getVisibleState(filterResult.visibility);\n\t} else {\n\t\treturn getVisibleState(filterResult);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd.js';\nimport { IIdentityProvider, IKeyboardNavigationLabelProvider, IListDragAndDrop, IListDragOverReaction, IListVirtualDelegate } from '../list/list.js';\nimport { ElementsDragAndDropData, ListViewTargetSector } from '../list/listView.js';\nimport { IListStyles } from '../list/listWidget.js';\nimport { ComposedTreeDelegate, TreeFindMode as TreeFindMode, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, TreeFindMatchType, LabelFuzzyScore, FindFilter, FindController, IFindControllerOptions } from './abstractTree.js';\nimport { ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ICompressibleKeyboardNavigationLabelProvider, ICompressibleObjectTreeOptions, ICompressibleTreeRenderer, IObjectTreeOptions, IObjectTreeSetChildrenOptions, ObjectTree } from './objectTree.js';\nimport { IAsyncDataSource, ICollapseStateChangeEvent, IObjectTreeElement, ITreeDragAndDrop, ITreeElementRenderDetails, ITreeEvent, ITreeFilter, ITreeMouseEvent, ITreeNode, ITreeRenderer, ITreeSorter, ObjectTreeElementCollapseState, TreeError, TreeFilterResult, TreeVisibility, WeakMapper } from './tree.js';\nimport { CancelablePromise, createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose, IDisposable, toDisposable } from '../../../common/lifecycle.js';\nimport { ScrollEvent } from '../../../common/scrollable.js';\nimport { isIterable } from '../../../common/types.js';\nimport { IContextViewProvider } from '../contextview/contextview.js';\nimport { FuzzyScore } from '../../../common/filters.js';\nimport { splice } from '../../../common/arrays.js';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\trefreshPromise: CancelablePromise<void> | undefined;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n\tforceExpanded: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\trefreshPromise: undefined,\n\t\tstale: true,\n\t\tslow: false,\n\t\tforceExpanded: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\ntype AsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>, ITreeNode<TInput | T, TFilterData>>;\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass AsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\n\tconstructor(\n\t\tprotected renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e!.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\ttarget: e.target\n\t};\n}\n\nclass AsyncDataTreeElementsDragAndDropData<TInput, T, TContext> extends ElementsDragAndDropData<T, TContext> {\n\n\tconstructor(private data: ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>, TContext>) {\n\t\tsuper(data.elements.map(node => node.element as T));\n\t}\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\treturn new AsyncDataTreeElementsDragAndDropData(data);\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[], originalEvent: DragEvent): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T), originalEvent);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tonDragEnd(originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragEnd?.(originalEvent);\n\t}\n\n\tdispose(): void {\n\t\tthis.dnd.dispose();\n\t}\n}\n\nexport interface IAsyncFindResult<T> {\n\tmatchCount: number;\n\tisMatch(element: T): boolean;\n}\n\nexport interface IAsyncFindProvider<T> {\n\n\t/**\n\t * `isVisible` is called to check if an element should be visible.\n\t * For an element to be visible, all its ancestors must also be visible and the label must match the find pattern.\n\t */\n\tisVisible?(element: T): boolean;\n\n\t/**\n\t * End Session is called when the user either closes the find widget or has an empty find input.\n\t * This can be used to deallocate any state that was allocated.\n\t */\n\tendSession?(): Promise<void>;\n}\n\nclass AsyncFindFilter<T> extends FindFilter<T> {\n\n\tpublic isFindSessionActive = false;\n\n\tconstructor(\n\t\tpublic readonly findProvider: IAsyncFindProvider<T>, // remove public\n\t\tkeyboardNavigationLabelProvider: IKeyboardNavigationLabelProvider<T>,\n\t\tfilter: ITreeFilter<T, FuzzyScore>\n\t) {\n\t\tsuper(keyboardNavigationLabelProvider, filter);\n\t}\n\n\toverride filter(element: T, parentVisibility: TreeVisibility): TreeFilterResult<FuzzyScore | LabelFuzzyScore> {\n\t\tconst filterResult = super.filter(element, parentVisibility);\n\n\t\tif (!this.isFindSessionActive || this.findMode === TreeFindMode.Highlight || !this.findProvider.isVisible) {\n\t\t\treturn filterResult;\n\t\t}\n\n\t\tconst visibility = isFilterResult(filterResult) ? filterResult.visibility : filterResult;\n\t\tif (getVisibleState(visibility) === TreeVisibility.Hidden) {\n\t\t\treturn TreeVisibility.Hidden;\n\t\t}\n\n\t\treturn this.findProvider.isVisible(element) ? filterResult : TreeVisibility.Hidden;\n\t}\n\n}\n\n// TODO Fix types\nclass AsyncFindController<TInput, T, TFilterData> extends FindController<T, TFilterData> {\n\tprivate activeFindMetadata: IAsyncFindResult<T> | undefined;\n\tprivate activeSession = false;\n\tprivate asyncWorkInProgress = false;\n\n\tconstructor(\n\t\ttree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t\tprivate readonly findProvider: IAsyncFindProvider<T>,\n\t\tprotected override filter: AsyncFindFilter<T>,\n\t\tcontextViewProvider: IContextViewProvider,\n\t\toptions: IAbstractTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData>,\n\t) {\n\t\tsuper(tree as any, filter, contextViewProvider, options);\n\t\t// Always make sure to end the session before disposing\n\t\tthis.disposables.add(toDisposable(async () => {\n\t\t\tif (this.activeSession) {\n\t\t\t\tawait this.findProvider.endSession?.();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected override render(): void {\n\t\tif (this.asyncWorkInProgress || !this.activeFindMetadata) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst showNotFound = this.activeFindMetadata.matchCount === 0 && this.pattern.length > 0;\n\t\tthis.renderMessage(showNotFound);\n\n\t\tif (this.pattern.length) {\n\t\t\tthis.alertResults(this.activeFindMetadata.matchCount);\n\t\t}\n\t}\n\n\toverride shouldAllowFocus(node: ITreeNode<T, TFilterData>): boolean {\n\t\treturn this.shouldFocusWhenNavigating(node as ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>);\n\t}\n\n\tshouldFocusWhenNavigating(node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>): boolean {\n\t\tif (!this.activeSession || !this.activeFindMetadata) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst element = node.element?.element as T | undefined;\n\t\tif (element && this.activeFindMetadata.isMatch(element)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !FuzzyScore.isDefault(node.filterData as any as FuzzyScore);\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\t...options.accessibilityProvider,\n\t\t\tgetPosInSet: undefined,\n\t\t\tgetSetSize: undefined,\n\t\t\tgetRole: options.accessibilityProvider.getRole ? (el) => {\n\t\t\t\treturn options.accessibilityProvider!.getRole!(el.element as T);\n\t\t\t} : () => 'treeitem',\n\t\t\tisChecked: options.accessibilityProvider.isChecked ? (e) => {\n\t\t\t\treturn !!(options.accessibilityProvider?.isChecked!(e.element as T));\n\t\t\t} : undefined,\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t},\n\t\t\tgetWidgetAriaLabel() {\n\t\t\t\treturn options.accessibilityProvider!.getWidgetAriaLabel();\n\t\t\t},\n\t\t\tgetWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider!.getWidgetRole!() : () => 'tree',\n\t\t\tgetAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLevel!(node.element as T);\n\t\t\t}),\n\t\t\tgetActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getActiveDescendantId!(node.element as T);\n\t\t\t})\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\t...options.keyboardNavigationLabelProvider,\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tdefaultFindVisibility: e => {\n\t\t\tif (e.hasChildren && e.stale) {\n\t\t\t\treturn TreeVisibility.Visible;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'number') {\n\t\t\t\treturn options.defaultFindVisibility;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'undefined') {\n\t\t\t\treturn TreeVisibility.Recurse;\n\t\t\t} else {\n\t\t\t\treturn (options.defaultFindVisibility as ((e: T) => TreeVisibility))(e.element as T);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\nexport interface IAsyncDataTreeUpdateChildrenOptions<T> extends IObjectTreeSetChildrenOptions<T> { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, Pick<IAbstractTreeOptions<T, TFilterData>, Exclude<keyof IAbstractTreeOptions<T, TFilterData>, 'collapseByDefault'>> {\n\treadonly collapseByDefault?: { (e: T): boolean };\n\treadonly identityProvider?: IIdentityProvider<T>;\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly autoExpandSingleChildren?: boolean;\n\treadonly findProvider?: IAsyncFindProvider<T>;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprotected readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\tprivate readonly findController?: AsyncFindController<TInput, T, TFilterData>;\n\tprivate readonly getDefaultCollapseState: { (e: T): undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded };\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<Iterable<T>>>();\n\n\tprotected readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprotected readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n\n\tprotected readonly disposables = new DisposableStore();\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onPointer(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\n\t/**\n\t * To be used internally only!\n\t * @deprecated\n\t */\n\tget onDidChangeModel(): Event<void> { return this.tree.onDidChangeModel; }\n\tget onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, TFilterData>> { return this.tree.onDidChangeCollapseState; }\n\n\tprivate focusNavigationFilter: ((node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) => boolean) | undefined;\n\n\treadonly onDidChangeFindOpenState: Event<boolean>;\n\tget onDidChangeStickyScrollFocused(): Event<boolean> { return this.tree.onDidChangeStickyScrollFocused; }\n\treadonly onDidChangeFindMode: Event<TreeFindMode>;\n\treadonly onDidChangeFindMatchType: Event<TreeFindMatchType>;\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tprotected user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\t\tthis.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n\n\t\tlet asyncFindEnabled = false;\n\t\tlet findFilter: AsyncFindFilter<T> | undefined;\n\t\tif (options.findProvider && (options.findWidgetEnabled ?? true) && options.keyboardNavigationLabelProvider && options.contextViewProvider) {\n\t\t\tasyncFindEnabled = true;\n\t\t\tfindFilter = new AsyncFindFilter<T>(options.findProvider, options.keyboardNavigationLabelProvider, options.filter as ITreeFilter<T, FuzzyScore>);\n\t\t}\n\n\t\tthis.tree = this.createTree(user, container, delegate, renderers, { ...options, findWidgetEnabled: !asyncFindEnabled, filter: findFilter as ITreeFilter<T, TFilterData> ?? options.filter });\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true,\n\t\t\tdefaultCollapseState: undefined\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\n\t\tif (asyncFindEnabled) {\n\t\t\tconst findOptions: IFindControllerOptions = {\n\t\t\t\tstyles: options.findWidgetStyles,\n\t\t\t\tshowNotFoundMessage: options.showNotFoundMessage,\n\t\t\t\tdefaultFindMatchType: options.defaultFindMatchType,\n\t\t\t\tdefaultFindMode: options.defaultFindMode,\n\t\t\t};\n\t\t\tthis.findController = this.disposables.add(new AsyncFindController(this.tree, options.findProvider!, findFilter!, this.tree.options.contextViewProvider!, findOptions));\n\n\t\t\tthis.focusNavigationFilter = node => this.findController!.shouldFocusWhenNavigating(node);\n\t\t\tthis.onDidChangeFindOpenState = this.findController!.onDidChangeOpenState;\n\t\t\tthis.onDidChangeFindMode = this.findController!.onDidChangeMode;\n\t\t\tthis.onDidChangeFindMatchType = this.findController!.onDidChangeMatchType;\n\t\t} else {\n\t\t\tthis.onDidChangeFindOpenState = this.tree.onDidChangeFindOpenState;\n\t\t\tthis.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n\t\t\tthis.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n\t\t}\n\t}\n\n\tprotected createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tupdateOptions(optionsUpdate: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tif (this.findController) {\n\t\t\tif (optionsUpdate.defaultFindMode !== undefined) {\n\t\t\t\tthis.findController.mode = optionsUpdate.defaultFindMode;\n\t\t\t}\n\n\t\t\tif (optionsUpdate.defaultFindMatchType !== undefined) {\n\t\t\t\tthis.findController.matchType = optionsUpdate.defaultFindMatchType;\n\t\t\t}\n\t\t}\n\n\t\tthis.tree.updateOptions(optionsUpdate);\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.cancelAllRefreshPromises();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext: IAsyncDataTreeViewStateContext<TInput, T> | undefined = viewState && { viewState, focus: [], selection: [] };\n\n\t\tawait this._updateChildren(input, true, false, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tcancelAllRefreshPromises(includeSubTrees: boolean = false): void {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tif (includeSubTrees) {\n\t\t\tthis.subTreeRefreshPromises.forEach(promise => promise.cancel());\n\t\t\tthis.subTreeRefreshPromises.clear();\n\t\t}\n\t}\n\n\tprivate async _updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tawait this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n\t\tif (rerender) {\n\t\t\ttry {\n\t\t\t\tthis.tree.rerender(node);\n\t\t\t} catch {\n\t\t\t\t// missing nodes are fine, this could've resulted from\n\t\t\t\t// parallel refresh calls, removing `node` altogether\n\t\t\t}\n\t\t}\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined || element === this.root.element) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn this.nodeMapper.map(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait node.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tif (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait node.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprotected getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tconst nodeIdentity = this.identityProvider?.getId(element as T).toString();\n\t\t\tthrow new TreeError(this.user, `Data tree node not found${nodeIdentity ? `: ${nodeIdentity}` : ''}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh, again (#228211)\n\t\t}\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh (#199264)\n\t\t}\n\t\tthis.render(node, viewStateContext, options);\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\n\t\t\tif (treeNode.collapsed) {\n\t\t\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\t\t\t\tnode.stale = true;\n\t\t\t\tthis.setChildren(node, [], recursive, viewStateContext);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn this.doRefreshSubTree(node, recursive, viewStateContext);\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tconst cancelablePromise = createCancelablePromise(async () => {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t});\n\n\t\tnode.refreshPromise = cancelablePromise;\n\t\tthis.subTreeRefreshPromises.set(node, cancelablePromise);\n\n\t\tcancelablePromise.finally(() => {\n\t\t\tnode.refreshPromise = undefined;\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t});\n\n\t\treturn cancelablePromise;\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n\t\tlet childrenPromise: Promise<Iterable<T>>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve(Iterable.empty());\n\t\t} else {\n\t\t\tconst children = this.doGetChildren(node);\n\t\t\tif (isIterable(children)) {\n\t\t\t\tchildrenPromise = Promise.resolve(children);\n\t\t\t} else {\n\t\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\t\tslowTimeout.then(() => {\n\t\t\t\t\tnode.slow = true;\n\t\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t\t}, _ => null);\n\n\t\t\t\tchildrenPromise = children.finally(() => slowTimeout.cancel());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root && this.tree.hasElement(node)) {\n\t\t\t\tthis.tree.collapse(node);\n\t\t\t}\n\n\t\t\tif (isCancellationError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<Iterable<T>> | Iterable<T> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tconst children = this.dataSource.getChildren(node.element);\n\t\tif (isIterable(children)) {\n\t\t\treturn this.processChildren(children);\n\t\t} else {\n\t\t\tresult = createCancelablePromise(async () => this.processChildren(await children));\n\t\t\tthis.refreshPromises.set(node, result);\n\t\t\treturn result.finally(() => { this.refreshPromises.delete(node); });\n\t\t}\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, any>): void {\n\t\tif (node.element === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElementsIterable: Iterable<T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\tconst childrenElements = [...childrenElementsIterable];\n\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, { node: IAsyncDataTreeNode<TInput, T>; collapsed: boolean }>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tconst hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\tif (!this.identityProvider) {\n\t\t\t\tconst asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\t\tif (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst result = childrenTreeNodesById.get(id);\n\n\t\t\tif (result) {\n\t\t\t\tconst asyncDataTreeNode = result.node;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = hasChildren;\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (result.collapsed) {\n\t\t\t\t\t\tasyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element as T)));\n\t\t\t\t\t\tasyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n\t\t\t\t\t\tasyncDataTreeNode.stale = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t} else if (hasChildren && !result.collapsed) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t} else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of nodesToForget.values()) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tsplice(node.children, 0, node.children.length, children);\n\n\t\t// TODO@joao this doesn't take filter into account\n\t\tif (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n\t\t\tchildren[0].forceExpanded = true;\n\t\t\tchildrenToRefresh.push(children[0]);\n\t\t}\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprotected render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tconst children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n\t\tconst objectTreeOptions: IObjectTreeSetChildrenOptions<IAsyncDataTreeNode<TInput, T>> | undefined = options && {\n\t\t\t...options,\n\t\t\tdiffIdentityProvider: options.diffIdentityProvider && {\n\t\t\t\tgetId(node: IAsyncDataTreeNode<TInput, T>): { toString(): string } {\n\t\t\t\t\treturn options.diffIdentityProvider!.getId(node.element as T);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n\t\tif (node !== this.root) {\n\t\t\tthis.tree.setCollapsible(node, node.hasChildren);\n\t\t}\n\n\t\tthis._onDidRender.fire();\n\t}\n\n\tprotected asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IObjectTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\tif (node.stale) {\n\t\t\treturn {\n\t\t\t\telement: node,\n\t\t\t\tcollapsible: node.hasChildren,\n\t\t\t\tcollapsed: true\n\t\t\t};\n\t\t}\n\n\t\tlet collapsed: boolean | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded | undefined;\n\n\t\tif (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n\t\t\tcollapsed = false;\n\t\t} else if (node.forceExpanded) {\n\t\t\tcollapsed = false;\n\t\t\tnode.forceExpanded = false;\n\t\t} else {\n\t\t\tcollapsed = node.defaultCollapseState;\n\t\t}\n\n\t\treturn {\n\t\t\telement: node,\n\t\t\tchildren: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n\t\t\tcollapsible: node.hasChildren,\n\t\t\tcollapsed\n\t\t};\n\t}\n\n\tprotected processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.sorter) {\n\t\t\tchildren = [...children].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn children;\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t\tthis.tree.dispose();\n\t}\n}\n\ntype CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>>;\n\nclass CompressibleAsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData> {\n\n\tget element(): ICompressedTreeNode<TInput | T> {\n\t\treturn {\n\t\t\telements: this.node.element.elements.map(e => e.element),\n\t\t\tincompressible: this.node.element.incompressible\n\t\t};\n\t}\n\n\tget children(): ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>[] { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>) { }\n}\n\nclass CompressibleAsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ICompressibleTreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprotected renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\tprivate compressibleNodeMapperProvider: () => CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, details?: ITreeElementRenderDetails): void {\n\t\tthis.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, details);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nexport interface ITreeCompressionDelegate<T> {\n\tisIncompressible(element: T): boolean;\n}\n\nfunction asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options?: ICompressibleAsyncDataTreeOptions<T, TFilterData>): ICompressibleObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\tconst objectTreeOptions = options && asObjectTreeOptions(options);\n\n\treturn objectTreeOptions && {\n\t\t...objectTreeOptions,\n\t\tkeyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n\t\t\t...objectTreeOptions.keyboardNavigationLabelProvider,\n\t\t\tgetCompressedNodeKeyboardNavigationLabel(els) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element as T));\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptions<T, TFilterData> {\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nexport interface ICompressibleAsyncDataTreeOptionsUpdate extends IAsyncDataTreeOptionsUpdate {\n}\n\nexport class CompressibleAsyncDataTree<TInput, T, TFilterData = void> extends AsyncDataTree<TInput, T, TFilterData> {\n\n\tprotected declare readonly tree: CompressibleObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly compressibleNodeMapper: CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tvirtualDelegate: IListVirtualDelegate<T>,\n\t\tprivate compressionDelegate: ITreeCompressionDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\tdataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, virtualDelegate, renderers, dataSource, options);\n\t\tthis.filter = options.filter;\n\t}\n\n\tprotected override createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tprotected override asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ICompressedTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\treturn {\n\t\t\tincompressible: this.compressionDelegate.isIncompressible(node.element as T),\n\t\t\t...super.asTreeElement(node, viewStateContext)\n\t\t};\n\t}\n\n\tprotected override render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tif (!this.identityProvider) {\n\t\t\treturn super.render(node, viewStateContext);\n\t\t}\n\n\t\t// Preserve traits across compressions. Hacky but does the trick.\n\t\t// This is hard to fix properly since it requires rewriting the traits\n\t\t// across trees and lists. Let's just keep it this way for now.\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst getUncompressedIds = (nodes: IAsyncDataTreeNode<TInput, T>[]): Set<string> => {\n\t\t\tconst result = new Set<string>();\n\n\t\t\tfor (const node of nodes) {\n\t\t\t\tconst compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n\t\t\t\tif (!compressedNode.element) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (const node of compressedNode.element.elements) {\n\t\t\t\t\tresult.add(getId(node.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst oldSelection = getUncompressedIds(this.tree.getSelection() as IAsyncDataTreeNode<TInput, T>[]);\n\t\tconst oldFocus = getUncompressedIds(this.tree.getFocus() as IAsyncDataTreeNode<TInput, T>[]);\n\n\t\tsuper.render(node, viewStateContext, options);\n\n\t\tconst selection = this.getSelection();\n\t\tlet didChangeSelection = false;\n\n\t\tconst focus = this.getFocus();\n\t\tlet didChangeFocus = false;\n\n\t\tconst visit = (node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>> | null, TFilterData>) => {\n\t\t\tconst compressedNode = node.element;\n\n\t\t\tif (compressedNode) {\n\t\t\t\tfor (let i = 0; i < compressedNode.elements.length; i++) {\n\t\t\t\t\tconst id = getId(compressedNode.elements[i].element as T);\n\t\t\t\t\tconst element = compressedNode.elements[compressedNode.elements.length - 1].element as T;\n\n\t\t\t\t\t// github.com/microsoft/vscode/issues/85938\n\t\t\t\t\tif (oldSelection.has(id) && selection.indexOf(element) === -1) {\n\t\t\t\t\t\tselection.push(element);\n\t\t\t\t\t\tdidChangeSelection = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (oldFocus.has(id) && focus.indexOf(element) === -1) {\n\t\t\t\t\t\tfocus.push(element);\n\t\t\t\t\t\tdidChangeFocus = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.children.forEach(visit);\n\t\t};\n\n\t\tvisit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n\t\tif (didChangeSelection) {\n\t\t\tthis.setSelection(selection);\n\t\t}\n\n\t\tif (didChangeFocus) {\n\t\t\tthis.setFocus(focus);\n\t\t}\n\t}\n\n\t// For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n\t// and we have to filter everything beforehand\n\t// Related to #85193 and #85835\n\tprotected override processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.filter) {\n\t\t\tchildren = Iterable.filter(children, e => {\n\t\t\t\tconst result = this.filter!.filter(e, TreeVisibility.Visible);\n\t\t\t\tconst visibility = getVisibility(result);\n\n\t\t\t\tif (visibility === TreeVisibility.Recurse) {\n\t\t\t\t\tthrow new Error('Recursive tree visibility not supported in async data compressed trees');\n\t\t\t\t}\n\n\t\t\t\treturn visibility === TreeVisibility.Visible;\n\t\t\t});\n\t\t}\n\n\t\treturn super.processChildren(children);\n\t}\n}\n\nfunction getVisibility<TFilterData>(filterResult: TreeFilterResult<TFilterData>): TreeVisibility {\n\tif (typeof filterResult === 'boolean') {\n\t\treturn filterResult ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t} else if (isFilterResult(filterResult)) {\n\t\treturn getVisibleState(filterResult.visibility);\n\t} else {\n\t\treturn getVisibleState(filterResult);\n\t}\n}\n"]}