{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableSignal.ts","vs/base/common/observableInternal/observables/observableSignal.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAC;AACrD,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AASpD,MAAM,UAAU,gBAAgB,CAAgB,gBAAiC,EAAE,aAAa,GAAG,aAAa,CAAC,QAAQ,EAAE;IAC1H,IAAI,OAAO,gBAAgB,KAAK,QAAQ,EAAE,CAAC;QAC1C,OAAO,IAAI,gBAAgB,CAAS,gBAAgB,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;IACjF,CAAC;SAAM,CAAC;QACP,OAAO,IAAI,gBAAgB,CAAS,SAAS,EAAE,gBAAgB,EAAE,aAAa,CAAC,CAAC;IACjF,CAAC;AACF,CAAC;AAMD,MAAM,gBAA0B,SAAQ,cAA6B;IACpE,IAAW,SAAS;QACnB,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC;IAC7G,CAAC;IAEe,QAAQ;QACvB,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAED,YACkB,UAA8B,EAC9B,MAA0B,EAC3C,aAA4B;QAE5B,KAAK,CAAC,aAAa,CAAC,CAAC;QAJJ,eAAU,GAAV,UAAU,CAAoB;QAC9B,WAAM,GAAN,MAAM,CAAoB;IAI5C,CAAC;IAEM,OAAO,CAAC,EAA4B,EAAE,MAAe;QAC3D,IAAI,CAAC,EAAE,EAAE,CAAC;YACT,WAAW,CAAC,EAAE,CAAC,EAAE;gBAChB,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;YAC1B,CAAC,EAAE,GAAG,EAAE,CAAC,kBAAkB,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;YAC7C,OAAO;QACR,CAAC;QAED,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACjC,EAAE,CAAC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YAC3B,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC9B,CAAC;IACF,CAAC;IAEe,GAAG;QAClB,QAAQ;IACT,CAAC;CACD","file":"observableSignal.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, ITransaction } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object, debugLocation = DebugLocation.ofCaller()): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner, undefined, debugLocation);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner, debugLocation);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner: object | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this._observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, ITransaction } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object, debugLocation = DebugLocation.ofCaller()): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner, undefined, debugLocation);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner, debugLocation);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner: object | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this._observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n"]}