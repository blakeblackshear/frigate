{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/assert.ts","vs/base/common/assert.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,MAAM,aAAa,CAAC;AAEpE;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,EAAE,CAAC,KAAe,EAAE,OAAgB;IACnD,IAAI,CAAC,KAAK,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,qBAAqB,OAAO,GAAG,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC;IACjF,CAAC;AACF,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,KAAY,EAAE,OAAO,GAAG,aAAa;IAChE,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AAC1B,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,MAAM,CACrB,SAAkB,EAClB,iBAAiC,kBAAkB;IAEnD,IAAI,CAAC,SAAS,EAAE,CAAC;QAChB,oEAAoE;QACpE,MAAM,YAAY,GAAG,OAAO,cAAc,KAAK,QAAQ;YACtD,CAAC,CAAC,IAAI,kBAAkB,CAAC,qBAAqB,cAAc,EAAE,CAAC;YAC/D,CAAC,CAAC,cAAc,CAAC;QAElB,MAAM,YAAY,CAAC;IACpB,CAAC;AACF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,UAAU,CAAC,SAAkB,EAAE,OAAO,GAAG,uBAAuB;IAC/E,IAAI,CAAC,SAAS,EAAE,CAAC;QAChB,iBAAiB,CAAC,IAAI,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC;IACpD,CAAC;AACF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,QAAQ,CAAC,SAAwB;IAChD,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;QAClB,uCAAuC;QACvC,QAAQ,CAAC;QACT,wDAAwD;QACxD,SAAS,EAAE,CAAC;QACZ,iBAAiB,CAAC,IAAI,kBAAkB,CAAC,kBAAkB,CAAC,CAAC,CAAC;IAC/D,CAAC;AACF,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAI,KAAmB,EAAE,SAA0C;IACpG,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC7B,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACnB,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACvB,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;YACtB,OAAO,KAAK,CAAC;QACd,CAAC;QACD,CAAC,EAAE,CAAC;IACL,CAAC;IACD,OAAO,IAAI,CAAC;AACb,CAAC","file":"assert.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n"]}