{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/derived.ts","vs/base/common/observableInternal/observables/derived.ts"],"names":[],"mappings":"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","file":"derived.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader, ITransaction, ISettableObservable, IObservableWithChange } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { _setDerivedOpts } from './baseObservable.js';\nimport { IDerivedReader, Derived, DerivedWithSetter } from './derivedImpl.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T, TChange = void>(computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(owner: DebugOwner, computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(\n\tcomputeFnOrOwner: ((reader: IDerivedReader<TChange>) => T) | DebugOwner,\n\tcomputeFn?: ((reader: IDerivedReader<TChange>) => T) | undefined,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tdebugLocation,\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TDelta, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IDerivedReader<TDelta>, changeSummary: TChangeSummary) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservableWithChange<T, TDelta> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.changeTracker,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T), debugLocation = DebugLocation.ofCaller()): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals,\n\t\tdebugLocation\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader, ITransaction, ISettableObservable, IObservableWithChange } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { _setDerivedOpts } from './baseObservable.js';\nimport { IDerivedReader, Derived, DerivedWithSetter } from './derivedImpl.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T, TChange = void>(computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(owner: DebugOwner, computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(\n\tcomputeFnOrOwner: ((reader: IDerivedReader<TChange>) => T) | DebugOwner,\n\tcomputeFn?: ((reader: IDerivedReader<TChange>) => T) | undefined,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tdebugLocation,\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TDelta, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IDerivedReader<TDelta>, changeSummary: TChangeSummary) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservableWithChange<T, TDelta> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.changeTracker,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T), debugLocation = DebugLocation.ofCaller()): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals,\n\t\tdebugLocation\n\t);\n}\n"]}