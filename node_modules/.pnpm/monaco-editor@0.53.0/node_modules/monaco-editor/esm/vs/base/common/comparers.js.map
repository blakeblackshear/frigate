{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/comparers.ts","vs/base/common/comparers.ts"],"names":[],"mappings":"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","file":"comparers.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from './date.js';\nimport { Lazy } from './lazy.js';\n\n// When comparing large numbers of strings it's better for performance to create an\n// Intl.Collator object and use the function provided by its compare property\n// than it is to use String.prototype.localeCompare()\n\n// A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.\nconst intlFileNameCollatorBaseNumeric: Lazy<{ collator: Intl.Collator; collatorIsNumeric: boolean }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true, sensitivity: 'base' }).value;\n\treturn {\n\t\tcollator,\n\t\tcollatorIsNumeric: collator.resolvedOptions().numeric\n\t};\n});\n\n// A collator with numeric sorting enabled.\nconst intlFileNameCollatorNumeric: Lazy<{ collator: Intl.Collator }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true }).value;\n\treturn {\n\t\tcollator\n\t};\n});\n\n// A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.\nconst intlFileNameCollatorNumericCaseInsensitive: Lazy<{ collator: Intl.Collator }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true, sensitivity: 'accent' }).value;\n\treturn {\n\t\tcollator\n\t};\n});\n\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\nexport function compareFileNames(one: string | null, other: string | null, caseSensitive = false): number {\n\tconst a = one || '';\n\tconst b = other || '';\n\tconst result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n\n\t// Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.\n\tif (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n\t\treturn a < b ? -1 : 1;\n\t}\n\n\treturn result;\n}\n\nexport function compareAnything(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst prefixCompare = compareByPrefix(one, other, lookFor);\n\tif (prefixCompare) {\n\t\treturn prefixCompare;\n\t}\n\n\t// Sort suffix matches over non suffix matches\n\tconst elementASuffixMatch = elementAName.endsWith(lookFor);\n\tconst elementBSuffixMatch = elementBName.endsWith(lookFor);\n\tif (elementASuffixMatch !== elementBSuffixMatch) {\n\t\treturn elementASuffixMatch ? -1 : 1;\n\t}\n\n\t// Understand file names\n\tconst r = compareFileNames(elementAName, elementBName);\n\tif (r !== 0) {\n\t\treturn r;\n\t}\n\n\t// Compare by name\n\treturn elementAName.localeCompare(elementBName);\n}\n\nexport function compareByPrefix(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst elementAPrefixMatch = elementAName.startsWith(lookFor);\n\tconst elementBPrefixMatch = elementBName.startsWith(lookFor);\n\tif (elementAPrefixMatch !== elementBPrefixMatch) {\n\t\treturn elementAPrefixMatch ? -1 : 1;\n\t}\n\n\t// Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n\telse if (elementAPrefixMatch && elementBPrefixMatch) {\n\t\tif (elementAName.length < elementBName.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (elementAName.length > elementBName.length) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from './date.js';\nimport { Lazy } from './lazy.js';\n\n// When comparing large numbers of strings it's better for performance to create an\n// Intl.Collator object and use the function provided by its compare property\n// than it is to use String.prototype.localeCompare()\n\n// A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.\nconst intlFileNameCollatorBaseNumeric: Lazy<{ collator: Intl.Collator; collatorIsNumeric: boolean }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true, sensitivity: 'base' }).value;\n\treturn {\n\t\tcollator,\n\t\tcollatorIsNumeric: collator.resolvedOptions().numeric\n\t};\n});\n\n// A collator with numeric sorting enabled.\nconst intlFileNameCollatorNumeric: Lazy<{ collator: Intl.Collator }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true }).value;\n\treturn {\n\t\tcollator\n\t};\n});\n\n// A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.\nconst intlFileNameCollatorNumericCaseInsensitive: Lazy<{ collator: Intl.Collator }> = new Lazy(() => {\n\tconst collator = safeIntl.Collator(undefined, { numeric: true, sensitivity: 'accent' }).value;\n\treturn {\n\t\tcollator\n\t};\n});\n\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\nexport function compareFileNames(one: string | null, other: string | null, caseSensitive = false): number {\n\tconst a = one || '';\n\tconst b = other || '';\n\tconst result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n\n\t// Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.\n\tif (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n\t\treturn a < b ? -1 : 1;\n\t}\n\n\treturn result;\n}\n\nexport function compareAnything(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst prefixCompare = compareByPrefix(one, other, lookFor);\n\tif (prefixCompare) {\n\t\treturn prefixCompare;\n\t}\n\n\t// Sort suffix matches over non suffix matches\n\tconst elementASuffixMatch = elementAName.endsWith(lookFor);\n\tconst elementBSuffixMatch = elementBName.endsWith(lookFor);\n\tif (elementASuffixMatch !== elementBSuffixMatch) {\n\t\treturn elementASuffixMatch ? -1 : 1;\n\t}\n\n\t// Understand file names\n\tconst r = compareFileNames(elementAName, elementBName);\n\tif (r !== 0) {\n\t\treturn r;\n\t}\n\n\t// Compare by name\n\treturn elementAName.localeCompare(elementBName);\n}\n\nexport function compareByPrefix(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst elementAPrefixMatch = elementAName.startsWith(lookFor);\n\tconst elementBPrefixMatch = elementBName.startsWith(lookFor);\n\tif (elementAPrefixMatch !== elementBPrefixMatch) {\n\t\treturn elementAPrefixMatch ? -1 : 1;\n\t}\n\n\t// Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n\telse if (elementAPrefixMatch && elementBPrefixMatch) {\n\t\tif (elementAName.length < elementBName.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (elementAName.length > elementBName.length) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"]}