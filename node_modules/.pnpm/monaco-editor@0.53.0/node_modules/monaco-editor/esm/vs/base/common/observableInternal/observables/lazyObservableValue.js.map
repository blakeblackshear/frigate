{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/lazyObservableValue.ts","vs/base/common/observableInternal/observables/lazyObservableValue.ts"],"names":[],"mappings":"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","file":"lazyObservableValue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer } from '../commonFacade/deps.js';\nimport { IObserver, ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\tprivate _isUpToDate = true;\n\tprivate readonly _deltas: TChange[] = [];\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\t}\n\n\tpublic override get(): T {\n\t\tthis._update();\n\t\treturn this._value;\n\t}\n\n\tprivate _update(): void {\n\t\tif (this._isUpToDate) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isUpToDate = true;\n\n\t\tif (this._deltas.length > 0) {\n\t\t\tfor (const change of this._deltas) {\n\t\t\t\tgetLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handleChange(this, change);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._deltas.length = 0;\n\t\t} else {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { change: undefined, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateCounter = 0;\n\n\tprivate _beginUpdate(): void {\n\t\tthis._updateCounter++;\n\t\tif (this._updateCounter === 1) {\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _endUpdate(): void {\n\t\tthis._updateCounter--;\n\t\tif (this._updateCounter === 0) {\n\t\t\tthis._update();\n\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tthis._isUpToDate = false;\n\t\t\tthis._setValue(value);\n\t\t\tif (change !== undefined) {\n\t\t\t\tthis._deltas.push(change);\n\t\t\t}\n\n\t\t\ttx.updateObserver({\n\t\t\t\tbeginUpdate: () => this._beginUpdate(),\n\t\t\t\tendUpdate: () => this._endUpdate(),\n\t\t\t\thandleChange: (observable, change) => { },\n\t\t\t\thandlePossibleChange: (observable) => { },\n\t\t\t}, this);\n\n\t\t\tif (this._updateCounter > 1) {\n\t\t\t\t// We already started begin/end update, so we need to manually call handlePossibleChange\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer } from '../commonFacade/deps.js';\nimport { IObserver, ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\tprivate _isUpToDate = true;\n\tprivate readonly _deltas: TChange[] = [];\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\t}\n\n\tpublic override get(): T {\n\t\tthis._update();\n\t\treturn this._value;\n\t}\n\n\tprivate _update(): void {\n\t\tif (this._isUpToDate) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isUpToDate = true;\n\n\t\tif (this._deltas.length > 0) {\n\t\t\tfor (const change of this._deltas) {\n\t\t\t\tgetLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handleChange(this, change);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._deltas.length = 0;\n\t\t} else {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { change: undefined, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateCounter = 0;\n\n\tprivate _beginUpdate(): void {\n\t\tthis._updateCounter++;\n\t\tif (this._updateCounter === 1) {\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _endUpdate(): void {\n\t\tthis._updateCounter--;\n\t\tif (this._updateCounter === 0) {\n\t\t\tthis._update();\n\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tthis._isUpToDate = false;\n\t\t\tthis._setValue(value);\n\t\t\tif (change !== undefined) {\n\t\t\t\tthis._deltas.push(change);\n\t\t\t}\n\n\t\t\ttx.updateObserver({\n\t\t\t\tbeginUpdate: () => this._beginUpdate(),\n\t\t\t\tendUpdate: () => this._endUpdate(),\n\t\t\t\thandleChange: (observable, change) => { },\n\t\t\t\thandlePossibleChange: (observable) => { },\n\t\t\t}, this);\n\n\t\t\tif (this._updateCounter > 1) {\n\t\t\t\t// We already started begin/end update, so we need to manually call handlePossibleChange\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n"]}