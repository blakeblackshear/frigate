{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/dataTransfer.ts","vs/base/common/dataTransfer.ts"],"names":[],"mappings":"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","file":"dataTransfer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { URI } from './uri.js';\nimport { generateUuid } from './uuid.js';\n\nexport interface IDataTransferFile {\n}\n\nexport interface IDataTransferItem {\n\tid?: string;\n\tasString(): Thenable<string>;\n\tasFile(): IDataTransferFile | undefined;\n\tvalue: unknown;\n}\n\nexport function createStringDataTransferItem(stringOrPromise: string | Promise<string>, id?: string): IDataTransferItem {\n\treturn {\n\t\tid,\n\t\tasString: async () => stringOrPromise,\n\t\tasFile: () => undefined,\n\t\tvalue: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n\t};\n}\n\nexport function createFileDataTransferItem(fileName: string, uri: URI | undefined, data: () => Promise<Uint8Array>, id?: string): IDataTransferItem {\n\tconst file = { id: generateUuid(), name: fileName, uri, data };\n\treturn {\n\t\tid,\n\t\tasString: async () => '',\n\t\tasFile: () => file,\n\t\tvalue: undefined,\n\t};\n}\n\nexport interface IReadonlyVSDataTransfer extends Iterable<readonly [string, IDataTransferItem]> {\n\t/**\n\t * Get the total number of entries in this data transfer.\n\t */\n\tget size(): number;\n\n\t/**\n\t * Check if this data transfer contains data for `mimeType`.\n\t *\n\t * This uses exact matching and does not support wildcards.\n\t */\n\thas(mimeType: string): boolean;\n\n\t/**\n\t * Retrieve the first entry for `mimeType`.\n\t *\n\t * Note that if you want to find all entries for a given mime type, use {@link IReadonlyVSDataTransfer.entries} instead.\n\t */\n\tget(mimeType: string): IDataTransferItem | undefined;\n}\n\nexport class VSDataTransfer implements IReadonlyVSDataTransfer {\n\n\tprivate readonly _entries = new Map<string, IDataTransferItem[]>();\n\n\tpublic get size(): number {\n\t\tlet size = 0;\n\t\tfor (const _ of this._entries) {\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\n\n\tpublic has(mimeType: string): boolean {\n\t\treturn this._entries.has(this.toKey(mimeType));\n\t}\n\n\tpublic matches(pattern: string): boolean {\n\t\tconst mimes = [...this._entries.keys()];\n\t\tif (Iterable.some(this, ([_, item]) => item.asFile())) {\n\t\t\tmimes.push('files');\n\t\t}\n\n\t\treturn matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n\t}\n\n\tpublic get(mimeType: string): IDataTransferItem | undefined {\n\t\treturn this._entries.get(this.toKey(mimeType))?.[0];\n\t}\n\n\t/**\n\t * Add a new entry to this data transfer.\n\t *\n\t * This does not replace existing entries for `mimeType`.\n\t */\n\tpublic append(mimeType: string, value: IDataTransferItem): void {\n\t\tconst existing = this._entries.get(mimeType);\n\t\tif (existing) {\n\t\t\texisting.push(value);\n\t\t} else {\n\t\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t\t}\n\t}\n\n\t/**\n\t * Set the entry for a given mime type.\n\t *\n\t * This replaces all existing entries for `mimeType`.\n\t */\n\tpublic replace(mimeType: string, value: IDataTransferItem): void {\n\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t}\n\n\t/**\n\t * Remove all entries for `mimeType`.\n\t */\n\tpublic delete(mimeType: string) {\n\t\tthis._entries.delete(this.toKey(mimeType));\n\t}\n\n\t/**\n\t * Iterate over all `[mime, item]` pairs in this data transfer.\n\t *\n\t * There may be multiple entries for each mime type.\n\t */\n\tpublic *[Symbol.iterator](): IterableIterator<readonly [string, IDataTransferItem]> {\n\t\tfor (const [mine, items] of this._entries) {\n\t\t\tfor (const item of items) {\n\t\t\t\tyield [mine, item];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate toKey(mimeType: string): string {\n\t\treturn normalizeMimeType(mimeType);\n\t}\n}\n\nfunction normalizeMimeType(mimeType: string): string {\n\treturn mimeType.toLowerCase();\n}\n\nexport function matchesMimeType(pattern: string, mimeTypes: readonly string[]): boolean {\n\treturn matchesMimeType_normalized(\n\t\tnormalizeMimeType(pattern),\n\t\tmimeTypes.map(normalizeMimeType));\n}\n\nfunction matchesMimeType_normalized(normalizedPattern: string, normalizedMimeTypes: readonly string[]): boolean {\n\t// Anything wildcard\n\tif (normalizedPattern === '*/*') {\n\t\treturn normalizedMimeTypes.length > 0;\n\t}\n\n\t// Exact match\n\tif (normalizedMimeTypes.includes(normalizedPattern)) {\n\t\treturn true;\n\t}\n\n\t// Wildcard, such as `image/*`\n\tconst wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n\tif (!wildcard) {\n\t\treturn false;\n\t}\n\n\tconst [_, type, subtype] = wildcard;\n\tif (subtype === '*') {\n\t\treturn normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n\t}\n\n\treturn false;\n}\n\n\nexport const UriList = Object.freeze({\n\t// http://amundsen.com/hypermedia/urilist/\n\tcreate: (entries: ReadonlyArray<string | URI>): string => {\n\t\treturn distinct(entries.map(x => x.toString())).join('\\r\\n');\n\t},\n\tsplit: (str: string): string[] => {\n\t\treturn str.split('\\r\\n');\n\t},\n\tparse: (str: string): string[] => {\n\t\treturn UriList.split(str).filter(value => !value.startsWith('#'));\n\t}\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { URI } from './uri.js';\nimport { generateUuid } from './uuid.js';\n\nexport interface IDataTransferFile {\n}\n\nexport interface IDataTransferItem {\n\tid?: string;\n\tasString(): Thenable<string>;\n\tasFile(): IDataTransferFile | undefined;\n\tvalue: unknown;\n}\n\nexport function createStringDataTransferItem(stringOrPromise: string | Promise<string>, id?: string): IDataTransferItem {\n\treturn {\n\t\tid,\n\t\tasString: async () => stringOrPromise,\n\t\tasFile: () => undefined,\n\t\tvalue: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n\t};\n}\n\nexport function createFileDataTransferItem(fileName: string, uri: URI | undefined, data: () => Promise<Uint8Array>, id?: string): IDataTransferItem {\n\tconst file = { id: generateUuid(), name: fileName, uri, data };\n\treturn {\n\t\tid,\n\t\tasString: async () => '',\n\t\tasFile: () => file,\n\t\tvalue: undefined,\n\t};\n}\n\nexport interface IReadonlyVSDataTransfer extends Iterable<readonly [string, IDataTransferItem]> {\n\t/**\n\t * Get the total number of entries in this data transfer.\n\t */\n\tget size(): number;\n\n\t/**\n\t * Check if this data transfer contains data for `mimeType`.\n\t *\n\t * This uses exact matching and does not support wildcards.\n\t */\n\thas(mimeType: string): boolean;\n\n\t/**\n\t * Retrieve the first entry for `mimeType`.\n\t *\n\t * Note that if you want to find all entries for a given mime type, use {@link IReadonlyVSDataTransfer.entries} instead.\n\t */\n\tget(mimeType: string): IDataTransferItem | undefined;\n}\n\nexport class VSDataTransfer implements IReadonlyVSDataTransfer {\n\n\tprivate readonly _entries = new Map<string, IDataTransferItem[]>();\n\n\tpublic get size(): number {\n\t\tlet size = 0;\n\t\tfor (const _ of this._entries) {\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\n\n\tpublic has(mimeType: string): boolean {\n\t\treturn this._entries.has(this.toKey(mimeType));\n\t}\n\n\tpublic matches(pattern: string): boolean {\n\t\tconst mimes = [...this._entries.keys()];\n\t\tif (Iterable.some(this, ([_, item]) => item.asFile())) {\n\t\t\tmimes.push('files');\n\t\t}\n\n\t\treturn matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n\t}\n\n\tpublic get(mimeType: string): IDataTransferItem | undefined {\n\t\treturn this._entries.get(this.toKey(mimeType))?.[0];\n\t}\n\n\t/**\n\t * Add a new entry to this data transfer.\n\t *\n\t * This does not replace existing entries for `mimeType`.\n\t */\n\tpublic append(mimeType: string, value: IDataTransferItem): void {\n\t\tconst existing = this._entries.get(mimeType);\n\t\tif (existing) {\n\t\t\texisting.push(value);\n\t\t} else {\n\t\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t\t}\n\t}\n\n\t/**\n\t * Set the entry for a given mime type.\n\t *\n\t * This replaces all existing entries for `mimeType`.\n\t */\n\tpublic replace(mimeType: string, value: IDataTransferItem): void {\n\t\tthis._entries.set(this.toKey(mimeType), [value]);\n\t}\n\n\t/**\n\t * Remove all entries for `mimeType`.\n\t */\n\tpublic delete(mimeType: string) {\n\t\tthis._entries.delete(this.toKey(mimeType));\n\t}\n\n\t/**\n\t * Iterate over all `[mime, item]` pairs in this data transfer.\n\t *\n\t * There may be multiple entries for each mime type.\n\t */\n\tpublic *[Symbol.iterator](): IterableIterator<readonly [string, IDataTransferItem]> {\n\t\tfor (const [mine, items] of this._entries) {\n\t\t\tfor (const item of items) {\n\t\t\t\tyield [mine, item];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate toKey(mimeType: string): string {\n\t\treturn normalizeMimeType(mimeType);\n\t}\n}\n\nfunction normalizeMimeType(mimeType: string): string {\n\treturn mimeType.toLowerCase();\n}\n\nexport function matchesMimeType(pattern: string, mimeTypes: readonly string[]): boolean {\n\treturn matchesMimeType_normalized(\n\t\tnormalizeMimeType(pattern),\n\t\tmimeTypes.map(normalizeMimeType));\n}\n\nfunction matchesMimeType_normalized(normalizedPattern: string, normalizedMimeTypes: readonly string[]): boolean {\n\t// Anything wildcard\n\tif (normalizedPattern === '*/*') {\n\t\treturn normalizedMimeTypes.length > 0;\n\t}\n\n\t// Exact match\n\tif (normalizedMimeTypes.includes(normalizedPattern)) {\n\t\treturn true;\n\t}\n\n\t// Wildcard, such as `image/*`\n\tconst wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n\tif (!wildcard) {\n\t\treturn false;\n\t}\n\n\tconst [_, type, subtype] = wildcard;\n\tif (subtype === '*') {\n\t\treturn normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n\t}\n\n\treturn false;\n}\n\n\nexport const UriList = Object.freeze({\n\t// http://amundsen.com/hypermedia/urilist/\n\tcreate: (entries: ReadonlyArray<string | URI>): string => {\n\t\treturn distinct(entries.map(x => x.toString())).join('\\r\\n');\n\t},\n\tsplit: (str: string): string[] => {\n\t\treturn str.split('\\r\\n');\n\t},\n\tparse: (str: string): string[] => {\n\t\treturn UriList.split(str).filter(value => !value.startsWith('#'));\n\t}\n});\n"]}