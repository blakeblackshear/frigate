{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/utils.ts","vs/base/common/observableInternal/utils/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorun } from '../reactions/autorun.js';\nimport { IObservable, IObservableWithChange, IObserver, IReader, ITransaction } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { derived, derivedOpts } from '../observables/derived.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { observableSignal } from '../observables/observableSignal.js';\nimport { _setKeepObserved, _setRecomputeInitiallyAndOnChange } from '../observables/baseObservable.js';\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: Timeout | undefined = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\ttry {\n\t\to.beginUpdate(observable);\n\t} finally {\n\t\to.endUpdate(observable);\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tif (this._counter === 1 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t\tthis._counter--;\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorun } from '../reactions/autorun.js';\nimport { IObservable, IObservableWithChange, IObserver, IReader, ITransaction } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { derived, derivedOpts } from '../observables/derived.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { observableSignal } from '../observables/observableSignal.js';\nimport { _setKeepObserved, _setRecomputeInitiallyAndOnChange } from '../observables/baseObservable.js';\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: Timeout | undefined = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\ttry {\n\t\to.beginUpdate(observable);\n\t} finally {\n\t\to.endUpdate(observable);\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tif (this._counter === 1 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t\tthis._counter--;\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n"]}