{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/transaction.ts","vs/base/common/observableInternal/transaction.ts"],"names":[],"mappings":"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","file":"transaction.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { handleBugIndicatingErrorRecovery, IObservable, IObserver, ITransaction } from './base.js';\nimport { getFunctionName } from './debugName.js';\nimport { getLogger } from './logging/logging.js';\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n/** @deprecated */\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n/**\n * Allows to chain transactions.\n */\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n} export class TransactionImpl implements ITransaction {\n\tprivate _updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tif (!this._updatingObservers) {\n\t\t\t// This happens when a transaction is used in a callback or async function.\n\t\t\t// If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).\n\t\t\thandleBugIndicatingErrorRecovery('Transaction already finished!');\n\t\t\t// Error recovery\n\t\t\ttransaction(tx => {\n\t\t\t\ttx.updateObserver(observer, observable);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis._updatingObservers.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this._updatingObservers;\n\t\tif (!updatingObservers) {\n\t\t\thandleBugIndicatingErrorRecovery('transaction.finish() has already been called!');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis._updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction(this);\n\t}\n\n\tpublic debugGetUpdatingObservers() {\n\t\treturn this._updatingObservers;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { handleBugIndicatingErrorRecovery, IObservable, IObserver, ITransaction } from './base.js';\nimport { getFunctionName } from './debugName.js';\nimport { getLogger } from './logging/logging.js';\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n/** @deprecated */\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n/**\n * Allows to chain transactions.\n */\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n} export class TransactionImpl implements ITransaction {\n\tprivate _updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tif (!this._updatingObservers) {\n\t\t\t// This happens when a transaction is used in a callback or async function.\n\t\t\t// If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).\n\t\t\thandleBugIndicatingErrorRecovery('Transaction already finished!');\n\t\t\t// Error recovery\n\t\t\ttransaction(tx => {\n\t\t\t\ttx.updateObserver(observer, observable);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis._updatingObservers.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this._updatingObservers;\n\t\tif (!updatingObservers) {\n\t\t\thandleBugIndicatingErrorRecovery('transaction.finish() has already been called!');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis._updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction(this);\n\t}\n\n\tpublic debugGetUpdatingObservers() {\n\t\treturn this._updatingObservers;\n\t}\n}\n\n"]}