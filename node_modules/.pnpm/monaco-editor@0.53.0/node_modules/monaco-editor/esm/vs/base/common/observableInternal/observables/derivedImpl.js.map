{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/derivedImpl.ts","vs/base/common/observableInternal/observables/derivedImpl.ts"],"names":[],"mappings":"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","file":"derivedImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore, ISettableObservable, ITransaction } from '../base.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, assertFn, onBugIndicatingError } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IDerivedReader<TChange = void> extends IReaderWithStore {\n}\n\nexport const enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any, TChange = void> extends BaseObservable<T, TChange> implements IDerivedReader<TChange>, IObserver {\n\tprivate _state = DerivedState.initial;\n\tprivate _value: T | undefined = undefined;\n\tprivate _updateCount = 0;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\tprivate _didReportChange = false;\n\tprivate _isInBeforeUpdate = false;\n\tprivate _isReaderValid = false;\n\tprivate _store: DisposableStore | undefined = undefined;\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis._state = DerivedState.initial;\n\t\tthis._value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this._dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t\tthis._store = undefined;\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t\tthis._delayedStore = undefined;\n\t\t}\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tconst checkEnabled = false; // TODO set to true\n\t\tif (this._isComputing && checkEnabled) {\n\t\t\t// investigate why this fails in the diff editor!\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this._observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tlet changeSummary = undefined;\n\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\tchangeSummary = this._changeTracker.createChangeSummary(undefined);\n\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t}\n\t\t\t\tresult = this._computeFn(this, changeSummary!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this._state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis._state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tif (this._state !== DerivedState.upToDate) {\n\t\t\t\t\tthis._recompute();\n\t\t\t\t}\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this._state !== DerivedState.upToDate);\n\t\t\treturn this._value!;\n\t\t}\n\t}\n\n\tprivate _recompute() {\n\t\tlet didChange = false;\n\t\tthis._isComputing = true;\n\t\tthis._didReportChange = false;\n\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\ttry {\n\t\t\tconst changeSummary = this._changeSummary!;\n\n\t\t\tthis._isReaderValid = true;\n\t\t\tif (this._changeTracker) {\n\t\t\t\tthis._isInBeforeUpdate = true;\n\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\tthis._isInBeforeUpdate = false;\n\t\t\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);\n\t\t\t}\n\n\t\t\tconst hadValue = this._state !== DerivedState.initial;\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._state = DerivedState.upToDate;\n\n\t\t\tconst delayedStore = this._delayedStore;\n\t\t\tif (delayedStore !== undefined) {\n\t\t\t\tthis._delayedStore = undefined;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\tthis._store = undefined;\n\t\t\t\t}\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis._value = this._computeFn(this, changeSummary);\n\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis._dependenciesToBeRemoved.clear();\n\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdidChange = this._didReportChange || (hadValue && !(this._equalityComparator(oldValue!, this._value)));\n\n\t\t\tgetLogger()?.handleObservableUpdated(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this._value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (!this._didReportChange && didChange) {\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._didReportChange = false;\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis._updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this._updateCount === 1;\n\t\t\tif (this._state === DerivedState.upToDate) {\n\t\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis._updateCount--;\n\t\tif (this._updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this._state === DerivedState.upToDate && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {\n\t\t\tgetLogger()?.handleDerivedDependencyChanged(this, observable, change);\n\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this._state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this._state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis._state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\n\tprivate _ensureReaderValid(): void {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureReaderValid();\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tget store(): DisposableStore {\n\t\tthis._ensureReaderValid();\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this._observers.has(observer) && this._updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tstate: this._state,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tisComputing: this._isComputing,\n\t\t\tdependencies: this._dependencies,\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(newValue: unknown) {\n\t\tthis._value = newValue as any;\n\t}\n\n\tpublic debugRecompute(): void {\n\t\tif (!this._isComputing) {\n\t\t\tthis._recompute();\n\t\t} else {\n\t\t\tthis._state = DerivedState.stale;\n\t\t}\n\t}\n\n\tpublic setValue(newValue: T, tx: ITransaction, change: TChange): void {\n\t\tthis._value = newValue;\n\t\tconst observers = this._observers;\n\t\ttx.updateObserver(this, this);\n\t\tfor (const d of observers) {\n\t\t\td.handleChange(this, change);\n\t\t}\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any, TOutChanges = any> extends Derived<T, TChangeSummary, TOutChanges> implements ISettableObservable<T, TOutChanges> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IDerivedReader<TOutChanges>, changeSummary: TChangeSummary) => T,\n\t\tchangeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tchangeTracker,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore, ISettableObservable, ITransaction } from '../base.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, assertFn, onBugIndicatingError } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IDerivedReader<TChange = void> extends IReaderWithStore {\n}\n\nexport const enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any, TChange = void> extends BaseObservable<T, TChange> implements IDerivedReader<TChange>, IObserver {\n\tprivate _state = DerivedState.initial;\n\tprivate _value: T | undefined = undefined;\n\tprivate _updateCount = 0;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\tprivate _didReportChange = false;\n\tprivate _isInBeforeUpdate = false;\n\tprivate _isReaderValid = false;\n\tprivate _store: DisposableStore | undefined = undefined;\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis._state = DerivedState.initial;\n\t\tthis._value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this._dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t\tthis._store = undefined;\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t\tthis._delayedStore = undefined;\n\t\t}\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tconst checkEnabled = false; // TODO set to true\n\t\tif (this._isComputing && checkEnabled) {\n\t\t\t// investigate why this fails in the diff editor!\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this._observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tlet changeSummary = undefined;\n\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\tchangeSummary = this._changeTracker.createChangeSummary(undefined);\n\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t}\n\t\t\t\tresult = this._computeFn(this, changeSummary!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this._state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis._state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tif (this._state !== DerivedState.upToDate) {\n\t\t\t\t\tthis._recompute();\n\t\t\t\t}\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this._state !== DerivedState.upToDate);\n\t\t\treturn this._value!;\n\t\t}\n\t}\n\n\tprivate _recompute() {\n\t\tlet didChange = false;\n\t\tthis._isComputing = true;\n\t\tthis._didReportChange = false;\n\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\ttry {\n\t\t\tconst changeSummary = this._changeSummary!;\n\n\t\t\tthis._isReaderValid = true;\n\t\t\tif (this._changeTracker) {\n\t\t\t\tthis._isInBeforeUpdate = true;\n\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\tthis._isInBeforeUpdate = false;\n\t\t\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);\n\t\t\t}\n\n\t\t\tconst hadValue = this._state !== DerivedState.initial;\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._state = DerivedState.upToDate;\n\n\t\t\tconst delayedStore = this._delayedStore;\n\t\t\tif (delayedStore !== undefined) {\n\t\t\t\tthis._delayedStore = undefined;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\tthis._store = undefined;\n\t\t\t\t}\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis._value = this._computeFn(this, changeSummary);\n\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis._dependenciesToBeRemoved.clear();\n\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdidChange = this._didReportChange || (hadValue && !(this._equalityComparator(oldValue!, this._value)));\n\n\t\t\tgetLogger()?.handleObservableUpdated(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this._value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (!this._didReportChange && didChange) {\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._didReportChange = false;\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis._updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this._updateCount === 1;\n\t\t\tif (this._state === DerivedState.upToDate) {\n\t\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis._updateCount--;\n\t\tif (this._updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this._state === DerivedState.upToDate && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {\n\t\t\tgetLogger()?.handleDerivedDependencyChanged(this, observable, change);\n\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this._state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this._state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis._state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\n\tprivate _ensureReaderValid(): void {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureReaderValid();\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tget store(): DisposableStore {\n\t\tthis._ensureReaderValid();\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this._observers.has(observer) && this._updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tstate: this._state,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tisComputing: this._isComputing,\n\t\t\tdependencies: this._dependencies,\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(newValue: unknown) {\n\t\tthis._value = newValue as any;\n\t}\n\n\tpublic debugRecompute(): void {\n\t\tif (!this._isComputing) {\n\t\t\tthis._recompute();\n\t\t} else {\n\t\t\tthis._state = DerivedState.stale;\n\t\t}\n\t}\n\n\tpublic setValue(newValue: T, tx: ITransaction, change: TChange): void {\n\t\tthis._value = newValue;\n\t\tconst observers = this._observers;\n\t\ttx.updateObserver(this, this);\n\t\tfor (const d of observers) {\n\t\t\td.handleChange(this, change);\n\t\t}\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any, TOutChanges = any> extends Derived<T, TChangeSummary, TOutChanges> implements ISettableObservable<T, TOutChanges> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IDerivedReader<TOutChanges>, changeSummary: TChangeSummary) => T,\n\t\tchangeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tchangeTracker,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n}\n"]}