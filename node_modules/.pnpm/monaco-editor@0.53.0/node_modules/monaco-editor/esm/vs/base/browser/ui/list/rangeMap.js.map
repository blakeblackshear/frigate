{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/ui/list/rangeMap.ts","vs/base/browser/ui/list/rangeMap.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAU,KAAK,EAAE,MAAM,0BAA0B,CAAC;AAWzD;;;GAGG;AACH,MAAM,UAAU,cAAc,CAAC,KAAa,EAAE,MAAsB;IACnE,MAAM,MAAM,GAAmB,EAAE,CAAC;IAElC,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE,CAAC;QACxB,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YAChC,SAAS;QACV,CAAC;QAED,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YAC/B,MAAM;QACP,CAAC;QAED,MAAM,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;QAErD,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC;YACjC,SAAS;QACV,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;YACX,KAAK,EAAE,YAAY;YACnB,IAAI,EAAE,CAAC,CAAC,IAAI;SACZ,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,KAAK,CAAC,EAAE,KAAK,EAAE,GAAG,EAAU,EAAE,IAAY;IACzD,OAAO,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,CAAC;AACjD,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,WAAW,CAAC,MAAsB;IACjD,MAAM,MAAM,GAAmB,EAAE,CAAC;IAClC,IAAI,aAAa,GAAwB,IAAI,CAAC;IAE9C,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;QAC5B,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;QAChC,MAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC;QAC5B,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QAExB,IAAI,aAAa,IAAI,IAAI,KAAK,aAAa,CAAC,IAAI,EAAE,CAAC;YAClD,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;YAC9B,SAAS;QACV,CAAC;QAED,aAAa,GAAG,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,CAAC;QAChD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC5B,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAED;;;GAGG;AACH,SAAS,MAAM,CAAC,GAAG,MAAwB;IAC1C,OAAO,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC9D,CAAC;AAYD,MAAM,OAAO,QAAQ;IAMpB,IAAI,UAAU;QACb,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;IAED,IAAI,UAAU,CAAC,UAAkB;QAChC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC;QACxD,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;IAC/B,CAAC;IAED,YAAY,UAAmB;QAbvB,WAAM,GAAmB,EAAE,CAAC;QAC5B,UAAK,GAAG,CAAC,CAAC;QACV,gBAAW,GAAG,CAAC,CAAC;QAYvB,IAAI,CAAC,WAAW,GAAG,UAAU,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC;IAC/B,CAAC;IAED,MAAM,CAAC,KAAa,EAAE,WAAmB,EAAE,QAAiB,EAAE;QAC7D,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC;QACxC,MAAM,MAAM,GAAG,cAAc,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACrE,MAAM,KAAK,GAAG,cAAc,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG,WAAW,EAAE,GAAG,EAAE,MAAM,CAAC,iBAAiB,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC;aACtG,GAAG,CAAe,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAE1E,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAe,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;YACpD,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,GAAG,CAAC,GAAG,CAAC,EAAE;YAC/C,IAAI,EAAE,IAAI,CAAC,IAAI;SACf,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAC5C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/G,CAAC;IAED;;OAEG;IACH,IAAI,KAAK;QACR,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAE/B,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,CAAC,CAAC;QACV,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,QAAgB;QACvB,IAAI,QAAQ,GAAG,CAAC,EAAE,CAAC;YAClB,OAAO,CAAC,CAAC,CAAC;QACX,CAAC;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;YACjC,OAAO,CAAC,CAAC;QACV,CAAC;QAED,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;QAE5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACjC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;YAClD,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;YAE5C,IAAI,QAAQ,GAAG,OAAO,EAAE,CAAC;gBACxB,OAAO,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;YAC3D,CAAC;YAED,KAAK,IAAI,KAAK,CAAC;YACf,IAAI,GAAG,OAAO,CAAC;QAChB,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;;OAGG;IACH,UAAU,CAAC,QAAgB;QAC1B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,KAAa;QACvB,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;YACf,OAAO,CAAC,CAAC,CAAC;QACX,CAAC;QAED,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACjC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;YACvD,MAAM,QAAQ,GAAG,KAAK,GAAG,UAAU,CAAC;YAEpC,IAAI,KAAK,GAAG,QAAQ,EAAE,CAAC;gBACtB,OAAO,IAAI,CAAC,WAAW,GAAG,QAAQ,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;YACrE,CAAC;YAED,QAAQ,IAAI,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC;YACpC,KAAK,GAAG,QAAQ,CAAC;QAClB,CAAC;QAED,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;CACD","file":"rangeMap.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from '../../../common/range.js';\n\nexport interface IItem {\n\tsize: number;\n}\n\nexport interface IRangedGroup {\n\trange: IRange;\n\tsize: number;\n}\n\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range: IRange, groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\n\tfor (const r of groups) {\n\t\tif (range.start >= r.range.end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (range.end < r.range.start) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst intersection = Range.intersect(range, r.range);\n\n\t\tif (Range.isEmpty(intersection)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push({\n\t\t\trange: intersection,\n\t\t\tsize: r.size\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }: IRange, much: number): IRange {\n\treturn { start: start + much, end: end + much };\n}\n\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\tlet previousGroup: IRangedGroup | null = null;\n\n\tfor (const group of groups) {\n\t\tconst start = group.range.start;\n\t\tconst end = group.range.end;\n\t\tconst size = group.size;\n\n\t\tif (previousGroup && size === previousGroup.size) {\n\t\t\tpreviousGroup.range.end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpreviousGroup = { range: { start, end }, size };\n\t\tresult.push(previousGroup);\n\t}\n\n\treturn result;\n}\n\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups: IRangedGroup[][]): IRangedGroup[] {\n\treturn consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\n\nexport interface IRangeMap {\n\treadonly size: number;\n\treadonly count: number;\n\tpaddingTop: number;\n\tsplice(index: number, deleteCount: number, items?: IItem[]): void;\n\tindexAt(position: number): number;\n\tindexAfter(position: number): number;\n\tpositionAt(index: number): number;\n}\n\nexport class RangeMap implements IRangeMap {\n\n\tprivate groups: IRangedGroup[] = [];\n\tprivate _size = 0;\n\tprivate _paddingTop = 0;\n\n\tget paddingTop() {\n\t\treturn this._paddingTop;\n\t}\n\n\tset paddingTop(paddingTop: number) {\n\t\tthis._size = this._size + paddingTop - this._paddingTop;\n\t\tthis._paddingTop = paddingTop;\n\t}\n\n\tconstructor(topPadding?: number) {\n\t\tthis._paddingTop = topPadding ?? 0;\n\t\tthis._size = this._paddingTop;\n\t}\n\n\tsplice(index: number, deleteCount: number, items: IItem[] = []): void {\n\t\tconst diff = items.length - deleteCount;\n\t\tconst before = groupIntersect({ start: 0, end: index }, this.groups);\n\t\tconst after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n\t\t\t.map<IRangedGroup>(g => ({ range: shift(g.range, diff), size: g.size }));\n\n\t\tconst middle = items.map<IRangedGroup>((item, i) => ({\n\t\t\trange: { start: index + i, end: index + i + 1 },\n\t\t\tsize: item.size\n\t\t}));\n\n\t\tthis.groups = concat(before, middle, after);\n\t\tthis._size = this._paddingTop + this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n\t}\n\n\t/**\n\t * Returns the number of items in the range map.\n\t */\n\tget count(): number {\n\t\tconst len = this.groups.length;\n\n\t\tif (!len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.groups[len - 1].range.end;\n\t}\n\n\t/**\n\t * Returns the sum of the sizes of all items in the range map.\n\t */\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Returns the index of the item at the given position.\n\t */\n\tindexAt(position: number): number {\n\t\tif (position < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (position < this._paddingTop) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet index = 0;\n\t\tlet size = this._paddingTop;\n\n\t\tfor (const group of this.groups) {\n\t\t\tconst count = group.range.end - group.range.start;\n\t\t\tconst newSize = size + (count * group.size);\n\n\t\t\tif (position < newSize) {\n\t\t\t\treturn index + Math.floor((position - size) / group.size);\n\t\t\t}\n\n\t\t\tindex += count;\n\t\t\tsize = newSize;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Returns the index of the item right after the item at the\n\t * index of the given position.\n\t */\n\tindexAfter(position: number): number {\n\t\treturn Math.min(this.indexAt(position) + 1, this.count);\n\t}\n\n\t/**\n\t * Returns the start position of the item at the given index.\n\t */\n\tpositionAt(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet position = 0;\n\t\tlet count = 0;\n\n\t\tfor (const group of this.groups) {\n\t\t\tconst groupCount = group.range.end - group.range.start;\n\t\t\tconst newCount = count + groupCount;\n\n\t\t\tif (index < newCount) {\n\t\t\t\treturn this._paddingTop + position + ((index - count) * group.size);\n\t\t\t}\n\n\t\t\tposition += groupCount * group.size;\n\t\t\tcount = newCount;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from '../../../common/range.js';\n\nexport interface IItem {\n\tsize: number;\n}\n\nexport interface IRangedGroup {\n\trange: IRange;\n\tsize: number;\n}\n\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range: IRange, groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\n\tfor (const r of groups) {\n\t\tif (range.start >= r.range.end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (range.end < r.range.start) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst intersection = Range.intersect(range, r.range);\n\n\t\tif (Range.isEmpty(intersection)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push({\n\t\t\trange: intersection,\n\t\t\tsize: r.size\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }: IRange, much: number): IRange {\n\treturn { start: start + much, end: end + much };\n}\n\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\tlet previousGroup: IRangedGroup | null = null;\n\n\tfor (const group of groups) {\n\t\tconst start = group.range.start;\n\t\tconst end = group.range.end;\n\t\tconst size = group.size;\n\n\t\tif (previousGroup && size === previousGroup.size) {\n\t\t\tpreviousGroup.range.end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpreviousGroup = { range: { start, end }, size };\n\t\tresult.push(previousGroup);\n\t}\n\n\treturn result;\n}\n\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups: IRangedGroup[][]): IRangedGroup[] {\n\treturn consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\n\nexport interface IRangeMap {\n\treadonly size: number;\n\treadonly count: number;\n\tpaddingTop: number;\n\tsplice(index: number, deleteCount: number, items?: IItem[]): void;\n\tindexAt(position: number): number;\n\tindexAfter(position: number): number;\n\tpositionAt(index: number): number;\n}\n\nexport class RangeMap implements IRangeMap {\n\n\tprivate groups: IRangedGroup[] = [];\n\tprivate _size = 0;\n\tprivate _paddingTop = 0;\n\n\tget paddingTop() {\n\t\treturn this._paddingTop;\n\t}\n\n\tset paddingTop(paddingTop: number) {\n\t\tthis._size = this._size + paddingTop - this._paddingTop;\n\t\tthis._paddingTop = paddingTop;\n\t}\n\n\tconstructor(topPadding?: number) {\n\t\tthis._paddingTop = topPadding ?? 0;\n\t\tthis._size = this._paddingTop;\n\t}\n\n\tsplice(index: number, deleteCount: number, items: IItem[] = []): void {\n\t\tconst diff = items.length - deleteCount;\n\t\tconst before = groupIntersect({ start: 0, end: index }, this.groups);\n\t\tconst after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n\t\t\t.map<IRangedGroup>(g => ({ range: shift(g.range, diff), size: g.size }));\n\n\t\tconst middle = items.map<IRangedGroup>((item, i) => ({\n\t\t\trange: { start: index + i, end: index + i + 1 },\n\t\t\tsize: item.size\n\t\t}));\n\n\t\tthis.groups = concat(before, middle, after);\n\t\tthis._size = this._paddingTop + this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n\t}\n\n\t/**\n\t * Returns the number of items in the range map.\n\t */\n\tget count(): number {\n\t\tconst len = this.groups.length;\n\n\t\tif (!len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.groups[len - 1].range.end;\n\t}\n\n\t/**\n\t * Returns the sum of the sizes of all items in the range map.\n\t */\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Returns the index of the item at the given position.\n\t */\n\tindexAt(position: number): number {\n\t\tif (position < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (position < this._paddingTop) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet index = 0;\n\t\tlet size = this._paddingTop;\n\n\t\tfor (const group of this.groups) {\n\t\t\tconst count = group.range.end - group.range.start;\n\t\t\tconst newSize = size + (count * group.size);\n\n\t\t\tif (position < newSize) {\n\t\t\t\treturn index + Math.floor((position - size) / group.size);\n\t\t\t}\n\n\t\t\tindex += count;\n\t\t\tsize = newSize;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Returns the index of the item right after the item at the\n\t * index of the given position.\n\t */\n\tindexAfter(position: number): number {\n\t\treturn Math.min(this.indexAt(position) + 1, this.count);\n\t}\n\n\t/**\n\t * Returns the start position of the item at the given index.\n\t */\n\tpositionAt(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet position = 0;\n\t\tlet count = 0;\n\n\t\tfor (const group of this.groups) {\n\t\t\tconst groupCount = group.range.end - group.range.start;\n\t\t\tconst newCount = count + groupCount;\n\n\t\t\tif (index < newCount) {\n\t\t\t\treturn this._paddingTop + position + ((index - count) * group.size);\n\t\t\t}\n\n\t\t\tposition += groupCount * group.size;\n\t\t\tcount = newCount;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n"]}