{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/lazy.ts","vs/base/common/lazy.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,IAAK,cAIJ;AAJD,WAAK,cAAc;IAClB,qEAAa,CAAA;IACb,yDAAO,CAAA;IACP,6DAAS,CAAA;AACV,CAAC,EAJI,cAAc,KAAd,cAAc,QAIlB;AAED,MAAM,OAAO,IAAI;IAMhB,YACkB,QAAiB;QAAjB,aAAQ,GAAR,QAAQ,CAAS;QAL3B,WAAM,GAAG,cAAc,CAAC,aAAa,CAAC;IAM1C,CAAC;IAEL;;;;;OAKG;IACH,IAAI,KAAK;QACR,IAAI,IAAI,CAAC,MAAM,KAAK,cAAc,CAAC,aAAa,EAAE,CAAC;YAClD,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC,OAAO,CAAC;YACrC,IAAI,CAAC;gBACJ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC/B,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACd,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;YACnB,CAAC;oBAAS,CAAC;gBACV,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC,SAAS,CAAC;YACxC,CAAC;QACF,CAAC;aAAM,IAAI,IAAI,CAAC,MAAM,KAAK,cAAc,CAAC,OAAO,EAAE,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;QAC9E,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACjB,MAAM,IAAI,CAAC,MAAM,CAAC;QACnB,CAAC;QACD,OAAO,IAAI,CAAC,MAAO,CAAC;IACrB,CAAC;IAED;;OAEG;IACH,IAAI,QAAQ,KAAoB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;CACrD","file":"lazy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n"]}