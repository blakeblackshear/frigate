{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/debugger/rpc.ts","vs/base/common/observableInternal/logging/debugger/rpc.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAiChG,MAAM,OAAO,wBAAwB;IAE7B,MAAM,CAAC,YAAY,CAAgB,cAA8B,EAAE,UAA6B;QACtG,OAAO,IAAI,wBAAwB,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;IACjE,CAAC;IAKD,YACkB,eAA+B,EAC/B,WAAuB;QADvB,oBAAe,GAAf,eAAe,CAAgB;QAC/B,gBAAW,GAAX,WAAW,CAAY;QAExC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;YACpC,kBAAkB,EAAE,CAAC,gBAAgB,EAAE,EAAE;gBACxC,MAAM,CAAC,GAAG,gBAAmC,CAAC;gBAC9C,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClD,IAAI,CAAC,EAAE,EAAE,CAAC;oBACT,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBACpD,CAAC;gBACD,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,CAAC;YACD,aAAa,EAAE,CAAC,WAAW,EAAE,EAAE;gBAC9B,MAAM,CAAC,GAAG,WAA8B,CAAC;gBACzC,IAAI,CAAC;oBACJ,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC1D,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC;gBAC1C,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACZ,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;gBACpC,CAAC;YACF,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,EAAE,EAAE;YAC9B,GAAG,EAAE,CAAC,MAAM,EAAE,GAAW,EAAE,EAAE;gBAC5B,OAAO,KAAK,EAAE,GAAG,IAAW,EAAE,EAAE;oBAC/B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,IAAI,CAA2B,CAAC,CAAC;oBACtF,IAAI,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;wBAC7B,MAAM,MAAM,CAAC,KAAK,CAAC;oBACpB,CAAC;yBAAM,CAAC;wBACP,OAAO,MAAM,CAAC,KAAK,CAAC;oBACrB,CAAC;gBACF,CAAC,CAAC;YACH,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,aAAa,GAAG,IAAI,KAAK,CAAC,EAAE,EAAE;YACnC,GAAG,EAAE,CAAC,MAAM,EAAE,GAAW,EAAE,EAAE;gBAC5B,OAAO,CAAC,GAAG,IAAW,EAAE,EAAE;oBACzB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,IAAI,CAA2B,CAAC,CAAC;gBACvE,CAAC,CAAC;YACH,CAAC;SACD,CAAC,CAAC;QAEH,IAAI,CAAC,GAAG,GAAG,EAAE,aAAa,EAAE,aAAa,EAAE,QAAQ,EAAE,QAAQ,EAAS,CAAC;IACxE,CAAC;CACD","file":"rpc.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ChannelFactory = (handler: IChannelHandler) => IChannel;\n\nexport interface IChannel {\n\tsendNotification(data: unknown): void;\n\tsendRequest(data: unknown): Promise<RpcRequestResult>;\n}\n\nexport interface IChannelHandler {\n\thandleNotification(notificationData: unknown): void;\n\thandleRequest(requestData: unknown): Promise<RpcRequestResult> | RpcRequestResult;\n}\n\nexport type RpcRequestResult = { type: 'result'; value: unknown } | { type: 'error'; value: unknown };\n\nexport type API = {\n\thost: Side;\n\tclient: Side;\n};\n\nexport type Side = {\n\tnotifications: Record<string, (...args: any[]) => void>;\n\trequests: Record<string, (...args: any[]) => Promise<unknown> | unknown>;\n};\n\ntype MakeAsyncIfNot<TFn> = TFn extends (...args: infer TArgs) => infer TResult ? TResult extends Promise<unknown> ? TFn : (...args: TArgs) => Promise<TResult> : never;\n\nexport type MakeSideAsync<T extends Side> = {\n\tnotifications: T['notifications'];\n\trequests: { [K in keyof T['requests']]: MakeAsyncIfNot<T['requests'][K]> };\n};\n\nexport class SimpleTypedRpcConnection<T extends Side> {\n\n\tpublic static createClient<T extends API>(channelFactory: ChannelFactory, getHandler: () => T['client']): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\t\treturn new SimpleTypedRpcConnection(channelFactory, getHandler);\n\t}\n\n\tpublic readonly api: T;\n\tprivate readonly _channel: IChannel;\n\n\tprivate constructor(\n\t\tprivate readonly _channelFactory: ChannelFactory,\n\t\tprivate readonly _getHandler: () => Side,\n\t) {\n\t\tthis._channel = this._channelFactory({\n\t\t\thandleNotification: (notificationData) => {\n\t\t\t\tconst m = notificationData as OutgoingMessage;\n\t\t\t\tconst fn = this._getHandler().notifications[m[0]];\n\t\t\t\tif (!fn) {\n\t\t\t\t\tthrow new Error(`Unknown notification \"${m[0]}\"!`);\n\t\t\t\t}\n\t\t\t\tfn(...m[1]);\n\t\t\t},\n\t\t\thandleRequest: (requestData) => {\n\t\t\t\tconst m = requestData as OutgoingMessage;\n\t\t\t\ttry {\n\t\t\t\t\tconst result = this._getHandler().requests[m[0]](...m[1]);\n\t\t\t\t\treturn { type: 'result', value: result };\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { type: 'error', value: e };\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tconst requests = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn async (...args: any[]) => {\n\t\t\t\t\tconst result = await this._channel.sendRequest([key, args] satisfies OutgoingMessage);\n\t\t\t\t\tif (result.type === 'error') {\n\t\t\t\t\t\tthrow result.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst notifications = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\tthis._channel.sendNotification([key, args] satisfies OutgoingMessage);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis.api = { notifications: notifications, requests: requests } as any;\n\t}\n}\n\ntype OutgoingMessage = [\n\tmethod: string,\n\targs: unknown[],\n];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ChannelFactory = (handler: IChannelHandler) => IChannel;\n\nexport interface IChannel {\n\tsendNotification(data: unknown): void;\n\tsendRequest(data: unknown): Promise<RpcRequestResult>;\n}\n\nexport interface IChannelHandler {\n\thandleNotification(notificationData: unknown): void;\n\thandleRequest(requestData: unknown): Promise<RpcRequestResult> | RpcRequestResult;\n}\n\nexport type RpcRequestResult = { type: 'result'; value: unknown } | { type: 'error'; value: unknown };\n\nexport type API = {\n\thost: Side;\n\tclient: Side;\n};\n\nexport type Side = {\n\tnotifications: Record<string, (...args: any[]) => void>;\n\trequests: Record<string, (...args: any[]) => Promise<unknown> | unknown>;\n};\n\ntype MakeAsyncIfNot<TFn> = TFn extends (...args: infer TArgs) => infer TResult ? TResult extends Promise<unknown> ? TFn : (...args: TArgs) => Promise<TResult> : never;\n\nexport type MakeSideAsync<T extends Side> = {\n\tnotifications: T['notifications'];\n\trequests: { [K in keyof T['requests']]: MakeAsyncIfNot<T['requests'][K]> };\n};\n\nexport class SimpleTypedRpcConnection<T extends Side> {\n\n\tpublic static createClient<T extends API>(channelFactory: ChannelFactory, getHandler: () => T['client']): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\t\treturn new SimpleTypedRpcConnection(channelFactory, getHandler);\n\t}\n\n\tpublic readonly api: T;\n\tprivate readonly _channel: IChannel;\n\n\tprivate constructor(\n\t\tprivate readonly _channelFactory: ChannelFactory,\n\t\tprivate readonly _getHandler: () => Side,\n\t) {\n\t\tthis._channel = this._channelFactory({\n\t\t\thandleNotification: (notificationData) => {\n\t\t\t\tconst m = notificationData as OutgoingMessage;\n\t\t\t\tconst fn = this._getHandler().notifications[m[0]];\n\t\t\t\tif (!fn) {\n\t\t\t\t\tthrow new Error(`Unknown notification \"${m[0]}\"!`);\n\t\t\t\t}\n\t\t\t\tfn(...m[1]);\n\t\t\t},\n\t\t\thandleRequest: (requestData) => {\n\t\t\t\tconst m = requestData as OutgoingMessage;\n\t\t\t\ttry {\n\t\t\t\t\tconst result = this._getHandler().requests[m[0]](...m[1]);\n\t\t\t\t\treturn { type: 'result', value: result };\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { type: 'error', value: e };\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tconst requests = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn async (...args: any[]) => {\n\t\t\t\t\tconst result = await this._channel.sendRequest([key, args] satisfies OutgoingMessage);\n\t\t\t\t\tif (result.type === 'error') {\n\t\t\t\t\t\tthrow result.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst notifications = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\tthis._channel.sendNotification([key, args] satisfies OutgoingMessage);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis.api = { notifications: notifications, requests: requests } as any;\n\t}\n}\n\ntype OutgoingMessage = [\n\tmethod: string,\n\targs: unknown[],\n];\n"]}