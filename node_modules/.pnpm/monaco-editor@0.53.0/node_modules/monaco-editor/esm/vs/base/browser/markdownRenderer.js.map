{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/browser/markdownRenderer.ts","vs/base/browser/markdownRenderer.ts"],"names":[],"mappings":"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","file":"markdownRenderer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../common/errors.js';\nimport { escapeDoubleQuotes, IMarkdownString, MarkdownStringTrustedOptions, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { KeyCode } from '../common/keyCodes.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nimport * as DOM from './dom.js';\nimport * as domSanitize from './domSanitize.js';\nimport { convertTagToPlaintext } from './domSanitize.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\n\nexport type MarkdownActionHandler = (linkContent: string, mdStr: IMarkdownString) => void;\n\n/**\n * Options for the rendering of markdown with {@link renderMarkdown}.\n */\nexport interface MarkdownRenderOptions {\n\treadonly codeBlockRenderer?: (languageId: string, value: string) => Promise<HTMLElement>;\n\treadonly codeBlockRendererSync?: (languageId: string, value: string, raw?: string) => HTMLElement;\n\treadonly asyncRenderCallback?: () => void;\n\n\treadonly actionHandler?: MarkdownActionHandler;\n\n\treadonly fillInIncompleteTokens?: boolean;\n\n\treadonly sanitizerConfig?: MarkdownSanitizerConfig;\n\n\treadonly markedOptions?: MarkdownRendererMarkedOptions;\n\treadonly markedExtensions?: marked.MarkedExtension[];\n}\n\n/**\n * Subset of options passed to `Marked` for rendering markdown.\n */\nexport interface MarkdownRendererMarkedOptions {\n}\n\nexport interface MarkdownSanitizerConfig {\n\treadonly replaceWithPlaintext?: boolean;\n\treadonly allowedTags?: {\n\t\treadonly override: readonly string[];\n\t};\n\treadonly allowedAttributes?: {\n\t\treadonly override: ReadonlyArray<string | domSanitize.SanitizeAttributeRule>;\n\t};\n\treadonly allowedLinkSchemes?: {\n\t\treadonly augment: readonly string[];\n\t};\n\treadonly remoteImageIsAllowed?: (uri: URI) => boolean;\n}\n\nconst defaultMarkedRenderers = Object.freeze({\n\timage: ({ href, title, text }: marked.Tokens.Image): string => {\n\t\tlet dimensions: string[] = [];\n\t\tlet attributes: string[] = [];\n\t\tif (href) {\n\t\t\t({ href, dimensions } = parseHrefAndDimensions(href));\n\t\t\tattributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n\t\t}\n\t\tif (text) {\n\t\t\tattributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n\t\t}\n\t\tif (title) {\n\t\t\tattributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n\t\t}\n\t\tif (dimensions.length) {\n\t\t\tattributes = attributes.concat(dimensions);\n\t\t}\n\t\treturn '<img ' + attributes.join(' ') + '>';\n\t},\n\n\tparagraph(this: marked.Renderer, { tokens }: marked.Tokens.Paragraph): string {\n\t\treturn `<p>${this.parser.parseInline(tokens)}</p>`;\n\t},\n\n\tlink(this: marked.Renderer, { href, title, tokens }: marked.Tokens.Link): string {\n\t\tlet text = this.parser.parseInline(tokens);\n\t\tif (typeof href !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n\t\tif (href === text) { // raw link case\n\t\t\ttext = removeMarkdownEscapes(text);\n\t\t}\n\n\t\ttitle = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n\t\thref = removeMarkdownEscapes(href);\n\n\t\t// HTML Encode href\n\t\thref = href.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t.replace(/'/g, '&#39;');\n\n\t\treturn `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n\t},\n});\n\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using {@link import('../../editor/browser/widget/markdownRenderer/browser/markdownRenderer.js').MarkdownRenderer MarkdownRenderer}\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown: IMarkdownString, options: MarkdownRenderOptions = {}, target?: HTMLElement): { element: HTMLElement; dispose: () => void } {\n\tconst disposables = new DisposableStore();\n\tlet isDisposed = false;\n\n\tconst markedInstance = new marked.Marked(...(options.markedExtensions ?? []));\n\tconst { renderer, codeBlocks, syncCodeBlocks } = createMarkdownRenderer(markedInstance, options, markdown);\n\tconst value = preprocessMarkdownString(markdown);\n\n\tlet renderedMarkdown: string;\n\tif (options.fillInIncompleteTokens) {\n\t\t// The defaults are applied by parse but not lexer()/parser(), and they need to be present\n\t\tconst opts: marked.MarkedOptions = {\n\t\t\t...markedInstance.defaults,\n\t\t\t...options.markedOptions,\n\t\t\trenderer\n\t\t};\n\t\tconst tokens = markedInstance.lexer(value, opts);\n\t\tconst newTokens = fillInIncompleteTokens(tokens);\n\t\trenderedMarkdown = markedInstance.parser(newTokens, opts);\n\t} else {\n\t\trenderedMarkdown = markedInstance.parse(value, { ...options?.markedOptions, renderer, async: false });\n\t}\n\n\t// Rewrite theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tconst elements = renderLabelWithIcons(renderedMarkdown);\n\t\trenderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n\t}\n\n\tconst renderedContent = document.createElement('div');\n\tconst sanitizerConfig = getDomSanitizerConfig(markdown.isTrusted ?? false, options.sanitizerConfig ?? {});\n\tdomSanitize.safeSetInnerHtml(renderedContent, renderedMarkdown, sanitizerConfig);\n\n\t// Rewrite links and images before potentially inserting them into the real dom\n\trewriteRenderedLinks(markdown, options, renderedContent);\n\n\tlet outElement: HTMLElement;\n\tif (target) {\n\t\toutElement = target;\n\t\tDOM.reset(target, ...renderedContent.children);\n\t} else {\n\t\toutElement = renderedContent;\n\t}\n\n\tif (codeBlocks.length > 0) {\n\t\tPromise.all(codeBlocks).then((tuples) => {\n\t\t\tif (isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst renderedElements = new Map(tuples);\n\t\t\tconst placeholderElements = outElement.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\t\tif (renderedElement) {\n\t\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\toptions.asyncRenderCallback?.();\n\t\t});\n\t} else if (syncCodeBlocks.length > 0) {\n\t\tconst renderedElements = new Map(syncCodeBlocks);\n\t\tconst placeholderElements = outElement.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\tif (renderedElement) {\n\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Signal size changes for image tags\n\tif (options.asyncRenderCallback) {\n\t\tfor (const img of outElement.getElementsByTagName('img')) {\n\t\t\tconst listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n\t\t\t\tlistener.dispose();\n\t\t\t\toptions.asyncRenderCallback!();\n\t\t\t}));\n\t\t}\n\t}\n\n\t// Add event listeners for links\n\tif (options.actionHandler) {\n\t\tconst clickCb = (e: PointerEvent) => {\n\t\t\tconst mouseEvent = new StandardMouseEvent(DOM.getWindow(outElement), e);\n\t\t\tif (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivateLink(markdown, options, mouseEvent);\n\t\t};\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'click', clickCb));\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'auxclick', clickCb));\n\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'keydown', (e) => {\n\t\t\tconst keyboardEvent = new StandardKeyboardEvent(e);\n\t\t\tif (!keyboardEvent.equals(KeyCode.Space) && !keyboardEvent.equals(KeyCode.Enter)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivateLink(markdown, options, keyboardEvent);\n\t\t}));\n\t}\n\n\t// Remove/disable inputs\n\tfor (const input of [...outElement.getElementsByTagName('input')]) {\n\t\tif (input.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\tinput.setAttribute('disabled', '');\n\t\t} else {\n\t\t\tif (options.sanitizerConfig?.replaceWithPlaintext) {\n\t\t\t\tconst replacement = convertTagToPlaintext(input);\n\t\t\t\tinput.parentElement?.replaceChild(replacement, input);\n\t\t\t} else {\n\t\t\t\tinput.remove();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\telement: outElement,\n\t\tdispose: () => {\n\t\t\tisDisposed = true;\n\t\t\tdisposables.dispose();\n\t\t}\n\t};\n}\n\nfunction rewriteRenderedLinks(markdown: IMarkdownString, options: MarkdownRenderOptions, root: HTMLElement) {\n\tfor (const el of root.querySelectorAll('img, audio, video, source')) {\n\t\tconst src = el.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n\t\tif (src) {\n\t\t\tlet href = src;\n\t\t\ttry {\n\t\t\t\tif (markdown.baseUri) { // absolute or relative local path, or file: uri\n\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t}\n\t\t\t} catch (err) { }\n\n\t\t\tel.setAttribute('src', massageHref(markdown, href, true));\n\n\t\t\tif (options.sanitizerConfig?.remoteImageIsAllowed) {\n\t\t\t\tconst uri = URI.parse(href);\n\t\t\t\tif (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.sanitizerConfig.remoteImageIsAllowed(uri)) {\n\t\t\t\t\tel.replaceWith(DOM.$('', undefined, el.outerHTML));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const el of root.querySelectorAll('a')) {\n\t\tconst href = el.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n\t\tel.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n\t\tif (!href\n\t\t\t|| /^data:|javascript:/i.test(href)\n\t\t\t|| (/^command:/i.test(href) && !markdown.isTrusted)\n\t\t\t|| /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n\t\t\t// drop the link\n\t\t\tel.replaceWith(...el.childNodes);\n\t\t} else {\n\t\t\tlet resolvedHref = massageHref(markdown, href, false);\n\t\t\tif (markdown.baseUri) {\n\t\t\t\tresolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t}\n\t\t\tel.dataset.href = resolvedHref;\n\t\t}\n\t}\n}\n\nfunction createMarkdownRenderer(marked: marked.Marked, options: MarkdownRenderOptions, markdown: IMarkdownString): { renderer: marked.Renderer; codeBlocks: Promise<[string, HTMLElement]>[]; syncCodeBlocks: [string, HTMLElement][] } {\n\tconst renderer = new marked.Renderer(options.markedOptions);\n\trenderer.image = defaultMarkedRenderers.image;\n\trenderer.link = defaultMarkedRenderers.link;\n\trenderer.paragraph = defaultMarkedRenderers.paragraph;\n\n\t// Will collect [id, renderedElement] tuples\n\tconst codeBlocks: Promise<[string, HTMLElement]>[] = [];\n\tconst syncCodeBlocks: [string, HTMLElement][] = [];\n\n\tif (options.codeBlockRendererSync) {\n\t\trenderer.code = ({ text, lang, raw }: marked.Tokens.Code) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRendererSync!(postProcessCodeBlockLanguageId(lang), text, raw);\n\t\t\tsyncCodeBlocks.push([id, value]);\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n\t\t};\n\t} else if (options.codeBlockRenderer) {\n\t\trenderer.code = ({ text, lang }: marked.Tokens.Code) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRenderer!(postProcessCodeBlockLanguageId(lang), text);\n\t\t\tcodeBlocks.push(value.then(element => [id, element]));\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n\t\t};\n\t}\n\n\tif (!markdown.supportHtml) {\n\t\t// Note: we always pass the output through dompurify after this so that we don't rely on\n\t\t// marked for real sanitization.\n\t\trenderer.html = ({ text }) => {\n\t\t\tif (options.sanitizerConfig?.replaceWithPlaintext) {\n\t\t\t\treturn escape(text);\n\t\t\t}\n\n\t\t\tconst match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n\t\t\treturn match ? text : '';\n\t\t};\n\t}\n\treturn { renderer, codeBlocks, syncCodeBlocks };\n}\n\nfunction preprocessMarkdownString(markdown: IMarkdownString) {\n\tlet value = markdown.value;\n\n\t// values that are too long will freeze the UI\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\t// escape theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tvalue = markdownEscapeEscapedIcons(value);\n\t}\n\n\treturn value;\n}\n\nfunction activateLink(mdStr: IMarkdownString, options: MarkdownRenderOptions, event: StandardMouseEvent | StandardKeyboardEvent): void {\n\tconst target = event.target.closest('a[data-href]');\n\tif (!DOM.isHTMLElement(target)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tlet href = target.dataset['href'];\n\t\tif (href) {\n\t\t\tif (mdStr.baseUri) {\n\t\t\t\thref = resolveWithBaseUri(URI.from(mdStr.baseUri), href);\n\t\t\t}\n\t\t\toptions.actionHandler?.(href, mdStr);\n\t\t}\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t} finally {\n\t\tevent.preventDefault();\n\t}\n}\n\nfunction uriMassage(markdown: IMarkdownString, part: string): string {\n\tlet data: unknown;\n\ttry {\n\t\tdata = parse(decodeURIComponent(part));\n\t} catch (e) {\n\t\t// ignore\n\t}\n\tif (!data) {\n\t\treturn part;\n\t}\n\tdata = cloneAndChange(data, value => {\n\t\tif (markdown.uris && markdown.uris[value]) {\n\t\t\treturn URI.revive(markdown.uris[value]);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t});\n\treturn encodeURIComponent(JSON.stringify(data));\n}\n\nfunction massageHref(markdown: IMarkdownString, href: string, isDomUri: boolean): string {\n\tconst data = markdown.uris && markdown.uris[href];\n\tlet uri = URI.revive(data);\n\tif (isDomUri) {\n\t\tif (href.startsWith(Schemas.data + ':')) {\n\t\t\treturn href;\n\t\t}\n\t\tif (!uri) {\n\t\t\turi = URI.parse(href);\n\t\t}\n\t\t// this URI will end up as \"src\"-attribute of a dom node\n\t\t// and because of that special rewriting needs to be done\n\t\t// so that the URI uses a protocol that's understood by\n\t\t// browsers (like http or https)\n\t\treturn FileAccess.uriToBrowserUri(uri).toString(true);\n\t}\n\tif (!uri) {\n\t\treturn href;\n\t}\n\tif (URI.parse(href).toString() === uri.toString()) {\n\t\treturn href; // no transformation performed\n\t}\n\tif (uri.query) {\n\t\turi = uri.with({ query: uriMassage(markdown, uri.query) });\n\t}\n\treturn uri.toString();\n}\n\nfunction postProcessCodeBlockLanguageId(lang: string | undefined): string {\n\tif (!lang) {\n\t\treturn '';\n\t}\n\n\tconst parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n\tif (parts.length) {\n\t\treturn parts[0];\n\t}\n\treturn lang;\n}\n\nfunction resolveWithBaseUri(baseUri: URI, href: string): string {\n\tconst hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n\tif (hasScheme) {\n\t\treturn href;\n\t}\n\n\tif (baseUri.path.endsWith('/')) {\n\t\treturn resolvePath(baseUri, href).toString();\n\t} else {\n\t\treturn resolvePath(dirname(baseUri), href).toString();\n\t}\n}\n\nfunction sanitizeRenderedMarkdown(\n\trenderedMarkdown: string,\n\tisTrusted: boolean | MarkdownStringTrustedOptions,\n\toptions: MarkdownSanitizerConfig = {},\n): TrustedHTML {\n\tconst sanitizerConfig = getDomSanitizerConfig(isTrusted, options);\n\treturn domSanitize.sanitizeHtml(renderedMarkdown, sanitizerConfig);\n}\n\nexport const allowedMarkdownHtmlTags = Object.freeze([\n\t...domSanitize.basicMarkupHtmlTags,\n\t'input', // Allow inputs for rendering checkboxes. Other types of inputs are removed and the inputs are always disabled\n]);\n\nexport const allowedMarkdownHtmlAttributes = Object.freeze<Array<string | domSanitize.SanitizeAttributeRule>>([\n\t'align',\n\t'autoplay',\n\t'alt',\n\t'colspan',\n\t'controls',\n\t'draggable',\n\t'height',\n\t'href',\n\t'loop',\n\t'muted',\n\t'playsinline',\n\t'poster',\n\t'rowspan',\n\t'src',\n\t'target',\n\t'title',\n\t'type',\n\t'width',\n\t'start',\n\n\t// Input (For disabled inputs)\n\t'checked',\n\t'disabled',\n\t'value',\n\n\t// Custom markdown attributes\n\t'data-code',\n\t'data-href',\n\n\t// Only allow very specific styles\n\t{\n\t\tattributeName: 'style',\n\t\tshouldKeep: (element, data) => {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (data.attrName === 'style') {\n\t\t\t\t\treturn /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z0-9]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z0-9]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(data.attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t// Only allow codicons for classes\n\t{\n\t\tattributeName: 'class',\n\t\tshouldKeep: (element, data) => {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (data.attrName === 'class') {\n\t\t\t\t\treturn /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(data.attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t},\n]);\n\nfunction getDomSanitizerConfig(isTrusted: boolean | MarkdownStringTrustedOptions, options: MarkdownSanitizerConfig): domSanitize.DomSanitizerConfig {\n\tconst allowedLinkSchemes = [\n\t\tSchemas.http,\n\t\tSchemas.https,\n\t\tSchemas.mailto,\n\t\tSchemas.file,\n\t\tSchemas.vscodeFileResource,\n\t\tSchemas.vscodeRemote,\n\t\tSchemas.vscodeRemoteResource,\n\t\tSchemas.vscodeNotebookCell\n\t];\n\n\tif (isTrusted) {\n\t\tallowedLinkSchemes.push(Schemas.command);\n\t}\n\n\tif (options.allowedLinkSchemes?.augment) {\n\t\tallowedLinkSchemes.push(...options.allowedLinkSchemes.augment);\n\t}\n\n\treturn {\n\t\t// allowedTags should included everything that markdown renders to.\n\t\t// Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n\t\t// HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n\t\t// HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n\t\tallowedTags: {\n\t\t\toverride: options.allowedTags?.override ?? allowedMarkdownHtmlTags\n\t\t},\n\t\tallowedAttributes: {\n\t\t\toverride: options.allowedAttributes?.override ?? allowedMarkdownHtmlAttributes,\n\t\t},\n\t\tallowedLinkProtocols: {\n\t\t\toverride: allowedLinkSchemes,\n\t\t},\n\t\tallowedMediaProtocols: {\n\t\t\toverride: [\n\t\t\t\tSchemas.http,\n\t\t\t\tSchemas.https,\n\t\t\t\tSchemas.data,\n\t\t\t\tSchemas.file,\n\t\t\t\tSchemas.vscodeFileResource,\n\t\t\t\tSchemas.vscodeRemote,\n\t\t\t\tSchemas.vscodeRemoteResource,\n\t\t\t]\n\t\t},\n\t\treplaceWithPlaintext: options.replaceWithPlaintext,\n\t};\n}\n\n/**\n * Renders `str` as plaintext, stripping out Markdown syntax if it's a {@link IMarkdownString}.\n *\n * For example `# Header` would be output as `Header`.\n */\nexport function renderAsPlaintext(str: IMarkdownString | string, options?: {\n\t/** Controls if the ``` of code blocks should be preserved in the output or not */\n\treadonly includeCodeBlocksFences?: boolean;\n}) {\n\tif (typeof str === 'string') {\n\t\treturn str;\n\t}\n\n\t// values that are too long will freeze the UI\n\tlet value = str.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\tconst html = marked.parse(value, { async: false, renderer: options?.includeCodeBlocksFences ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value });\n\treturn sanitizeRenderedMarkdown(html, /* isTrusted */ false, {})\n\t\t.toString()\n\t\t.replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m)\n\t\t.trim();\n}\n\nconst unescapeInfo = new Map<string, string>([\n\t['&quot;', '\"'],\n\t['&nbsp;', ' '],\n\t['&amp;', '&'],\n\t['&#39;', '\\''],\n\t['&lt;', '<'],\n\t['&gt;', '>'],\n]);\n\nfunction createPlainTextRenderer(): marked.Renderer {\n\tconst renderer = new marked.Renderer();\n\n\trenderer.code = ({ text }: marked.Tokens.Code): string => {\n\t\treturn escape(text);\n\t};\n\trenderer.blockquote = ({ text }: marked.Tokens.Blockquote): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.html = (_: marked.Tokens.HTML): string => {\n\t\treturn '';\n\t};\n\trenderer.heading = function ({ tokens }: marked.Tokens.Heading): string {\n\t\treturn this.parser.parseInline(tokens) + '\\n';\n\t};\n\trenderer.hr = (): string => {\n\t\treturn '';\n\t};\n\trenderer.list = function ({ items }: marked.Tokens.List): string {\n\t\treturn items.map(x => this.listitem(x)).join('\\n') + '\\n';\n\t};\n\trenderer.listitem = ({ text }: marked.Tokens.ListItem): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.paragraph = function ({ tokens }: marked.Tokens.Paragraph): string {\n\t\treturn this.parser.parseInline(tokens) + '\\n';\n\t};\n\trenderer.table = function ({ header, rows }: marked.Tokens.Table): string {\n\t\treturn header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n\t};\n\trenderer.tablerow = ({ text }: marked.Tokens.TableRow): string => {\n\t\treturn text;\n\t};\n\trenderer.tablecell = function ({ tokens }: marked.Tokens.TableCell): string {\n\t\treturn this.parser.parseInline(tokens);\n\t};\n\trenderer.strong = ({ text }: marked.Tokens.Strong): string => {\n\t\treturn text;\n\t};\n\trenderer.em = ({ text }: marked.Tokens.Em): string => {\n\t\treturn text;\n\t};\n\trenderer.codespan = ({ text }: marked.Tokens.Codespan): string => {\n\t\treturn escape(text);\n\t};\n\trenderer.br = (_: marked.Tokens.Br): string => {\n\t\treturn '\\n';\n\t};\n\trenderer.del = ({ text }: marked.Tokens.Del): string => {\n\t\treturn text;\n\t};\n\trenderer.image = (_: marked.Tokens.Image): string => {\n\t\treturn '';\n\t};\n\trenderer.text = ({ text }: marked.Tokens.Text): string => {\n\t\treturn text;\n\t};\n\trenderer.link = ({ text }: marked.Tokens.Link): string => {\n\t\treturn text;\n\t};\n\treturn renderer;\n}\nconst plainTextRenderer = new Lazy<marked.Renderer>(createPlainTextRenderer);\n\nconst plainTextWithCodeBlocksRenderer = new Lazy<marked.Renderer>(() => {\n\tconst renderer = createPlainTextRenderer();\n\trenderer.code = ({ text }: marked.Tokens.Code): string => {\n\t\treturn `\\n\\`\\`\\`\\n${escape(text)}\\n\\`\\`\\`\\n`;\n\t};\n\treturn renderer;\n});\n\nfunction mergeRawTokenText(tokens: marked.Token[]): string {\n\tlet mergedTokenText = '';\n\ttokens.forEach(token => {\n\t\tmergedTokenText += token.raw;\n\t});\n\treturn mergedTokenText;\n}\n\nfunction completeSingleLinePattern(token: marked.Tokens.Text | marked.Tokens.Paragraph): marked.Token | undefined {\n\tif (!token.tokens) {\n\t\treturn undefined;\n\t}\n\n\tfor (let i = token.tokens.length - 1; i >= 0; i--) {\n\t\tconst subtoken = token.tokens[i];\n\t\tif (subtoken.type === 'text') {\n\t\t\tconst lines = subtoken.raw.split('\\n');\n\t\t\tconst lastLine = lines[lines.length - 1];\n\t\t\tif (lastLine.includes('`')) {\n\t\t\t\treturn completeCodespan(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.includes('**')) {\n\t\t\t\treturn completeDoublestar(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/\\*\\w/)) {\n\t\t\t\treturn completeStar(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/(^|\\s)__\\w/)) {\n\t\t\t\treturn completeDoubleUnderscore(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/(^|\\s)_\\w/)) {\n\t\t\t\treturn completeUnderscore(token);\n\t\t\t}\n\n\t\t\telse if (\n\t\t\t\t// Text with start of link target\n\t\t\t\thasLinkTextAndStartOfLinkTarget(lastLine) ||\n\t\t\t\t// This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n\t\t\t\t// But some preceding token does have an unbalanced [ at least\n\t\t\t\thasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))\n\t\t\t) {\n\t\t\t\tconst nextTwoSubTokens = token.tokens.slice(i + 1);\n\n\t\t\t\t// A markdown link can look like\n\t\t\t\t// [link text](https://microsoft.com \"more text\")\n\t\t\t\t// Where \"more text\" is a title for the link or an argument to a vscode command link\n\t\t\t\tif (\n\t\t\t\t\t// If the link was parsed as a link, then look for a link token and a text token with a quote\n\t\t\t\t\tnextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n\t\t\t\t\t// And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n\t\t\t\t\tlastLine.match(/^[^\"]* +\"[^\"]*$/)\n\t\t\t\t) {\n\n\t\t\t\t\treturn completeLinkTargetArg(token);\n\t\t\t\t}\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t}\n\n\t\t\t// Contains the start of link text, and no following tokens contain the link target\n\t\t\telse if (lastLine.match(/(^|\\s)\\[\\w*[^\\]]*$/)) {\n\t\t\t\treturn completeLinkText(token);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction hasLinkTextAndStartOfLinkTarget(str: string): boolean {\n\treturn !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\n\nfunction hasStartOfLinkTargetAndNoLinkText(str: string): boolean {\n\treturn !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\n\nfunction completeListItemPattern(list: marked.Tokens.List): marked.Tokens.List | undefined {\n\t// Patch up this one list item\n\tconst lastListItem = list.items[list.items.length - 1];\n\tconst lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n\n\t/*\n\tExample list token structures:\n\n\tlist\n\t\tlist_item\n\t\t\ttext\n\t\t\t\ttext\n\t\t\t\tcodespan\n\t\t\t\tlink\n\t\tlist_item\n\t\t\ttext\n\t\t\tcode // Complete indented codeblock\n\t\tlist_item\n\t\t\ttext\n\t\t\tspace\n\t\t\ttext\n\t\t\t\ttext // Incomplete indented codeblock\n\t\tlist_item\n\t\t\ttext\n\t\t\tlist // Nested list\n\t\t\t\tlist_item\n\t\t\t\t\ttext\n\t\t\t\t\t\ttext\n\n\tContrast with paragraph:\n\tparagraph\n\t\ttext\n\t\tcodespan\n\t*/\n\n\tconst listEndsInHeading = (list: marked.Tokens.List): boolean => {\n\t\t// A list item can be rendered as a heading for some reason when it has a subitem where we haven't rendered the text yet like this:\n\t\t// 1. list item\n\t\t//    -\n\t\tconst lastItem = list.items.at(-1);\n\t\tconst lastToken = lastItem?.tokens.at(-1);\n\t\treturn lastToken?.type === 'heading' || lastToken?.type === 'list' && listEndsInHeading(lastToken as marked.Tokens.List);\n\t};\n\n\tlet newToken: marked.Token | undefined;\n\tif (lastListSubToken?.type === 'text' && !('inRawBlock' in lastListItem)) { // Why does Tag have a type of 'text'\n\t\tnewToken = completeSingleLinePattern(lastListSubToken as marked.Tokens.Text);\n\t} else if (listEndsInHeading(list)) {\n\t\tconst newList = marked.lexer(list.raw.trim() + ' &nbsp;')[0] as marked.Tokens.List;\n\t\tif (newList.type !== 'list') {\n\t\t\t// Something went wrong\n\t\t\treturn;\n\t\t}\n\t\treturn newList;\n\t}\n\n\tif (!newToken || newToken.type !== 'paragraph') { // 'text' item inside the list item turns into paragraph\n\t\t// Nothing to fix, or not a pattern we were expecting\n\t\treturn;\n\t}\n\n\tconst previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n\n\t// Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n\tconst lastListItemLead = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)?.[0];\n\tif (!lastListItemLead) {\n\t\t// Is badly formatted\n\t\treturn;\n\t}\n\n\tconst newListItemText = lastListItemLead +\n\t\tmergeRawTokenText(lastListItem.tokens.slice(0, -1)) +\n\t\tnewToken.raw;\n\n\tconst newList = marked.lexer(previousListItemsText + newListItemText)[0] as marked.Tokens.List;\n\tif (newList.type !== 'list') {\n\t\t// Something went wrong\n\t\treturn;\n\t}\n\n\treturn newList;\n}\n\nfunction completeHeading(token: marked.Tokens.Heading, fullRawText: string): marked.TokensList | void {\n\tif (token.raw.match(/-\\s*$/)) {\n\t\treturn marked.lexer(fullRawText + ' &nbsp;');\n\t}\n}\n\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens: marked.TokensList): marked.TokensList {\n\tfor (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n\t\tconst newTokens = fillInIncompleteTokensOnce(tokens);\n\t\tif (newTokens) {\n\t\t\ttokens = newTokens;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tokens;\n}\n\nfunction fillInIncompleteTokensOnce(tokens: marked.TokensList): marked.TokensList | null {\n\tlet i: number;\n\tlet newTokens: marked.Token[] | undefined;\n\tfor (i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\n\t\tif (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n\t\t\tnewTokens = completeTable(tokens.slice(i));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst lastToken = tokens.at(-1);\n\tif (!newTokens && lastToken?.type === 'list') {\n\t\tconst newListToken = completeListItemPattern(lastToken as marked.Tokens.List);\n\t\tif (newListToken) {\n\t\t\tnewTokens = [newListToken];\n\t\t\ti = tokens.length - 1;\n\t\t}\n\t}\n\n\tif (!newTokens && lastToken?.type === 'paragraph') {\n\t\t// Only operates on a single token, because any newline that follows this should break these patterns\n\t\tconst newToken = completeSingleLinePattern(lastToken as marked.Tokens.Paragraph);\n\t\tif (newToken) {\n\t\t\tnewTokens = [newToken];\n\t\t\ti = tokens.length - 1;\n\t\t}\n\t}\n\n\tif (newTokens) {\n\t\tconst newTokensList = [\n\t\t\t...tokens.slice(0, i),\n\t\t\t...newTokens\n\t\t];\n\t\t(newTokensList as marked.TokensList).links = tokens.links;\n\t\treturn newTokensList as marked.TokensList;\n\t}\n\n\tif (lastToken?.type === 'heading') {\n\t\tconst completeTokens = completeHeading(lastToken as marked.Tokens.Heading, mergeRawTokenText(tokens));\n\t\tif (completeTokens) {\n\t\t\treturn completeTokens;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n\nfunction completeCodespan(token: marked.Token): marked.Token {\n\treturn completeWithString(token, '`');\n}\n\nfunction completeStar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '*');\n}\n\nfunction completeUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '_');\n}\n\nfunction completeLinkTarget(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, ')', false);\n}\n\nfunction completeLinkTargetArg(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '\")', false);\n}\n\nfunction completeLinkText(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '](https://microsoft.com)', false);\n}\n\nfunction completeDoublestar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '**');\n}\n\nfunction completeDoubleUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '__');\n}\n\nfunction completeWithString(tokens: marked.Token[] | marked.Token, closingString: string, shouldTrim = true): marked.Token {\n\tconst mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n\n\t// If it was completed correctly, this should be a single token.\n\t// Expecting either a Paragraph or a List\n\tconst trimmedRawText = shouldTrim ? mergedRawText.trimEnd() : mergedRawText;\n\treturn marked.lexer(trimmedRawText + closingString)[0] as marked.Token;\n}\n\nfunction completeTable(tokens: marked.Token[]): marked.Token[] | undefined {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\tconst lines = mergedRawText.split('\\n');\n\n\tlet numCols: number | undefined; // The number of line1 col headers\n\tlet hasSeparatorRow = false;\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i].trim();\n\t\tif (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n\t\t\tconst line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n\t\t\tif (line1Matches) {\n\t\t\t\tnumCols = line1Matches.length;\n\t\t\t}\n\t\t} else if (typeof numCols === 'number') {\n\t\t\tif (line.match(/^\\s*\\|/)) {\n\t\t\t\tif (i !== lines.length - 1) {\n\t\t\t\t\t// We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n\t\t\t\t\t// That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n\t\t\t\thasSeparatorRow = true;\n\t\t\t} else {\n\t\t\t\t// The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof numCols === 'number' && numCols > 0) {\n\t\tconst prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n\t\tconst line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n\t\tconst newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n\t\treturn marked.lexer(newRawText);\n\t}\n\n\treturn undefined;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../common/errors.js';\nimport { escapeDoubleQuotes, IMarkdownString, MarkdownStringTrustedOptions, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { KeyCode } from '../common/keyCodes.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nimport * as DOM from './dom.js';\nimport * as domSanitize from './domSanitize.js';\nimport { convertTagToPlaintext } from './domSanitize.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\n\nexport type MarkdownActionHandler = (linkContent: string, mdStr: IMarkdownString) => void;\n\n/**\n * Options for the rendering of markdown with {@link renderMarkdown}.\n */\nexport interface MarkdownRenderOptions {\n\treadonly codeBlockRenderer?: (languageId: string, value: string) => Promise<HTMLElement>;\n\treadonly codeBlockRendererSync?: (languageId: string, value: string, raw?: string) => HTMLElement;\n\treadonly asyncRenderCallback?: () => void;\n\n\treadonly actionHandler?: MarkdownActionHandler;\n\n\treadonly fillInIncompleteTokens?: boolean;\n\n\treadonly sanitizerConfig?: MarkdownSanitizerConfig;\n\n\treadonly markedOptions?: MarkdownRendererMarkedOptions;\n\treadonly markedExtensions?: marked.MarkedExtension[];\n}\n\n/**\n * Subset of options passed to `Marked` for rendering markdown.\n */\nexport interface MarkdownRendererMarkedOptions {\n}\n\nexport interface MarkdownSanitizerConfig {\n\treadonly replaceWithPlaintext?: boolean;\n\treadonly allowedTags?: {\n\t\treadonly override: readonly string[];\n\t};\n\treadonly allowedAttributes?: {\n\t\treadonly override: ReadonlyArray<string | domSanitize.SanitizeAttributeRule>;\n\t};\n\treadonly allowedLinkSchemes?: {\n\t\treadonly augment: readonly string[];\n\t};\n\treadonly remoteImageIsAllowed?: (uri: URI) => boolean;\n}\n\nconst defaultMarkedRenderers = Object.freeze({\n\timage: ({ href, title, text }: marked.Tokens.Image): string => {\n\t\tlet dimensions: string[] = [];\n\t\tlet attributes: string[] = [];\n\t\tif (href) {\n\t\t\t({ href, dimensions } = parseHrefAndDimensions(href));\n\t\t\tattributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n\t\t}\n\t\tif (text) {\n\t\t\tattributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n\t\t}\n\t\tif (title) {\n\t\t\tattributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n\t\t}\n\t\tif (dimensions.length) {\n\t\t\tattributes = attributes.concat(dimensions);\n\t\t}\n\t\treturn '<img ' + attributes.join(' ') + '>';\n\t},\n\n\tparagraph(this: marked.Renderer, { tokens }: marked.Tokens.Paragraph): string {\n\t\treturn `<p>${this.parser.parseInline(tokens)}</p>`;\n\t},\n\n\tlink(this: marked.Renderer, { href, title, tokens }: marked.Tokens.Link): string {\n\t\tlet text = this.parser.parseInline(tokens);\n\t\tif (typeof href !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n\t\tif (href === text) { // raw link case\n\t\t\ttext = removeMarkdownEscapes(text);\n\t\t}\n\n\t\ttitle = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n\t\thref = removeMarkdownEscapes(href);\n\n\t\t// HTML Encode href\n\t\thref = href.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t.replace(/'/g, '&#39;');\n\n\t\treturn `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n\t},\n});\n\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using {@link import('../../editor/browser/widget/markdownRenderer/browser/markdownRenderer.js').MarkdownRenderer MarkdownRenderer}\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown: IMarkdownString, options: MarkdownRenderOptions = {}, target?: HTMLElement): { element: HTMLElement; dispose: () => void } {\n\tconst disposables = new DisposableStore();\n\tlet isDisposed = false;\n\n\tconst markedInstance = new marked.Marked(...(options.markedExtensions ?? []));\n\tconst { renderer, codeBlocks, syncCodeBlocks } = createMarkdownRenderer(markedInstance, options, markdown);\n\tconst value = preprocessMarkdownString(markdown);\n\n\tlet renderedMarkdown: string;\n\tif (options.fillInIncompleteTokens) {\n\t\t// The defaults are applied by parse but not lexer()/parser(), and they need to be present\n\t\tconst opts: marked.MarkedOptions = {\n\t\t\t...markedInstance.defaults,\n\t\t\t...options.markedOptions,\n\t\t\trenderer\n\t\t};\n\t\tconst tokens = markedInstance.lexer(value, opts);\n\t\tconst newTokens = fillInIncompleteTokens(tokens);\n\t\trenderedMarkdown = markedInstance.parser(newTokens, opts);\n\t} else {\n\t\trenderedMarkdown = markedInstance.parse(value, { ...options?.markedOptions, renderer, async: false });\n\t}\n\n\t// Rewrite theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tconst elements = renderLabelWithIcons(renderedMarkdown);\n\t\trenderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n\t}\n\n\tconst renderedContent = document.createElement('div');\n\tconst sanitizerConfig = getDomSanitizerConfig(markdown.isTrusted ?? false, options.sanitizerConfig ?? {});\n\tdomSanitize.safeSetInnerHtml(renderedContent, renderedMarkdown, sanitizerConfig);\n\n\t// Rewrite links and images before potentially inserting them into the real dom\n\trewriteRenderedLinks(markdown, options, renderedContent);\n\n\tlet outElement: HTMLElement;\n\tif (target) {\n\t\toutElement = target;\n\t\tDOM.reset(target, ...renderedContent.children);\n\t} else {\n\t\toutElement = renderedContent;\n\t}\n\n\tif (codeBlocks.length > 0) {\n\t\tPromise.all(codeBlocks).then((tuples) => {\n\t\t\tif (isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst renderedElements = new Map(tuples);\n\t\t\tconst placeholderElements = outElement.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\t\tif (renderedElement) {\n\t\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\toptions.asyncRenderCallback?.();\n\t\t});\n\t} else if (syncCodeBlocks.length > 0) {\n\t\tconst renderedElements = new Map(syncCodeBlocks);\n\t\tconst placeholderElements = outElement.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\tif (renderedElement) {\n\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Signal size changes for image tags\n\tif (options.asyncRenderCallback) {\n\t\tfor (const img of outElement.getElementsByTagName('img')) {\n\t\t\tconst listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n\t\t\t\tlistener.dispose();\n\t\t\t\toptions.asyncRenderCallback!();\n\t\t\t}));\n\t\t}\n\t}\n\n\t// Add event listeners for links\n\tif (options.actionHandler) {\n\t\tconst clickCb = (e: PointerEvent) => {\n\t\t\tconst mouseEvent = new StandardMouseEvent(DOM.getWindow(outElement), e);\n\t\t\tif (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivateLink(markdown, options, mouseEvent);\n\t\t};\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'click', clickCb));\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'auxclick', clickCb));\n\n\t\tdisposables.add(DOM.addDisposableListener(outElement, 'keydown', (e) => {\n\t\t\tconst keyboardEvent = new StandardKeyboardEvent(e);\n\t\t\tif (!keyboardEvent.equals(KeyCode.Space) && !keyboardEvent.equals(KeyCode.Enter)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivateLink(markdown, options, keyboardEvent);\n\t\t}));\n\t}\n\n\t// Remove/disable inputs\n\tfor (const input of [...outElement.getElementsByTagName('input')]) {\n\t\tif (input.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\tinput.setAttribute('disabled', '');\n\t\t} else {\n\t\t\tif (options.sanitizerConfig?.replaceWithPlaintext) {\n\t\t\t\tconst replacement = convertTagToPlaintext(input);\n\t\t\t\tinput.parentElement?.replaceChild(replacement, input);\n\t\t\t} else {\n\t\t\t\tinput.remove();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\telement: outElement,\n\t\tdispose: () => {\n\t\t\tisDisposed = true;\n\t\t\tdisposables.dispose();\n\t\t}\n\t};\n}\n\nfunction rewriteRenderedLinks(markdown: IMarkdownString, options: MarkdownRenderOptions, root: HTMLElement) {\n\tfor (const el of root.querySelectorAll('img, audio, video, source')) {\n\t\tconst src = el.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n\t\tif (src) {\n\t\t\tlet href = src;\n\t\t\ttry {\n\t\t\t\tif (markdown.baseUri) { // absolute or relative local path, or file: uri\n\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t}\n\t\t\t} catch (err) { }\n\n\t\t\tel.setAttribute('src', massageHref(markdown, href, true));\n\n\t\t\tif (options.sanitizerConfig?.remoteImageIsAllowed) {\n\t\t\t\tconst uri = URI.parse(href);\n\t\t\t\tif (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.sanitizerConfig.remoteImageIsAllowed(uri)) {\n\t\t\t\t\tel.replaceWith(DOM.$('', undefined, el.outerHTML));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const el of root.querySelectorAll('a')) {\n\t\tconst href = el.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n\t\tel.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n\t\tif (!href\n\t\t\t|| /^data:|javascript:/i.test(href)\n\t\t\t|| (/^command:/i.test(href) && !markdown.isTrusted)\n\t\t\t|| /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n\t\t\t// drop the link\n\t\t\tel.replaceWith(...el.childNodes);\n\t\t} else {\n\t\t\tlet resolvedHref = massageHref(markdown, href, false);\n\t\t\tif (markdown.baseUri) {\n\t\t\t\tresolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t}\n\t\t\tel.dataset.href = resolvedHref;\n\t\t}\n\t}\n}\n\nfunction createMarkdownRenderer(marked: marked.Marked, options: MarkdownRenderOptions, markdown: IMarkdownString): { renderer: marked.Renderer; codeBlocks: Promise<[string, HTMLElement]>[]; syncCodeBlocks: [string, HTMLElement][] } {\n\tconst renderer = new marked.Renderer(options.markedOptions);\n\trenderer.image = defaultMarkedRenderers.image;\n\trenderer.link = defaultMarkedRenderers.link;\n\trenderer.paragraph = defaultMarkedRenderers.paragraph;\n\n\t// Will collect [id, renderedElement] tuples\n\tconst codeBlocks: Promise<[string, HTMLElement]>[] = [];\n\tconst syncCodeBlocks: [string, HTMLElement][] = [];\n\n\tif (options.codeBlockRendererSync) {\n\t\trenderer.code = ({ text, lang, raw }: marked.Tokens.Code) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRendererSync!(postProcessCodeBlockLanguageId(lang), text, raw);\n\t\t\tsyncCodeBlocks.push([id, value]);\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n\t\t};\n\t} else if (options.codeBlockRenderer) {\n\t\trenderer.code = ({ text, lang }: marked.Tokens.Code) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRenderer!(postProcessCodeBlockLanguageId(lang), text);\n\t\t\tcodeBlocks.push(value.then(element => [id, element]));\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n\t\t};\n\t}\n\n\tif (!markdown.supportHtml) {\n\t\t// Note: we always pass the output through dompurify after this so that we don't rely on\n\t\t// marked for real sanitization.\n\t\trenderer.html = ({ text }) => {\n\t\t\tif (options.sanitizerConfig?.replaceWithPlaintext) {\n\t\t\t\treturn escape(text);\n\t\t\t}\n\n\t\t\tconst match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n\t\t\treturn match ? text : '';\n\t\t};\n\t}\n\treturn { renderer, codeBlocks, syncCodeBlocks };\n}\n\nfunction preprocessMarkdownString(markdown: IMarkdownString) {\n\tlet value = markdown.value;\n\n\t// values that are too long will freeze the UI\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\t// escape theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tvalue = markdownEscapeEscapedIcons(value);\n\t}\n\n\treturn value;\n}\n\nfunction activateLink(mdStr: IMarkdownString, options: MarkdownRenderOptions, event: StandardMouseEvent | StandardKeyboardEvent): void {\n\tconst target = event.target.closest('a[data-href]');\n\tif (!DOM.isHTMLElement(target)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tlet href = target.dataset['href'];\n\t\tif (href) {\n\t\t\tif (mdStr.baseUri) {\n\t\t\t\thref = resolveWithBaseUri(URI.from(mdStr.baseUri), href);\n\t\t\t}\n\t\t\toptions.actionHandler?.(href, mdStr);\n\t\t}\n\t} catch (err) {\n\t\tonUnexpectedError(err);\n\t} finally {\n\t\tevent.preventDefault();\n\t}\n}\n\nfunction uriMassage(markdown: IMarkdownString, part: string): string {\n\tlet data: unknown;\n\ttry {\n\t\tdata = parse(decodeURIComponent(part));\n\t} catch (e) {\n\t\t// ignore\n\t}\n\tif (!data) {\n\t\treturn part;\n\t}\n\tdata = cloneAndChange(data, value => {\n\t\tif (markdown.uris && markdown.uris[value]) {\n\t\t\treturn URI.revive(markdown.uris[value]);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t});\n\treturn encodeURIComponent(JSON.stringify(data));\n}\n\nfunction massageHref(markdown: IMarkdownString, href: string, isDomUri: boolean): string {\n\tconst data = markdown.uris && markdown.uris[href];\n\tlet uri = URI.revive(data);\n\tif (isDomUri) {\n\t\tif (href.startsWith(Schemas.data + ':')) {\n\t\t\treturn href;\n\t\t}\n\t\tif (!uri) {\n\t\t\turi = URI.parse(href);\n\t\t}\n\t\t// this URI will end up as \"src\"-attribute of a dom node\n\t\t// and because of that special rewriting needs to be done\n\t\t// so that the URI uses a protocol that's understood by\n\t\t// browsers (like http or https)\n\t\treturn FileAccess.uriToBrowserUri(uri).toString(true);\n\t}\n\tif (!uri) {\n\t\treturn href;\n\t}\n\tif (URI.parse(href).toString() === uri.toString()) {\n\t\treturn href; // no transformation performed\n\t}\n\tif (uri.query) {\n\t\turi = uri.with({ query: uriMassage(markdown, uri.query) });\n\t}\n\treturn uri.toString();\n}\n\nfunction postProcessCodeBlockLanguageId(lang: string | undefined): string {\n\tif (!lang) {\n\t\treturn '';\n\t}\n\n\tconst parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n\tif (parts.length) {\n\t\treturn parts[0];\n\t}\n\treturn lang;\n}\n\nfunction resolveWithBaseUri(baseUri: URI, href: string): string {\n\tconst hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n\tif (hasScheme) {\n\t\treturn href;\n\t}\n\n\tif (baseUri.path.endsWith('/')) {\n\t\treturn resolvePath(baseUri, href).toString();\n\t} else {\n\t\treturn resolvePath(dirname(baseUri), href).toString();\n\t}\n}\n\nfunction sanitizeRenderedMarkdown(\n\trenderedMarkdown: string,\n\tisTrusted: boolean | MarkdownStringTrustedOptions,\n\toptions: MarkdownSanitizerConfig = {},\n): TrustedHTML {\n\tconst sanitizerConfig = getDomSanitizerConfig(isTrusted, options);\n\treturn domSanitize.sanitizeHtml(renderedMarkdown, sanitizerConfig);\n}\n\nexport const allowedMarkdownHtmlTags = Object.freeze([\n\t...domSanitize.basicMarkupHtmlTags,\n\t'input', // Allow inputs for rendering checkboxes. Other types of inputs are removed and the inputs are always disabled\n]);\n\nexport const allowedMarkdownHtmlAttributes = Object.freeze<Array<string | domSanitize.SanitizeAttributeRule>>([\n\t'align',\n\t'autoplay',\n\t'alt',\n\t'colspan',\n\t'controls',\n\t'draggable',\n\t'height',\n\t'href',\n\t'loop',\n\t'muted',\n\t'playsinline',\n\t'poster',\n\t'rowspan',\n\t'src',\n\t'target',\n\t'title',\n\t'type',\n\t'width',\n\t'start',\n\n\t// Input (For disabled inputs)\n\t'checked',\n\t'disabled',\n\t'value',\n\n\t// Custom markdown attributes\n\t'data-code',\n\t'data-href',\n\n\t// Only allow very specific styles\n\t{\n\t\tattributeName: 'style',\n\t\tshouldKeep: (element, data) => {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (data.attrName === 'style') {\n\t\t\t\t\treturn /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z0-9]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z0-9]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(data.attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t// Only allow codicons for classes\n\t{\n\t\tattributeName: 'class',\n\t\tshouldKeep: (element, data) => {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (data.attrName === 'class') {\n\t\t\t\t\treturn /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(data.attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t},\n]);\n\nfunction getDomSanitizerConfig(isTrusted: boolean | MarkdownStringTrustedOptions, options: MarkdownSanitizerConfig): domSanitize.DomSanitizerConfig {\n\tconst allowedLinkSchemes = [\n\t\tSchemas.http,\n\t\tSchemas.https,\n\t\tSchemas.mailto,\n\t\tSchemas.file,\n\t\tSchemas.vscodeFileResource,\n\t\tSchemas.vscodeRemote,\n\t\tSchemas.vscodeRemoteResource,\n\t\tSchemas.vscodeNotebookCell\n\t];\n\n\tif (isTrusted) {\n\t\tallowedLinkSchemes.push(Schemas.command);\n\t}\n\n\tif (options.allowedLinkSchemes?.augment) {\n\t\tallowedLinkSchemes.push(...options.allowedLinkSchemes.augment);\n\t}\n\n\treturn {\n\t\t// allowedTags should included everything that markdown renders to.\n\t\t// Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n\t\t// HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n\t\t// HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n\t\tallowedTags: {\n\t\t\toverride: options.allowedTags?.override ?? allowedMarkdownHtmlTags\n\t\t},\n\t\tallowedAttributes: {\n\t\t\toverride: options.allowedAttributes?.override ?? allowedMarkdownHtmlAttributes,\n\t\t},\n\t\tallowedLinkProtocols: {\n\t\t\toverride: allowedLinkSchemes,\n\t\t},\n\t\tallowedMediaProtocols: {\n\t\t\toverride: [\n\t\t\t\tSchemas.http,\n\t\t\t\tSchemas.https,\n\t\t\t\tSchemas.data,\n\t\t\t\tSchemas.file,\n\t\t\t\tSchemas.vscodeFileResource,\n\t\t\t\tSchemas.vscodeRemote,\n\t\t\t\tSchemas.vscodeRemoteResource,\n\t\t\t]\n\t\t},\n\t\treplaceWithPlaintext: options.replaceWithPlaintext,\n\t};\n}\n\n/**\n * Renders `str` as plaintext, stripping out Markdown syntax if it's a {@link IMarkdownString}.\n *\n * For example `# Header` would be output as `Header`.\n */\nexport function renderAsPlaintext(str: IMarkdownString | string, options?: {\n\t/** Controls if the ``` of code blocks should be preserved in the output or not */\n\treadonly includeCodeBlocksFences?: boolean;\n}) {\n\tif (typeof str === 'string') {\n\t\treturn str;\n\t}\n\n\t// values that are too long will freeze the UI\n\tlet value = str.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\tconst html = marked.parse(value, { async: false, renderer: options?.includeCodeBlocksFences ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value });\n\treturn sanitizeRenderedMarkdown(html, /* isTrusted */ false, {})\n\t\t.toString()\n\t\t.replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m)\n\t\t.trim();\n}\n\nconst unescapeInfo = new Map<string, string>([\n\t['&quot;', '\"'],\n\t['&nbsp;', ' '],\n\t['&amp;', '&'],\n\t['&#39;', '\\''],\n\t['&lt;', '<'],\n\t['&gt;', '>'],\n]);\n\nfunction createPlainTextRenderer(): marked.Renderer {\n\tconst renderer = new marked.Renderer();\n\n\trenderer.code = ({ text }: marked.Tokens.Code): string => {\n\t\treturn escape(text);\n\t};\n\trenderer.blockquote = ({ text }: marked.Tokens.Blockquote): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.html = (_: marked.Tokens.HTML): string => {\n\t\treturn '';\n\t};\n\trenderer.heading = function ({ tokens }: marked.Tokens.Heading): string {\n\t\treturn this.parser.parseInline(tokens) + '\\n';\n\t};\n\trenderer.hr = (): string => {\n\t\treturn '';\n\t};\n\trenderer.list = function ({ items }: marked.Tokens.List): string {\n\t\treturn items.map(x => this.listitem(x)).join('\\n') + '\\n';\n\t};\n\trenderer.listitem = ({ text }: marked.Tokens.ListItem): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.paragraph = function ({ tokens }: marked.Tokens.Paragraph): string {\n\t\treturn this.parser.parseInline(tokens) + '\\n';\n\t};\n\trenderer.table = function ({ header, rows }: marked.Tokens.Table): string {\n\t\treturn header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n\t};\n\trenderer.tablerow = ({ text }: marked.Tokens.TableRow): string => {\n\t\treturn text;\n\t};\n\trenderer.tablecell = function ({ tokens }: marked.Tokens.TableCell): string {\n\t\treturn this.parser.parseInline(tokens);\n\t};\n\trenderer.strong = ({ text }: marked.Tokens.Strong): string => {\n\t\treturn text;\n\t};\n\trenderer.em = ({ text }: marked.Tokens.Em): string => {\n\t\treturn text;\n\t};\n\trenderer.codespan = ({ text }: marked.Tokens.Codespan): string => {\n\t\treturn escape(text);\n\t};\n\trenderer.br = (_: marked.Tokens.Br): string => {\n\t\treturn '\\n';\n\t};\n\trenderer.del = ({ text }: marked.Tokens.Del): string => {\n\t\treturn text;\n\t};\n\trenderer.image = (_: marked.Tokens.Image): string => {\n\t\treturn '';\n\t};\n\trenderer.text = ({ text }: marked.Tokens.Text): string => {\n\t\treturn text;\n\t};\n\trenderer.link = ({ text }: marked.Tokens.Link): string => {\n\t\treturn text;\n\t};\n\treturn renderer;\n}\nconst plainTextRenderer = new Lazy<marked.Renderer>(createPlainTextRenderer);\n\nconst plainTextWithCodeBlocksRenderer = new Lazy<marked.Renderer>(() => {\n\tconst renderer = createPlainTextRenderer();\n\trenderer.code = ({ text }: marked.Tokens.Code): string => {\n\t\treturn `\\n\\`\\`\\`\\n${escape(text)}\\n\\`\\`\\`\\n`;\n\t};\n\treturn renderer;\n});\n\nfunction mergeRawTokenText(tokens: marked.Token[]): string {\n\tlet mergedTokenText = '';\n\ttokens.forEach(token => {\n\t\tmergedTokenText += token.raw;\n\t});\n\treturn mergedTokenText;\n}\n\nfunction completeSingleLinePattern(token: marked.Tokens.Text | marked.Tokens.Paragraph): marked.Token | undefined {\n\tif (!token.tokens) {\n\t\treturn undefined;\n\t}\n\n\tfor (let i = token.tokens.length - 1; i >= 0; i--) {\n\t\tconst subtoken = token.tokens[i];\n\t\tif (subtoken.type === 'text') {\n\t\t\tconst lines = subtoken.raw.split('\\n');\n\t\t\tconst lastLine = lines[lines.length - 1];\n\t\t\tif (lastLine.includes('`')) {\n\t\t\t\treturn completeCodespan(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.includes('**')) {\n\t\t\t\treturn completeDoublestar(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/\\*\\w/)) {\n\t\t\t\treturn completeStar(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/(^|\\s)__\\w/)) {\n\t\t\t\treturn completeDoubleUnderscore(token);\n\t\t\t}\n\n\t\t\telse if (lastLine.match(/(^|\\s)_\\w/)) {\n\t\t\t\treturn completeUnderscore(token);\n\t\t\t}\n\n\t\t\telse if (\n\t\t\t\t// Text with start of link target\n\t\t\t\thasLinkTextAndStartOfLinkTarget(lastLine) ||\n\t\t\t\t// This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n\t\t\t\t// But some preceding token does have an unbalanced [ at least\n\t\t\t\thasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))\n\t\t\t) {\n\t\t\t\tconst nextTwoSubTokens = token.tokens.slice(i + 1);\n\n\t\t\t\t// A markdown link can look like\n\t\t\t\t// [link text](https://microsoft.com \"more text\")\n\t\t\t\t// Where \"more text\" is a title for the link or an argument to a vscode command link\n\t\t\t\tif (\n\t\t\t\t\t// If the link was parsed as a link, then look for a link token and a text token with a quote\n\t\t\t\t\tnextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n\t\t\t\t\t// And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n\t\t\t\t\tlastLine.match(/^[^\"]* +\"[^\"]*$/)\n\t\t\t\t) {\n\n\t\t\t\t\treturn completeLinkTargetArg(token);\n\t\t\t\t}\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t}\n\n\t\t\t// Contains the start of link text, and no following tokens contain the link target\n\t\t\telse if (lastLine.match(/(^|\\s)\\[\\w*[^\\]]*$/)) {\n\t\t\t\treturn completeLinkText(token);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction hasLinkTextAndStartOfLinkTarget(str: string): boolean {\n\treturn !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\n\nfunction hasStartOfLinkTargetAndNoLinkText(str: string): boolean {\n\treturn !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\n\nfunction completeListItemPattern(list: marked.Tokens.List): marked.Tokens.List | undefined {\n\t// Patch up this one list item\n\tconst lastListItem = list.items[list.items.length - 1];\n\tconst lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n\n\t/*\n\tExample list token structures:\n\n\tlist\n\t\tlist_item\n\t\t\ttext\n\t\t\t\ttext\n\t\t\t\tcodespan\n\t\t\t\tlink\n\t\tlist_item\n\t\t\ttext\n\t\t\tcode // Complete indented codeblock\n\t\tlist_item\n\t\t\ttext\n\t\t\tspace\n\t\t\ttext\n\t\t\t\ttext // Incomplete indented codeblock\n\t\tlist_item\n\t\t\ttext\n\t\t\tlist // Nested list\n\t\t\t\tlist_item\n\t\t\t\t\ttext\n\t\t\t\t\t\ttext\n\n\tContrast with paragraph:\n\tparagraph\n\t\ttext\n\t\tcodespan\n\t*/\n\n\tconst listEndsInHeading = (list: marked.Tokens.List): boolean => {\n\t\t// A list item can be rendered as a heading for some reason when it has a subitem where we haven't rendered the text yet like this:\n\t\t// 1. list item\n\t\t//    -\n\t\tconst lastItem = list.items.at(-1);\n\t\tconst lastToken = lastItem?.tokens.at(-1);\n\t\treturn lastToken?.type === 'heading' || lastToken?.type === 'list' && listEndsInHeading(lastToken as marked.Tokens.List);\n\t};\n\n\tlet newToken: marked.Token | undefined;\n\tif (lastListSubToken?.type === 'text' && !('inRawBlock' in lastListItem)) { // Why does Tag have a type of 'text'\n\t\tnewToken = completeSingleLinePattern(lastListSubToken as marked.Tokens.Text);\n\t} else if (listEndsInHeading(list)) {\n\t\tconst newList = marked.lexer(list.raw.trim() + ' &nbsp;')[0] as marked.Tokens.List;\n\t\tif (newList.type !== 'list') {\n\t\t\t// Something went wrong\n\t\t\treturn;\n\t\t}\n\t\treturn newList;\n\t}\n\n\tif (!newToken || newToken.type !== 'paragraph') { // 'text' item inside the list item turns into paragraph\n\t\t// Nothing to fix, or not a pattern we were expecting\n\t\treturn;\n\t}\n\n\tconst previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n\n\t// Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n\tconst lastListItemLead = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)?.[0];\n\tif (!lastListItemLead) {\n\t\t// Is badly formatted\n\t\treturn;\n\t}\n\n\tconst newListItemText = lastListItemLead +\n\t\tmergeRawTokenText(lastListItem.tokens.slice(0, -1)) +\n\t\tnewToken.raw;\n\n\tconst newList = marked.lexer(previousListItemsText + newListItemText)[0] as marked.Tokens.List;\n\tif (newList.type !== 'list') {\n\t\t// Something went wrong\n\t\treturn;\n\t}\n\n\treturn newList;\n}\n\nfunction completeHeading(token: marked.Tokens.Heading, fullRawText: string): marked.TokensList | void {\n\tif (token.raw.match(/-\\s*$/)) {\n\t\treturn marked.lexer(fullRawText + ' &nbsp;');\n\t}\n}\n\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens: marked.TokensList): marked.TokensList {\n\tfor (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n\t\tconst newTokens = fillInIncompleteTokensOnce(tokens);\n\t\tif (newTokens) {\n\t\t\ttokens = newTokens;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tokens;\n}\n\nfunction fillInIncompleteTokensOnce(tokens: marked.TokensList): marked.TokensList | null {\n\tlet i: number;\n\tlet newTokens: marked.Token[] | undefined;\n\tfor (i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\n\t\tif (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n\t\t\tnewTokens = completeTable(tokens.slice(i));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst lastToken = tokens.at(-1);\n\tif (!newTokens && lastToken?.type === 'list') {\n\t\tconst newListToken = completeListItemPattern(lastToken as marked.Tokens.List);\n\t\tif (newListToken) {\n\t\t\tnewTokens = [newListToken];\n\t\t\ti = tokens.length - 1;\n\t\t}\n\t}\n\n\tif (!newTokens && lastToken?.type === 'paragraph') {\n\t\t// Only operates on a single token, because any newline that follows this should break these patterns\n\t\tconst newToken = completeSingleLinePattern(lastToken as marked.Tokens.Paragraph);\n\t\tif (newToken) {\n\t\t\tnewTokens = [newToken];\n\t\t\ti = tokens.length - 1;\n\t\t}\n\t}\n\n\tif (newTokens) {\n\t\tconst newTokensList = [\n\t\t\t...tokens.slice(0, i),\n\t\t\t...newTokens\n\t\t];\n\t\t(newTokensList as marked.TokensList).links = tokens.links;\n\t\treturn newTokensList as marked.TokensList;\n\t}\n\n\tif (lastToken?.type === 'heading') {\n\t\tconst completeTokens = completeHeading(lastToken as marked.Tokens.Heading, mergeRawTokenText(tokens));\n\t\tif (completeTokens) {\n\t\t\treturn completeTokens;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n\nfunction completeCodespan(token: marked.Token): marked.Token {\n\treturn completeWithString(token, '`');\n}\n\nfunction completeStar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '*');\n}\n\nfunction completeUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '_');\n}\n\nfunction completeLinkTarget(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, ')', false);\n}\n\nfunction completeLinkTargetArg(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '\")', false);\n}\n\nfunction completeLinkText(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '](https://microsoft.com)', false);\n}\n\nfunction completeDoublestar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '**');\n}\n\nfunction completeDoubleUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '__');\n}\n\nfunction completeWithString(tokens: marked.Token[] | marked.Token, closingString: string, shouldTrim = true): marked.Token {\n\tconst mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n\n\t// If it was completed correctly, this should be a single token.\n\t// Expecting either a Paragraph or a List\n\tconst trimmedRawText = shouldTrim ? mergedRawText.trimEnd() : mergedRawText;\n\treturn marked.lexer(trimmedRawText + closingString)[0] as marked.Token;\n}\n\nfunction completeTable(tokens: marked.Token[]): marked.Token[] | undefined {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\tconst lines = mergedRawText.split('\\n');\n\n\tlet numCols: number | undefined; // The number of line1 col headers\n\tlet hasSeparatorRow = false;\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i].trim();\n\t\tif (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n\t\t\tconst line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n\t\t\tif (line1Matches) {\n\t\t\t\tnumCols = line1Matches.length;\n\t\t\t}\n\t\t} else if (typeof numCols === 'number') {\n\t\t\tif (line.match(/^\\s*\\|/)) {\n\t\t\t\tif (i !== lines.length - 1) {\n\t\t\t\t\t// We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n\t\t\t\t\t// That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n\t\t\t\thasSeparatorRow = true;\n\t\t\t} else {\n\t\t\t\t// The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof numCols === 'number' && numCols > 0) {\n\t\tconst prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n\t\tconst line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n\t\tconst newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n\t\treturn marked.lexer(newRawText);\n\t}\n\n\treturn undefined;\n}\n\n"]}