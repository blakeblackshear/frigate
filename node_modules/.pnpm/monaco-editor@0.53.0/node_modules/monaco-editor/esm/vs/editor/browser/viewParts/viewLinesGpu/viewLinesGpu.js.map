{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/viewParts/viewLinesGpu/viewLinesGpu.ts","vs/editor/browser/viewParts/viewLinesGpu/viewLinesGpu.ts"],"names":[],"mappings":"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","file":"viewLinesGpu.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { autorun, runOnChange } from '../../../../base/common/observable.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { EditorOption } from '../../../common/config/editorOptions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { TextureAtlasPage } from '../../gpu/atlas/textureAtlasPage.js';\nimport { BindingId, type IGpuRenderStrategy } from '../../gpu/gpu.js';\nimport { GPULifecycle } from '../../gpu/gpuDisposable.js';\nimport { quadVertices } from '../../gpu/gpuUtils.js';\nimport { ViewGpuContext } from '../../gpu/viewGpuContext.js';\nimport { FloatHorizontalRange, HorizontalPosition, HorizontalRange, IViewLines, LineVisibleRanges, RenderingContext, RestrictedRenderingContext, VisibleRanges } from '../../view/renderingContext.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { ViewLineOptions } from '../viewLines/viewLineOptions.js';\nimport type * as viewEvents from '../../../common/viewEvents.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { TextureAtlas } from '../../gpu/atlas/textureAtlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../../gpu/contentSegmenter.js';\nimport { ViewportRenderStrategy } from '../../gpu/renderStrategy/viewportRenderStrategy.js';\nimport { FullFileRenderStrategy } from '../../gpu/renderStrategy/fullFileRenderStrategy.js';\nimport { MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { GlyphRasterizer } from '../../gpu/raster/glyphRasterizer.js';\n\nconst enum GlyphStorageBufferInfo {\n\tFloatsPerEntry = 2 + 2 + 2,\n\tBytesPerEntry = GlyphStorageBufferInfo.FloatsPerEntry * 4,\n\tOffset_TexturePosition = 0,\n\tOffset_TextureSize = 2,\n\tOffset_OriginPosition = 4,\n}\n\n/**\n * The GPU implementation of the ViewLines part.\n */\nexport class ViewLinesGpu extends ViewPart implements IViewLines {\n\n\tprivate readonly canvas: HTMLCanvasElement;\n\n\tprivate _initViewportData?: ViewportData[];\n\tprivate _lastViewportData?: ViewportData;\n\tprivate _lastViewLineOptions?: ViewLineOptions;\n\n\tprivate _device!: GPUDevice;\n\tprivate _renderPassDescriptor!: GPURenderPassDescriptor;\n\tprivate _renderPassColorAttachment!: GPURenderPassColorAttachment;\n\tprivate _bindGroup!: GPUBindGroup;\n\tprivate _pipeline!: GPURenderPipeline;\n\n\tprivate _vertexBuffer!: GPUBuffer;\n\n\tprivate _glyphStorageBuffer!: GPUBuffer;\n\tprivate _atlasGpuTexture!: GPUTexture;\n\tprivate readonly _atlasGpuTextureVersions: number[] = [];\n\n\tprivate _initialized = false;\n\n\tprivate readonly _glyphRasterizer: MutableDisposable<GlyphRasterizer> = this._register(new MutableDisposable());\n\tprivate readonly _renderStrategy: MutableDisposable<IGpuRenderStrategy> = this._register(new MutableDisposable());\n\tprivate _rebuildBindGroup?: () => void;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tprivate readonly _viewGpuContext: ViewGpuContext,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper(context);\n\n\t\tthis.canvas = this._viewGpuContext.canvas.domNode;\n\n\t\t// Re-render the following frame after canvas device pixel dimensions change, provided a\n\t\t// new render does not occur.\n\t\tthis._register(autorun(reader => {\n\t\t\tthis._viewGpuContext.canvasDevicePixelDimensions.read(reader);\n\t\t\tconst lastViewportData = this._lastViewportData;\n\t\t\tif (lastViewportData) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (lastViewportData === this._lastViewportData) {\n\t\t\t\t\t\tthis.renderText(lastViewportData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\n\t\tthis.initWebgpu();\n\t}\n\n\tasync initWebgpu() {\n\t\t// #region General\n\n\t\tthis._device = ViewGpuContext.deviceSync || await ViewGpuContext.device;\n\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst atlas = ViewGpuContext.atlas;\n\n\t\t// Rerender when the texture atlas deletes glyphs\n\t\tthis._register(atlas.onDidDeleteGlyphs(() => {\n\t\t\tthis._atlasGpuTextureVersions.length = 0;\n\t\t\tthis._atlasGpuTextureVersions[0] = 0;\n\t\t\tthis._atlasGpuTextureVersions[1] = 0;\n\t\t\tthis._renderStrategy.value!.reset();\n\t\t}));\n\n\t\tconst presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\t\tthis._viewGpuContext.ctx.configure({\n\t\t\tdevice: this._device,\n\t\t\tformat: presentationFormat,\n\t\t\talphaMode: 'premultiplied',\n\t\t});\n\n\t\tthis._renderPassColorAttachment = {\n\t\t\tview: null!, // Will be filled at render time\n\t\t\tloadOp: 'load',\n\t\t\tstoreOp: 'store',\n\t\t};\n\t\tthis._renderPassDescriptor = {\n\t\t\tlabel: 'Monaco render pass',\n\t\t\tcolorAttachments: [this._renderPassColorAttachment],\n\t\t};\n\n\t\t// #endregion General\n\n\t\t// #region Uniforms\n\n\t\tlet layoutInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 6,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_CanvasWidth____ = 0,\n\t\t\t\tOffset_CanvasHeight___ = 1,\n\t\t\t\tOffset_ViewportOffsetX = 2,\n\t\t\t\tOffset_ViewportOffsetY = 3,\n\t\t\t\tOffset_ViewportWidth__ = 4,\n\t\t\t\tOffset_ViewportHeight_ = 5,\n\t\t\t}\n\t\t\tconst bufferValues = new Float32Array(Info.FloatsPerEntry);\n\t\t\tconst updateBufferValues = (canvasDevicePixelWidth: number = this.canvas.width, canvasDevicePixelHeight: number = this.canvas.height) => {\n\t\t\t\tbufferValues[Info.Offset_CanvasWidth____] = canvasDevicePixelWidth;\n\t\t\t\tbufferValues[Info.Offset_CanvasHeight___] = canvasDevicePixelHeight;\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetX] = Math.ceil(this._context.configuration.options.get(EditorOption.layoutInfo).contentLeft * getActiveWindow().devicePixelRatio);\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetY] = 0;\n\t\t\t\tbufferValues[Info.Offset_ViewportWidth__] = bufferValues[Info.Offset_CanvasWidth____] - bufferValues[Info.Offset_ViewportOffsetX];\n\t\t\t\tbufferValues[Info.Offset_ViewportHeight_] = bufferValues[Info.Offset_CanvasHeight___] - bufferValues[Info.Offset_ViewportOffsetY];\n\t\t\t\treturn bufferValues;\n\t\t\t};\n\t\t\tlayoutInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => updateBufferValues())).object;\n\t\t\tthis._register(runOnChange(this._viewGpuContext.canvasDevicePixelDimensions, ({ width, height }) => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues(width, height));\n\t\t\t}));\n\t\t\tthis._register(runOnChange(this._viewGpuContext.contentLeft, () => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues());\n\t\t\t}));\n\t\t}\n\n\t\tlet atlasInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 2,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_Width_ = 0,\n\t\t\t\tOffset_Height = 1,\n\t\t\t}\n\t\t\tatlasInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco atlas info uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => {\n\t\t\t\tconst values = new Float32Array(Info.FloatsPerEntry);\n\t\t\t\tvalues[Info.Offset_Width_] = atlas.pageSize;\n\t\t\t\tvalues[Info.Offset_Height] = atlas.pageSize;\n\t\t\t\treturn values;\n\t\t\t})).object;\n\t\t}\n\n\t\t// #endregion Uniforms\n\n\t\t// #region Storage buffers\n\n\t\tconst fontFamily = this._context.configuration.options.get(EditorOption.fontFamily);\n\t\tconst fontSize = this._context.configuration.options.get(EditorOption.fontSize);\n\t\tthis._glyphRasterizer.value = this._register(new GlyphRasterizer(fontSize, fontFamily, this._viewGpuContext.devicePixelRatio.get(), ViewGpuContext.decorationStyleCache));\n\t\tthis._register(runOnChange(this._viewGpuContext.devicePixelRatio, () => {\n\t\t\tthis._refreshGlyphRasterizer();\n\t\t}));\n\n\n\t\tthis._renderStrategy.value = this._instantiationService.createInstance(FullFileRenderStrategy, this._context, this._viewGpuContext, this._device, this._glyphRasterizer as { value: GlyphRasterizer });\n\t\t// this._renderStrategy.value = this._instantiationService.createInstance(ViewportRenderStrategy, this._context, this._viewGpuContext, this._device);\n\n\t\tthis._glyphStorageBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco glyph storage buffer',\n\t\t\tsize: TextureAtlas.maximumPageCount * (TextureAtlasPage.maximumGlyphCount * GlyphStorageBufferInfo.BytesPerEntry),\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._atlasGpuTextureVersions[0] = 0;\n\t\tthis._atlasGpuTextureVersions[1] = 0;\n\t\tthis._atlasGpuTexture = this._register(GPULifecycle.createTexture(this._device, {\n\t\t\tlabel: 'Monaco atlas texture',\n\t\t\tformat: 'rgba8unorm',\n\t\t\tsize: { width: atlas.pageSize, height: atlas.pageSize, depthOrArrayLayers: TextureAtlas.maximumPageCount },\n\t\t\tdimension: '2d',\n\t\t\tusage: GPUTextureUsage.TEXTURE_BINDING |\n\t\t\t\tGPUTextureUsage.COPY_DST |\n\t\t\t\tGPUTextureUsage.RENDER_ATTACHMENT,\n\t\t})).object;\n\n\t\tthis._updateAtlasStorageBufferAndTexture();\n\n\t\t// #endregion Storage buffers\n\n\t\t// #region Vertex buffer\n\n\t\tthis._vertexBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco vertex buffer',\n\t\t\tsize: quadVertices.byteLength,\n\t\t\tusage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n\t\t}, quadVertices)).object;\n\n\t\t// #endregion Vertex buffer\n\n\t\t// #region Shader module\n\n\t\tconst module = this._device.createShaderModule({\n\t\t\tlabel: 'Monaco shader module',\n\t\t\tcode: this._renderStrategy.value!.wgsl,\n\t\t});\n\n\t\t// #endregion Shader module\n\n\t\t// #region Pipeline\n\n\t\tthis._pipeline = this._device.createRenderPipeline({\n\t\t\tlabel: 'Monaco render pipeline',\n\t\t\tlayout: 'auto',\n\t\t\tvertex: {\n\t\t\t\tmodule,\n\t\t\t\tbuffers: [\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // 2 floats, 4 bytes each\n\t\t\t\t\t\tattributes: [\n\t\t\t\t\t\t\t{ shaderLocation: 0, offset: 0, format: 'float32x2' },  // position\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tfragment: {\n\t\t\t\tmodule,\n\t\t\t\ttargets: [\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: presentationFormat,\n\t\t\t\t\t\tblend: {\n\t\t\t\t\t\t\tcolor: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talpha: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\t// #endregion Pipeline\n\n\t\t// #region Bind group\n\n\t\tthis._rebuildBindGroup = () => {\n\t\t\tthis._bindGroup = this._device.createBindGroup({\n\t\t\t\tlabel: 'Monaco bind group',\n\t\t\t\tlayout: this._pipeline.getBindGroupLayout(0),\n\t\t\t\tentries: [\n\t\t\t\t\t// TODO: Pass in generically as array?\n\t\t\t\t\t{ binding: BindingId.GlyphInfo, resource: { buffer: this._glyphStorageBuffer } },\n\t\t\t\t\t{\n\t\t\t\t\t\tbinding: BindingId.TextureSampler, resource: this._device.createSampler({\n\t\t\t\t\t\t\tlabel: 'Monaco atlas sampler',\n\t\t\t\t\t\t\tmagFilter: 'nearest',\n\t\t\t\t\t\t\tminFilter: 'nearest',\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t\t{ binding: BindingId.Texture, resource: this._atlasGpuTexture.createView() },\n\t\t\t\t\t{ binding: BindingId.LayoutInfoUniform, resource: { buffer: layoutInfoUniformBuffer } },\n\t\t\t\t\t{ binding: BindingId.AtlasDimensionsUniform, resource: { buffer: atlasInfoUniformBuffer } },\n\t\t\t\t\t...this._renderStrategy.value!.bindGroupEntries\n\t\t\t\t],\n\t\t\t});\n\t\t};\n\t\tthis._rebuildBindGroup();\n\n\t\t// endregion Bind group\n\n\t\tthis._initialized = true;\n\n\t\t// Render the initial viewport immediately after initialization\n\t\tif (this._initViewportData) {\n\t\t\t// HACK: Rendering multiple times in the same frame like this isn't ideal, but there\n\t\t\t//       isn't an easy way to merge viewport data\n\t\t\tfor (const viewportData of this._initViewportData) {\n\t\t\t\tthis.renderText(viewportData);\n\t\t\t}\n\t\t\tthis._initViewportData = undefined;\n\t\t}\n\t}\n\n\tprivate _refreshRenderStrategy(viewportData: ViewportData) {\n\t\tif (this._renderStrategy.value?.type === 'viewport') {\n\t\t\treturn;\n\t\t}\n\t\tif (viewportData.endLineNumber < FullFileRenderStrategy.maxSupportedLines && this._viewportMaxColumn(viewportData) < FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\treturn;\n\t\t}\n\t\tthis._logService.trace(`File is larger than ${FullFileRenderStrategy.maxSupportedLines} lines or ${FullFileRenderStrategy.maxSupportedColumns} columns, switching to viewport render strategy`);\n\t\tconst viewportRenderStrategy = this._instantiationService.createInstance(ViewportRenderStrategy, this._context, this._viewGpuContext, this._device, this._glyphRasterizer as { value: GlyphRasterizer });\n\t\tthis._renderStrategy.value = viewportRenderStrategy;\n\t\tthis._register(viewportRenderStrategy.onDidChangeBindGroupEntries(() => this._rebuildBindGroup?.()));\n\t\tthis._rebuildBindGroup?.();\n\t}\n\n\tprivate _viewportMaxColumn(viewportData: ViewportData): number {\n\t\tlet maxColumn = 0;\n\t\tlet lineData: ViewLineRenderingData;\n\t\tfor (let i = viewportData.startLineNumber; i <= viewportData.endLineNumber; i++) {\n\t\t\tlineData = viewportData.getViewLineRenderingData(i);\n\t\t\tmaxColumn = Math.max(maxColumn, lineData.maxColumn);\n\t\t}\n\t\treturn maxColumn;\n\t}\n\n\tprivate _updateAtlasStorageBufferAndTexture() {\n\t\tfor (const [layerIndex, page] of ViewGpuContext.atlas.pages.entries()) {\n\t\t\tif (layerIndex >= TextureAtlas.maximumPageCount) {\n\t\t\t\tconsole.log(`Attempt to upload atlas page [${layerIndex}], only ${TextureAtlas.maximumPageCount} are supported currently`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip the update if it's already the latest version\n\t\t\tif (page.version === this._atlasGpuTextureVersions[layerIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace('Updating atlas page[', layerIndex, '] from version ', this._atlasGpuTextureVersions[layerIndex], ' to version ', page.version);\n\n\t\t\tconst entryCount = GlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount;\n\t\t\tconst values = new Float32Array(entryCount);\n\t\t\tlet entryOffset = 0;\n\t\t\tfor (const glyph of page.glyphs) {\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TexturePosition] = glyph.x;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TexturePosition + 1] = glyph.y;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TextureSize] = glyph.w;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TextureSize + 1] = glyph.h;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_OriginPosition] = glyph.originOffsetX;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_OriginPosition + 1] = glyph.originOffsetY;\n\t\t\t\tentryOffset += GlyphStorageBufferInfo.FloatsPerEntry;\n\t\t\t}\n\t\t\tif (entryOffset / GlyphStorageBufferInfo.FloatsPerEntry > TextureAtlasPage.maximumGlyphCount) {\n\t\t\t\tthrow new Error(`Attempting to write more glyphs (${entryOffset / GlyphStorageBufferInfo.FloatsPerEntry}) than the GPUBuffer can hold (${TextureAtlasPage.maximumGlyphCount})`);\n\t\t\t}\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._glyphStorageBuffer,\n\t\t\t\tlayerIndex * GlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tvalues,\n\t\t\t\t0,\n\t\t\t\tGlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount\n\t\t\t);\n\t\t\tif (page.usedArea.right - page.usedArea.left > 0 && page.usedArea.bottom - page.usedArea.top > 0) {\n\t\t\t\tthis._device.queue.copyExternalImageToTexture(\n\t\t\t\t\t{ source: page.source },\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: this._atlasGpuTexture,\n\t\t\t\t\t\torigin: {\n\t\t\t\t\t\t\tx: page.usedArea.left,\n\t\t\t\t\t\t\ty: page.usedArea.top,\n\t\t\t\t\t\t\tz: layerIndex\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: page.usedArea.right - page.usedArea.left + 1,\n\t\t\t\t\t\theight: page.usedArea.bottom - page.usedArea.top + 1\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._atlasGpuTextureVersions[layerIndex] = page.version;\n\t\t}\n\t}\n\n\tpublic prepareRender(ctx: RenderingContext): void {\n\t\tthrow new BugIndicatingError('Should not be called');\n\t}\n\n\tpublic override render(ctx: RestrictedRenderingContext): void {\n\t\tthrow new BugIndicatingError('Should not be called');\n\t}\n\n\t// #region Event handlers\n\n\t// Since ViewLinesGpu currently coordinates rendering to the canvas, it must listen to all\n\t// changed events that any GPU part listens to. This is because any drawing to the canvas will\n\t// clear it for that frame, so all parts must be rendered every time.\n\t//\n\t// Additionally, since this is intrinsically linked to ViewLines, it must also listen to events\n\t// from that side. Luckily rendering is cheap, it's only when uploaded data changes does it\n\t// start to cost.\n\n\toverride onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\tthis._refreshGlyphRasterizer();\n\t\treturn true;\n\t}\n\toverride onCursorStateChanged(e: viewEvents.ViewCursorStateChangedEvent): boolean { return true; }\n\toverride onDecorationsChanged(e: viewEvents.ViewDecorationsChangedEvent): boolean { return true; }\n\toverride onFlushed(e: viewEvents.ViewFlushedEvent): boolean { return true; }\n\n\toverride onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean { return true; }\n\toverride onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean { return true; }\n\toverride onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean { return true; }\n\toverride onLineMappingChanged(e: viewEvents.ViewLineMappingChangedEvent): boolean { return true; }\n\toverride onRevealRangeRequest(e: viewEvents.ViewRevealRangeRequestEvent): boolean { return true; }\n\toverride onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean { return true; }\n\toverride onThemeChanged(e: viewEvents.ViewThemeChangedEvent): boolean { return true; }\n\toverride onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean { return true; }\n\n\t// #endregion\n\n\tprivate _refreshGlyphRasterizer() {\n\t\tconst glyphRasterizer = this._glyphRasterizer.value;\n\t\tif (!glyphRasterizer) {\n\t\t\treturn;\n\t\t}\n\t\tconst fontFamily = this._context.configuration.options.get(EditorOption.fontFamily);\n\t\tconst fontSize = this._context.configuration.options.get(EditorOption.fontSize);\n\t\tconst devicePixelRatio = this._viewGpuContext.devicePixelRatio.get();\n\t\tif (\n\t\t\tglyphRasterizer.fontFamily !== fontFamily ||\n\t\t\tglyphRasterizer.fontSize !== fontSize ||\n\t\t\tglyphRasterizer.devicePixelRatio !== devicePixelRatio\n\t\t) {\n\t\t\tthis._glyphRasterizer.value = new GlyphRasterizer(fontSize, fontFamily, devicePixelRatio, ViewGpuContext.decorationStyleCache);\n\t\t}\n\t}\n\n\tpublic renderText(viewportData: ViewportData): void {\n\t\tif (this._initialized) {\n\t\t\tthis._refreshRenderStrategy(viewportData);\n\t\t\treturn this._renderText(viewportData);\n\t\t} else {\n\t\t\tthis._initViewportData = this._initViewportData ?? [];\n\t\t\tthis._initViewportData.push(viewportData);\n\t\t}\n\t}\n\n\tprivate _renderText(viewportData: ViewportData): void {\n\t\tthis._viewGpuContext.rectangleRenderer.draw(viewportData);\n\n\t\tconst options = new ViewLineOptions(this._context.configuration, this._context.theme.type);\n\n\t\tthis._renderStrategy.value!.update(viewportData, options);\n\n\t\tthis._updateAtlasStorageBufferAndTexture();\n\n\t\tconst encoder = this._device.createCommandEncoder({ label: 'Monaco command encoder' });\n\n\t\tthis._renderPassColorAttachment.view = this._viewGpuContext.ctx.getCurrentTexture().createView({ label: 'Monaco canvas texture view' });\n\t\tconst pass = encoder.beginRenderPass(this._renderPassDescriptor);\n\t\tpass.setPipeline(this._pipeline);\n\t\tpass.setVertexBuffer(0, this._vertexBuffer);\n\n\t\t// Only draw the content area\n\t\tconst contentLeft = Math.ceil(this._viewGpuContext.contentLeft.get() * this._viewGpuContext.devicePixelRatio.get());\n\t\tpass.setScissorRect(contentLeft, 0, this.canvas.width - contentLeft, this.canvas.height);\n\n\t\tpass.setBindGroup(0, this._bindGroup);\n\n\t\tthis._renderStrategy.value!.draw(pass, viewportData);\n\n\t\tpass.end();\n\n\t\tconst commandBuffer = encoder.finish();\n\n\t\tthis._device.queue.submit([commandBuffer]);\n\n\t\tthis._lastViewportData = viewportData;\n\t\tthis._lastViewLineOptions = options;\n\t}\n\n\tlinesVisibleRangesForRange(_range: Range, includeNewLines: boolean): LineVisibleRanges[] | null {\n\t\tif (!this._lastViewportData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst originalEndLineNumber = _range.endLineNumber;\n\t\tconst range = Range.intersectRanges(_range, this._lastViewportData.visibleRange);\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rendStartLineNumber = this._lastViewportData.startLineNumber;\n\t\tconst rendEndLineNumber = this._lastViewportData.endLineNumber;\n\n\t\tconst viewportData = this._lastViewportData;\n\t\tconst viewLineOptions = this._lastViewLineOptions;\n\n\t\tif (!viewportData || !viewLineOptions) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst visibleRanges: LineVisibleRanges[] = [];\n\n\t\tlet nextLineModelLineNumber: number = 0;\n\t\tif (includeNewLines) {\n\t\t\tnextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n\t\t}\n\n\t\tfor (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n\n\t\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n\t\t\tconst continuesInNextLine = lineNumber !== originalEndLineNumber;\n\t\t\tconst endColumn = continuesInNextLine ? this._context.viewModel.getLineMaxColumn(lineNumber) : range.endColumn;\n\n\t\t\tconst visibleRangesForLine = this._visibleRangesForLineRange(lineNumber, startColumn, endColumn);\n\n\t\t\tif (!visibleRangesForLine) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (includeNewLines && lineNumber < originalEndLineNumber) {\n\t\t\t\tconst currentLineModelLineNumber = nextLineModelLineNumber;\n\t\t\t\tnextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n\t\t\t\tif (currentLineModelLineNumber !== nextLineModelLineNumber) {\n\t\t\t\t\tvisibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += viewLineOptions.spaceWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvisibleRanges.push(new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges), continuesInNextLine));\n\t\t}\n\n\t\tif (visibleRanges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn visibleRanges;\n\t}\n\n\tprivate _visibleRangesForLineRange(lineNumber: number, startColumn: number, endColumn: number): VisibleRanges | null {\n\t\tif (this.shouldRender()) {\n\t\t\t// Cannot read from the DOM because it is dirty\n\t\t\t// i.e. the model & the dom are out of sync, so I'd be reading something stale\n\t\t\treturn null;\n\t\t}\n\n\t\tconst viewportData = this._lastViewportData;\n\t\tconst viewLineOptions = this._lastViewLineOptions;\n\n\t\tif (!viewportData || !viewLineOptions || lineNumber < viewportData.startLineNumber || lineNumber > viewportData.endLineNumber) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Resolve tab widths for this line\n\t\tconst lineData = viewportData.getViewLineRenderingData(lineNumber);\n\t\tconst content = lineData.content;\n\n\t\tlet contentSegmenter: IContentSegmenter | undefined;\n\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t}\n\n\t\tlet chars: string | undefined = '';\n\n\t\tlet resolvedStartColumn = 0;\n\t\tlet resolvedStartCssPixelOffset = 0;\n\t\tfor (let x = 0; x < startColumn - 1; x++) {\n\t\t\tif (lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tchars = content.charAt(x);\n\t\t\t} else {\n\t\t\t\tchars = contentSegmenter!.getSegmentAtIndex(x);\n\t\t\t\tif (chars === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresolvedStartCssPixelOffset += (this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width / getActiveWindow().devicePixelRatio) - viewLineOptions.spaceWidth;\n\t\t\t}\n\t\t\tif (chars === '\\t') {\n\t\t\t\tresolvedStartColumn = CursorColumns.nextRenderTabStop(resolvedStartColumn, lineData.tabSize);\n\t\t\t} else {\n\t\t\t\tresolvedStartColumn++;\n\t\t\t}\n\t\t}\n\t\tlet resolvedEndColumn = resolvedStartColumn;\n\t\tlet resolvedEndCssPixelOffset = 0;\n\t\tfor (let x = startColumn - 1; x < endColumn - 1; x++) {\n\t\t\tif (lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tchars = content.charAt(x);\n\t\t\t} else {\n\t\t\t\tchars = contentSegmenter!.getSegmentAtIndex(x);\n\t\t\t\tif (chars === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresolvedEndCssPixelOffset += (this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width / getActiveWindow().devicePixelRatio) - viewLineOptions.spaceWidth;\n\t\t\t}\n\t\t\tif (chars === '\\t') {\n\t\t\t\tresolvedEndColumn = CursorColumns.nextRenderTabStop(resolvedEndColumn, lineData.tabSize);\n\t\t\t} else {\n\t\t\t\tresolvedEndColumn++;\n\t\t\t}\n\t\t}\n\n\t\t// Visible horizontal range in _scaled_ pixels\n\t\tconst result = new VisibleRanges(false, [new FloatHorizontalRange(\n\t\t\tresolvedStartColumn * viewLineOptions.spaceWidth + resolvedStartCssPixelOffset,\n\t\t\t(resolvedEndColumn - resolvedStartColumn) * viewLineOptions.spaceWidth + resolvedEndCssPixelOffset)\n\t\t]);\n\n\t\treturn result;\n\t}\n\n\tvisibleRangeForPosition(position: Position): HorizontalPosition | null {\n\t\tconst visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n\t\tif (!visibleRanges) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n\t}\n\n\tgetLineWidth(lineNumber: number): number | undefined {\n\t\tif (!this._lastViewportData || !this._lastViewLineOptions) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._viewGpuContext.canRender(this._lastViewLineOptions, this._lastViewportData, lineNumber)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst lineData = this._lastViewportData.getViewLineRenderingData(lineNumber);\n\t\tconst lineRange = this._visibleRangesForLineRange(lineNumber, 1, lineData.maxColumn);\n\t\tconst lastRange = lineRange?.ranges.at(-1);\n\t\tif (lastRange) {\n\t\t\treturn lastRange.width;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetPositionAtCoordinate(lineNumber: number, mouseContentHorizontalOffset: number): Position | undefined {\n\t\tif (!this._lastViewportData || !this._lastViewLineOptions) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._viewGpuContext.canRender(this._lastViewLineOptions, this._lastViewportData, lineNumber)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lineData = this._lastViewportData.getViewLineRenderingData(lineNumber);\n\t\tconst content = lineData.content;\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tconst mouseContentHorizontalOffsetDevicePixels = mouseContentHorizontalOffset * dpr;\n\t\tconst spaceWidthDevicePixels = this._lastViewLineOptions.spaceWidth * dpr;\n\t\tconst contentSegmenter = createContentSegmenter(lineData, this._lastViewLineOptions);\n\n\t\tlet widthSoFar = 0;\n\t\tlet charWidth = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet column = 0;\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst chars = contentSegmenter.getSegmentAtIndex(x);\n\n\t\t\t// Part of an earlier segment\n\t\t\tif (chars === undefined) {\n\t\t\t\tcolumn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get the width of the character\n\t\t\tif (chars === '\\t') {\n\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\tcharWidth = spaceWidthDevicePixels * (tabXOffset - offsetBefore);\n\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\ttabXOffset -= x + 1;\n\t\t\t} else if (lineData.isBasicASCII && this._lastViewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tcharWidth = spaceWidthDevicePixels;\n\t\t\t} else {\n\t\t\t\tcharWidth = this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t}\n\n\t\t\tif (mouseContentHorizontalOffsetDevicePixels < widthSoFar + charWidth / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twidthSoFar += charWidth;\n\t\t\tcolumn++;\n\t\t}\n\n\t\treturn new Position(lineNumber, column + 1);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { autorun, runOnChange } from '../../../../base/common/observable.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { EditorOption } from '../../../common/config/editorOptions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { TextureAtlasPage } from '../../gpu/atlas/textureAtlasPage.js';\nimport { BindingId, type IGpuRenderStrategy } from '../../gpu/gpu.js';\nimport { GPULifecycle } from '../../gpu/gpuDisposable.js';\nimport { quadVertices } from '../../gpu/gpuUtils.js';\nimport { ViewGpuContext } from '../../gpu/viewGpuContext.js';\nimport { FloatHorizontalRange, HorizontalPosition, HorizontalRange, IViewLines, LineVisibleRanges, RenderingContext, RestrictedRenderingContext, VisibleRanges } from '../../view/renderingContext.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { ViewLineOptions } from '../viewLines/viewLineOptions.js';\nimport type * as viewEvents from '../../../common/viewEvents.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { TextureAtlas } from '../../gpu/atlas/textureAtlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../../gpu/contentSegmenter.js';\nimport { ViewportRenderStrategy } from '../../gpu/renderStrategy/viewportRenderStrategy.js';\nimport { FullFileRenderStrategy } from '../../gpu/renderStrategy/fullFileRenderStrategy.js';\nimport { MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { GlyphRasterizer } from '../../gpu/raster/glyphRasterizer.js';\n\nconst enum GlyphStorageBufferInfo {\n\tFloatsPerEntry = 2 + 2 + 2,\n\tBytesPerEntry = GlyphStorageBufferInfo.FloatsPerEntry * 4,\n\tOffset_TexturePosition = 0,\n\tOffset_TextureSize = 2,\n\tOffset_OriginPosition = 4,\n}\n\n/**\n * The GPU implementation of the ViewLines part.\n */\nexport class ViewLinesGpu extends ViewPart implements IViewLines {\n\n\tprivate readonly canvas: HTMLCanvasElement;\n\n\tprivate _initViewportData?: ViewportData[];\n\tprivate _lastViewportData?: ViewportData;\n\tprivate _lastViewLineOptions?: ViewLineOptions;\n\n\tprivate _device!: GPUDevice;\n\tprivate _renderPassDescriptor!: GPURenderPassDescriptor;\n\tprivate _renderPassColorAttachment!: GPURenderPassColorAttachment;\n\tprivate _bindGroup!: GPUBindGroup;\n\tprivate _pipeline!: GPURenderPipeline;\n\n\tprivate _vertexBuffer!: GPUBuffer;\n\n\tprivate _glyphStorageBuffer!: GPUBuffer;\n\tprivate _atlasGpuTexture!: GPUTexture;\n\tprivate readonly _atlasGpuTextureVersions: number[] = [];\n\n\tprivate _initialized = false;\n\n\tprivate readonly _glyphRasterizer: MutableDisposable<GlyphRasterizer> = this._register(new MutableDisposable());\n\tprivate readonly _renderStrategy: MutableDisposable<IGpuRenderStrategy> = this._register(new MutableDisposable());\n\tprivate _rebuildBindGroup?: () => void;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tprivate readonly _viewGpuContext: ViewGpuContext,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t) {\n\t\tsuper(context);\n\n\t\tthis.canvas = this._viewGpuContext.canvas.domNode;\n\n\t\t// Re-render the following frame after canvas device pixel dimensions change, provided a\n\t\t// new render does not occur.\n\t\tthis._register(autorun(reader => {\n\t\t\tthis._viewGpuContext.canvasDevicePixelDimensions.read(reader);\n\t\t\tconst lastViewportData = this._lastViewportData;\n\t\t\tif (lastViewportData) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (lastViewportData === this._lastViewportData) {\n\t\t\t\t\t\tthis.renderText(lastViewportData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\n\t\tthis.initWebgpu();\n\t}\n\n\tasync initWebgpu() {\n\t\t// #region General\n\n\t\tthis._device = ViewGpuContext.deviceSync || await ViewGpuContext.device;\n\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst atlas = ViewGpuContext.atlas;\n\n\t\t// Rerender when the texture atlas deletes glyphs\n\t\tthis._register(atlas.onDidDeleteGlyphs(() => {\n\t\t\tthis._atlasGpuTextureVersions.length = 0;\n\t\t\tthis._atlasGpuTextureVersions[0] = 0;\n\t\t\tthis._atlasGpuTextureVersions[1] = 0;\n\t\t\tthis._renderStrategy.value!.reset();\n\t\t}));\n\n\t\tconst presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\t\tthis._viewGpuContext.ctx.configure({\n\t\t\tdevice: this._device,\n\t\t\tformat: presentationFormat,\n\t\t\talphaMode: 'premultiplied',\n\t\t});\n\n\t\tthis._renderPassColorAttachment = {\n\t\t\tview: null!, // Will be filled at render time\n\t\t\tloadOp: 'load',\n\t\t\tstoreOp: 'store',\n\t\t};\n\t\tthis._renderPassDescriptor = {\n\t\t\tlabel: 'Monaco render pass',\n\t\t\tcolorAttachments: [this._renderPassColorAttachment],\n\t\t};\n\n\t\t// #endregion General\n\n\t\t// #region Uniforms\n\n\t\tlet layoutInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 6,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_CanvasWidth____ = 0,\n\t\t\t\tOffset_CanvasHeight___ = 1,\n\t\t\t\tOffset_ViewportOffsetX = 2,\n\t\t\t\tOffset_ViewportOffsetY = 3,\n\t\t\t\tOffset_ViewportWidth__ = 4,\n\t\t\t\tOffset_ViewportHeight_ = 5,\n\t\t\t}\n\t\t\tconst bufferValues = new Float32Array(Info.FloatsPerEntry);\n\t\t\tconst updateBufferValues = (canvasDevicePixelWidth: number = this.canvas.width, canvasDevicePixelHeight: number = this.canvas.height) => {\n\t\t\t\tbufferValues[Info.Offset_CanvasWidth____] = canvasDevicePixelWidth;\n\t\t\t\tbufferValues[Info.Offset_CanvasHeight___] = canvasDevicePixelHeight;\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetX] = Math.ceil(this._context.configuration.options.get(EditorOption.layoutInfo).contentLeft * getActiveWindow().devicePixelRatio);\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetY] = 0;\n\t\t\t\tbufferValues[Info.Offset_ViewportWidth__] = bufferValues[Info.Offset_CanvasWidth____] - bufferValues[Info.Offset_ViewportOffsetX];\n\t\t\t\tbufferValues[Info.Offset_ViewportHeight_] = bufferValues[Info.Offset_CanvasHeight___] - bufferValues[Info.Offset_ViewportOffsetY];\n\t\t\t\treturn bufferValues;\n\t\t\t};\n\t\t\tlayoutInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => updateBufferValues())).object;\n\t\t\tthis._register(runOnChange(this._viewGpuContext.canvasDevicePixelDimensions, ({ width, height }) => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues(width, height));\n\t\t\t}));\n\t\t\tthis._register(runOnChange(this._viewGpuContext.contentLeft, () => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues());\n\t\t\t}));\n\t\t}\n\n\t\tlet atlasInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 2,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_Width_ = 0,\n\t\t\t\tOffset_Height = 1,\n\t\t\t}\n\t\t\tatlasInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco atlas info uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => {\n\t\t\t\tconst values = new Float32Array(Info.FloatsPerEntry);\n\t\t\t\tvalues[Info.Offset_Width_] = atlas.pageSize;\n\t\t\t\tvalues[Info.Offset_Height] = atlas.pageSize;\n\t\t\t\treturn values;\n\t\t\t})).object;\n\t\t}\n\n\t\t// #endregion Uniforms\n\n\t\t// #region Storage buffers\n\n\t\tconst fontFamily = this._context.configuration.options.get(EditorOption.fontFamily);\n\t\tconst fontSize = this._context.configuration.options.get(EditorOption.fontSize);\n\t\tthis._glyphRasterizer.value = this._register(new GlyphRasterizer(fontSize, fontFamily, this._viewGpuContext.devicePixelRatio.get(), ViewGpuContext.decorationStyleCache));\n\t\tthis._register(runOnChange(this._viewGpuContext.devicePixelRatio, () => {\n\t\t\tthis._refreshGlyphRasterizer();\n\t\t}));\n\n\n\t\tthis._renderStrategy.value = this._instantiationService.createInstance(FullFileRenderStrategy, this._context, this._viewGpuContext, this._device, this._glyphRasterizer as { value: GlyphRasterizer });\n\t\t// this._renderStrategy.value = this._instantiationService.createInstance(ViewportRenderStrategy, this._context, this._viewGpuContext, this._device);\n\n\t\tthis._glyphStorageBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco glyph storage buffer',\n\t\t\tsize: TextureAtlas.maximumPageCount * (TextureAtlasPage.maximumGlyphCount * GlyphStorageBufferInfo.BytesPerEntry),\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._atlasGpuTextureVersions[0] = 0;\n\t\tthis._atlasGpuTextureVersions[1] = 0;\n\t\tthis._atlasGpuTexture = this._register(GPULifecycle.createTexture(this._device, {\n\t\t\tlabel: 'Monaco atlas texture',\n\t\t\tformat: 'rgba8unorm',\n\t\t\tsize: { width: atlas.pageSize, height: atlas.pageSize, depthOrArrayLayers: TextureAtlas.maximumPageCount },\n\t\t\tdimension: '2d',\n\t\t\tusage: GPUTextureUsage.TEXTURE_BINDING |\n\t\t\t\tGPUTextureUsage.COPY_DST |\n\t\t\t\tGPUTextureUsage.RENDER_ATTACHMENT,\n\t\t})).object;\n\n\t\tthis._updateAtlasStorageBufferAndTexture();\n\n\t\t// #endregion Storage buffers\n\n\t\t// #region Vertex buffer\n\n\t\tthis._vertexBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco vertex buffer',\n\t\t\tsize: quadVertices.byteLength,\n\t\t\tusage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n\t\t}, quadVertices)).object;\n\n\t\t// #endregion Vertex buffer\n\n\t\t// #region Shader module\n\n\t\tconst module = this._device.createShaderModule({\n\t\t\tlabel: 'Monaco shader module',\n\t\t\tcode: this._renderStrategy.value!.wgsl,\n\t\t});\n\n\t\t// #endregion Shader module\n\n\t\t// #region Pipeline\n\n\t\tthis._pipeline = this._device.createRenderPipeline({\n\t\t\tlabel: 'Monaco render pipeline',\n\t\t\tlayout: 'auto',\n\t\t\tvertex: {\n\t\t\t\tmodule,\n\t\t\t\tbuffers: [\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // 2 floats, 4 bytes each\n\t\t\t\t\t\tattributes: [\n\t\t\t\t\t\t\t{ shaderLocation: 0, offset: 0, format: 'float32x2' },  // position\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tfragment: {\n\t\t\t\tmodule,\n\t\t\t\ttargets: [\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: presentationFormat,\n\t\t\t\t\t\tblend: {\n\t\t\t\t\t\t\tcolor: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talpha: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\t// #endregion Pipeline\n\n\t\t// #region Bind group\n\n\t\tthis._rebuildBindGroup = () => {\n\t\t\tthis._bindGroup = this._device.createBindGroup({\n\t\t\t\tlabel: 'Monaco bind group',\n\t\t\t\tlayout: this._pipeline.getBindGroupLayout(0),\n\t\t\t\tentries: [\n\t\t\t\t\t// TODO: Pass in generically as array?\n\t\t\t\t\t{ binding: BindingId.GlyphInfo, resource: { buffer: this._glyphStorageBuffer } },\n\t\t\t\t\t{\n\t\t\t\t\t\tbinding: BindingId.TextureSampler, resource: this._device.createSampler({\n\t\t\t\t\t\t\tlabel: 'Monaco atlas sampler',\n\t\t\t\t\t\t\tmagFilter: 'nearest',\n\t\t\t\t\t\t\tminFilter: 'nearest',\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t\t{ binding: BindingId.Texture, resource: this._atlasGpuTexture.createView() },\n\t\t\t\t\t{ binding: BindingId.LayoutInfoUniform, resource: { buffer: layoutInfoUniformBuffer } },\n\t\t\t\t\t{ binding: BindingId.AtlasDimensionsUniform, resource: { buffer: atlasInfoUniformBuffer } },\n\t\t\t\t\t...this._renderStrategy.value!.bindGroupEntries\n\t\t\t\t],\n\t\t\t});\n\t\t};\n\t\tthis._rebuildBindGroup();\n\n\t\t// endregion Bind group\n\n\t\tthis._initialized = true;\n\n\t\t// Render the initial viewport immediately after initialization\n\t\tif (this._initViewportData) {\n\t\t\t// HACK: Rendering multiple times in the same frame like this isn't ideal, but there\n\t\t\t//       isn't an easy way to merge viewport data\n\t\t\tfor (const viewportData of this._initViewportData) {\n\t\t\t\tthis.renderText(viewportData);\n\t\t\t}\n\t\t\tthis._initViewportData = undefined;\n\t\t}\n\t}\n\n\tprivate _refreshRenderStrategy(viewportData: ViewportData) {\n\t\tif (this._renderStrategy.value?.type === 'viewport') {\n\t\t\treturn;\n\t\t}\n\t\tif (viewportData.endLineNumber < FullFileRenderStrategy.maxSupportedLines && this._viewportMaxColumn(viewportData) < FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\treturn;\n\t\t}\n\t\tthis._logService.trace(`File is larger than ${FullFileRenderStrategy.maxSupportedLines} lines or ${FullFileRenderStrategy.maxSupportedColumns} columns, switching to viewport render strategy`);\n\t\tconst viewportRenderStrategy = this._instantiationService.createInstance(ViewportRenderStrategy, this._context, this._viewGpuContext, this._device, this._glyphRasterizer as { value: GlyphRasterizer });\n\t\tthis._renderStrategy.value = viewportRenderStrategy;\n\t\tthis._register(viewportRenderStrategy.onDidChangeBindGroupEntries(() => this._rebuildBindGroup?.()));\n\t\tthis._rebuildBindGroup?.();\n\t}\n\n\tprivate _viewportMaxColumn(viewportData: ViewportData): number {\n\t\tlet maxColumn = 0;\n\t\tlet lineData: ViewLineRenderingData;\n\t\tfor (let i = viewportData.startLineNumber; i <= viewportData.endLineNumber; i++) {\n\t\t\tlineData = viewportData.getViewLineRenderingData(i);\n\t\t\tmaxColumn = Math.max(maxColumn, lineData.maxColumn);\n\t\t}\n\t\treturn maxColumn;\n\t}\n\n\tprivate _updateAtlasStorageBufferAndTexture() {\n\t\tfor (const [layerIndex, page] of ViewGpuContext.atlas.pages.entries()) {\n\t\t\tif (layerIndex >= TextureAtlas.maximumPageCount) {\n\t\t\t\tconsole.log(`Attempt to upload atlas page [${layerIndex}], only ${TextureAtlas.maximumPageCount} are supported currently`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip the update if it's already the latest version\n\t\t\tif (page.version === this._atlasGpuTextureVersions[layerIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._logService.trace('Updating atlas page[', layerIndex, '] from version ', this._atlasGpuTextureVersions[layerIndex], ' to version ', page.version);\n\n\t\t\tconst entryCount = GlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount;\n\t\t\tconst values = new Float32Array(entryCount);\n\t\t\tlet entryOffset = 0;\n\t\t\tfor (const glyph of page.glyphs) {\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TexturePosition] = glyph.x;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TexturePosition + 1] = glyph.y;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TextureSize] = glyph.w;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_TextureSize + 1] = glyph.h;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_OriginPosition] = glyph.originOffsetX;\n\t\t\t\tvalues[entryOffset + GlyphStorageBufferInfo.Offset_OriginPosition + 1] = glyph.originOffsetY;\n\t\t\t\tentryOffset += GlyphStorageBufferInfo.FloatsPerEntry;\n\t\t\t}\n\t\t\tif (entryOffset / GlyphStorageBufferInfo.FloatsPerEntry > TextureAtlasPage.maximumGlyphCount) {\n\t\t\t\tthrow new Error(`Attempting to write more glyphs (${entryOffset / GlyphStorageBufferInfo.FloatsPerEntry}) than the GPUBuffer can hold (${TextureAtlasPage.maximumGlyphCount})`);\n\t\t\t}\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._glyphStorageBuffer,\n\t\t\t\tlayerIndex * GlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tvalues,\n\t\t\t\t0,\n\t\t\t\tGlyphStorageBufferInfo.FloatsPerEntry * TextureAtlasPage.maximumGlyphCount\n\t\t\t);\n\t\t\tif (page.usedArea.right - page.usedArea.left > 0 && page.usedArea.bottom - page.usedArea.top > 0) {\n\t\t\t\tthis._device.queue.copyExternalImageToTexture(\n\t\t\t\t\t{ source: page.source },\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: this._atlasGpuTexture,\n\t\t\t\t\t\torigin: {\n\t\t\t\t\t\t\tx: page.usedArea.left,\n\t\t\t\t\t\t\ty: page.usedArea.top,\n\t\t\t\t\t\t\tz: layerIndex\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: page.usedArea.right - page.usedArea.left + 1,\n\t\t\t\t\t\theight: page.usedArea.bottom - page.usedArea.top + 1\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._atlasGpuTextureVersions[layerIndex] = page.version;\n\t\t}\n\t}\n\n\tpublic prepareRender(ctx: RenderingContext): void {\n\t\tthrow new BugIndicatingError('Should not be called');\n\t}\n\n\tpublic override render(ctx: RestrictedRenderingContext): void {\n\t\tthrow new BugIndicatingError('Should not be called');\n\t}\n\n\t// #region Event handlers\n\n\t// Since ViewLinesGpu currently coordinates rendering to the canvas, it must listen to all\n\t// changed events that any GPU part listens to. This is because any drawing to the canvas will\n\t// clear it for that frame, so all parts must be rendered every time.\n\t//\n\t// Additionally, since this is intrinsically linked to ViewLines, it must also listen to events\n\t// from that side. Luckily rendering is cheap, it's only when uploaded data changes does it\n\t// start to cost.\n\n\toverride onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\tthis._refreshGlyphRasterizer();\n\t\treturn true;\n\t}\n\toverride onCursorStateChanged(e: viewEvents.ViewCursorStateChangedEvent): boolean { return true; }\n\toverride onDecorationsChanged(e: viewEvents.ViewDecorationsChangedEvent): boolean { return true; }\n\toverride onFlushed(e: viewEvents.ViewFlushedEvent): boolean { return true; }\n\n\toverride onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean { return true; }\n\toverride onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean { return true; }\n\toverride onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean { return true; }\n\toverride onLineMappingChanged(e: viewEvents.ViewLineMappingChangedEvent): boolean { return true; }\n\toverride onRevealRangeRequest(e: viewEvents.ViewRevealRangeRequestEvent): boolean { return true; }\n\toverride onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean { return true; }\n\toverride onThemeChanged(e: viewEvents.ViewThemeChangedEvent): boolean { return true; }\n\toverride onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean { return true; }\n\n\t// #endregion\n\n\tprivate _refreshGlyphRasterizer() {\n\t\tconst glyphRasterizer = this._glyphRasterizer.value;\n\t\tif (!glyphRasterizer) {\n\t\t\treturn;\n\t\t}\n\t\tconst fontFamily = this._context.configuration.options.get(EditorOption.fontFamily);\n\t\tconst fontSize = this._context.configuration.options.get(EditorOption.fontSize);\n\t\tconst devicePixelRatio = this._viewGpuContext.devicePixelRatio.get();\n\t\tif (\n\t\t\tglyphRasterizer.fontFamily !== fontFamily ||\n\t\t\tglyphRasterizer.fontSize !== fontSize ||\n\t\t\tglyphRasterizer.devicePixelRatio !== devicePixelRatio\n\t\t) {\n\t\t\tthis._glyphRasterizer.value = new GlyphRasterizer(fontSize, fontFamily, devicePixelRatio, ViewGpuContext.decorationStyleCache);\n\t\t}\n\t}\n\n\tpublic renderText(viewportData: ViewportData): void {\n\t\tif (this._initialized) {\n\t\t\tthis._refreshRenderStrategy(viewportData);\n\t\t\treturn this._renderText(viewportData);\n\t\t} else {\n\t\t\tthis._initViewportData = this._initViewportData ?? [];\n\t\t\tthis._initViewportData.push(viewportData);\n\t\t}\n\t}\n\n\tprivate _renderText(viewportData: ViewportData): void {\n\t\tthis._viewGpuContext.rectangleRenderer.draw(viewportData);\n\n\t\tconst options = new ViewLineOptions(this._context.configuration, this._context.theme.type);\n\n\t\tthis._renderStrategy.value!.update(viewportData, options);\n\n\t\tthis._updateAtlasStorageBufferAndTexture();\n\n\t\tconst encoder = this._device.createCommandEncoder({ label: 'Monaco command encoder' });\n\n\t\tthis._renderPassColorAttachment.view = this._viewGpuContext.ctx.getCurrentTexture().createView({ label: 'Monaco canvas texture view' });\n\t\tconst pass = encoder.beginRenderPass(this._renderPassDescriptor);\n\t\tpass.setPipeline(this._pipeline);\n\t\tpass.setVertexBuffer(0, this._vertexBuffer);\n\n\t\t// Only draw the content area\n\t\tconst contentLeft = Math.ceil(this._viewGpuContext.contentLeft.get() * this._viewGpuContext.devicePixelRatio.get());\n\t\tpass.setScissorRect(contentLeft, 0, this.canvas.width - contentLeft, this.canvas.height);\n\n\t\tpass.setBindGroup(0, this._bindGroup);\n\n\t\tthis._renderStrategy.value!.draw(pass, viewportData);\n\n\t\tpass.end();\n\n\t\tconst commandBuffer = encoder.finish();\n\n\t\tthis._device.queue.submit([commandBuffer]);\n\n\t\tthis._lastViewportData = viewportData;\n\t\tthis._lastViewLineOptions = options;\n\t}\n\n\tlinesVisibleRangesForRange(_range: Range, includeNewLines: boolean): LineVisibleRanges[] | null {\n\t\tif (!this._lastViewportData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst originalEndLineNumber = _range.endLineNumber;\n\t\tconst range = Range.intersectRanges(_range, this._lastViewportData.visibleRange);\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rendStartLineNumber = this._lastViewportData.startLineNumber;\n\t\tconst rendEndLineNumber = this._lastViewportData.endLineNumber;\n\n\t\tconst viewportData = this._lastViewportData;\n\t\tconst viewLineOptions = this._lastViewLineOptions;\n\n\t\tif (!viewportData || !viewLineOptions) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst visibleRanges: LineVisibleRanges[] = [];\n\n\t\tlet nextLineModelLineNumber: number = 0;\n\t\tif (includeNewLines) {\n\t\t\tnextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n\t\t}\n\n\t\tfor (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n\n\t\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n\t\t\tconst continuesInNextLine = lineNumber !== originalEndLineNumber;\n\t\t\tconst endColumn = continuesInNextLine ? this._context.viewModel.getLineMaxColumn(lineNumber) : range.endColumn;\n\n\t\t\tconst visibleRangesForLine = this._visibleRangesForLineRange(lineNumber, startColumn, endColumn);\n\n\t\t\tif (!visibleRangesForLine) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (includeNewLines && lineNumber < originalEndLineNumber) {\n\t\t\t\tconst currentLineModelLineNumber = nextLineModelLineNumber;\n\t\t\t\tnextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n\t\t\t\tif (currentLineModelLineNumber !== nextLineModelLineNumber) {\n\t\t\t\t\tvisibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += viewLineOptions.spaceWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvisibleRanges.push(new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges), continuesInNextLine));\n\t\t}\n\n\t\tif (visibleRanges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn visibleRanges;\n\t}\n\n\tprivate _visibleRangesForLineRange(lineNumber: number, startColumn: number, endColumn: number): VisibleRanges | null {\n\t\tif (this.shouldRender()) {\n\t\t\t// Cannot read from the DOM because it is dirty\n\t\t\t// i.e. the model & the dom are out of sync, so I'd be reading something stale\n\t\t\treturn null;\n\t\t}\n\n\t\tconst viewportData = this._lastViewportData;\n\t\tconst viewLineOptions = this._lastViewLineOptions;\n\n\t\tif (!viewportData || !viewLineOptions || lineNumber < viewportData.startLineNumber || lineNumber > viewportData.endLineNumber) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Resolve tab widths for this line\n\t\tconst lineData = viewportData.getViewLineRenderingData(lineNumber);\n\t\tconst content = lineData.content;\n\n\t\tlet contentSegmenter: IContentSegmenter | undefined;\n\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t}\n\n\t\tlet chars: string | undefined = '';\n\n\t\tlet resolvedStartColumn = 0;\n\t\tlet resolvedStartCssPixelOffset = 0;\n\t\tfor (let x = 0; x < startColumn - 1; x++) {\n\t\t\tif (lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tchars = content.charAt(x);\n\t\t\t} else {\n\t\t\t\tchars = contentSegmenter!.getSegmentAtIndex(x);\n\t\t\t\tif (chars === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresolvedStartCssPixelOffset += (this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width / getActiveWindow().devicePixelRatio) - viewLineOptions.spaceWidth;\n\t\t\t}\n\t\t\tif (chars === '\\t') {\n\t\t\t\tresolvedStartColumn = CursorColumns.nextRenderTabStop(resolvedStartColumn, lineData.tabSize);\n\t\t\t} else {\n\t\t\t\tresolvedStartColumn++;\n\t\t\t}\n\t\t}\n\t\tlet resolvedEndColumn = resolvedStartColumn;\n\t\tlet resolvedEndCssPixelOffset = 0;\n\t\tfor (let x = startColumn - 1; x < endColumn - 1; x++) {\n\t\t\tif (lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tchars = content.charAt(x);\n\t\t\t} else {\n\t\t\t\tchars = contentSegmenter!.getSegmentAtIndex(x);\n\t\t\t\tif (chars === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresolvedEndCssPixelOffset += (this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width / getActiveWindow().devicePixelRatio) - viewLineOptions.spaceWidth;\n\t\t\t}\n\t\t\tif (chars === '\\t') {\n\t\t\t\tresolvedEndColumn = CursorColumns.nextRenderTabStop(resolvedEndColumn, lineData.tabSize);\n\t\t\t} else {\n\t\t\t\tresolvedEndColumn++;\n\t\t\t}\n\t\t}\n\n\t\t// Visible horizontal range in _scaled_ pixels\n\t\tconst result = new VisibleRanges(false, [new FloatHorizontalRange(\n\t\t\tresolvedStartColumn * viewLineOptions.spaceWidth + resolvedStartCssPixelOffset,\n\t\t\t(resolvedEndColumn - resolvedStartColumn) * viewLineOptions.spaceWidth + resolvedEndCssPixelOffset)\n\t\t]);\n\n\t\treturn result;\n\t}\n\n\tvisibleRangeForPosition(position: Position): HorizontalPosition | null {\n\t\tconst visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n\t\tif (!visibleRanges) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n\t}\n\n\tgetLineWidth(lineNumber: number): number | undefined {\n\t\tif (!this._lastViewportData || !this._lastViewLineOptions) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._viewGpuContext.canRender(this._lastViewLineOptions, this._lastViewportData, lineNumber)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst lineData = this._lastViewportData.getViewLineRenderingData(lineNumber);\n\t\tconst lineRange = this._visibleRangesForLineRange(lineNumber, 1, lineData.maxColumn);\n\t\tconst lastRange = lineRange?.ranges.at(-1);\n\t\tif (lastRange) {\n\t\t\treturn lastRange.width;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetPositionAtCoordinate(lineNumber: number, mouseContentHorizontalOffset: number): Position | undefined {\n\t\tif (!this._lastViewportData || !this._lastViewLineOptions) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._viewGpuContext.canRender(this._lastViewLineOptions, this._lastViewportData, lineNumber)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lineData = this._lastViewportData.getViewLineRenderingData(lineNumber);\n\t\tconst content = lineData.content;\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tconst mouseContentHorizontalOffsetDevicePixels = mouseContentHorizontalOffset * dpr;\n\t\tconst spaceWidthDevicePixels = this._lastViewLineOptions.spaceWidth * dpr;\n\t\tconst contentSegmenter = createContentSegmenter(lineData, this._lastViewLineOptions);\n\n\t\tlet widthSoFar = 0;\n\t\tlet charWidth = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet column = 0;\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst chars = contentSegmenter.getSegmentAtIndex(x);\n\n\t\t\t// Part of an earlier segment\n\t\t\tif (chars === undefined) {\n\t\t\t\tcolumn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get the width of the character\n\t\t\tif (chars === '\\t') {\n\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\tcharWidth = spaceWidthDevicePixels * (tabXOffset - offsetBefore);\n\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\ttabXOffset -= x + 1;\n\t\t\t} else if (lineData.isBasicASCII && this._lastViewLineOptions.useMonospaceOptimizations) {\n\t\t\t\tcharWidth = spaceWidthDevicePixels;\n\t\t\t} else {\n\t\t\t\tcharWidth = this._renderStrategy.value!.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t}\n\n\t\t\tif (mouseContentHorizontalOffsetDevicePixels < widthSoFar + charWidth / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twidthSoFar += charWidth;\n\t\t\tcolumn++;\n\t\t}\n\n\t\treturn new Position(lineNumber, column + 1);\n\t}\n}\n"]}