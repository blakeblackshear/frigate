{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.ts","vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.ts"],"names":[],"mappings":"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","file":"stickyScrollModelProvider.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IActiveCodeEditor } from '../../../browser/editorBrowser.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { OutlineElement, OutlineGroup, OutlineModel } from '../../documentSymbols/browser/outlineModel.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancelablePromise, createCancelablePromise, Delayer } from '../../../../base/common/async.js';\nimport { FoldingController, RangesLimitReporter } from '../../folding/browser/folding.js';\nimport { SyntaxRangeProvider } from '../../folding/browser/syntaxRangeProvider.js';\nimport { IndentRangeProvider } from '../../folding/browser/indentRangeProvider.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingRegions } from '../../folding/browser/foldingRanges.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { StickyElement, StickyModel, StickyRange } from './stickyScrollElement.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorOption } from '../../../common/config/editorOptions.js';\n\nenum ModelProvider {\n\tOUTLINE_MODEL = 'outlineModel',\n\tFOLDING_PROVIDER_MODEL = 'foldingProviderModel',\n\tINDENTATION_MODEL = 'indentationModel'\n}\n\nenum Status {\n\tVALID,\n\tINVALID,\n\tCANCELED\n}\n\nexport interface IStickyModelProvider extends IDisposable {\n\n\t/**\n\t * Method which updates the sticky model\n\t * @param token cancellation token\n\t * @returns the sticky model\n\t */\n\tupdate(token: CancellationToken): Promise<StickyModel | null>;\n}\n\nexport class StickyModelProvider extends Disposable implements IStickyModelProvider {\n\n\tprivate _modelProviders: IStickyModelCandidateProvider<any>[] = [];\n\tprivate _modelPromise: CancelablePromise<any | null> | null = null;\n\tprivate _updateScheduler: Delayer<StickyModel | null> = this._register(new Delayer<StickyModel | null>(300));\n\tprivate readonly _updateOperation: DisposableStore = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _editor: IActiveCodeEditor,\n\t\tonProviderUpdate: () => void,\n\t\t@IInstantiationService _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILanguageFeaturesService _languageFeaturesService: ILanguageFeaturesService,\n\t) {\n\t\tsuper();\n\n\t\tswitch (this._editor.getOption(EditorOption.stickyScroll).defaultModel) {\n\t\t\tcase ModelProvider.OUTLINE_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateOutlineProvider(this._editor, _languageFeaturesService));\n\t\t\t// fall through\n\t\t\tcase ModelProvider.FOLDING_PROVIDER_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, onProviderUpdate, _languageFeaturesService));\n\t\t\t// fall through\n\t\t\tcase ModelProvider.INDENTATION_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._modelProviders.forEach(provider => provider.dispose());\n\t\tthis._updateOperation.clear();\n\t\tthis._cancelModelPromise();\n\t\tsuper.dispose();\n\t}\n\n\tprivate _cancelModelPromise(): void {\n\t\tif (this._modelPromise) {\n\t\t\tthis._modelPromise.cancel();\n\t\t\tthis._modelPromise = null;\n\t\t}\n\t}\n\n\tpublic async update(token: CancellationToken): Promise<StickyModel | null> {\n\n\t\tthis._updateOperation.clear();\n\t\tthis._updateOperation.add({\n\t\t\tdispose: () => {\n\t\t\t\tthis._cancelModelPromise();\n\t\t\t\tthis._updateScheduler.cancel();\n\t\t\t}\n\t\t});\n\t\tthis._cancelModelPromise();\n\n\t\treturn await this._updateScheduler.trigger(async () => {\n\n\t\t\tfor (const modelProvider of this._modelProviders) {\n\t\t\t\tconst { statusPromise, modelPromise } = modelProvider.computeStickyModel(token);\n\t\t\t\tthis._modelPromise = modelPromise;\n\t\t\t\tconst status = await statusPromise;\n\t\t\t\tif (this._modelPromise !== modelPromise) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tswitch (status) {\n\t\t\t\t\tcase Status.CANCELED:\n\t\t\t\t\t\tthis._updateOperation.clear();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase Status.VALID:\n\t\t\t\t\t\treturn modelProvider.stickyModel;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}).catch((error) => {\n\t\t\tonUnexpectedError(error);\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\ninterface IStickyModelCandidateProvider<T> extends IDisposable {\n\tget stickyModel(): StickyModel | null;\n\n\t/**\n\t * Method which computes the sticky model and returns a status to signal whether the sticky model has been successfully found\n\t * @param token cancellation token\n\t * @returns a promise of a status indicating whether the sticky model has been successfully found as well as the model promise\n\t */\n\tcomputeStickyModel(token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null };\n}\n\nabstract class StickyModelCandidateProvider<T> extends Disposable implements IStickyModelCandidateProvider<T> {\n\n\tprotected _stickyModel: StickyModel | null = null;\n\n\tconstructor(protected readonly _editor: IActiveCodeEditor) {\n\t\tsuper();\n\t}\n\n\tget stickyModel(): StickyModel | null {\n\t\treturn this._stickyModel;\n\t}\n\n\tprivate _invalid(): Status {\n\t\tthis._stickyModel = null;\n\t\treturn Status.INVALID;\n\t}\n\n\tpublic computeStickyModel(token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null } {\n\t\tif (token.isCancellationRequested || !this.isProviderValid()) {\n\t\t\treturn { statusPromise: this._invalid(), modelPromise: null };\n\t\t}\n\t\tconst providerModelPromise = createCancelablePromise(token => this.createModelFromProvider(token));\n\n\t\treturn {\n\t\t\tstatusPromise: providerModelPromise.then(providerModel => {\n\t\t\t\tif (!this.isModelValid(providerModel)) {\n\t\t\t\t\treturn this._invalid();\n\n\t\t\t\t}\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn Status.CANCELED;\n\t\t\t\t}\n\t\t\t\tthis._stickyModel = this.createStickyModel(token, providerModel);\n\t\t\t\treturn Status.VALID;\n\t\t\t}).then(undefined, (err) => {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\treturn Status.CANCELED;\n\t\t\t}),\n\t\t\tmodelPromise: providerModelPromise\n\t\t};\n\t}\n\n\t/**\n\t * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.\n\t * This method by default returns true.\n\t * @param model model returned by the provider\n\t * @returns boolean indicating whether the model is valid\n\t */\n\tprotected isModelValid(model: T): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Method which checks whether the provider is valid before applying it to find the provider model.\n\t * This method by default returns true.\n\t * @returns boolean indicating whether the provider is valid\n\t */\n\tprotected isProviderValid(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Abstract method which creates the model from the provider and returns the provider model\n\t * @param token cancellation token\n\t * @returns the model returned by the provider\n\t */\n\tprotected abstract createModelFromProvider(token: CancellationToken): Promise<T>;\n\n\t/**\n\t * Abstract method which computes the sticky model from the model returned by the provider and returns the sticky model\n\t * @param token cancellation token\n\t * @param model model returned by the provider\n\t * @returns the sticky model\n\t */\n\tprotected abstract createStickyModel(token: CancellationToken, model: T): StickyModel;\n}\n\nclass StickyModelFromCandidateOutlineProvider extends StickyModelCandidateProvider<OutlineModel> {\n\n\tconstructor(_editor: IActiveCodeEditor, @ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper(_editor);\n\t}\n\n\tprotected createModelFromProvider(token: CancellationToken): Promise<OutlineModel> {\n\t\treturn OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._editor.getModel(), token);\n\t}\n\n\tprotected createStickyModel(token: CancellationToken, model: OutlineModel): StickyModel {\n\t\tconst { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);\n\t\tconst textModel = this._editor.getModel();\n\t\treturn new StickyModel(textModel.uri, textModel.getVersionId(), stickyOutlineElement, providerID);\n\t}\n\n\tprotected override isModelValid(model: OutlineModel): boolean {\n\t\treturn model && model.children.size > 0;\n\t}\n\n\tprivate _stickyModelFromOutlineModel(outlineModel: OutlineModel, preferredProvider: string | undefined): { stickyOutlineElement: StickyElement; providerID: string | undefined } {\n\n\t\tlet outlineElements: Map<string, OutlineElement>;\n\t\t// When several possible outline providers\n\t\tif (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n\t\t\tconst provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n\t\t\tif (provider) {\n\t\t\t\toutlineElements = provider.children;\n\t\t\t} else {\n\t\t\t\tlet tempID = '';\n\t\t\t\tlet maxTotalSumOfRanges = -1;\n\t\t\t\tlet optimalOutlineGroup = undefined;\n\t\t\t\tfor (const [_key, outlineGroup] of outlineModel.children.entries()) {\n\t\t\t\t\tconst totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);\n\t\t\t\t\tif (totalSumRanges > maxTotalSumOfRanges) {\n\t\t\t\t\t\toptimalOutlineGroup = outlineGroup;\n\t\t\t\t\t\tmaxTotalSumOfRanges = totalSumRanges;\n\t\t\t\t\t\ttempID = outlineGroup.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreferredProvider = tempID;\n\t\t\t\toutlineElements = optimalOutlineGroup!.children;\n\t\t\t}\n\t\t} else {\n\t\t\toutlineElements = outlineModel.children as Map<string, OutlineElement>;\n\t\t}\n\t\tconst stickyChildren: StickyElement[] = [];\n\t\tconst outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n\t\t\tconst range1: StickyRange = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n\t\t\tconst range2: StickyRange = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n\t\t\treturn this._comparator(range1, range2);\n\t\t});\n\t\tfor (const outlineElement of outlineElementsArray) {\n\t\t\tstickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n\t\t}\n\t\tconst stickyOutlineElement = new StickyElement(undefined, stickyChildren, undefined);\n\n\t\treturn {\n\t\t\tstickyOutlineElement: stickyOutlineElement,\n\t\t\tproviderID: preferredProvider\n\t\t};\n\t}\n\n\tprivate _stickyModelFromOutlineElement(outlineElement: OutlineElement, previousStartLine: number): StickyElement {\n\t\tconst children: StickyElement[] = [];\n\t\tfor (const child of outlineElement.children.values()) {\n\t\t\tif (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n\t\t\t\tif (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t} else {\n\t\t\t\t\tfor (const subchild of child.children.values()) {\n\t\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchildren.sort((child1, child2) => this._comparator(child1.range!, child2.range!));\n\t\tconst range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n\t\treturn new StickyElement(range, children, undefined);\n\t}\n\n\tprivate _comparator(range1: StickyRange, range2: StickyRange): number {\n\t\tif (range1.startLineNumber !== range2.startLineNumber) {\n\t\t\treturn range1.startLineNumber - range2.startLineNumber;\n\t\t} else {\n\t\t\treturn range2.endLineNumber - range1.endLineNumber;\n\t\t}\n\t}\n\n\tprivate _findSumOfRangesOfGroup(outline: OutlineGroup | OutlineElement): number {\n\t\tlet res = 0;\n\t\tfor (const child of outline.children.values()) {\n\t\t\tres += this._findSumOfRangesOfGroup(child);\n\t\t}\n\t\tif (outline instanceof OutlineElement) {\n\t\t\treturn res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nabstract class StickyModelFromCandidateFoldingProvider extends StickyModelCandidateProvider<FoldingRegions | null> {\n\n\tprotected _foldingLimitReporter: RangesLimitReporter;\n\n\tconstructor(editor: IActiveCodeEditor) {\n\t\tsuper(editor);\n\t\tthis._foldingLimitReporter = this._register(new RangesLimitReporter(editor));\n\t}\n\n\tprotected createStickyModel(token: CancellationToken, model: FoldingRegions): StickyModel {\n\t\tconst foldingElement = this._fromFoldingRegions(model);\n\t\tconst textModel = this._editor.getModel();\n\t\treturn new StickyModel(textModel.uri, textModel.getVersionId(), foldingElement, undefined);\n\t}\n\n\tprotected override isModelValid(model: FoldingRegions): boolean {\n\t\treturn model !== null;\n\t}\n\n\n\tprivate _fromFoldingRegions(foldingRegions: FoldingRegions): StickyElement {\n\t\tconst length = foldingRegions.length;\n\t\tconst orderedStickyElements: StickyElement[] = [];\n\n\t\t// The root sticky outline element\n\t\tconst stickyOutlineElement = new StickyElement(\n\t\t\tundefined,\n\t\t\t[],\n\t\t\tundefined\n\t\t);\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Finding the parent index of the current range\n\t\t\tconst parentIndex = foldingRegions.getParentIndex(i);\n\n\t\t\tlet parentNode;\n\t\t\tif (parentIndex !== -1) {\n\t\t\t\t// Access the reference of the parent node\n\t\t\t\tparentNode = orderedStickyElements[parentIndex];\n\t\t\t} else {\n\t\t\t\t// In that case the parent node is the root node\n\t\t\t\tparentNode = stickyOutlineElement;\n\t\t\t}\n\n\t\t\tconst child = new StickyElement(\n\t\t\t\tnew StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1),\n\t\t\t\t[],\n\t\t\t\tparentNode\n\t\t\t);\n\t\t\tparentNode.children.push(child);\n\t\t\torderedStickyElements.push(child);\n\t\t}\n\t\treturn stickyOutlineElement;\n\t}\n}\n\nclass StickyModelFromCandidateIndentationFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tprivate readonly provider: IndentRangeProvider;\n\n\tconstructor(\n\t\teditor: IActiveCodeEditor,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService) {\n\t\tsuper(editor);\n\n\t\tthis.provider = this._register(new IndentRangeProvider(editor.getModel(), this._languageConfigurationService, this._foldingLimitReporter));\n\t}\n\n\tprotected override async createModelFromProvider(token: CancellationToken): Promise<FoldingRegions> {\n\t\treturn this.provider.compute(token);\n\t}\n}\n\nclass StickyModelFromCandidateSyntaxFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tprivate readonly provider: MutableDisposable<SyntaxRangeProvider> = this._register(new MutableDisposable<SyntaxRangeProvider>());\n\n\tconstructor(\n\t\teditor: IActiveCodeEditor,\n\t\tonProviderUpdate: () => void,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService\n\t) {\n\t\tsuper(editor);\n\t\tthis._register(this._languageFeaturesService.foldingRangeProvider.onDidChange(() => {\n\t\t\tthis._updateProvider(editor, onProviderUpdate);\n\t\t}));\n\t\tthis._updateProvider(editor, onProviderUpdate);\n\t}\n\n\tprivate _updateProvider(editor: IActiveCodeEditor, onProviderUpdate: () => void): void {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, editor.getModel());\n\t\tif (selectedProviders.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.provider.value = new SyntaxRangeProvider(editor.getModel(), selectedProviders, onProviderUpdate, this._foldingLimitReporter, undefined);\n\t}\n\n\tprotected override isProviderValid(): boolean {\n\t\treturn this.provider !== undefined;\n\t}\n\n\tprotected override async createModelFromProvider(token: CancellationToken): Promise<FoldingRegions | null> {\n\t\treturn this.provider.value?.compute(token) ?? null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IActiveCodeEditor } from '../../../browser/editorBrowser.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { OutlineElement, OutlineGroup, OutlineModel } from '../../documentSymbols/browser/outlineModel.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancelablePromise, createCancelablePromise, Delayer } from '../../../../base/common/async.js';\nimport { FoldingController, RangesLimitReporter } from '../../folding/browser/folding.js';\nimport { SyntaxRangeProvider } from '../../folding/browser/syntaxRangeProvider.js';\nimport { IndentRangeProvider } from '../../folding/browser/indentRangeProvider.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingRegions } from '../../folding/browser/foldingRanges.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { StickyElement, StickyModel, StickyRange } from './stickyScrollElement.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorOption } from '../../../common/config/editorOptions.js';\n\nenum ModelProvider {\n\tOUTLINE_MODEL = 'outlineModel',\n\tFOLDING_PROVIDER_MODEL = 'foldingProviderModel',\n\tINDENTATION_MODEL = 'indentationModel'\n}\n\nenum Status {\n\tVALID,\n\tINVALID,\n\tCANCELED\n}\n\nexport interface IStickyModelProvider extends IDisposable {\n\n\t/**\n\t * Method which updates the sticky model\n\t * @param token cancellation token\n\t * @returns the sticky model\n\t */\n\tupdate(token: CancellationToken): Promise<StickyModel | null>;\n}\n\nexport class StickyModelProvider extends Disposable implements IStickyModelProvider {\n\n\tprivate _modelProviders: IStickyModelCandidateProvider<any>[] = [];\n\tprivate _modelPromise: CancelablePromise<any | null> | null = null;\n\tprivate _updateScheduler: Delayer<StickyModel | null> = this._register(new Delayer<StickyModel | null>(300));\n\tprivate readonly _updateOperation: DisposableStore = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _editor: IActiveCodeEditor,\n\t\tonProviderUpdate: () => void,\n\t\t@IInstantiationService _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILanguageFeaturesService _languageFeaturesService: ILanguageFeaturesService,\n\t) {\n\t\tsuper();\n\n\t\tswitch (this._editor.getOption(EditorOption.stickyScroll).defaultModel) {\n\t\t\tcase ModelProvider.OUTLINE_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateOutlineProvider(this._editor, _languageFeaturesService));\n\t\t\t// fall through\n\t\t\tcase ModelProvider.FOLDING_PROVIDER_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, onProviderUpdate, _languageFeaturesService));\n\t\t\t// fall through\n\t\t\tcase ModelProvider.INDENTATION_MODEL:\n\t\t\t\tthis._modelProviders.push(new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._modelProviders.forEach(provider => provider.dispose());\n\t\tthis._updateOperation.clear();\n\t\tthis._cancelModelPromise();\n\t\tsuper.dispose();\n\t}\n\n\tprivate _cancelModelPromise(): void {\n\t\tif (this._modelPromise) {\n\t\t\tthis._modelPromise.cancel();\n\t\t\tthis._modelPromise = null;\n\t\t}\n\t}\n\n\tpublic async update(token: CancellationToken): Promise<StickyModel | null> {\n\n\t\tthis._updateOperation.clear();\n\t\tthis._updateOperation.add({\n\t\t\tdispose: () => {\n\t\t\t\tthis._cancelModelPromise();\n\t\t\t\tthis._updateScheduler.cancel();\n\t\t\t}\n\t\t});\n\t\tthis._cancelModelPromise();\n\n\t\treturn await this._updateScheduler.trigger(async () => {\n\n\t\t\tfor (const modelProvider of this._modelProviders) {\n\t\t\t\tconst { statusPromise, modelPromise } = modelProvider.computeStickyModel(token);\n\t\t\t\tthis._modelPromise = modelPromise;\n\t\t\t\tconst status = await statusPromise;\n\t\t\t\tif (this._modelPromise !== modelPromise) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tswitch (status) {\n\t\t\t\t\tcase Status.CANCELED:\n\t\t\t\t\t\tthis._updateOperation.clear();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase Status.VALID:\n\t\t\t\t\t\treturn modelProvider.stickyModel;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}).catch((error) => {\n\t\t\tonUnexpectedError(error);\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\ninterface IStickyModelCandidateProvider<T> extends IDisposable {\n\tget stickyModel(): StickyModel | null;\n\n\t/**\n\t * Method which computes the sticky model and returns a status to signal whether the sticky model has been successfully found\n\t * @param token cancellation token\n\t * @returns a promise of a status indicating whether the sticky model has been successfully found as well as the model promise\n\t */\n\tcomputeStickyModel(token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null };\n}\n\nabstract class StickyModelCandidateProvider<T> extends Disposable implements IStickyModelCandidateProvider<T> {\n\n\tprotected _stickyModel: StickyModel | null = null;\n\n\tconstructor(protected readonly _editor: IActiveCodeEditor) {\n\t\tsuper();\n\t}\n\n\tget stickyModel(): StickyModel | null {\n\t\treturn this._stickyModel;\n\t}\n\n\tprivate _invalid(): Status {\n\t\tthis._stickyModel = null;\n\t\treturn Status.INVALID;\n\t}\n\n\tpublic computeStickyModel(token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null } {\n\t\tif (token.isCancellationRequested || !this.isProviderValid()) {\n\t\t\treturn { statusPromise: this._invalid(), modelPromise: null };\n\t\t}\n\t\tconst providerModelPromise = createCancelablePromise(token => this.createModelFromProvider(token));\n\n\t\treturn {\n\t\t\tstatusPromise: providerModelPromise.then(providerModel => {\n\t\t\t\tif (!this.isModelValid(providerModel)) {\n\t\t\t\t\treturn this._invalid();\n\n\t\t\t\t}\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn Status.CANCELED;\n\t\t\t\t}\n\t\t\t\tthis._stickyModel = this.createStickyModel(token, providerModel);\n\t\t\t\treturn Status.VALID;\n\t\t\t}).then(undefined, (err) => {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\treturn Status.CANCELED;\n\t\t\t}),\n\t\t\tmodelPromise: providerModelPromise\n\t\t};\n\t}\n\n\t/**\n\t * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.\n\t * This method by default returns true.\n\t * @param model model returned by the provider\n\t * @returns boolean indicating whether the model is valid\n\t */\n\tprotected isModelValid(model: T): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Method which checks whether the provider is valid before applying it to find the provider model.\n\t * This method by default returns true.\n\t * @returns boolean indicating whether the provider is valid\n\t */\n\tprotected isProviderValid(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Abstract method which creates the model from the provider and returns the provider model\n\t * @param token cancellation token\n\t * @returns the model returned by the provider\n\t */\n\tprotected abstract createModelFromProvider(token: CancellationToken): Promise<T>;\n\n\t/**\n\t * Abstract method which computes the sticky model from the model returned by the provider and returns the sticky model\n\t * @param token cancellation token\n\t * @param model model returned by the provider\n\t * @returns the sticky model\n\t */\n\tprotected abstract createStickyModel(token: CancellationToken, model: T): StickyModel;\n}\n\nclass StickyModelFromCandidateOutlineProvider extends StickyModelCandidateProvider<OutlineModel> {\n\n\tconstructor(_editor: IActiveCodeEditor, @ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper(_editor);\n\t}\n\n\tprotected createModelFromProvider(token: CancellationToken): Promise<OutlineModel> {\n\t\treturn OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._editor.getModel(), token);\n\t}\n\n\tprotected createStickyModel(token: CancellationToken, model: OutlineModel): StickyModel {\n\t\tconst { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);\n\t\tconst textModel = this._editor.getModel();\n\t\treturn new StickyModel(textModel.uri, textModel.getVersionId(), stickyOutlineElement, providerID);\n\t}\n\n\tprotected override isModelValid(model: OutlineModel): boolean {\n\t\treturn model && model.children.size > 0;\n\t}\n\n\tprivate _stickyModelFromOutlineModel(outlineModel: OutlineModel, preferredProvider: string | undefined): { stickyOutlineElement: StickyElement; providerID: string | undefined } {\n\n\t\tlet outlineElements: Map<string, OutlineElement>;\n\t\t// When several possible outline providers\n\t\tif (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n\t\t\tconst provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n\t\t\tif (provider) {\n\t\t\t\toutlineElements = provider.children;\n\t\t\t} else {\n\t\t\t\tlet tempID = '';\n\t\t\t\tlet maxTotalSumOfRanges = -1;\n\t\t\t\tlet optimalOutlineGroup = undefined;\n\t\t\t\tfor (const [_key, outlineGroup] of outlineModel.children.entries()) {\n\t\t\t\t\tconst totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);\n\t\t\t\t\tif (totalSumRanges > maxTotalSumOfRanges) {\n\t\t\t\t\t\toptimalOutlineGroup = outlineGroup;\n\t\t\t\t\t\tmaxTotalSumOfRanges = totalSumRanges;\n\t\t\t\t\t\ttempID = outlineGroup.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreferredProvider = tempID;\n\t\t\t\toutlineElements = optimalOutlineGroup!.children;\n\t\t\t}\n\t\t} else {\n\t\t\toutlineElements = outlineModel.children as Map<string, OutlineElement>;\n\t\t}\n\t\tconst stickyChildren: StickyElement[] = [];\n\t\tconst outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n\t\t\tconst range1: StickyRange = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n\t\t\tconst range2: StickyRange = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n\t\t\treturn this._comparator(range1, range2);\n\t\t});\n\t\tfor (const outlineElement of outlineElementsArray) {\n\t\t\tstickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n\t\t}\n\t\tconst stickyOutlineElement = new StickyElement(undefined, stickyChildren, undefined);\n\n\t\treturn {\n\t\t\tstickyOutlineElement: stickyOutlineElement,\n\t\t\tproviderID: preferredProvider\n\t\t};\n\t}\n\n\tprivate _stickyModelFromOutlineElement(outlineElement: OutlineElement, previousStartLine: number): StickyElement {\n\t\tconst children: StickyElement[] = [];\n\t\tfor (const child of outlineElement.children.values()) {\n\t\t\tif (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n\t\t\t\tif (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t} else {\n\t\t\t\t\tfor (const subchild of child.children.values()) {\n\t\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchildren.sort((child1, child2) => this._comparator(child1.range!, child2.range!));\n\t\tconst range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n\t\treturn new StickyElement(range, children, undefined);\n\t}\n\n\tprivate _comparator(range1: StickyRange, range2: StickyRange): number {\n\t\tif (range1.startLineNumber !== range2.startLineNumber) {\n\t\t\treturn range1.startLineNumber - range2.startLineNumber;\n\t\t} else {\n\t\t\treturn range2.endLineNumber - range1.endLineNumber;\n\t\t}\n\t}\n\n\tprivate _findSumOfRangesOfGroup(outline: OutlineGroup | OutlineElement): number {\n\t\tlet res = 0;\n\t\tfor (const child of outline.children.values()) {\n\t\t\tres += this._findSumOfRangesOfGroup(child);\n\t\t}\n\t\tif (outline instanceof OutlineElement) {\n\t\t\treturn res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nabstract class StickyModelFromCandidateFoldingProvider extends StickyModelCandidateProvider<FoldingRegions | null> {\n\n\tprotected _foldingLimitReporter: RangesLimitReporter;\n\n\tconstructor(editor: IActiveCodeEditor) {\n\t\tsuper(editor);\n\t\tthis._foldingLimitReporter = this._register(new RangesLimitReporter(editor));\n\t}\n\n\tprotected createStickyModel(token: CancellationToken, model: FoldingRegions): StickyModel {\n\t\tconst foldingElement = this._fromFoldingRegions(model);\n\t\tconst textModel = this._editor.getModel();\n\t\treturn new StickyModel(textModel.uri, textModel.getVersionId(), foldingElement, undefined);\n\t}\n\n\tprotected override isModelValid(model: FoldingRegions): boolean {\n\t\treturn model !== null;\n\t}\n\n\n\tprivate _fromFoldingRegions(foldingRegions: FoldingRegions): StickyElement {\n\t\tconst length = foldingRegions.length;\n\t\tconst orderedStickyElements: StickyElement[] = [];\n\n\t\t// The root sticky outline element\n\t\tconst stickyOutlineElement = new StickyElement(\n\t\t\tundefined,\n\t\t\t[],\n\t\t\tundefined\n\t\t);\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Finding the parent index of the current range\n\t\t\tconst parentIndex = foldingRegions.getParentIndex(i);\n\n\t\t\tlet parentNode;\n\t\t\tif (parentIndex !== -1) {\n\t\t\t\t// Access the reference of the parent node\n\t\t\t\tparentNode = orderedStickyElements[parentIndex];\n\t\t\t} else {\n\t\t\t\t// In that case the parent node is the root node\n\t\t\t\tparentNode = stickyOutlineElement;\n\t\t\t}\n\n\t\t\tconst child = new StickyElement(\n\t\t\t\tnew StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1),\n\t\t\t\t[],\n\t\t\t\tparentNode\n\t\t\t);\n\t\t\tparentNode.children.push(child);\n\t\t\torderedStickyElements.push(child);\n\t\t}\n\t\treturn stickyOutlineElement;\n\t}\n}\n\nclass StickyModelFromCandidateIndentationFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tprivate readonly provider: IndentRangeProvider;\n\n\tconstructor(\n\t\teditor: IActiveCodeEditor,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService) {\n\t\tsuper(editor);\n\n\t\tthis.provider = this._register(new IndentRangeProvider(editor.getModel(), this._languageConfigurationService, this._foldingLimitReporter));\n\t}\n\n\tprotected override async createModelFromProvider(token: CancellationToken): Promise<FoldingRegions> {\n\t\treturn this.provider.compute(token);\n\t}\n}\n\nclass StickyModelFromCandidateSyntaxFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tprivate readonly provider: MutableDisposable<SyntaxRangeProvider> = this._register(new MutableDisposable<SyntaxRangeProvider>());\n\n\tconstructor(\n\t\teditor: IActiveCodeEditor,\n\t\tonProviderUpdate: () => void,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService\n\t) {\n\t\tsuper(editor);\n\t\tthis._register(this._languageFeaturesService.foldingRangeProvider.onDidChange(() => {\n\t\t\tthis._updateProvider(editor, onProviderUpdate);\n\t\t}));\n\t\tthis._updateProvider(editor, onProviderUpdate);\n\t}\n\n\tprivate _updateProvider(editor: IActiveCodeEditor, onProviderUpdate: () => void): void {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, editor.getModel());\n\t\tif (selectedProviders.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.provider.value = new SyntaxRangeProvider(editor.getModel(), selectedProviders, onProviderUpdate, this._foldingLimitReporter, undefined);\n\t}\n\n\tprotected override isProviderValid(): boolean {\n\t\treturn this.provider !== undefined;\n\t}\n\n\tprotected override async createModelFromProvider(token: CancellationToken): Promise<FoldingRegions | null> {\n\t\treturn this.provider.value?.compute(token) ?? null;\n\t}\n}\n"]}