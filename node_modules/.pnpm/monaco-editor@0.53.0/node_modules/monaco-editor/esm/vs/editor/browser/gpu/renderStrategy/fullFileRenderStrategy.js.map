{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.ts","vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.ts"],"names":[],"mappings":"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","file":"fullFileRenderStrategy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { ViewEventType, type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\ntype QueuedBufferEvent = (\n\tViewConfigurationChangedEvent |\n\tViewLineMappingChangedEvent |\n\tViewLinesDeletedEvent |\n\tViewZonesChangedEvent\n);\n\n/**\n * A render strategy that tracks a large buffer, uploading only dirty lines as they change and\n * leveraging heavy caching. This is the most performant strategy but has limitations around long\n * lines and too many lines.\n */\nexport class FullFileRenderStrategy extends BaseRenderStrategy {\n\n\t/**\n\t * The hard cap for line count that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedLines = 3000;\n\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 200;\n\n\treadonly type = 'fullfile';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [new Set(), new Set()];\n\tprivate _visibleObjectCount: number = 0;\n\tprivate _finalRenderedLine: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tprivate readonly _queuedBufferUpdates: [QueuedBufferEvent[], QueuedBufferEvent[]] = [[], []];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tconst bufferSize = FullFileRenderStrategy.maxSupportedLines * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\t// TODO: This currently fires for the entire viewport whenever scrolling stops\n\t\t//       https://github.com/microsoft/vscode/issues/233942\n\t\tfor (const range of e.ranges) {\n\t\t\tthis._invalidateLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\t// TODO: This does not invalidate lines that are no longer in the file\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\tthis._invalidateLineRange(e.fromLineNumber, e.fromLineNumber + e.count);\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _invalidateAllLines(): void {\n\t\tthis._upToDateLines[0].clear();\n\t\tthis._upToDateLines[1].clear();\n\t}\n\n\tprivate _invalidateLinesFrom(lineNumber: number): void {\n\t\tfor (const i of [0, 1]) {\n\t\t\tconst upToDateLines = this._upToDateLines[i];\n\t\t\tfor (const upToDateLine of upToDateLines) {\n\t\t\t\tif (upToDateLine >= lineNumber) {\n\t\t\t\t\tupToDateLines.delete(upToDateLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _invalidateLineRange(fromLineNumber: number, toLineNumber: number): void {\n\t\tfor (let i = fromLineNumber; i <= toLineNumber; i++) {\n\t\t\tthis._upToDateLines[0].delete(i);\n\t\t\tthis._upToDateLines[1].delete(i);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._invalidateAllLines();\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t\tthis._finalRenderedLine = 0;\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tconst lineIndexCount = FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = 3000;\n\t\tlet dirtyLineEnd = 0;\n\n\t\t// Handle any queued buffer updates\n\t\tconst queuedBufferUpdates = this._queuedBufferUpdates[this._activeDoubleBufferIndex];\n\t\twhile (queuedBufferUpdates.length) {\n\t\t\tconst e = queuedBufferUpdates.shift()!;\n\t\t\tswitch (e.type) {\n\t\t\t\t// TODO: Refine these cases so we're not throwing away everything\n\t\t\t\tcase ViewEventType.ViewConfigurationChanged:\n\t\t\t\tcase ViewEventType.ViewLineMappingChanged:\n\t\t\t\tcase ViewEventType.ViewZonesChanged: {\n\t\t\t\t\tcellBuffer.fill(0);\n\n\t\t\t\t\tdirtyLineStart = 1;\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase ViewEventType.ViewLinesDeleted: {\n\t\t\t\t\t// Shift content below deleted line up\n\t\t\t\t\tconst deletedLineContentStartIndex = (e.fromLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst deletedLineContentEndIndex = (e.toLineNumber) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst nullContentStartIndex = (this._finalRenderedLine - (e.toLineNumber - e.fromLineNumber + 1)) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer.set(cellBuffer.subarray(deletedLineContentEndIndex), deletedLineContentStartIndex);\n\n\t\t\t\t\t// Zero out content on lines that are no longer valid\n\t\t\t\t\tcellBuffer.fill(0, nullContentStartIndex);\n\n\t\t\t\t\t// Update dirty lines and final rendered line\n\t\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, e.fromLineNumber);\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine -= e.toLineNumber - e.fromLineNumber + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip updating the line if it's already up to date\n\t\t\tif (upToDateLines.has(y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tdirtyLineStart = Math.min(dirtyLineStart, FullFileRenderStrategy.maxSupportedLines);\n\t\tdirtyLineEnd = Math.min(dirtyLineEnd, FullFileRenderStrategy.maxSupportedLines);\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t\t);\n\t\t}\n\n\t\tthis._finalRenderedLine = Math.max(this._finalRenderedLine, dirtyLineEnd);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns\n\t\t);\n\t}\n\n\t/**\n\t * Queue updates that need to happen on the active buffer, not just the cache. This will be\n\t * deferred to when the actual cell buffer is changed since the active buffer could be locked by\n\t * the GPU which would block the main thread.\n\t */\n\tprivate _queueBufferUpdate(e: QueuedBufferEvent) {\n\t\tthis._queuedBufferUpdates[0].push(e);\n\t\tthis._queuedBufferUpdates[1].push(e);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { ViewEventType, type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\ntype QueuedBufferEvent = (\n\tViewConfigurationChangedEvent |\n\tViewLineMappingChangedEvent |\n\tViewLinesDeletedEvent |\n\tViewZonesChangedEvent\n);\n\n/**\n * A render strategy that tracks a large buffer, uploading only dirty lines as they change and\n * leveraging heavy caching. This is the most performant strategy but has limitations around long\n * lines and too many lines.\n */\nexport class FullFileRenderStrategy extends BaseRenderStrategy {\n\n\t/**\n\t * The hard cap for line count that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedLines = 3000;\n\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 200;\n\n\treadonly type = 'fullfile';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [new Set(), new Set()];\n\tprivate _visibleObjectCount: number = 0;\n\tprivate _finalRenderedLine: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tprivate readonly _queuedBufferUpdates: [QueuedBufferEvent[], QueuedBufferEvent[]] = [[], []];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tconst bufferSize = FullFileRenderStrategy.maxSupportedLines * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\t// TODO: This currently fires for the entire viewport whenever scrolling stops\n\t\t//       https://github.com/microsoft/vscode/issues/233942\n\t\tfor (const range of e.ranges) {\n\t\t\tthis._invalidateLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\t// TODO: This does not invalidate lines that are no longer in the file\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\tthis._invalidateLineRange(e.fromLineNumber, e.fromLineNumber + e.count);\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _invalidateAllLines(): void {\n\t\tthis._upToDateLines[0].clear();\n\t\tthis._upToDateLines[1].clear();\n\t}\n\n\tprivate _invalidateLinesFrom(lineNumber: number): void {\n\t\tfor (const i of [0, 1]) {\n\t\t\tconst upToDateLines = this._upToDateLines[i];\n\t\t\tfor (const upToDateLine of upToDateLines) {\n\t\t\t\tif (upToDateLine >= lineNumber) {\n\t\t\t\t\tupToDateLines.delete(upToDateLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _invalidateLineRange(fromLineNumber: number, toLineNumber: number): void {\n\t\tfor (let i = fromLineNumber; i <= toLineNumber; i++) {\n\t\t\tthis._upToDateLines[0].delete(i);\n\t\t\tthis._upToDateLines[1].delete(i);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._invalidateAllLines();\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t\tthis._finalRenderedLine = 0;\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tconst lineIndexCount = FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = 3000;\n\t\tlet dirtyLineEnd = 0;\n\n\t\t// Handle any queued buffer updates\n\t\tconst queuedBufferUpdates = this._queuedBufferUpdates[this._activeDoubleBufferIndex];\n\t\twhile (queuedBufferUpdates.length) {\n\t\t\tconst e = queuedBufferUpdates.shift()!;\n\t\t\tswitch (e.type) {\n\t\t\t\t// TODO: Refine these cases so we're not throwing away everything\n\t\t\t\tcase ViewEventType.ViewConfigurationChanged:\n\t\t\t\tcase ViewEventType.ViewLineMappingChanged:\n\t\t\t\tcase ViewEventType.ViewZonesChanged: {\n\t\t\t\t\tcellBuffer.fill(0);\n\n\t\t\t\t\tdirtyLineStart = 1;\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase ViewEventType.ViewLinesDeleted: {\n\t\t\t\t\t// Shift content below deleted line up\n\t\t\t\t\tconst deletedLineContentStartIndex = (e.fromLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst deletedLineContentEndIndex = (e.toLineNumber) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst nullContentStartIndex = (this._finalRenderedLine - (e.toLineNumber - e.fromLineNumber + 1)) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer.set(cellBuffer.subarray(deletedLineContentEndIndex), deletedLineContentStartIndex);\n\n\t\t\t\t\t// Zero out content on lines that are no longer valid\n\t\t\t\t\tcellBuffer.fill(0, nullContentStartIndex);\n\n\t\t\t\t\t// Update dirty lines and final rendered line\n\t\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, e.fromLineNumber);\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine -= e.toLineNumber - e.fromLineNumber + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip updating the line if it's already up to date\n\t\t\tif (upToDateLines.has(y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tdirtyLineStart = Math.min(dirtyLineStart, FullFileRenderStrategy.maxSupportedLines);\n\t\tdirtyLineEnd = Math.min(dirtyLineEnd, FullFileRenderStrategy.maxSupportedLines);\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t\t);\n\t\t}\n\n\t\tthis._finalRenderedLine = Math.max(this._finalRenderedLine, dirtyLineEnd);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns\n\t\t);\n\t}\n\n\t/**\n\t * Queue updates that need to happen on the active buffer, not just the cache. This will be\n\t * deferred to when the actual cell buffer is changed since the active buffer could be locked by\n\t * the GPU which would block the main thread.\n\t */\n\tprivate _queueBufferUpdate(e: QueuedBufferEvent) {\n\t\tthis._queuedBufferUpdates[0].push(e);\n\t\tthis._queuedBufferUpdates[1].push(e);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n"]}