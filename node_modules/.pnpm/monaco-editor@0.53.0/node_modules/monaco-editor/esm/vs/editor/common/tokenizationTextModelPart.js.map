{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/tokenizationTextModelPart.ts","vs/editor/common/tokenizationTextModelPart.ts"],"names":[],"mappings":"AAAA;;;gGAGgG","file":"tokenizationTextModelPart.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from './core/range.js';\nimport { StandardTokenType } from './encodedTokenAttributes.js';\nimport { LineTokens } from './tokens/lineTokens.js';\nimport { SparseMultilineTokens } from './tokens/sparseMultilineTokens.js';\n\n/**\n * Provides tokenization related functionality of the text model.\n*/\nexport interface ITokenizationTextModelPart {\n\treadonly hasTokens: boolean;\n\n\t/**\n\t * Replaces all semantic tokens with the provided `tokens`.\n\t * @internal\n\t */\n\tsetSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void;\n\n\t/**\n\t * Merges the provided semantic tokens into existing semantic tokens.\n\t * @internal\n\t */\n\tsetPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\thasCompleteSemanticTokens(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\thasSomeSemanticTokens(): boolean;\n\n\t/**\n\t * Flush all tokenization state.\n\t * @internal\n\t */\n\tresetTokenization(): void;\n\n\t/**\n\t * Force tokenization information for `lineNumber` to be accurate.\n\t * @internal\n\t */\n\tforceTokenization(lineNumber: number): void;\n\n\t/**\n\t * If it is cheap, force tokenization information for `lineNumber` to be accurate.\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\ttokenizeIfCheap(lineNumber: number): void;\n\n\t/**\n\t * Check if tokenization information is accurate for `lineNumber`.\n\t * @internal\n\t */\n\thasAccurateTokensForLine(lineNumber: number): boolean;\n\n\t/**\n\t * Check if calling `forceTokenization` for this `lineNumber` will be cheap (time-wise).\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\tisCheapToTokenize(lineNumber: number): boolean;\n\n\t/**\n\t * Get the tokens for the line `lineNumber`.\n\t * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLineTokens(lineNumber: number): LineTokens;\n\n\t/**\n\t* Returns the standard token type for a character if the character were to be inserted at\n\t* the given position. If the result cannot be accurate, it returns null.\n\t* @internal\n\t*/\n\tgetTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;\n\n\t/**\n\t * Tokens the lines as if they were inserted at [lineNumber, lineNumber).\n\t * @internal\n\t*/\n\ttokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null;\n\n\tgetLanguageId(): string;\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\tsetLanguageId(languageId: string, source?: string): void;\n\n\treadonly backgroundTokenizationState: BackgroundTokenizationState;\n}\n\nexport const enum BackgroundTokenizationState {\n\tInProgress = 1,\n\tCompleted = 2,\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from './core/range.js';\nimport { StandardTokenType } from './encodedTokenAttributes.js';\nimport { LineTokens } from './tokens/lineTokens.js';\nimport { SparseMultilineTokens } from './tokens/sparseMultilineTokens.js';\n\n/**\n * Provides tokenization related functionality of the text model.\n*/\nexport interface ITokenizationTextModelPart {\n\treadonly hasTokens: boolean;\n\n\t/**\n\t * Replaces all semantic tokens with the provided `tokens`.\n\t * @internal\n\t */\n\tsetSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void;\n\n\t/**\n\t * Merges the provided semantic tokens into existing semantic tokens.\n\t * @internal\n\t */\n\tsetPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\thasCompleteSemanticTokens(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\thasSomeSemanticTokens(): boolean;\n\n\t/**\n\t * Flush all tokenization state.\n\t * @internal\n\t */\n\tresetTokenization(): void;\n\n\t/**\n\t * Force tokenization information for `lineNumber` to be accurate.\n\t * @internal\n\t */\n\tforceTokenization(lineNumber: number): void;\n\n\t/**\n\t * If it is cheap, force tokenization information for `lineNumber` to be accurate.\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\ttokenizeIfCheap(lineNumber: number): void;\n\n\t/**\n\t * Check if tokenization information is accurate for `lineNumber`.\n\t * @internal\n\t */\n\thasAccurateTokensForLine(lineNumber: number): boolean;\n\n\t/**\n\t * Check if calling `forceTokenization` for this `lineNumber` will be cheap (time-wise).\n\t * This is based on a heuristic.\n\t * @internal\n\t */\n\tisCheapToTokenize(lineNumber: number): boolean;\n\n\t/**\n\t * Get the tokens for the line `lineNumber`.\n\t * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLineTokens(lineNumber: number): LineTokens;\n\n\t/**\n\t* Returns the standard token type for a character if the character were to be inserted at\n\t* the given position. If the result cannot be accurate, it returns null.\n\t* @internal\n\t*/\n\tgetTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;\n\n\t/**\n\t * Tokens the lines as if they were inserted at [lineNumber, lineNumber).\n\t * @internal\n\t*/\n\ttokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null;\n\n\tgetLanguageId(): string;\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\tsetLanguageId(languageId: string, source?: string): void;\n\n\treadonly backgroundTokenizationState: BackgroundTokenizationState;\n}\n\nexport const enum BackgroundTokenizationState {\n\tInProgress = 1,\n\tCompleted = 2,\n}\n"]}