{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts","vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts"],"names":[],"mappings":"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","file":"linesSliceCharSequence.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n"]}