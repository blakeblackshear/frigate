{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/languages/autoIndent.ts","vs/editor/common/languages/autoIndent.ts"],"names":[],"mappings":"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","file":"autoIndent.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { ITextModel } from '../model.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { IndentConsts } from './supports/indentRules.js';\nimport { EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { ILanguageConfigurationService } from './languageConfigurationRegistry.js';\nimport { IViewLineTokens } from '../tokens/lineTokens.js';\nimport { IndentationContextProcessor, isLanguageDifferentFromLineStart, ProcessedIndentRulesSupport } from './supports/indentationLineProcessor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\n\nexport interface IVirtualModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t\tgetLanguageId(): string;\n\t\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\t\tforceTokenization?(lineNumber: number): void;\n\t};\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model: IVirtualModel, lineNumber: number, processedIndentRulesSupport: ProcessedIndentRulesSupport) {\n\tconst languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n\tif (lineNumber > 1) {\n\t\tlet lastLineNumber: number;\n\t\tlet resultLineNumber = -1;\n\n\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\tif (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n\t\t\t\treturn resultLineNumber;\n\t\t\t}\n\t\t\tconst text = model.getLineContent(lastLineNumber);\n\t\t\tif (processedIndentRulesSupport.shouldIgnore(lastLineNumber) || /^\\s+$/.test(text) || text === '') {\n\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn lastLineNumber;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\thonorIntentialIndent: boolean = true,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { indentation: string; action: IndentAction | null; line?: number } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentRulesSupport, languageConfigurationService);\n\n\tif (lineNumber <= 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\t// Use no indent if this is the first non-blank line\n\tfor (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n\t\tif (model.getLineContent(priorLineNumber) !== '') {\n\t\t\tbreak;\n\t\t}\n\t\tif (priorLineNumber === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\t}\n\n\tconst precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport);\n\tif (precedingUnIgnoredLine < 0) {\n\t\treturn null;\n\t} else if (precedingUnIgnoredLine < 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\tif (processedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) || processedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: IndentAction.Indent,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else if (processedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: null,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else {\n\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t// it doesn't increase indent of following lines\n\t\t// it doesn't increase just next line\n\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t// and then we should get a correct inheritted indentation from above lines\n\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t}\n\n\t\tconst previousLine = precedingUnIgnoredLine - 1;\n\n\t\tconst previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\t\tif (!(previousLineIndentMetadata & (IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)) &&\n\t\t\t(previousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK)) {\n\t\t\tlet stopLine = 0;\n\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstopLine = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\taction: null,\n\t\t\t\tline: stopLine + 1\n\t\t\t};\n\t\t}\n\n\t\tif (honorIntentialIndent) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else {\n\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIncrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t} else if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\tif (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: stopLine + 1\n\t\t\t\t\t};\n\t\t\t\t} else if (processedIndentRulesSupport.shouldDecrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n\t\t\t\taction: null,\n\t\t\t\tline: 1\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function getGoodIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tvirtualModel: IVirtualModel,\n\tlanguageId: string,\n\tlineNumber: number,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n\tif (!richEditSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(virtualModel, indentRulesSupport, languageConfigurationService);\n\tconst indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n\n\tif (indent) {\n\t\tconst inheritLine = indent.line;\n\t\tif (inheritLine !== undefined) {\n\t\t\t// Apply enter action as long as there are only whitespace lines between inherited line and this line.\n\t\t\tlet shouldApplyEnterRules = true;\n\t\t\tfor (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n\t\t\t\tif (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n\t\t\t\t\tshouldApplyEnterRules = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldApplyEnterRules) {\n\t\t\t\tconst enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (enterResult.indentAction === IndentAction.Outdent) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indent.indentation;\n\t\t\t} else {\n\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t}\n\t\t} else {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t\t} else {\n\t\t\t\treturn indent.indentation;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport function getIndentForEnter(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { beforeEnter: string; afterEnter: string } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tmodel.tokenization.forceTokenization(range.startLineNumber);\n\tconst indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n\tconst processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst afterEnterProcessedTokens = processedContextTokens.afterRangeProcessedTokens;\n\tconst beforeEnterProcessedTokens = processedContextTokens.beforeRangeProcessedTokens;\n\tconst beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterProcessedTokens.getLineContent());\n\n\tconst virtualModel = createVirtualModelWithModifiedTokensAtLine(model, range.startLineNumber, beforeEnterProcessedTokens);\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n\tconst currentLine = model.getLineContent(range.startLineNumber);\n\tconst currentLineIndent = strings.getLeadingWhitespace(currentLine);\n\tconst afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n\tif (!afterEnterAction) {\n\t\tconst beforeEnter = languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent;\n\t\treturn {\n\t\t\tbeforeEnter: beforeEnter,\n\t\t\tafterEnter: beforeEnter\n\t\t};\n\t}\n\n\tlet afterEnterIndent = languageIsDifferentFromLineStart ? currentLineIndent : afterEnterAction.indentation;\n\n\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t}\n\n\tif (indentRulesSupport.shouldDecrease(afterEnterProcessedTokens.getLineContent())) {\n\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t}\n\n\treturn {\n\t\tbeforeEnter: languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent,\n\t\tafterEnter: afterEnterIndent\n\t};\n}\n\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(\n\tcursorConfig: CursorConfiguration,\n\tmodel: ITextModel,\n\trange: Range,\n\tch: string,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tconst autoIndent = cursorConfig.autoIndent;\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n\tif (languageIsDifferentFromLineStart) {\n\t\t// this line has mixed languages and indentation rules will not work\n\t\treturn null;\n\t}\n\n\tconst languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n\tconst processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst beforeRangeText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n\tconst afterRangeText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n\tconst textAroundRange = beforeRangeText + afterRangeText;\n\tconst textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n\n\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\tif (!indentRulesSupport.shouldDecrease(textAroundRange) && indentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)) {\n\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t// 1. Get inherited indent action\n\t\tconst r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indentation = r.indentation;\n\t\tif (r.action !== IndentAction.Indent) {\n\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\tconst previousLineNumber = range.startLineNumber - 1;\n\tif (previousLineNumber > 0) {\n\t\tconst previousLine = model.getLineContent(previousLineNumber);\n\t\tif (indentRulesSupport.shouldIndentNextLine(previousLine) && indentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)) {\n\t\t\tconst inheritedIndentationData = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\t\tconst inheritedIndentation = inheritedIndentationData?.indentation;\n\t\t\tif (inheritedIndentation !== undefined) {\n\t\t\t\tconst currentLine = model.getLineContent(range.startLineNumber);\n\t\t\t\tconst actualCurrentIndentation = strings.getLeadingWhitespace(currentLine);\n\t\t\t\tconst inferredCurrentIndentation = indentConverter.shiftIndent(inheritedIndentation);\n\t\t\t\t// If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n\t\t\t\tconst inferredIndentationEqualsActual = inferredCurrentIndentation === actualCurrentIndentation;\n\t\t\t\tconst textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(textAroundRange);\n\t\t\t\tconst autoClosingPairs = cursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\t\t\tconst autoClosingPairExists = autoClosingPairs && autoClosingPairs.length > 0;\n\t\t\t\tconst isChFirstNonWhitespaceCharacterAndInAutoClosingPair = autoClosingPairExists && textAroundRangeContainsOnlyWhitespace;\n\t\t\t\tif (inferredIndentationEqualsActual && isChFirstNonWhitespaceCharacterAndInAutoClosingPair) {\n\t\t\t\t\treturn inheritedIndentation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getIndentMetadata(\n\tmodel: ITextModel,\n\tlineNumber: number,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): number | null {\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\treturn null;\n\t}\n\treturn indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n\nfunction createVirtualModelWithModifiedTokensAtLine(model: ITextModel, modifiedLineNumber: number, modifiedTokens: IViewLineTokens): IVirtualModel {\n\tconst virtualModel: IVirtualModel = {\n\t\ttokenization: {\n\t\t\tgetLineTokens: (lineNumber: number): IViewLineTokens => {\n\t\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\t\treturn modifiedTokens;\n\t\t\t\t} else {\n\t\t\t\t\treturn model.tokenization.getLineTokens(lineNumber);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetLanguageId: (): string => {\n\t\t\t\treturn model.getLanguageId();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (lineNumber: number, column: number): string => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t},\n\t\tgetLineContent: (lineNumber: number): string => {\n\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\treturn modifiedTokens.getLineContent();\n\t\t\t} else {\n\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t}\n\t\t}\n\t};\n\treturn virtualModel;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { ITextModel } from '../model.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { IndentConsts } from './supports/indentRules.js';\nimport { EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { ILanguageConfigurationService } from './languageConfigurationRegistry.js';\nimport { IViewLineTokens } from '../tokens/lineTokens.js';\nimport { IndentationContextProcessor, isLanguageDifferentFromLineStart, ProcessedIndentRulesSupport } from './supports/indentationLineProcessor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\n\nexport interface IVirtualModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t\tgetLanguageId(): string;\n\t\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\t\tforceTokenization?(lineNumber: number): void;\n\t};\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model: IVirtualModel, lineNumber: number, processedIndentRulesSupport: ProcessedIndentRulesSupport) {\n\tconst languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n\tif (lineNumber > 1) {\n\t\tlet lastLineNumber: number;\n\t\tlet resultLineNumber = -1;\n\n\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\tif (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n\t\t\t\treturn resultLineNumber;\n\t\t\t}\n\t\t\tconst text = model.getLineContent(lastLineNumber);\n\t\t\tif (processedIndentRulesSupport.shouldIgnore(lastLineNumber) || /^\\s+$/.test(text) || text === '') {\n\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn lastLineNumber;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\thonorIntentialIndent: boolean = true,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { indentation: string; action: IndentAction | null; line?: number } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentRulesSupport, languageConfigurationService);\n\n\tif (lineNumber <= 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\t// Use no indent if this is the first non-blank line\n\tfor (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n\t\tif (model.getLineContent(priorLineNumber) !== '') {\n\t\t\tbreak;\n\t\t}\n\t\tif (priorLineNumber === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\t}\n\n\tconst precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport);\n\tif (precedingUnIgnoredLine < 0) {\n\t\treturn null;\n\t} else if (precedingUnIgnoredLine < 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\tif (processedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) || processedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: IndentAction.Indent,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else if (processedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)) {\n\t\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: null,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else {\n\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t// it doesn't increase indent of following lines\n\t\t// it doesn't increase just next line\n\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t// and then we should get a correct inheritted indentation from above lines\n\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t}\n\n\t\tconst previousLine = precedingUnIgnoredLine - 1;\n\n\t\tconst previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\t\tif (!(previousLineIndentMetadata & (IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)) &&\n\t\t\t(previousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK)) {\n\t\t\tlet stopLine = 0;\n\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstopLine = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\taction: null,\n\t\t\t\tline: stopLine + 1\n\t\t\t};\n\t\t}\n\n\t\tif (honorIntentialIndent) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else {\n\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\tif (processedIndentRulesSupport.shouldIncrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t} else if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\tif (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: stopLine + 1\n\t\t\t\t\t};\n\t\t\t\t} else if (processedIndentRulesSupport.shouldDecrease(i)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n\t\t\t\taction: null,\n\t\t\t\tline: 1\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function getGoodIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tvirtualModel: IVirtualModel,\n\tlanguageId: string,\n\tlineNumber: number,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n\tif (!richEditSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst processedIndentRulesSupport = new ProcessedIndentRulesSupport(virtualModel, indentRulesSupport, languageConfigurationService);\n\tconst indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n\n\tif (indent) {\n\t\tconst inheritLine = indent.line;\n\t\tif (inheritLine !== undefined) {\n\t\t\t// Apply enter action as long as there are only whitespace lines between inherited line and this line.\n\t\t\tlet shouldApplyEnterRules = true;\n\t\t\tfor (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n\t\t\t\tif (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n\t\t\t\t\tshouldApplyEnterRules = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldApplyEnterRules) {\n\t\t\t\tconst enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (enterResult.indentAction === IndentAction.Outdent) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indent.indentation;\n\t\t\t} else {\n\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t}\n\t\t} else {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t\t} else {\n\t\t\t\treturn indent.indentation;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport function getIndentForEnter(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { beforeEnter: string; afterEnter: string } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tmodel.tokenization.forceTokenization(range.startLineNumber);\n\tconst indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n\tconst processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst afterEnterProcessedTokens = processedContextTokens.afterRangeProcessedTokens;\n\tconst beforeEnterProcessedTokens = processedContextTokens.beforeRangeProcessedTokens;\n\tconst beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterProcessedTokens.getLineContent());\n\n\tconst virtualModel = createVirtualModelWithModifiedTokensAtLine(model, range.startLineNumber, beforeEnterProcessedTokens);\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n\tconst currentLine = model.getLineContent(range.startLineNumber);\n\tconst currentLineIndent = strings.getLeadingWhitespace(currentLine);\n\tconst afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n\tif (!afterEnterAction) {\n\t\tconst beforeEnter = languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent;\n\t\treturn {\n\t\t\tbeforeEnter: beforeEnter,\n\t\t\tafterEnter: beforeEnter\n\t\t};\n\t}\n\n\tlet afterEnterIndent = languageIsDifferentFromLineStart ? currentLineIndent : afterEnterAction.indentation;\n\n\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t}\n\n\tif (indentRulesSupport.shouldDecrease(afterEnterProcessedTokens.getLineContent())) {\n\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t}\n\n\treturn {\n\t\tbeforeEnter: languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent,\n\t\tafterEnter: afterEnterIndent\n\t};\n}\n\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(\n\tcursorConfig: CursorConfiguration,\n\tmodel: ITextModel,\n\trange: Range,\n\tch: string,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tconst autoIndent = cursorConfig.autoIndent;\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n\tif (languageIsDifferentFromLineStart) {\n\t\t// this line has mixed languages and indentation rules will not work\n\t\treturn null;\n\t}\n\n\tconst languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n\tconst processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n\tconst beforeRangeText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n\tconst afterRangeText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n\tconst textAroundRange = beforeRangeText + afterRangeText;\n\tconst textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n\n\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\tif (!indentRulesSupport.shouldDecrease(textAroundRange) && indentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)) {\n\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t// 1. Get inherited indent action\n\t\tconst r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indentation = r.indentation;\n\t\tif (r.action !== IndentAction.Indent) {\n\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\tconst previousLineNumber = range.startLineNumber - 1;\n\tif (previousLineNumber > 0) {\n\t\tconst previousLine = model.getLineContent(previousLineNumber);\n\t\tif (indentRulesSupport.shouldIndentNextLine(previousLine) && indentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)) {\n\t\t\tconst inheritedIndentationData = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\t\tconst inheritedIndentation = inheritedIndentationData?.indentation;\n\t\t\tif (inheritedIndentation !== undefined) {\n\t\t\t\tconst currentLine = model.getLineContent(range.startLineNumber);\n\t\t\t\tconst actualCurrentIndentation = strings.getLeadingWhitespace(currentLine);\n\t\t\t\tconst inferredCurrentIndentation = indentConverter.shiftIndent(inheritedIndentation);\n\t\t\t\t// If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n\t\t\t\tconst inferredIndentationEqualsActual = inferredCurrentIndentation === actualCurrentIndentation;\n\t\t\t\tconst textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(textAroundRange);\n\t\t\t\tconst autoClosingPairs = cursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\t\t\tconst autoClosingPairExists = autoClosingPairs && autoClosingPairs.length > 0;\n\t\t\t\tconst isChFirstNonWhitespaceCharacterAndInAutoClosingPair = autoClosingPairExists && textAroundRangeContainsOnlyWhitespace;\n\t\t\t\tif (inferredIndentationEqualsActual && isChFirstNonWhitespaceCharacterAndInAutoClosingPair) {\n\t\t\t\t\treturn inheritedIndentation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getIndentMetadata(\n\tmodel: ITextModel,\n\tlineNumber: number,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): number | null {\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\treturn null;\n\t}\n\treturn indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n\nfunction createVirtualModelWithModifiedTokensAtLine(model: ITextModel, modifiedLineNumber: number, modifiedTokens: IViewLineTokens): IVirtualModel {\n\tconst virtualModel: IVirtualModel = {\n\t\ttokenization: {\n\t\t\tgetLineTokens: (lineNumber: number): IViewLineTokens => {\n\t\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\t\treturn modifiedTokens;\n\t\t\t\t} else {\n\t\t\t\t\treturn model.tokenization.getLineTokens(lineNumber);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetLanguageId: (): string => {\n\t\t\t\treturn model.getLanguageId();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (lineNumber: number, column: number): string => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t},\n\t\tgetLineContent: (lineNumber: number): string => {\n\t\t\tif (lineNumber === modifiedLineNumber) {\n\t\t\t\treturn modifiedTokens.getLineContent();\n\t\t\t} else {\n\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t}\n\t\t}\n\t};\n\treturn virtualModel;\n}\n\n"]}