{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.ts"],"names":[],"mappings":"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","file":"bracketPairsTree.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { ITextModel } from '../../../model.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo, IFoundBracket } from '../../../textModelBracketPairs.js';\nimport { TextModel } from '../../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './ast.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { Position } from '../../../core/position.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nimport { ClosingBracketKind, OpeningBracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\n\nexport class BracketPairsTree extends Disposable {\n\tprivate readonly didChangeEmitter;\n\n\t/*\n\t\tThere are two trees:\n\t\t* The initial tree that has no token information and is used for performant initial bracket colorization.\n\t\t* The tree that used token information to detect bracket pairs.\n\n\t\tTo prevent flickering, we only switch from the initial tree to tree with token information\n\t\twhen tokenization completes.\n\t\tSince the text can be edited while background tokenization is in progress, we need to update both trees.\n\t*/\n\tprivate initialAstWithoutTokens: AstNode | undefined;\n\tprivate astWithTokens: AstNode | undefined;\n\n\tprivate readonly denseKeyProvider;\n\tprivate readonly brackets;\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\treturn this.brackets.didLanguageChange(languageId);\n\t}\n\n\tpublic readonly onDidChange;\n\tprivate queuedTextEditsForInitialAstWithoutTokens: TextEditInfo[];\n\tprivate queuedTextEdits: TextEditInfo[];\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration\n\t) {\n\t\tsuper();\n\t\tthis.didChangeEmitter = new Emitter<void>();\n\t\tthis.denseKeyProvider = new DenseKeyProvider<string>();\n\t\tthis.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n\t\tthis.onDidChange = this.didChangeEmitter.event;\n\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\tthis.queuedTextEdits = [];\n\n\t\tif (!textModel.tokenization.hasTokens) {\n\t\t\tconst brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n\t\t\tconst tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n\t\t\tthis.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t} else if (textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t// Skip the initial ast, as there is no flickering.\n\t\t\t// Directly create the tree with token information.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n\t\t} else {\n\t\t\t// We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t}\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tif (this.textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\tconst wasUndefined = this.initialAstWithoutTokens === undefined;\n\t\t\t// Clear the initial tree as we can use the tree with token information now.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tif (!wasUndefined) {\n\t\t\t\tthis.didChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleDidChangeTokens({ ranges }: IModelTokensChangedEvent): void {\n\t\tconst edits = ranges.map(r =>\n\t\t\tnew TextEditInfo(\n\t\t\t\ttoLength(r.fromLineNumber - 1, 0),\n\t\t\t\ttoLength(r.toLineNumber, 0),\n\t\t\t\ttoLength(r.toLineNumber - r.fromLineNumber + 1, 0)\n\t\t\t)\n\t\t);\n\n\t\tthis.handleEdits(edits, true);\n\n\t\tif (!this.initialAstWithoutTokens) {\n\t\t\tthis.didChangeEmitter.fire();\n\t\t}\n\t}\n\n\tpublic handleContentChanged(change: IModelContentChangedEvent) {\n\t\tconst edits = TextEditInfo.fromModelContentChanges(change.changes);\n\t\tthis.handleEdits(edits, false);\n\t}\n\n\tprivate handleEdits(edits: TextEditInfo[], tokenChange: boolean): void {\n\t\t// Lazily queue the edits and only apply them when the tree is accessed.\n\t\tconst result = combineTextEditInfos(this.queuedTextEdits, edits);\n\n\t\tthis.queuedTextEdits = result;\n\t\tif (this.initialAstWithoutTokens && !tokenChange) {\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tprivate flushQueue() {\n\t\tif (this.queuedTextEdits.length > 0) {\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n\t\t\tthis.queuedTextEdits = [];\n\t\t}\n\t\tif (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n\t\t\tif (this.initialAstWithoutTokens) {\n\t\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n\t\t\t}\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\t}\n\t}\n\n\t/**\n\t * @pure (only if isPure = true)\n\t*/\n\tprivate parseDocumentFromTextBuffer(edits: TextEditInfo[], previousAst: AstNode | undefined, immutable: boolean): AstNode {\n\t\t// Is much faster if `isPure = false`.\n\t\tconst isPure = false;\n\t\tconst previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n\t\tconst tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n\t\tconst result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n\t\treturn result;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean): CallbackIterable<BracketInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n\t\tconst endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tcollectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n\t\t});\n\t}\n\n\tpublic getBracketPairsInRange(range: Range, includeMinIndentation: boolean): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startLength = positionToLength(range.getStartPosition());\n\t\tconst endLength = positionToLength(range.getEndPosition());\n\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tconst context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n\t\t\tcollectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n\t\t});\n\t}\n\n\tpublic getFirstBracketAfter(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n\t}\n\n\tpublic getFirstBracketBefore(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n\t}\n}\n\nfunction getFirstBracketBefore(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tconst lengths: { nodeOffsetStart: Length; nodeOffsetEnd: Length }[] = [];\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tlengths.push({ nodeOffsetStart, nodeOffsetEnd });\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\tfor (let i = lengths.length - 1; i >= 0; i--) {\n\t\t\tconst { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n\t\t\tif (lengthLessThan(nodeOffsetStart, position)) {\n\t\t\t\tconst result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction getFirstBracketAfter(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (lengthLessThan(position, nodeOffsetEnd)) {\n\t\t\t\tconst result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction collectBrackets(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tpush: (item: BracketInfo) => boolean,\n\tlevel: number,\n\tnestingLevelOfEqualBracketType: number,\n\tlevelPerBracketType: Map<string, number>,\n\tonlyColorizedBrackets: boolean,\n\tparentPairIsIncomplete: boolean = false,\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\twhileLoop:\n\twhile (true) {\n\t\tswitch (node.kind) {\n\t\t\tcase AstNodeKind.List: {\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.Pair: {\n\t\t\t\tconst colorize = !onlyColorizedBrackets || !node.closingBracket || (node.closingBracket.bracketInfo as ClosingBracketKind).closesColorized(node.openingBracket.bracketInfo as OpeningBracketKind);\n\n\t\t\t\tlet levelPerBracket = 0;\n\t\t\t\tif (levelPerBracketType) {\n\t\t\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\t\t\tif (existing === undefined) {\n\t\t\t\t\t\texisting = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlevelPerBracket = existing;\n\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\texisting++;\n\t\t\t\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd && child.kind !== AstNodeKind.Bracket) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\t// Don't do this for brackets because of unclosed/unopened brackets\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket + 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorize || child.kind !== AstNodeKind.Bracket || !node.closingBracket) {\n\t\t\t\t\t\t\tconst shouldContinue = collectBrackets(\n\t\t\t\t\t\t\t\tchild,\n\t\t\t\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\t\t\t\tstartOffset,\n\t\t\t\t\t\t\t\tendOffset,\n\t\t\t\t\t\t\t\tpush,\n\t\t\t\t\t\t\t\tcolorize ? level + 1 : level,\n\t\t\t\t\t\t\t\tcolorize ? levelPerBracket + 1 : levelPerBracket,\n\t\t\t\t\t\t\t\tlevelPerBracketType,\n\t\t\t\t\t\t\t\tonlyColorizedBrackets,\n\t\t\t\t\t\t\t\t!node.closingBracket,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\n\t\t\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.UnexpectedClosingBracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, 0, true));\n\t\t\t}\n\t\t\tcase AstNodeKind.Bracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n\t\t\t}\n\t\t\tcase AstNodeKind.Text:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass CollectBracketPairsContext {\n\tconstructor(\n\t\tpublic readonly push: (item: BracketPairWithMinIndentationInfo) => boolean,\n\t\tpublic readonly includeMinIndentation: boolean,\n\t\tpublic readonly textModel: ITextModel,\n\t) {\n\t}\n}\n\nfunction collectBracketPairs(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tcontext: CollectBracketPairsContext,\n\tlevel: number,\n\tlevelPerBracketType: Map<string, number>\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\tlet shouldContinue = true;\n\n\tif (node.kind === AstNodeKind.Pair) {\n\t\tlet levelPerBracket = 0;\n\t\tif (levelPerBracketType) {\n\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\tif (existing === undefined) {\n\t\t\t\texisting = 0;\n\t\t\t}\n\t\t\tlevelPerBracket = existing;\n\t\t\texisting++;\n\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t}\n\n\t\tconst openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n\t\tlet minIndentation = -1;\n\t\tif (context.includeMinIndentation) {\n\t\t\tminIndentation = node.computeMinIndentation(\n\t\t\t\tnodeOffsetStart,\n\t\t\t\tcontext.textModel\n\t\t\t);\n\t\t}\n\n\t\tshouldContinue = context.push(\n\t\t\tnew BracketPairWithMinIndentationInfo(\n\t\t\t\tlengthsToRange(nodeOffsetStart, nodeOffsetEnd),\n\t\t\t\tlengthsToRange(nodeOffsetStart, openingBracketEnd),\n\t\t\t\tnode.closingBracket\n\t\t\t\t\t? lengthsToRange(\n\t\t\t\t\t\tlengthAdd(openingBracketEnd, node.child?.length || lengthZero),\n\t\t\t\t\t\tnodeOffsetEnd\n\t\t\t\t\t)\n\t\t\t\t\t: undefined,\n\t\t\t\tlevel,\n\t\t\t\tlevelPerBracket,\n\t\t\t\tnode,\n\t\t\t\tminIndentation\n\t\t\t)\n\t\t);\n\n\t\tnodeOffsetStart = openingBracketEnd;\n\t\tif (shouldContinue && node.child) {\n\t\t\tconst child = node.child;\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel + 1,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\t} else {\n\t\tlet curOffset = nodeOffsetStart;\n\t\tfor (const child of node.children) {\n\t\t\tconst childOffset = curOffset;\n\t\t\tcurOffset = lengthAdd(curOffset, child.length);\n\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(childOffset, endOffset) &&\n\t\t\t\tlengthLessThanEqual(startOffset, curOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tchildOffset,\n\t\t\t\t\tcurOffset,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { ITextModel } from '../../../model.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo, IFoundBracket } from '../../../textModelBracketPairs.js';\nimport { TextModel } from '../../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './ast.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { Position } from '../../../core/position.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nimport { ClosingBracketKind, OpeningBracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\n\nexport class BracketPairsTree extends Disposable {\n\tprivate readonly didChangeEmitter;\n\n\t/*\n\t\tThere are two trees:\n\t\t* The initial tree that has no token information and is used for performant initial bracket colorization.\n\t\t* The tree that used token information to detect bracket pairs.\n\n\t\tTo prevent flickering, we only switch from the initial tree to tree with token information\n\t\twhen tokenization completes.\n\t\tSince the text can be edited while background tokenization is in progress, we need to update both trees.\n\t*/\n\tprivate initialAstWithoutTokens: AstNode | undefined;\n\tprivate astWithTokens: AstNode | undefined;\n\n\tprivate readonly denseKeyProvider;\n\tprivate readonly brackets;\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\treturn this.brackets.didLanguageChange(languageId);\n\t}\n\n\tpublic readonly onDidChange;\n\tprivate queuedTextEditsForInitialAstWithoutTokens: TextEditInfo[];\n\tprivate queuedTextEdits: TextEditInfo[];\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration\n\t) {\n\t\tsuper();\n\t\tthis.didChangeEmitter = new Emitter<void>();\n\t\tthis.denseKeyProvider = new DenseKeyProvider<string>();\n\t\tthis.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n\t\tthis.onDidChange = this.didChangeEmitter.event;\n\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\tthis.queuedTextEdits = [];\n\n\t\tif (!textModel.tokenization.hasTokens) {\n\t\t\tconst brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n\t\t\tconst tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n\t\t\tthis.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t} else if (textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t// Skip the initial ast, as there is no flickering.\n\t\t\t// Directly create the tree with token information.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n\t\t} else {\n\t\t\t// We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t}\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tif (this.textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\tconst wasUndefined = this.initialAstWithoutTokens === undefined;\n\t\t\t// Clear the initial tree as we can use the tree with token information now.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tif (!wasUndefined) {\n\t\t\t\tthis.didChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleDidChangeTokens({ ranges }: IModelTokensChangedEvent): void {\n\t\tconst edits = ranges.map(r =>\n\t\t\tnew TextEditInfo(\n\t\t\t\ttoLength(r.fromLineNumber - 1, 0),\n\t\t\t\ttoLength(r.toLineNumber, 0),\n\t\t\t\ttoLength(r.toLineNumber - r.fromLineNumber + 1, 0)\n\t\t\t)\n\t\t);\n\n\t\tthis.handleEdits(edits, true);\n\n\t\tif (!this.initialAstWithoutTokens) {\n\t\t\tthis.didChangeEmitter.fire();\n\t\t}\n\t}\n\n\tpublic handleContentChanged(change: IModelContentChangedEvent) {\n\t\tconst edits = TextEditInfo.fromModelContentChanges(change.changes);\n\t\tthis.handleEdits(edits, false);\n\t}\n\n\tprivate handleEdits(edits: TextEditInfo[], tokenChange: boolean): void {\n\t\t// Lazily queue the edits and only apply them when the tree is accessed.\n\t\tconst result = combineTextEditInfos(this.queuedTextEdits, edits);\n\n\t\tthis.queuedTextEdits = result;\n\t\tif (this.initialAstWithoutTokens && !tokenChange) {\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tprivate flushQueue() {\n\t\tif (this.queuedTextEdits.length > 0) {\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n\t\t\tthis.queuedTextEdits = [];\n\t\t}\n\t\tif (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n\t\t\tif (this.initialAstWithoutTokens) {\n\t\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n\t\t\t}\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\t}\n\t}\n\n\t/**\n\t * @pure (only if isPure = true)\n\t*/\n\tprivate parseDocumentFromTextBuffer(edits: TextEditInfo[], previousAst: AstNode | undefined, immutable: boolean): AstNode {\n\t\t// Is much faster if `isPure = false`.\n\t\tconst isPure = false;\n\t\tconst previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n\t\tconst tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n\t\tconst result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n\t\treturn result;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean): CallbackIterable<BracketInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n\t\tconst endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tcollectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n\t\t});\n\t}\n\n\tpublic getBracketPairsInRange(range: Range, includeMinIndentation: boolean): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startLength = positionToLength(range.getStartPosition());\n\t\tconst endLength = positionToLength(range.getEndPosition());\n\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tconst context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n\t\t\tcollectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n\t\t});\n\t}\n\n\tpublic getFirstBracketAfter(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n\t}\n\n\tpublic getFirstBracketBefore(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n\t}\n}\n\nfunction getFirstBracketBefore(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tconst lengths: { nodeOffsetStart: Length; nodeOffsetEnd: Length }[] = [];\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tlengths.push({ nodeOffsetStart, nodeOffsetEnd });\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\tfor (let i = lengths.length - 1; i >= 0; i--) {\n\t\t\tconst { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n\t\t\tif (lengthLessThan(nodeOffsetStart, position)) {\n\t\t\t\tconst result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction getFirstBracketAfter(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (lengthLessThan(position, nodeOffsetEnd)) {\n\t\t\t\tconst result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction collectBrackets(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tpush: (item: BracketInfo) => boolean,\n\tlevel: number,\n\tnestingLevelOfEqualBracketType: number,\n\tlevelPerBracketType: Map<string, number>,\n\tonlyColorizedBrackets: boolean,\n\tparentPairIsIncomplete: boolean = false,\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\twhileLoop:\n\twhile (true) {\n\t\tswitch (node.kind) {\n\t\t\tcase AstNodeKind.List: {\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.Pair: {\n\t\t\t\tconst colorize = !onlyColorizedBrackets || !node.closingBracket || (node.closingBracket.bracketInfo as ClosingBracketKind).closesColorized(node.openingBracket.bracketInfo as OpeningBracketKind);\n\n\t\t\t\tlet levelPerBracket = 0;\n\t\t\t\tif (levelPerBracketType) {\n\t\t\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\t\t\tif (existing === undefined) {\n\t\t\t\t\t\texisting = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlevelPerBracket = existing;\n\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\texisting++;\n\t\t\t\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd && child.kind !== AstNodeKind.Bracket) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\t// Don't do this for brackets because of unclosed/unopened brackets\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket + 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorize || child.kind !== AstNodeKind.Bracket || !node.closingBracket) {\n\t\t\t\t\t\t\tconst shouldContinue = collectBrackets(\n\t\t\t\t\t\t\t\tchild,\n\t\t\t\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\t\t\t\tstartOffset,\n\t\t\t\t\t\t\t\tendOffset,\n\t\t\t\t\t\t\t\tpush,\n\t\t\t\t\t\t\t\tcolorize ? level + 1 : level,\n\t\t\t\t\t\t\t\tcolorize ? levelPerBracket + 1 : levelPerBracket,\n\t\t\t\t\t\t\t\tlevelPerBracketType,\n\t\t\t\t\t\t\t\tonlyColorizedBrackets,\n\t\t\t\t\t\t\t\t!node.closingBracket,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\n\t\t\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.UnexpectedClosingBracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, 0, true));\n\t\t\t}\n\t\t\tcase AstNodeKind.Bracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n\t\t\t}\n\t\t\tcase AstNodeKind.Text:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass CollectBracketPairsContext {\n\tconstructor(\n\t\tpublic readonly push: (item: BracketPairWithMinIndentationInfo) => boolean,\n\t\tpublic readonly includeMinIndentation: boolean,\n\t\tpublic readonly textModel: ITextModel,\n\t) {\n\t}\n}\n\nfunction collectBracketPairs(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tcontext: CollectBracketPairsContext,\n\tlevel: number,\n\tlevelPerBracketType: Map<string, number>\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\tlet shouldContinue = true;\n\n\tif (node.kind === AstNodeKind.Pair) {\n\t\tlet levelPerBracket = 0;\n\t\tif (levelPerBracketType) {\n\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\tif (existing === undefined) {\n\t\t\t\texisting = 0;\n\t\t\t}\n\t\t\tlevelPerBracket = existing;\n\t\t\texisting++;\n\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t}\n\n\t\tconst openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n\t\tlet minIndentation = -1;\n\t\tif (context.includeMinIndentation) {\n\t\t\tminIndentation = node.computeMinIndentation(\n\t\t\t\tnodeOffsetStart,\n\t\t\t\tcontext.textModel\n\t\t\t);\n\t\t}\n\n\t\tshouldContinue = context.push(\n\t\t\tnew BracketPairWithMinIndentationInfo(\n\t\t\t\tlengthsToRange(nodeOffsetStart, nodeOffsetEnd),\n\t\t\t\tlengthsToRange(nodeOffsetStart, openingBracketEnd),\n\t\t\t\tnode.closingBracket\n\t\t\t\t\t? lengthsToRange(\n\t\t\t\t\t\tlengthAdd(openingBracketEnd, node.child?.length || lengthZero),\n\t\t\t\t\t\tnodeOffsetEnd\n\t\t\t\t\t)\n\t\t\t\t\t: undefined,\n\t\t\t\tlevel,\n\t\t\t\tlevelPerBracket,\n\t\t\t\tnode,\n\t\t\t\tminIndentation\n\t\t\t)\n\t\t);\n\n\t\tnodeOffsetStart = openingBracketEnd;\n\t\tif (shouldContinue && node.child) {\n\t\t\tconst child = node.child;\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel + 1,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\t} else {\n\t\tlet curOffset = nodeOffsetStart;\n\t\tfor (const child of node.children) {\n\t\t\tconst childOffset = curOffset;\n\t\t\tcurOffset = lengthAdd(curOffset, child.length);\n\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(childOffset, endOffset) &&\n\t\t\t\tlengthLessThanEqual(startOffset, curOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tchildOffset,\n\t\t\t\t\tcurOffset,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shouldContinue;\n}\n"]}