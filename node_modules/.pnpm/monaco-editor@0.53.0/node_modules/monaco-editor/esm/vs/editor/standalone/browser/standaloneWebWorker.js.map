{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/standalone/browser/standaloneWebWorker.ts","vs/editor/standalone/browser/standaloneWebWorker.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAGhG,OAAO,EAAE,kBAAkB,EAAE,MAAM,+CAA+C,CAAC;AAGnF;;;GAGG;AACH,MAAM,UAAU,eAAe,CAAmB,YAA2B,EAAE,IAA+B;IAC7G,OAAO,IAAI,mBAAmB,CAAI,YAAY,EAAE,IAAI,CAAC,CAAC;AACvD,CAAC;AAqCD,MAAM,mBAAsC,SAAQ,kBAAkB;IAKrE,YAAY,YAA2B,EAAE,IAA+B;QACvE,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,IAAI,KAAK,EAAE,YAAY,CAAC,CAAC;QAC/D,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;QAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YAClD,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE;gBACpB,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ;oBACzB,IAAI,IAAI,KAAK,MAAM,EAAE,CAAC;wBACrB,4GAA4G;wBAC5G,OAAO,SAAS,CAAC;oBAClB,CAAC;oBACD,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;wBAC9B,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;oBAClC,CAAC;oBACD,OAAO,CAAC,GAAG,IAAW,EAAE,EAAE;wBACzB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;oBAC/B,CAAC,CAAC;gBACH,CAAC;aACD,CAAM,CAAC;QACT,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,uBAAuB;IACP,GAAG,CAAC,MAAc,EAAE,IAAW;QAC9C,IAAI,CAAC,IAAI,CAAC,kBAAkB,IAAI,OAAO,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,KAAK,UAAU,EAAE,CAAC;YACvF,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,GAAG,MAAM,GAAG,uCAAuC,CAAC,CAAC,CAAC;QACxG,CAAC;QAED,IAAI,CAAC;YACJ,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC,CAAC;QAC9F,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACZ,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC1B,CAAC;IACF,CAAC;IAEM,QAAQ;QACd,OAAO,IAAI,CAAC,aAAa,CAAC;IAC3B,CAAC;IAEM,mBAAmB,CAAC,SAAgB;QAC1C,OAAO,IAAI,CAAC,yBAAyB,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC7E,CAAC;CACD","file":"standaloneWebWorker.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/model.js';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, opts: IInternalWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IInternalWebWorkerOptions {\n\t/**\n\t * The worker.\n\t */\n\tworker: Worker | Promise<Worker>;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignProxy: Promise<T>;\n\n\tconstructor(modelService: IModelService, opts: IInternalWebWorkerOptions) {\n\t\tsuper(opts.worker, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = this._getProxy().then(proxy => {\n\t\t\treturn new Proxy({}, {\n\t\t\t\tget(target, prop, receiver) {\n\t\t\t\t\tif (prop === 'then') {\n\t\t\t\t\t\t// Don't forward the call when the proxy is returned in an async function and the runtime tries to .then it.\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof prop !== 'string') {\n\t\t\t\t\t\tthrow new Error(`Not supported`);\n\t\t\t\t\t}\n\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\treturn proxy.$fmr(prop, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}) as T;\n\t\t});\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/model.js';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, opts: IInternalWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IInternalWebWorkerOptions {\n\t/**\n\t * The worker.\n\t */\n\tworker: Worker | Promise<Worker>;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignProxy: Promise<T>;\n\n\tconstructor(modelService: IModelService, opts: IInternalWebWorkerOptions) {\n\t\tsuper(opts.worker, opts.keepIdleModels || false, modelService);\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = this._getProxy().then(proxy => {\n\t\t\treturn new Proxy({}, {\n\t\t\t\tget(target, prop, receiver) {\n\t\t\t\t\tif (prop === 'then') {\n\t\t\t\t\t\t// Don't forward the call when the proxy is returned in an async function and the runtime tries to .then it.\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof prop !== 'string') {\n\t\t\t\t\t\tthrow new Error(`Not supported`);\n\t\t\t\t\t}\n\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\treturn proxy.$fmr(prop, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}) as T;\n\t\t});\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n"]}