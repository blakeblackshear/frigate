{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/view/viewLayer.ts","vs/editor/browser/view/viewLayer.ts"],"names":[],"mappings":"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","file":"viewLayer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { FastDomNode, createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { EditorOption } from '../../common/config/editorOptions.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport * as viewEvents from '../../common/viewEvents.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../common/viewModel/viewContext.js';\n\n/**\n * Represents a visible line\n */\nexport interface IVisibleLine extends ILine {\n\tgetDomNode(): HTMLElement | null;\n\tsetDomNode(domNode: HTMLElement): void;\n\n\t/**\n\t * Return null if the HTML should not be touched.\n\t * Return the new HTML otherwise.\n\t */\n\trenderLine(lineNumber: number, deltaTop: number, lineHeight: number, viewportData: ViewportData, sb: StringBuilder): boolean;\n\n\t/**\n\t * Layout the line.\n\t */\n\tlayoutLine(lineNumber: number, deltaTop: number, lineHeight: number): void;\n}\n\nexport interface ILine {\n\tonContentChanged(): void;\n\tonTokensChanged(): void;\n}\n\nexport interface ILineFactory<T extends ILine> {\n\tcreateLine(): T;\n}\n\nexport class RenderedLinesCollection<T extends ILine> {\n\tprivate _lines!: T[];\n\tprivate _rendLineNumberStart!: number;\n\n\tconstructor(\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t) {\n\t\tthis._set(1, []);\n\t}\n\n\tpublic flush(): void {\n\t\tthis._set(1, []);\n\t}\n\n\t_set(rendLineNumberStart: number, lines: T[]): void {\n\t\tthis._lines = lines;\n\t\tthis._rendLineNumberStart = rendLineNumberStart;\n\t}\n\n\t_get(): { rendLineNumberStart: number; lines: T[] } {\n\t\treturn {\n\t\t\trendLineNumberStart: this._rendLineNumberStart,\n\t\t\tlines: this._lines\n\t\t};\n\t}\n\n\t/**\n\t * @returns Inclusive line number that is inside this collection\n\t */\n\tpublic getStartLineNumber(): number {\n\t\treturn this._rendLineNumberStart;\n\t}\n\n\t/**\n\t * @returns Inclusive line number that is inside this collection\n\t */\n\tpublic getEndLineNumber(): number {\n\t\treturn this._rendLineNumberStart + this._lines.length - 1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLine(lineNumber: number): T {\n\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\t\tif (lineIndex < 0 || lineIndex >= this._lines.length) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._lines[lineIndex];\n\t}\n\n\t/**\n\t * @returns Lines that were removed from this collection\n\t */\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): T[] | null {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn null;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tif (deleteToLineNumber < startLineNumber) {\n\t\t\t// deleting above the viewport\n\t\t\tconst deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n\t\t\tthis._rendLineNumberStart -= deleteCnt;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (deleteFromLineNumber > endLineNumber) {\n\t\t\t// deleted below the viewport\n\t\t\treturn null;\n\t\t}\n\n\t\t// Record what needs to be deleted\n\t\tlet deleteStartIndex = 0;\n\t\tlet deleteCount = 0;\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\n\t\t\tif (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n\t\t\t\t// this is a line to be deleted\n\t\t\t\tif (deleteCount === 0) {\n\t\t\t\t\t// this is the first line to be deleted\n\t\t\t\t\tdeleteStartIndex = lineIndex;\n\t\t\t\t\tdeleteCount = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdeleteCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adjust this._rendLineNumberStart for lines deleted above\n\t\tif (deleteFromLineNumber < startLineNumber) {\n\t\t\t// Something was deleted above\n\t\t\tlet deleteAboveCount = 0;\n\n\t\t\tif (deleteToLineNumber < startLineNumber) {\n\t\t\t\t// the entire deleted lines are above\n\t\t\t\tdeleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n\t\t\t} else {\n\t\t\t\tdeleteAboveCount = startLineNumber - deleteFromLineNumber;\n\t\t\t}\n\n\t\t\tthis._rendLineNumberStart -= deleteAboveCount;\n\t\t}\n\n\t\tconst deleted = this._lines.splice(deleteStartIndex, deleteCount);\n\t\treturn deleted;\n\t}\n\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\tconst changeToLineNumber = changeFromLineNumber + changeCount - 1;\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn false;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tlet someoneNotified = false;\n\n\t\tfor (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n\t\t\tif (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n\t\t\t\t// Notify the line\n\t\t\t\tthis._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n\t\t\t\tsomeoneNotified = true;\n\t\t\t}\n\t\t}\n\n\t\treturn someoneNotified;\n\t}\n\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): T[] | null {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn null;\n\t\t}\n\n\t\tconst insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tif (insertFromLineNumber <= startLineNumber) {\n\t\t\t// inserting above the viewport\n\t\t\tthis._rendLineNumberStart += insertCnt;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (insertFromLineNumber > endLineNumber) {\n\t\t\t// inserting below the viewport\n\t\t\treturn null;\n\t\t}\n\n\t\tif (insertCnt + insertFromLineNumber > endLineNumber) {\n\t\t\t// insert inside the viewport in such a way that all remaining lines are pushed outside\n\t\t\tconst deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n\t\t\treturn deleted;\n\t\t}\n\n\t\t// insert inside the viewport, push out some lines, but not all remaining lines\n\t\tconst newLines: T[] = [];\n\t\tfor (let i = 0; i < insertCnt; i++) {\n\t\t\tnewLines[i] = this._lineFactory.createLine();\n\t\t}\n\t\tconst insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n\t\tconst beforeLines = this._lines.slice(0, insertIndex);\n\t\tconst afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n\t\tconst deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n\n\t\tthis._lines = beforeLines.concat(newLines).concat(afterLines);\n\n\t\treturn deletedLines;\n\t}\n\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn false;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tlet notifiedSomeone = false;\n\t\tfor (let i = 0, len = ranges.length; i < len; i++) {\n\t\t\tconst rng = ranges[i];\n\n\t\t\tif (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n\t\t\t\t// range outside viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst from = Math.max(startLineNumber, rng.fromLineNumber);\n\t\t\tconst to = Math.min(endLineNumber, rng.toLineNumber);\n\n\t\t\tfor (let lineNumber = from; lineNumber <= to; lineNumber++) {\n\t\t\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\t\t\t\tthis._lines[lineIndex].onTokensChanged();\n\t\t\t\tnotifiedSomeone = true;\n\t\t\t}\n\t\t}\n\n\t\treturn notifiedSomeone;\n\t}\n}\n\nexport class VisibleLinesCollection<T extends IVisibleLine> {\n\n\tpublic readonly domNode: FastDomNode<HTMLElement>;\n\tprivate readonly _linesCollection: RenderedLinesCollection<T>;\n\n\tconstructor(\n\t\tprivate readonly _viewContext: ViewContext,\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t) {\n\t\tthis.domNode = this._createDomNode();\n\t\tthis._linesCollection = new RenderedLinesCollection<T>(this._lineFactory);\n\t}\n\n\tprivate _createDomNode(): FastDomNode<HTMLElement> {\n\t\tconst domNode = createFastDomNode(document.createElement('div'));\n\t\tdomNode.setClassName('view-layer');\n\t\tdomNode.setPosition('absolute');\n\t\tdomNode.domNode.setAttribute('role', 'presentation');\n\t\tdomNode.domNode.setAttribute('aria-hidden', 'true');\n\t\treturn domNode;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\tif (e.hasChanged(EditorOption.layoutInfo)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic onFlushed(e: viewEvents.ViewFlushedEvent, flushDom?: boolean): boolean {\n\t\t// No need to clear the dom node because a full .innerHTML will occur in\n\t\t// ViewLayerRenderer._render, however the fallback mechanism in the\n\t\t// GPU renderer may cause this to be necessary as the .innerHTML call\n\t\t// may not happen depending on the new state, leaving stale DOM nodes\n\t\t// around.\n\t\tif (flushDom) {\n\t\t\tconst start = this._linesCollection.getStartLineNumber();\n\t\t\tconst end = this._linesCollection.getEndLineNumber();\n\t\t\tfor (let i = start; i <= end; i++) {\n\t\t\t\tthis._linesCollection.getLine(i).getDomNode()?.remove();\n\t\t\t}\n\t\t}\n\t\tthis._linesCollection.flush();\n\t\treturn true;\n\t}\n\n\tpublic onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean {\n\t\treturn this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n\t}\n\n\tpublic onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean {\n\t\tconst deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\t\tif (deleted) {\n\t\t\t// Remove from DOM\n\t\t\tfor (let i = 0, len = deleted.length; i < len; i++) {\n\t\t\t\tconst lineDomNode = deleted[i].getDomNode();\n\t\t\t\tlineDomNode?.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean {\n\t\tconst deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\t\tif (deleted) {\n\t\t\t// Remove from DOM\n\t\t\tfor (let i = 0, len = deleted.length; i < len; i++) {\n\t\t\t\tconst lineDomNode = deleted[i].getDomNode();\n\t\t\t\tlineDomNode?.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\treturn e.scrollTopChanged;\n\t}\n\n\tpublic onTokensChanged(e: viewEvents.ViewTokensChangedEvent): boolean {\n\t\treturn this._linesCollection.onTokensChanged(e.ranges);\n\t}\n\n\tpublic onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// ---- end view event handlers\n\n\tpublic getStartLineNumber(): number {\n\t\treturn this._linesCollection.getStartLineNumber();\n\t}\n\n\tpublic getEndLineNumber(): number {\n\t\treturn this._linesCollection.getEndLineNumber();\n\t}\n\n\tpublic getVisibleLine(lineNumber: number): T {\n\t\treturn this._linesCollection.getLine(lineNumber);\n\t}\n\n\tpublic renderLines(viewportData: ViewportData): void {\n\n\t\tconst inp = this._linesCollection._get();\n\n\t\tconst renderer = new ViewLayerRenderer<T>(this.domNode.domNode, this._lineFactory, viewportData, this._viewContext);\n\n\t\tconst ctx: IRendererContext<T> = {\n\t\t\trendLineNumberStart: inp.rendLineNumberStart,\n\t\t\tlines: inp.lines,\n\t\t\tlinesLength: inp.lines.length\n\t\t};\n\n\t\t// Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n\t\tconst resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n\n\t\tthis._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n\t}\n}\n\ninterface IRendererContext<T extends IVisibleLine> {\n\trendLineNumberStart: number;\n\tlines: T[];\n\tlinesLength: number;\n}\n\nclass ViewLayerRenderer<T extends IVisibleLine> {\n\n\tprivate static _ttPolicy = createTrustedTypesPolicy('editorViewLayer', { createHTML: value => value });\n\n\tconstructor(\n\t\tprivate readonly _domNode: HTMLElement,\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t\tprivate readonly _viewportData: ViewportData,\n\t\tprivate readonly _viewContext: ViewContext\n\t) {\n\t}\n\n\tpublic render(inContext: IRendererContext<T>, startLineNumber: number, stopLineNumber: number, deltaTop: number[]): IRendererContext<T> {\n\n\t\tconst ctx: IRendererContext<T> = {\n\t\t\trendLineNumberStart: inContext.rendLineNumberStart,\n\t\t\tlines: inContext.lines.slice(0),\n\t\t\tlinesLength: inContext.linesLength\n\t\t};\n\n\t\tif ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n\t\t\t// There is no overlap whatsoever\n\t\t\tctx.rendLineNumberStart = startLineNumber;\n\t\t\tctx.linesLength = stopLineNumber - startLineNumber + 1;\n\t\t\tctx.lines = [];\n\t\t\tfor (let x = startLineNumber; x <= stopLineNumber; x++) {\n\t\t\t\tctx.lines[x - startLineNumber] = this._lineFactory.createLine();\n\t\t\t}\n\t\t\tthis._finishRendering(ctx, true, deltaTop);\n\t\t\treturn ctx;\n\t\t}\n\n\t\t// Update lines which will remain untouched\n\t\tthis._renderUntouchedLines(\n\t\t\tctx,\n\t\t\tMath.max(startLineNumber - ctx.rendLineNumberStart, 0),\n\t\t\tMath.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1),\n\t\t\tdeltaTop,\n\t\t\tstartLineNumber\n\t\t);\n\n\t\tif (ctx.rendLineNumberStart > startLineNumber) {\n\t\t\t// Insert lines before\n\t\t\tconst fromLineNumber = startLineNumber;\n\t\t\tconst toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n\t\t\tif (fromLineNumber <= toLineNumber) {\n\t\t\t\tthis._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\t\t\t\tctx.linesLength += toLineNumber - fromLineNumber + 1;\n\t\t\t}\n\t\t} else if (ctx.rendLineNumberStart < startLineNumber) {\n\t\t\t// Remove lines before\n\t\t\tconst removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n\t\t\tif (removeCnt > 0) {\n\t\t\t\tthis._removeLinesBefore(ctx, removeCnt);\n\t\t\t\tctx.linesLength -= removeCnt;\n\t\t\t}\n\t\t}\n\n\t\tctx.rendLineNumberStart = startLineNumber;\n\n\t\tif (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n\t\t\t// Insert lines after\n\t\t\tconst fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n\t\t\tconst toLineNumber = stopLineNumber;\n\n\t\t\tif (fromLineNumber <= toLineNumber) {\n\t\t\t\tthis._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\t\t\t\tctx.linesLength += toLineNumber - fromLineNumber + 1;\n\t\t\t}\n\n\t\t} else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n\t\t\t// Remove lines after\n\t\t\tconst fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n\t\t\tconst toLineNumber = ctx.linesLength - 1;\n\t\t\tconst removeCnt = toLineNumber - fromLineNumber + 1;\n\n\t\t\tif (removeCnt > 0) {\n\t\t\t\tthis._removeLinesAfter(ctx, removeCnt);\n\t\t\t\tctx.linesLength -= removeCnt;\n\t\t\t}\n\t\t}\n\n\t\tthis._finishRendering(ctx, false, deltaTop);\n\n\t\treturn ctx;\n\t}\n\n\tprivate _renderUntouchedLines(ctx: IRendererContext<T>, startIndex: number, endIndex: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst rendLineNumberStart = ctx.rendLineNumberStart;\n\t\tconst lines = ctx.lines;\n\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst lineNumber = rendLineNumberStart + i;\n\t\t\tlines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN], this._lineHeightForLineNumber(lineNumber));\n\t\t}\n\t}\n\n\tprivate _insertLinesBefore(ctx: IRendererContext<T>, fromLineNumber: number, toLineNumber: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst newLines: T[] = [];\n\t\tlet newLinesLen = 0;\n\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\tnewLines[newLinesLen++] = this._lineFactory.createLine();\n\t\t}\n\t\tctx.lines = newLines.concat(ctx.lines);\n\t}\n\n\tprivate _removeLinesBefore(ctx: IRendererContext<T>, removeCount: number): void {\n\t\tfor (let i = 0; i < removeCount; i++) {\n\t\t\tconst lineDomNode = ctx.lines[i].getDomNode();\n\t\t\tlineDomNode?.remove();\n\t\t}\n\t\tctx.lines.splice(0, removeCount);\n\t}\n\n\tprivate _insertLinesAfter(ctx: IRendererContext<T>, fromLineNumber: number, toLineNumber: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst newLines: T[] = [];\n\t\tlet newLinesLen = 0;\n\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\tnewLines[newLinesLen++] = this._lineFactory.createLine();\n\t\t}\n\t\tctx.lines = ctx.lines.concat(newLines);\n\t}\n\n\tprivate _removeLinesAfter(ctx: IRendererContext<T>, removeCount: number): void {\n\t\tconst removeIndex = ctx.linesLength - removeCount;\n\n\t\tfor (let i = 0; i < removeCount; i++) {\n\t\t\tconst lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n\t\t\tlineDomNode?.remove();\n\t\t}\n\t\tctx.lines.splice(removeIndex, removeCount);\n\t}\n\n\tprivate _finishRenderingNewLines(ctx: IRendererContext<T>, domNodeIsEmpty: boolean, newLinesHTML: string | TrustedHTML, wasNew: boolean[]): void {\n\t\tif (ViewLayerRenderer._ttPolicy) {\n\t\t\tnewLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML as string);\n\t\t}\n\t\tconst lastChild = <HTMLElement>this._domNode.lastChild;\n\t\tif (domNodeIsEmpty || !lastChild) {\n\t\t\tthis._domNode.innerHTML = newLinesHTML as string; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n\t\t} else {\n\t\t\tlastChild.insertAdjacentHTML('afterend', newLinesHTML as string);\n\t\t}\n\n\t\tlet currChild = <HTMLElement>this._domNode.lastChild;\n\t\tfor (let i = ctx.linesLength - 1; i >= 0; i--) {\n\t\t\tconst line = ctx.lines[i];\n\t\t\tif (wasNew[i]) {\n\t\t\t\tline.setDomNode(currChild);\n\t\t\t\tcurrChild = <HTMLElement>currChild.previousSibling;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _finishRenderingInvalidLines(ctx: IRendererContext<T>, invalidLinesHTML: string | TrustedHTML, wasInvalid: boolean[]): void {\n\t\tconst hugeDomNode = document.createElement('div');\n\n\t\tif (ViewLayerRenderer._ttPolicy) {\n\t\t\tinvalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML as string);\n\t\t}\n\t\thugeDomNode.innerHTML = invalidLinesHTML as string;\n\n\t\tfor (let i = 0; i < ctx.linesLength; i++) {\n\t\t\tconst line = ctx.lines[i];\n\t\t\tif (wasInvalid[i]) {\n\t\t\t\tconst source = <HTMLElement>hugeDomNode.firstChild;\n\t\t\t\tconst lineDomNode = line.getDomNode()!;\n\t\t\t\tlineDomNode.parentNode!.replaceChild(source, lineDomNode);\n\t\t\t\tline.setDomNode(source);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static readonly _sb = new StringBuilder(100000);\n\n\tprivate _finishRendering(ctx: IRendererContext<T>, domNodeIsEmpty: boolean, deltaTop: number[]): void {\n\n\t\tconst sb = ViewLayerRenderer._sb;\n\t\tconst linesLength = ctx.linesLength;\n\t\tconst lines = ctx.lines;\n\t\tconst rendLineNumberStart = ctx.rendLineNumberStart;\n\n\t\tconst wasNew: boolean[] = [];\n\t\t{\n\t\t\tsb.reset();\n\t\t\tlet hadNewLine = false;\n\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tconst line = lines[i];\n\t\t\t\twasNew[i] = false;\n\n\t\t\t\tconst lineDomNode = line.getDomNode();\n\t\t\t\tif (lineDomNode) {\n\t\t\t\t\t// line is not new\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst renderedLineNumber = i + rendLineNumberStart;\n\t\t\t\tconst renderResult = line.renderLine(renderedLineNumber, deltaTop[i], this._lineHeightForLineNumber(renderedLineNumber), this._viewportData, sb);\n\t\t\t\tif (!renderResult) {\n\t\t\t\t\t// line does not need rendering\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twasNew[i] = true;\n\t\t\t\thadNewLine = true;\n\t\t\t}\n\n\t\t\tif (hadNewLine) {\n\t\t\t\tthis._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsb.reset();\n\n\t\t\tlet hadInvalidLine = false;\n\t\t\tconst wasInvalid: boolean[] = [];\n\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tconst line = lines[i];\n\t\t\t\twasInvalid[i] = false;\n\n\t\t\t\tif (wasNew[i]) {\n\t\t\t\t\t// line was new\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst renderedLineNumber = i + rendLineNumberStart;\n\t\t\t\tconst renderResult = line.renderLine(renderedLineNumber, deltaTop[i], this._lineHeightForLineNumber(renderedLineNumber), this._viewportData, sb);\n\t\t\t\tif (!renderResult) {\n\t\t\t\t\t// line does not need rendering\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twasInvalid[i] = true;\n\t\t\t\thadInvalidLine = true;\n\t\t\t}\n\n\t\t\tif (hadInvalidLine) {\n\t\t\t\tthis._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _lineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._viewContext.viewLayout.getLineHeightForLineNumber(lineNumber);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { FastDomNode, createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { EditorOption } from '../../common/config/editorOptions.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport * as viewEvents from '../../common/viewEvents.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../common/viewModel/viewContext.js';\n\n/**\n * Represents a visible line\n */\nexport interface IVisibleLine extends ILine {\n\tgetDomNode(): HTMLElement | null;\n\tsetDomNode(domNode: HTMLElement): void;\n\n\t/**\n\t * Return null if the HTML should not be touched.\n\t * Return the new HTML otherwise.\n\t */\n\trenderLine(lineNumber: number, deltaTop: number, lineHeight: number, viewportData: ViewportData, sb: StringBuilder): boolean;\n\n\t/**\n\t * Layout the line.\n\t */\n\tlayoutLine(lineNumber: number, deltaTop: number, lineHeight: number): void;\n}\n\nexport interface ILine {\n\tonContentChanged(): void;\n\tonTokensChanged(): void;\n}\n\nexport interface ILineFactory<T extends ILine> {\n\tcreateLine(): T;\n}\n\nexport class RenderedLinesCollection<T extends ILine> {\n\tprivate _lines!: T[];\n\tprivate _rendLineNumberStart!: number;\n\n\tconstructor(\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t) {\n\t\tthis._set(1, []);\n\t}\n\n\tpublic flush(): void {\n\t\tthis._set(1, []);\n\t}\n\n\t_set(rendLineNumberStart: number, lines: T[]): void {\n\t\tthis._lines = lines;\n\t\tthis._rendLineNumberStart = rendLineNumberStart;\n\t}\n\n\t_get(): { rendLineNumberStart: number; lines: T[] } {\n\t\treturn {\n\t\t\trendLineNumberStart: this._rendLineNumberStart,\n\t\t\tlines: this._lines\n\t\t};\n\t}\n\n\t/**\n\t * @returns Inclusive line number that is inside this collection\n\t */\n\tpublic getStartLineNumber(): number {\n\t\treturn this._rendLineNumberStart;\n\t}\n\n\t/**\n\t * @returns Inclusive line number that is inside this collection\n\t */\n\tpublic getEndLineNumber(): number {\n\t\treturn this._rendLineNumberStart + this._lines.length - 1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLine(lineNumber: number): T {\n\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\t\tif (lineIndex < 0 || lineIndex >= this._lines.length) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._lines[lineIndex];\n\t}\n\n\t/**\n\t * @returns Lines that were removed from this collection\n\t */\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): T[] | null {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn null;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tif (deleteToLineNumber < startLineNumber) {\n\t\t\t// deleting above the viewport\n\t\t\tconst deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n\t\t\tthis._rendLineNumberStart -= deleteCnt;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (deleteFromLineNumber > endLineNumber) {\n\t\t\t// deleted below the viewport\n\t\t\treturn null;\n\t\t}\n\n\t\t// Record what needs to be deleted\n\t\tlet deleteStartIndex = 0;\n\t\tlet deleteCount = 0;\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\n\t\t\tif (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n\t\t\t\t// this is a line to be deleted\n\t\t\t\tif (deleteCount === 0) {\n\t\t\t\t\t// this is the first line to be deleted\n\t\t\t\t\tdeleteStartIndex = lineIndex;\n\t\t\t\t\tdeleteCount = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdeleteCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adjust this._rendLineNumberStart for lines deleted above\n\t\tif (deleteFromLineNumber < startLineNumber) {\n\t\t\t// Something was deleted above\n\t\t\tlet deleteAboveCount = 0;\n\n\t\t\tif (deleteToLineNumber < startLineNumber) {\n\t\t\t\t// the entire deleted lines are above\n\t\t\t\tdeleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n\t\t\t} else {\n\t\t\t\tdeleteAboveCount = startLineNumber - deleteFromLineNumber;\n\t\t\t}\n\n\t\t\tthis._rendLineNumberStart -= deleteAboveCount;\n\t\t}\n\n\t\tconst deleted = this._lines.splice(deleteStartIndex, deleteCount);\n\t\treturn deleted;\n\t}\n\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\tconst changeToLineNumber = changeFromLineNumber + changeCount - 1;\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn false;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tlet someoneNotified = false;\n\n\t\tfor (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n\t\t\tif (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n\t\t\t\t// Notify the line\n\t\t\t\tthis._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n\t\t\t\tsomeoneNotified = true;\n\t\t\t}\n\t\t}\n\n\t\treturn someoneNotified;\n\t}\n\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): T[] | null {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn null;\n\t\t}\n\n\t\tconst insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tif (insertFromLineNumber <= startLineNumber) {\n\t\t\t// inserting above the viewport\n\t\t\tthis._rendLineNumberStart += insertCnt;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (insertFromLineNumber > endLineNumber) {\n\t\t\t// inserting below the viewport\n\t\t\treturn null;\n\t\t}\n\n\t\tif (insertCnt + insertFromLineNumber > endLineNumber) {\n\t\t\t// insert inside the viewport in such a way that all remaining lines are pushed outside\n\t\t\tconst deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n\t\t\treturn deleted;\n\t\t}\n\n\t\t// insert inside the viewport, push out some lines, but not all remaining lines\n\t\tconst newLines: T[] = [];\n\t\tfor (let i = 0; i < insertCnt; i++) {\n\t\t\tnewLines[i] = this._lineFactory.createLine();\n\t\t}\n\t\tconst insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n\t\tconst beforeLines = this._lines.slice(0, insertIndex);\n\t\tconst afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n\t\tconst deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n\n\t\tthis._lines = beforeLines.concat(newLines).concat(afterLines);\n\n\t\treturn deletedLines;\n\t}\n\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\tif (this.getCount() === 0) {\n\t\t\t// no lines\n\t\t\treturn false;\n\t\t}\n\n\t\tconst startLineNumber = this.getStartLineNumber();\n\t\tconst endLineNumber = this.getEndLineNumber();\n\n\t\tlet notifiedSomeone = false;\n\t\tfor (let i = 0, len = ranges.length; i < len; i++) {\n\t\t\tconst rng = ranges[i];\n\n\t\t\tif (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n\t\t\t\t// range outside viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst from = Math.max(startLineNumber, rng.fromLineNumber);\n\t\t\tconst to = Math.min(endLineNumber, rng.toLineNumber);\n\n\t\t\tfor (let lineNumber = from; lineNumber <= to; lineNumber++) {\n\t\t\t\tconst lineIndex = lineNumber - this._rendLineNumberStart;\n\t\t\t\tthis._lines[lineIndex].onTokensChanged();\n\t\t\t\tnotifiedSomeone = true;\n\t\t\t}\n\t\t}\n\n\t\treturn notifiedSomeone;\n\t}\n}\n\nexport class VisibleLinesCollection<T extends IVisibleLine> {\n\n\tpublic readonly domNode: FastDomNode<HTMLElement>;\n\tprivate readonly _linesCollection: RenderedLinesCollection<T>;\n\n\tconstructor(\n\t\tprivate readonly _viewContext: ViewContext,\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t) {\n\t\tthis.domNode = this._createDomNode();\n\t\tthis._linesCollection = new RenderedLinesCollection<T>(this._lineFactory);\n\t}\n\n\tprivate _createDomNode(): FastDomNode<HTMLElement> {\n\t\tconst domNode = createFastDomNode(document.createElement('div'));\n\t\tdomNode.setClassName('view-layer');\n\t\tdomNode.setPosition('absolute');\n\t\tdomNode.domNode.setAttribute('role', 'presentation');\n\t\tdomNode.domNode.setAttribute('aria-hidden', 'true');\n\t\treturn domNode;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\tif (e.hasChanged(EditorOption.layoutInfo)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic onFlushed(e: viewEvents.ViewFlushedEvent, flushDom?: boolean): boolean {\n\t\t// No need to clear the dom node because a full .innerHTML will occur in\n\t\t// ViewLayerRenderer._render, however the fallback mechanism in the\n\t\t// GPU renderer may cause this to be necessary as the .innerHTML call\n\t\t// may not happen depending on the new state, leaving stale DOM nodes\n\t\t// around.\n\t\tif (flushDom) {\n\t\t\tconst start = this._linesCollection.getStartLineNumber();\n\t\t\tconst end = this._linesCollection.getEndLineNumber();\n\t\t\tfor (let i = start; i <= end; i++) {\n\t\t\t\tthis._linesCollection.getLine(i).getDomNode()?.remove();\n\t\t\t}\n\t\t}\n\t\tthis._linesCollection.flush();\n\t\treturn true;\n\t}\n\n\tpublic onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean {\n\t\treturn this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n\t}\n\n\tpublic onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean {\n\t\tconst deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\t\tif (deleted) {\n\t\t\t// Remove from DOM\n\t\t\tfor (let i = 0, len = deleted.length; i < len; i++) {\n\t\t\t\tconst lineDomNode = deleted[i].getDomNode();\n\t\t\t\tlineDomNode?.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean {\n\t\tconst deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\t\tif (deleted) {\n\t\t\t// Remove from DOM\n\t\t\tfor (let i = 0, len = deleted.length; i < len; i++) {\n\t\t\t\tconst lineDomNode = deleted[i].getDomNode();\n\t\t\t\tlineDomNode?.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\treturn e.scrollTopChanged;\n\t}\n\n\tpublic onTokensChanged(e: viewEvents.ViewTokensChangedEvent): boolean {\n\t\treturn this._linesCollection.onTokensChanged(e.ranges);\n\t}\n\n\tpublic onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// ---- end view event handlers\n\n\tpublic getStartLineNumber(): number {\n\t\treturn this._linesCollection.getStartLineNumber();\n\t}\n\n\tpublic getEndLineNumber(): number {\n\t\treturn this._linesCollection.getEndLineNumber();\n\t}\n\n\tpublic getVisibleLine(lineNumber: number): T {\n\t\treturn this._linesCollection.getLine(lineNumber);\n\t}\n\n\tpublic renderLines(viewportData: ViewportData): void {\n\n\t\tconst inp = this._linesCollection._get();\n\n\t\tconst renderer = new ViewLayerRenderer<T>(this.domNode.domNode, this._lineFactory, viewportData, this._viewContext);\n\n\t\tconst ctx: IRendererContext<T> = {\n\t\t\trendLineNumberStart: inp.rendLineNumberStart,\n\t\t\tlines: inp.lines,\n\t\t\tlinesLength: inp.lines.length\n\t\t};\n\n\t\t// Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n\t\tconst resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n\n\t\tthis._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n\t}\n}\n\ninterface IRendererContext<T extends IVisibleLine> {\n\trendLineNumberStart: number;\n\tlines: T[];\n\tlinesLength: number;\n}\n\nclass ViewLayerRenderer<T extends IVisibleLine> {\n\n\tprivate static _ttPolicy = createTrustedTypesPolicy('editorViewLayer', { createHTML: value => value });\n\n\tconstructor(\n\t\tprivate readonly _domNode: HTMLElement,\n\t\tprivate readonly _lineFactory: ILineFactory<T>,\n\t\tprivate readonly _viewportData: ViewportData,\n\t\tprivate readonly _viewContext: ViewContext\n\t) {\n\t}\n\n\tpublic render(inContext: IRendererContext<T>, startLineNumber: number, stopLineNumber: number, deltaTop: number[]): IRendererContext<T> {\n\n\t\tconst ctx: IRendererContext<T> = {\n\t\t\trendLineNumberStart: inContext.rendLineNumberStart,\n\t\t\tlines: inContext.lines.slice(0),\n\t\t\tlinesLength: inContext.linesLength\n\t\t};\n\n\t\tif ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n\t\t\t// There is no overlap whatsoever\n\t\t\tctx.rendLineNumberStart = startLineNumber;\n\t\t\tctx.linesLength = stopLineNumber - startLineNumber + 1;\n\t\t\tctx.lines = [];\n\t\t\tfor (let x = startLineNumber; x <= stopLineNumber; x++) {\n\t\t\t\tctx.lines[x - startLineNumber] = this._lineFactory.createLine();\n\t\t\t}\n\t\t\tthis._finishRendering(ctx, true, deltaTop);\n\t\t\treturn ctx;\n\t\t}\n\n\t\t// Update lines which will remain untouched\n\t\tthis._renderUntouchedLines(\n\t\t\tctx,\n\t\t\tMath.max(startLineNumber - ctx.rendLineNumberStart, 0),\n\t\t\tMath.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1),\n\t\t\tdeltaTop,\n\t\t\tstartLineNumber\n\t\t);\n\n\t\tif (ctx.rendLineNumberStart > startLineNumber) {\n\t\t\t// Insert lines before\n\t\t\tconst fromLineNumber = startLineNumber;\n\t\t\tconst toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n\t\t\tif (fromLineNumber <= toLineNumber) {\n\t\t\t\tthis._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\t\t\t\tctx.linesLength += toLineNumber - fromLineNumber + 1;\n\t\t\t}\n\t\t} else if (ctx.rendLineNumberStart < startLineNumber) {\n\t\t\t// Remove lines before\n\t\t\tconst removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n\t\t\tif (removeCnt > 0) {\n\t\t\t\tthis._removeLinesBefore(ctx, removeCnt);\n\t\t\t\tctx.linesLength -= removeCnt;\n\t\t\t}\n\t\t}\n\n\t\tctx.rendLineNumberStart = startLineNumber;\n\n\t\tif (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n\t\t\t// Insert lines after\n\t\t\tconst fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n\t\t\tconst toLineNumber = stopLineNumber;\n\n\t\t\tif (fromLineNumber <= toLineNumber) {\n\t\t\t\tthis._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\t\t\t\tctx.linesLength += toLineNumber - fromLineNumber + 1;\n\t\t\t}\n\n\t\t} else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n\t\t\t// Remove lines after\n\t\t\tconst fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n\t\t\tconst toLineNumber = ctx.linesLength - 1;\n\t\t\tconst removeCnt = toLineNumber - fromLineNumber + 1;\n\n\t\t\tif (removeCnt > 0) {\n\t\t\t\tthis._removeLinesAfter(ctx, removeCnt);\n\t\t\t\tctx.linesLength -= removeCnt;\n\t\t\t}\n\t\t}\n\n\t\tthis._finishRendering(ctx, false, deltaTop);\n\n\t\treturn ctx;\n\t}\n\n\tprivate _renderUntouchedLines(ctx: IRendererContext<T>, startIndex: number, endIndex: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst rendLineNumberStart = ctx.rendLineNumberStart;\n\t\tconst lines = ctx.lines;\n\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst lineNumber = rendLineNumberStart + i;\n\t\t\tlines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN], this._lineHeightForLineNumber(lineNumber));\n\t\t}\n\t}\n\n\tprivate _insertLinesBefore(ctx: IRendererContext<T>, fromLineNumber: number, toLineNumber: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst newLines: T[] = [];\n\t\tlet newLinesLen = 0;\n\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\tnewLines[newLinesLen++] = this._lineFactory.createLine();\n\t\t}\n\t\tctx.lines = newLines.concat(ctx.lines);\n\t}\n\n\tprivate _removeLinesBefore(ctx: IRendererContext<T>, removeCount: number): void {\n\t\tfor (let i = 0; i < removeCount; i++) {\n\t\t\tconst lineDomNode = ctx.lines[i].getDomNode();\n\t\t\tlineDomNode?.remove();\n\t\t}\n\t\tctx.lines.splice(0, removeCount);\n\t}\n\n\tprivate _insertLinesAfter(ctx: IRendererContext<T>, fromLineNumber: number, toLineNumber: number, deltaTop: number[], deltaLN: number): void {\n\t\tconst newLines: T[] = [];\n\t\tlet newLinesLen = 0;\n\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\tnewLines[newLinesLen++] = this._lineFactory.createLine();\n\t\t}\n\t\tctx.lines = ctx.lines.concat(newLines);\n\t}\n\n\tprivate _removeLinesAfter(ctx: IRendererContext<T>, removeCount: number): void {\n\t\tconst removeIndex = ctx.linesLength - removeCount;\n\n\t\tfor (let i = 0; i < removeCount; i++) {\n\t\t\tconst lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n\t\t\tlineDomNode?.remove();\n\t\t}\n\t\tctx.lines.splice(removeIndex, removeCount);\n\t}\n\n\tprivate _finishRenderingNewLines(ctx: IRendererContext<T>, domNodeIsEmpty: boolean, newLinesHTML: string | TrustedHTML, wasNew: boolean[]): void {\n\t\tif (ViewLayerRenderer._ttPolicy) {\n\t\t\tnewLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML as string);\n\t\t}\n\t\tconst lastChild = <HTMLElement>this._domNode.lastChild;\n\t\tif (domNodeIsEmpty || !lastChild) {\n\t\t\tthis._domNode.innerHTML = newLinesHTML as string; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n\t\t} else {\n\t\t\tlastChild.insertAdjacentHTML('afterend', newLinesHTML as string);\n\t\t}\n\n\t\tlet currChild = <HTMLElement>this._domNode.lastChild;\n\t\tfor (let i = ctx.linesLength - 1; i >= 0; i--) {\n\t\t\tconst line = ctx.lines[i];\n\t\t\tif (wasNew[i]) {\n\t\t\t\tline.setDomNode(currChild);\n\t\t\t\tcurrChild = <HTMLElement>currChild.previousSibling;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _finishRenderingInvalidLines(ctx: IRendererContext<T>, invalidLinesHTML: string | TrustedHTML, wasInvalid: boolean[]): void {\n\t\tconst hugeDomNode = document.createElement('div');\n\n\t\tif (ViewLayerRenderer._ttPolicy) {\n\t\t\tinvalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML as string);\n\t\t}\n\t\thugeDomNode.innerHTML = invalidLinesHTML as string;\n\n\t\tfor (let i = 0; i < ctx.linesLength; i++) {\n\t\t\tconst line = ctx.lines[i];\n\t\t\tif (wasInvalid[i]) {\n\t\t\t\tconst source = <HTMLElement>hugeDomNode.firstChild;\n\t\t\t\tconst lineDomNode = line.getDomNode()!;\n\t\t\t\tlineDomNode.parentNode!.replaceChild(source, lineDomNode);\n\t\t\t\tline.setDomNode(source);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static readonly _sb = new StringBuilder(100000);\n\n\tprivate _finishRendering(ctx: IRendererContext<T>, domNodeIsEmpty: boolean, deltaTop: number[]): void {\n\n\t\tconst sb = ViewLayerRenderer._sb;\n\t\tconst linesLength = ctx.linesLength;\n\t\tconst lines = ctx.lines;\n\t\tconst rendLineNumberStart = ctx.rendLineNumberStart;\n\n\t\tconst wasNew: boolean[] = [];\n\t\t{\n\t\t\tsb.reset();\n\t\t\tlet hadNewLine = false;\n\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tconst line = lines[i];\n\t\t\t\twasNew[i] = false;\n\n\t\t\t\tconst lineDomNode = line.getDomNode();\n\t\t\t\tif (lineDomNode) {\n\t\t\t\t\t// line is not new\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst renderedLineNumber = i + rendLineNumberStart;\n\t\t\t\tconst renderResult = line.renderLine(renderedLineNumber, deltaTop[i], this._lineHeightForLineNumber(renderedLineNumber), this._viewportData, sb);\n\t\t\t\tif (!renderResult) {\n\t\t\t\t\t// line does not need rendering\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twasNew[i] = true;\n\t\t\t\thadNewLine = true;\n\t\t\t}\n\n\t\t\tif (hadNewLine) {\n\t\t\t\tthis._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsb.reset();\n\n\t\t\tlet hadInvalidLine = false;\n\t\t\tconst wasInvalid: boolean[] = [];\n\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tconst line = lines[i];\n\t\t\t\twasInvalid[i] = false;\n\n\t\t\t\tif (wasNew[i]) {\n\t\t\t\t\t// line was new\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst renderedLineNumber = i + rendLineNumberStart;\n\t\t\t\tconst renderResult = line.renderLine(renderedLineNumber, deltaTop[i], this._lineHeightForLineNumber(renderedLineNumber), this._viewportData, sb);\n\t\t\t\tif (!renderResult) {\n\t\t\t\t\t// line does not need rendering\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twasInvalid[i] = true;\n\t\t\t\thadInvalidLine = true;\n\t\t\t}\n\n\t\t\tif (hadInvalidLine) {\n\t\t\t\tthis._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _lineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._viewContext.viewLayout.getLineHeightForLineNumber(lineNumber);\n\t}\n}\n"]}