{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/linesLayout.ts","vs/editor/common/viewLayout/linesLayout.ts"],"names":[],"mappings":"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","file":"linesLayout.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewWhitespaceViewportData, IWhitespaceChangeAccessor } from '../viewModel.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ICustomLineHeightData, LineHeightsManager } from './lineHeights.js';\n\ninterface IPendingChange { id: string; newAfterLineNumber: number; newHeight: number }\ninterface IPendingRemove { id: string }\n\nclass PendingChanges {\n\tprivate _hasPending: boolean;\n\tprivate _inserts: EditorWhitespace[];\n\tprivate _changes: IPendingChange[];\n\tprivate _removes: IPendingRemove[];\n\n\tconstructor() {\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\t}\n\n\tpublic insert(x: EditorWhitespace): void {\n\t\tthis._hasPending = true;\n\t\tthis._inserts.push(x);\n\t}\n\n\tpublic change(x: IPendingChange): void {\n\t\tthis._hasPending = true;\n\t\tthis._changes.push(x);\n\t}\n\n\tpublic remove(x: IPendingRemove): void {\n\t\tthis._hasPending = true;\n\t\tthis._removes.push(x);\n\t}\n\n\tpublic commit(linesLayout: LinesLayout): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inserts = this._inserts;\n\t\tconst changes = this._changes;\n\t\tconst removes = this._removes;\n\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\n\t\tlinesLayout._commitPendingChanges(inserts, changes, removes);\n\t}\n}\n\nexport class EditorWhitespace implements IEditorWhitespace {\n\tpublic id: string;\n\tpublic afterLineNumber: number;\n\tpublic ordinal: number;\n\tpublic height: number;\n\tpublic minWidth: number;\n\tpublic prefixSum: number;\n\n\tconstructor(id: string, afterLineNumber: number, ordinal: number, height: number, minWidth: number) {\n\t\tthis.id = id;\n\t\tthis.afterLineNumber = afterLineNumber;\n\t\tthis.ordinal = ordinal;\n\t\tthis.height = height;\n\t\tthis.minWidth = minWidth;\n\t\tthis.prefixSum = 0;\n\t}\n}\n\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n\n\tprivate static INSTANCE_COUNT = 0;\n\n\tprivate readonly _instanceId: string;\n\tprivate readonly _pendingChanges: PendingChanges;\n\tprivate _lastWhitespaceId: number;\n\tprivate _arr: EditorWhitespace[];\n\tprivate _prefixSumValidIndex: number;\n\tprivate _minWidth: number;\n\tprivate _lineCount: number;\n\tprivate _paddingTop: number;\n\tprivate _paddingBottom: number;\n\tprivate _lineHeightsManager: LineHeightsManager;\n\n\tconstructor(lineCount: number, defaultLineHeight: number, paddingTop: number, paddingBottom: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n\t\tthis._pendingChanges = new PendingChanges();\n\t\tthis._lastWhitespaceId = 0;\n\t\tthis._arr = [];\n\t\tthis._prefixSumValidIndex = -1;\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\tthis._lineCount = lineCount;\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t\tthis._lineHeightsManager = new LineHeightsManager(defaultLineHeight, customLineHeightData);\n\t}\n\n\t/**\n\t * Find the insertion index for a new value inside a sorted array of values.\n\t * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n\t */\n\tpublic static findInsertionIndex(arr: EditorWhitespace[], afterLineNumber: number, ordinal: number): number {\n\t\tlet low = 0;\n\t\tlet high = arr.length;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = ((low + high) >>> 1);\n\n\t\t\tif (afterLineNumber === arr[mid].afterLineNumber) {\n\t\t\t\tif (ordinal < arr[mid].ordinal) {\n\t\t\t\t\thigh = mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (afterLineNumber < arr[mid].afterLineNumber) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * Change the height of a line in pixels.\n\t */\n\tpublic setDefaultLineHeight(lineHeight: number): void {\n\t\tthis._lineHeightsManager.defaultLineHeight = lineHeight;\n\t}\n\n\t/**\n\t * Changes the padding used to calculate vertical offsets.\n\t */\n\tpublic setPadding(paddingTop: number, paddingBottom: number): void {\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t}\n\n\t/**\n\t * Set the number of lines.\n\t *\n\t * @param lineCount New number of lines.\n\t */\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._lineCount = lineCount;\n\t\tthis._lineHeightsManager = new LineHeightsManager(this._lineHeightsManager.defaultLineHeight, customLineHeightData);\n\t}\n\n\tpublic changeLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: ILineHeightChangeAccessor = {\n\t\t\t\tinsertOrChangeCustomLineHeight: (decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight);\n\t\t\t\t},\n\t\t\t\tremoveCustomLineHeight: (decorationId: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.removeCustomLineHeight(decorationId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._lineHeightsManager.commit();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: IWhitespaceChangeAccessor = {\n\t\t\t\tinsertWhitespace: (afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tafterLineNumber = afterLineNumber | 0;\n\t\t\t\t\tordinal = ordinal | 0;\n\t\t\t\t\theightInPx = heightInPx | 0;\n\t\t\t\t\tminWidth = minWidth | 0;\n\t\t\t\t\tconst id = this._instanceId + (++this._lastWhitespaceId);\n\t\t\t\t\tthis._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\t\t\t\t\treturn id;\n\t\t\t\t},\n\t\t\t\tchangeOneWhitespace: (id: string, newAfterLineNumber: number, newHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\t\t\t\t\tnewHeight = newHeight | 0;\n\t\t\t\t\tthis._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n\t\t\t\t},\n\t\t\t\tremoveWhitespace: (id: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._pendingChanges.remove({ id });\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._pendingChanges.commit(this);\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic _commitPendingChanges(inserts: EditorWhitespace[], changes: IPendingChange[], removes: IPendingRemove[]): void {\n\t\tif (inserts.length > 0 || removes.length > 0) {\n\t\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\t}\n\n\t\tif (inserts.length + changes.length + removes.length <= 1) {\n\t\t\t// when only one thing happened, handle it \"delicately\"\n\t\t\tfor (const insert of inserts) {\n\t\t\t\tthis._insertWhitespace(insert);\n\t\t\t}\n\t\t\tfor (const change of changes) {\n\t\t\t\tthis._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n\t\t\t}\n\t\t\tfor (const remove of removes) {\n\t\t\t\tconst index = this._findWhitespaceIndex(remove.id);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._removeWhitespace(index);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// simply rebuild the entire datastructure\n\n\t\tconst toRemove = new Set<string>();\n\t\tfor (const remove of removes) {\n\t\t\ttoRemove.add(remove.id);\n\t\t}\n\n\t\tconst toChange = new Map<string, IPendingChange>();\n\t\tfor (const change of changes) {\n\t\t\ttoChange.set(change.id, change);\n\t\t}\n\n\t\tconst applyRemoveAndChange = (whitespaces: EditorWhitespace[]): EditorWhitespace[] => {\n\t\t\tconst result: EditorWhitespace[] = [];\n\t\t\tfor (const whitespace of whitespaces) {\n\t\t\t\tif (toRemove.has(whitespace.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (toChange.has(whitespace.id)) {\n\t\t\t\t\tconst change = toChange.get(whitespace.id)!;\n\t\t\t\t\twhitespace.afterLineNumber = change.newAfterLineNumber;\n\t\t\t\t\twhitespace.height = change.newHeight;\n\t\t\t\t}\n\t\t\t\tresult.push(whitespace);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n\t\tresult.sort((a, b) => {\n\t\t\tif (a.afterLineNumber === b.afterLineNumber) {\n\t\t\t\treturn a.ordinal - b.ordinal;\n\t\t\t}\n\t\t\treturn a.afterLineNumber - b.afterLineNumber;\n\t\t});\n\n\t\tthis._arr = result;\n\t\tthis._prefixSumValidIndex = -1;\n\t}\n\n\tprivate _insertWhitespace(whitespace: EditorWhitespace): void {\n\t\tconst insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\t\tthis._arr.splice(insertIndex, 0, whitespace);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n\t}\n\n\tprivate _findWhitespaceIndex(id: string): number {\n\t\tconst arr = this._arr;\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i].id === id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate _changeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void {\n\t\tconst index = this._findWhitespaceIndex(id);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._arr[index].height !== newHeight) {\n\t\t\tthis._arr[index].height = newHeight;\n\t\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n\t\t}\n\t\tif (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n\t\t\t// `afterLineNumber` changed for this whitespace\n\n\t\t\t// Record old whitespace\n\t\t\tconst whitespace = this._arr[index];\n\n\t\t\t// Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\t\t\tthis._removeWhitespace(index);\n\n\t\t\twhitespace.afterLineNumber = newAfterLineNumber;\n\n\t\t\t// And add it again\n\t\t\tthis._insertWhitespace(whitespace);\n\t\t}\n\t}\n\n\tprivate _removeWhitespace(removeIndex: number): void {\n\t\tthis._arr.splice(removeIndex, 1);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been deleted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount -= (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been deleted\n\t\t\t\t//  => move whitespace to before first deleted line\n\t\t\t\tthis._arr[i].afterLineNumber = fromLineNumber - 1;\n\t\t\t} else if (afterLineNumber > toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been moved up\n\t\t\t\t//  => move whitespace up\n\t\t\t\tthis._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been inserted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount += (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber) {\n\t\t\t\tthis._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Get the sum of all the whitespaces.\n\t */\n\tpublic getWhitespacesTotalHeight(): number {\n\t\tif (this._arr.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n\t}\n\n\t/**\n\t * Return the sum of the heights of the whitespaces at [0..index].\n\t * This includes the whitespace at `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n\t */\n\tpublic getWhitespacesAccumulatedHeight(index: number): number {\n\t\tindex = index | 0;\n\n\t\tlet startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\t\tif (startIndex === 0) {\n\t\t\tthis._arr[0].prefixSum = this._arr[0].height;\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n\t\t}\n\t\tthis._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n\t\treturn this._arr[index].prefixSum;\n\t}\n\n\t/**\n\t * Get the sum of heights for all objects.\n\t *\n\t * @return The sum of heights for all objects.\n\t */\n\tpublic getLinesTotalHeight(): number {\n\t\tconst linesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(this._lineCount);\n\t\tconst whitespacesHeight = this.getWhitespacesTotalHeight();\n\n\t\treturn linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n\t}\n\n\t/**\n\t * Returns the accumulated height of whitespaces before the given line number.\n\t *\n\t * @param lineNumber The line number\n\t */\n\tpublic getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n\t\tif (lastWhitespaceBeforeLineNumber === -1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n\t}\n\n\tprivate _findLastWhitespaceBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\t// Find the whitespace before line number\n\t\tconst arr = this._arr;\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst delta = (high - low) | 0;\n\t\t\tconst halfDelta = (delta / 2) | 0;\n\t\t\tconst mid = (low + halfDelta) | 0;\n\n\t\t\tif (arr[mid].afterLineNumber < lineNumber) {\n\t\t\t\tif (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = (mid + 1) | 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thigh = (mid - 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findFirstWhitespaceAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\t\tconst firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n\t\tif (firstWhitespaceAfterLineNumber < this._arr.length) {\n\t\t\treturn firstWhitespaceAfterLineNumber;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n\t * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n\t */\n\tpublic getFirstWhitespaceIndexAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\treturn this._findFirstWhitespaceAfterLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet previousLinesHeight: number;\n\t\tif (lineNumber > 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber - 1);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._lineHeightsManager.heightForLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number and also the line height of the line.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\t\tconst previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber);\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\t/**\n\t * The maximum min width for all whitespaces.\n\t */\n\tpublic getWhitespaceMinWidth(): number {\n\t\tif (this._minWidth === -1) {\n\t\t\tlet minWidth = 0;\n\t\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\t\tminWidth = Math.max(minWidth, this._arr[i].minWidth);\n\t\t\t}\n\t\t\tthis._minWidth = minWidth;\n\t\t}\n\t\treturn this._minWidth;\n\t}\n\n\t/**\n\t * Check if `verticalOffset` is below all lines.\n\t */\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn verticalOffset > totalHeight;\n\t}\n\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingTop === 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (verticalOffset < this._paddingTop);\n\t}\n\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingBottom === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn (verticalOffset >= totalHeight - this._paddingBottom);\n\t}\n\n\t/**\n\t * Find the first line number that is at or after vertical offset `verticalOffset`.\n\t * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n\t * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n\t *\n\t * @param verticalOffset The vertical offset to search at.\n\t * @return The line number at or after vertical offset `verticalOffset`.\n\t */\n\tpublic getLineNumberAtOrAfterVerticalOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tif (verticalOffset < 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst linesCount = this._lineCount | 0;\n\t\tlet minLineNumber = 1;\n\t\tlet maxLineNumber = linesCount;\n\n\t\twhile (minLineNumber < maxLineNumber) {\n\t\t\tconst midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(midLineNumber);\n\t\t\tconst midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n\t\t\tif (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n\t\t\t\t// vertical offset is after mid line number\n\t\t\t\tminLineNumber = midLineNumber + 1;\n\t\t\t} else if (verticalOffset >= midLineNumberVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midLineNumber;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before mid line number, but mid line number could still be what we're searching for\n\t\t\t\tmaxLineNumber = midLineNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (minLineNumber > linesCount) {\n\t\t\treturn linesCount;\n\t\t}\n\n\t\treturn minLineNumber;\n\t}\n\n\t/**\n\t * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n\t */\n\tpublic getLinesViewportData(verticalOffset1: number, verticalOffset2: number): IPartialViewLinesViewportData {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\t// Find first line number\n\t\t// We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\t\tconst startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n\t\tconst startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n\n\t\tlet endLineNumber = this._lineCount | 0;\n\n\t\t// Also keep track of what whitespace we've got\n\t\tlet whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n\t\tconst whitespaceCount = this.getWhitespacesCount() | 0;\n\t\tlet currentWhitespaceHeight: number;\n\t\tlet currentWhitespaceAfterLineNumber: number;\n\n\t\tif (whitespaceIndex === -1) {\n\t\t\twhitespaceIndex = whitespaceCount;\n\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\tcurrentWhitespaceHeight = 0;\n\t\t} else {\n\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t}\n\n\t\tlet currentVerticalOffset = startLineNumberVerticalOffset;\n\t\tlet currentLineRelativeOffset = currentVerticalOffset;\n\n\t\t// IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\t\tconst STEP_SIZE = 500000;\n\t\tlet bigNumbersDelta = 0;\n\t\tif (startLineNumberVerticalOffset >= STEP_SIZE) {\n\t\t\t// Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n\t\t\tbigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n\t\t\tbigNumbersDelta = Math.floor(bigNumbersDelta / this._lineHeightsManager.defaultLineHeight) * this._lineHeightsManager.defaultLineHeight;\n\n\t\t\tcurrentLineRelativeOffset -= bigNumbersDelta;\n\t\t}\n\n\t\tconst linesOffsets: number[] = [];\n\n\t\tconst verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n\t\tlet centeredLineNumber = -1;\n\n\t\t// Figure out how far the lines go\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(lineNumber);\n\t\t\tif (centeredLineNumber === -1) {\n\t\t\t\tconst currentLineTop = currentVerticalOffset;\n\t\t\t\tconst currentLineBottom = currentVerticalOffset + lineHeight;\n\t\t\t\tif ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n\t\t\t\t\tcenteredLineNumber = lineNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Count current line height in the vertical offsets\n\t\t\tcurrentVerticalOffset += lineHeight;\n\t\t\tlinesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n\n\t\t\t// Next line starts immediately after this one\n\t\t\tcurrentLineRelativeOffset += lineHeight;\n\t\t\twhile (currentWhitespaceAfterLineNumber === lineNumber) {\n\t\t\t\t// Push down next line with the height of the current whitespace\n\t\t\t\tcurrentLineRelativeOffset += currentWhitespaceHeight;\n\n\t\t\t\t// Count current whitespace in the vertical offsets\n\t\t\t\tcurrentVerticalOffset += currentWhitespaceHeight;\n\t\t\t\twhitespaceIndex++;\n\n\t\t\t\tif (whitespaceIndex >= whitespaceCount) {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentVerticalOffset >= verticalOffset2) {\n\t\t\t\t// We have covered the entire viewport area, time to stop\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (centeredLineNumber === -1) {\n\t\t\tcenteredLineNumber = endLineNumber;\n\t\t}\n\n\t\tconst endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n\n\t\tlet completelyVisibleStartLineNumber = startLineNumber;\n\t\tlet completelyVisibleEndLineNumber = endLineNumber;\n\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (startLineNumberVerticalOffset < verticalOffset1) {\n\t\t\t\tcompletelyVisibleStartLineNumber++;\n\t\t\t}\n\t\t}\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tconst endLineHeight = this.getLineHeightForLineNumber(endLineNumber);\n\t\t\tif (endLineNumberVerticalOffset + endLineHeight > verticalOffset2) {\n\t\t\t\tcompletelyVisibleEndLineNumber--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbigNumbersDelta: bigNumbersDelta,\n\t\t\tstartLineNumber: startLineNumber,\n\t\t\tendLineNumber: endLineNumber,\n\t\t\trelativeVerticalOffset: linesOffsets,\n\t\t\tcenteredLineNumber: centeredLineNumber,\n\t\t\tcompletelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n\t\t\tcompletelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n\t\t\tlineHeight: this._lineHeightsManager.defaultLineHeight,\n\t\t};\n\t}\n\n\tpublic getVerticalOffsetForWhitespaceIndex(whitespaceIndex: number): number {\n\t\twhitespaceIndex = whitespaceIndex | 0;\n\n\t\tconst afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n\n\t\tlet previousLinesHeight: number;\n\t\tif (afterLineNumber >= 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(afterLineNumber);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight: number;\n\t\tif (whitespaceIndex > 0) {\n\t\t\tpreviousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n\t\t} else {\n\t\t\tpreviousWhitespacesHeight = 0;\n\t\t}\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet minWhitespaceIndex = 0;\n\t\tlet maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (maxWhitespaceIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Special case: nothing to be found\n\t\tconst maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n\t\tconst maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\t\tif (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (minWhitespaceIndex < maxWhitespaceIndex) {\n\t\t\tconst midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n\n\t\t\tconst midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n\t\t\tconst midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n\t\t\tif (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n\t\t\t\t// vertical offset is after whitespace\n\t\t\t\tminWhitespaceIndex = midWhitespaceIndex + 1;\n\t\t\t} else if (verticalOffset >= midWhitespaceVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midWhitespaceIndex;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n\t\t\t\tmaxWhitespaceIndex = midWhitespaceIndex;\n\t\t\t}\n\t\t}\n\t\treturn minWhitespaceIndex;\n\t}\n\n\t/**\n\t * Get exactly the whitespace that is layouted at `verticalOffset`.\n\t *\n\t * @param verticalOffset The vertical offset.\n\t * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n\t */\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tconst candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n\t\tif (candidateIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (candidateIndex >= this.getWhitespacesCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n\t\tif (candidateTop > verticalOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n\t\tconst candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n\t\tconst candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n\n\t\treturn {\n\t\t\tid: candidateId,\n\t\t\tafterLineNumber: candidateAfterLineNumber,\n\t\t\tverticalOffset: candidateTop,\n\t\t\theight: candidateHeight\n\t\t};\n\t}\n\n\t/**\n\t * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n\t */\n\tpublic getWhitespaceViewportData(verticalOffset1: number, verticalOffset2: number): IViewWhitespaceViewportData[] {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\tconst startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n\t\tconst endIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (startIndex < 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IViewWhitespaceViewportData[] = [];\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst top = this.getVerticalOffsetForWhitespaceIndex(i);\n\t\t\tconst height = this.getHeightForWhitespaceIndex(i);\n\t\t\tif (top >= verticalOffset2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tid: this.getIdForWhitespaceIndex(i),\n\t\t\t\tafterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n\t\t\t\tverticalOffset: top,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._arr.slice(0);\n\t}\n\n\t/**\n\t * The number of whitespaces.\n\t */\n\tpublic getWhitespacesCount(): number {\n\t\treturn this._arr.length;\n\t}\n\n\t/**\n\t * Get the `id` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `id` of whitespace at `index`.\n\t */\n\tpublic getIdForWhitespaceIndex(index: number): string {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].id;\n\t}\n\n\t/**\n\t * Get the `afterLineNumber` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `afterLineNumber` of whitespace at `index`.\n\t */\n\tpublic getAfterLineNumberForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].afterLineNumber;\n\t}\n\n\t/**\n\t * Get the `height` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `height` of whitespace at `index`.\n\t */\n\tpublic getHeightForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].height;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewWhitespaceViewportData, IWhitespaceChangeAccessor } from '../viewModel.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ICustomLineHeightData, LineHeightsManager } from './lineHeights.js';\n\ninterface IPendingChange { id: string; newAfterLineNumber: number; newHeight: number }\ninterface IPendingRemove { id: string }\n\nclass PendingChanges {\n\tprivate _hasPending: boolean;\n\tprivate _inserts: EditorWhitespace[];\n\tprivate _changes: IPendingChange[];\n\tprivate _removes: IPendingRemove[];\n\n\tconstructor() {\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\t}\n\n\tpublic insert(x: EditorWhitespace): void {\n\t\tthis._hasPending = true;\n\t\tthis._inserts.push(x);\n\t}\n\n\tpublic change(x: IPendingChange): void {\n\t\tthis._hasPending = true;\n\t\tthis._changes.push(x);\n\t}\n\n\tpublic remove(x: IPendingRemove): void {\n\t\tthis._hasPending = true;\n\t\tthis._removes.push(x);\n\t}\n\n\tpublic commit(linesLayout: LinesLayout): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inserts = this._inserts;\n\t\tconst changes = this._changes;\n\t\tconst removes = this._removes;\n\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\n\t\tlinesLayout._commitPendingChanges(inserts, changes, removes);\n\t}\n}\n\nexport class EditorWhitespace implements IEditorWhitespace {\n\tpublic id: string;\n\tpublic afterLineNumber: number;\n\tpublic ordinal: number;\n\tpublic height: number;\n\tpublic minWidth: number;\n\tpublic prefixSum: number;\n\n\tconstructor(id: string, afterLineNumber: number, ordinal: number, height: number, minWidth: number) {\n\t\tthis.id = id;\n\t\tthis.afterLineNumber = afterLineNumber;\n\t\tthis.ordinal = ordinal;\n\t\tthis.height = height;\n\t\tthis.minWidth = minWidth;\n\t\tthis.prefixSum = 0;\n\t}\n}\n\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n\n\tprivate static INSTANCE_COUNT = 0;\n\n\tprivate readonly _instanceId: string;\n\tprivate readonly _pendingChanges: PendingChanges;\n\tprivate _lastWhitespaceId: number;\n\tprivate _arr: EditorWhitespace[];\n\tprivate _prefixSumValidIndex: number;\n\tprivate _minWidth: number;\n\tprivate _lineCount: number;\n\tprivate _paddingTop: number;\n\tprivate _paddingBottom: number;\n\tprivate _lineHeightsManager: LineHeightsManager;\n\n\tconstructor(lineCount: number, defaultLineHeight: number, paddingTop: number, paddingBottom: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n\t\tthis._pendingChanges = new PendingChanges();\n\t\tthis._lastWhitespaceId = 0;\n\t\tthis._arr = [];\n\t\tthis._prefixSumValidIndex = -1;\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\tthis._lineCount = lineCount;\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t\tthis._lineHeightsManager = new LineHeightsManager(defaultLineHeight, customLineHeightData);\n\t}\n\n\t/**\n\t * Find the insertion index for a new value inside a sorted array of values.\n\t * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n\t */\n\tpublic static findInsertionIndex(arr: EditorWhitespace[], afterLineNumber: number, ordinal: number): number {\n\t\tlet low = 0;\n\t\tlet high = arr.length;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = ((low + high) >>> 1);\n\n\t\t\tif (afterLineNumber === arr[mid].afterLineNumber) {\n\t\t\t\tif (ordinal < arr[mid].ordinal) {\n\t\t\t\t\thigh = mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (afterLineNumber < arr[mid].afterLineNumber) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * Change the height of a line in pixels.\n\t */\n\tpublic setDefaultLineHeight(lineHeight: number): void {\n\t\tthis._lineHeightsManager.defaultLineHeight = lineHeight;\n\t}\n\n\t/**\n\t * Changes the padding used to calculate vertical offsets.\n\t */\n\tpublic setPadding(paddingTop: number, paddingBottom: number): void {\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t}\n\n\t/**\n\t * Set the number of lines.\n\t *\n\t * @param lineCount New number of lines.\n\t */\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._lineCount = lineCount;\n\t\tthis._lineHeightsManager = new LineHeightsManager(this._lineHeightsManager.defaultLineHeight, customLineHeightData);\n\t}\n\n\tpublic changeLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: ILineHeightChangeAccessor = {\n\t\t\t\tinsertOrChangeCustomLineHeight: (decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight);\n\t\t\t\t},\n\t\t\t\tremoveCustomLineHeight: (decorationId: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.removeCustomLineHeight(decorationId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._lineHeightsManager.commit();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: IWhitespaceChangeAccessor = {\n\t\t\t\tinsertWhitespace: (afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tafterLineNumber = afterLineNumber | 0;\n\t\t\t\t\tordinal = ordinal | 0;\n\t\t\t\t\theightInPx = heightInPx | 0;\n\t\t\t\t\tminWidth = minWidth | 0;\n\t\t\t\t\tconst id = this._instanceId + (++this._lastWhitespaceId);\n\t\t\t\t\tthis._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\t\t\t\t\treturn id;\n\t\t\t\t},\n\t\t\t\tchangeOneWhitespace: (id: string, newAfterLineNumber: number, newHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\t\t\t\t\tnewHeight = newHeight | 0;\n\t\t\t\t\tthis._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n\t\t\t\t},\n\t\t\t\tremoveWhitespace: (id: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._pendingChanges.remove({ id });\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._pendingChanges.commit(this);\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic _commitPendingChanges(inserts: EditorWhitespace[], changes: IPendingChange[], removes: IPendingRemove[]): void {\n\t\tif (inserts.length > 0 || removes.length > 0) {\n\t\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\t}\n\n\t\tif (inserts.length + changes.length + removes.length <= 1) {\n\t\t\t// when only one thing happened, handle it \"delicately\"\n\t\t\tfor (const insert of inserts) {\n\t\t\t\tthis._insertWhitespace(insert);\n\t\t\t}\n\t\t\tfor (const change of changes) {\n\t\t\t\tthis._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n\t\t\t}\n\t\t\tfor (const remove of removes) {\n\t\t\t\tconst index = this._findWhitespaceIndex(remove.id);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._removeWhitespace(index);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// simply rebuild the entire datastructure\n\n\t\tconst toRemove = new Set<string>();\n\t\tfor (const remove of removes) {\n\t\t\ttoRemove.add(remove.id);\n\t\t}\n\n\t\tconst toChange = new Map<string, IPendingChange>();\n\t\tfor (const change of changes) {\n\t\t\ttoChange.set(change.id, change);\n\t\t}\n\n\t\tconst applyRemoveAndChange = (whitespaces: EditorWhitespace[]): EditorWhitespace[] => {\n\t\t\tconst result: EditorWhitespace[] = [];\n\t\t\tfor (const whitespace of whitespaces) {\n\t\t\t\tif (toRemove.has(whitespace.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (toChange.has(whitespace.id)) {\n\t\t\t\t\tconst change = toChange.get(whitespace.id)!;\n\t\t\t\t\twhitespace.afterLineNumber = change.newAfterLineNumber;\n\t\t\t\t\twhitespace.height = change.newHeight;\n\t\t\t\t}\n\t\t\t\tresult.push(whitespace);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n\t\tresult.sort((a, b) => {\n\t\t\tif (a.afterLineNumber === b.afterLineNumber) {\n\t\t\t\treturn a.ordinal - b.ordinal;\n\t\t\t}\n\t\t\treturn a.afterLineNumber - b.afterLineNumber;\n\t\t});\n\n\t\tthis._arr = result;\n\t\tthis._prefixSumValidIndex = -1;\n\t}\n\n\tprivate _insertWhitespace(whitespace: EditorWhitespace): void {\n\t\tconst insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\t\tthis._arr.splice(insertIndex, 0, whitespace);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n\t}\n\n\tprivate _findWhitespaceIndex(id: string): number {\n\t\tconst arr = this._arr;\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i].id === id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate _changeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void {\n\t\tconst index = this._findWhitespaceIndex(id);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._arr[index].height !== newHeight) {\n\t\t\tthis._arr[index].height = newHeight;\n\t\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n\t\t}\n\t\tif (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n\t\t\t// `afterLineNumber` changed for this whitespace\n\n\t\t\t// Record old whitespace\n\t\t\tconst whitespace = this._arr[index];\n\n\t\t\t// Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\t\t\tthis._removeWhitespace(index);\n\n\t\t\twhitespace.afterLineNumber = newAfterLineNumber;\n\n\t\t\t// And add it again\n\t\t\tthis._insertWhitespace(whitespace);\n\t\t}\n\t}\n\n\tprivate _removeWhitespace(removeIndex: number): void {\n\t\tthis._arr.splice(removeIndex, 1);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been deleted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount -= (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been deleted\n\t\t\t\t//  => move whitespace to before first deleted line\n\t\t\t\tthis._arr[i].afterLineNumber = fromLineNumber - 1;\n\t\t\t} else if (afterLineNumber > toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been moved up\n\t\t\t\t//  => move whitespace up\n\t\t\t\tthis._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been inserted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount += (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber) {\n\t\t\t\tthis._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Get the sum of all the whitespaces.\n\t */\n\tpublic getWhitespacesTotalHeight(): number {\n\t\tif (this._arr.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n\t}\n\n\t/**\n\t * Return the sum of the heights of the whitespaces at [0..index].\n\t * This includes the whitespace at `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n\t */\n\tpublic getWhitespacesAccumulatedHeight(index: number): number {\n\t\tindex = index | 0;\n\n\t\tlet startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\t\tif (startIndex === 0) {\n\t\t\tthis._arr[0].prefixSum = this._arr[0].height;\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n\t\t}\n\t\tthis._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n\t\treturn this._arr[index].prefixSum;\n\t}\n\n\t/**\n\t * Get the sum of heights for all objects.\n\t *\n\t * @return The sum of heights for all objects.\n\t */\n\tpublic getLinesTotalHeight(): number {\n\t\tconst linesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(this._lineCount);\n\t\tconst whitespacesHeight = this.getWhitespacesTotalHeight();\n\n\t\treturn linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n\t}\n\n\t/**\n\t * Returns the accumulated height of whitespaces before the given line number.\n\t *\n\t * @param lineNumber The line number\n\t */\n\tpublic getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n\t\tif (lastWhitespaceBeforeLineNumber === -1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n\t}\n\n\tprivate _findLastWhitespaceBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\t// Find the whitespace before line number\n\t\tconst arr = this._arr;\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst delta = (high - low) | 0;\n\t\t\tconst halfDelta = (delta / 2) | 0;\n\t\t\tconst mid = (low + halfDelta) | 0;\n\n\t\t\tif (arr[mid].afterLineNumber < lineNumber) {\n\t\t\t\tif (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = (mid + 1) | 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thigh = (mid - 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findFirstWhitespaceAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\t\tconst firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n\t\tif (firstWhitespaceAfterLineNumber < this._arr.length) {\n\t\t\treturn firstWhitespaceAfterLineNumber;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n\t * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n\t */\n\tpublic getFirstWhitespaceIndexAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\treturn this._findFirstWhitespaceAfterLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet previousLinesHeight: number;\n\t\tif (lineNumber > 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber - 1);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._lineHeightsManager.heightForLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number and also the line height of the line.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\t\tconst previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber);\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\t/**\n\t * The maximum min width for all whitespaces.\n\t */\n\tpublic getWhitespaceMinWidth(): number {\n\t\tif (this._minWidth === -1) {\n\t\t\tlet minWidth = 0;\n\t\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\t\tminWidth = Math.max(minWidth, this._arr[i].minWidth);\n\t\t\t}\n\t\t\tthis._minWidth = minWidth;\n\t\t}\n\t\treturn this._minWidth;\n\t}\n\n\t/**\n\t * Check if `verticalOffset` is below all lines.\n\t */\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn verticalOffset > totalHeight;\n\t}\n\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingTop === 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (verticalOffset < this._paddingTop);\n\t}\n\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingBottom === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn (verticalOffset >= totalHeight - this._paddingBottom);\n\t}\n\n\t/**\n\t * Find the first line number that is at or after vertical offset `verticalOffset`.\n\t * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n\t * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n\t *\n\t * @param verticalOffset The vertical offset to search at.\n\t * @return The line number at or after vertical offset `verticalOffset`.\n\t */\n\tpublic getLineNumberAtOrAfterVerticalOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tif (verticalOffset < 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst linesCount = this._lineCount | 0;\n\t\tlet minLineNumber = 1;\n\t\tlet maxLineNumber = linesCount;\n\n\t\twhile (minLineNumber < maxLineNumber) {\n\t\t\tconst midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(midLineNumber);\n\t\t\tconst midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n\t\t\tif (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n\t\t\t\t// vertical offset is after mid line number\n\t\t\t\tminLineNumber = midLineNumber + 1;\n\t\t\t} else if (verticalOffset >= midLineNumberVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midLineNumber;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before mid line number, but mid line number could still be what we're searching for\n\t\t\t\tmaxLineNumber = midLineNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (minLineNumber > linesCount) {\n\t\t\treturn linesCount;\n\t\t}\n\n\t\treturn minLineNumber;\n\t}\n\n\t/**\n\t * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n\t */\n\tpublic getLinesViewportData(verticalOffset1: number, verticalOffset2: number): IPartialViewLinesViewportData {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\t// Find first line number\n\t\t// We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\t\tconst startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n\t\tconst startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n\n\t\tlet endLineNumber = this._lineCount | 0;\n\n\t\t// Also keep track of what whitespace we've got\n\t\tlet whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n\t\tconst whitespaceCount = this.getWhitespacesCount() | 0;\n\t\tlet currentWhitespaceHeight: number;\n\t\tlet currentWhitespaceAfterLineNumber: number;\n\n\t\tif (whitespaceIndex === -1) {\n\t\t\twhitespaceIndex = whitespaceCount;\n\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\tcurrentWhitespaceHeight = 0;\n\t\t} else {\n\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t}\n\n\t\tlet currentVerticalOffset = startLineNumberVerticalOffset;\n\t\tlet currentLineRelativeOffset = currentVerticalOffset;\n\n\t\t// IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\t\tconst STEP_SIZE = 500000;\n\t\tlet bigNumbersDelta = 0;\n\t\tif (startLineNumberVerticalOffset >= STEP_SIZE) {\n\t\t\t// Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n\t\t\tbigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n\t\t\tbigNumbersDelta = Math.floor(bigNumbersDelta / this._lineHeightsManager.defaultLineHeight) * this._lineHeightsManager.defaultLineHeight;\n\n\t\t\tcurrentLineRelativeOffset -= bigNumbersDelta;\n\t\t}\n\n\t\tconst linesOffsets: number[] = [];\n\n\t\tconst verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n\t\tlet centeredLineNumber = -1;\n\n\t\t// Figure out how far the lines go\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(lineNumber);\n\t\t\tif (centeredLineNumber === -1) {\n\t\t\t\tconst currentLineTop = currentVerticalOffset;\n\t\t\t\tconst currentLineBottom = currentVerticalOffset + lineHeight;\n\t\t\t\tif ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n\t\t\t\t\tcenteredLineNumber = lineNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Count current line height in the vertical offsets\n\t\t\tcurrentVerticalOffset += lineHeight;\n\t\t\tlinesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n\n\t\t\t// Next line starts immediately after this one\n\t\t\tcurrentLineRelativeOffset += lineHeight;\n\t\t\twhile (currentWhitespaceAfterLineNumber === lineNumber) {\n\t\t\t\t// Push down next line with the height of the current whitespace\n\t\t\t\tcurrentLineRelativeOffset += currentWhitespaceHeight;\n\n\t\t\t\t// Count current whitespace in the vertical offsets\n\t\t\t\tcurrentVerticalOffset += currentWhitespaceHeight;\n\t\t\t\twhitespaceIndex++;\n\n\t\t\t\tif (whitespaceIndex >= whitespaceCount) {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentVerticalOffset >= verticalOffset2) {\n\t\t\t\t// We have covered the entire viewport area, time to stop\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (centeredLineNumber === -1) {\n\t\t\tcenteredLineNumber = endLineNumber;\n\t\t}\n\n\t\tconst endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n\n\t\tlet completelyVisibleStartLineNumber = startLineNumber;\n\t\tlet completelyVisibleEndLineNumber = endLineNumber;\n\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (startLineNumberVerticalOffset < verticalOffset1) {\n\t\t\t\tcompletelyVisibleStartLineNumber++;\n\t\t\t}\n\t\t}\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tconst endLineHeight = this.getLineHeightForLineNumber(endLineNumber);\n\t\t\tif (endLineNumberVerticalOffset + endLineHeight > verticalOffset2) {\n\t\t\t\tcompletelyVisibleEndLineNumber--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbigNumbersDelta: bigNumbersDelta,\n\t\t\tstartLineNumber: startLineNumber,\n\t\t\tendLineNumber: endLineNumber,\n\t\t\trelativeVerticalOffset: linesOffsets,\n\t\t\tcenteredLineNumber: centeredLineNumber,\n\t\t\tcompletelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n\t\t\tcompletelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n\t\t\tlineHeight: this._lineHeightsManager.defaultLineHeight,\n\t\t};\n\t}\n\n\tpublic getVerticalOffsetForWhitespaceIndex(whitespaceIndex: number): number {\n\t\twhitespaceIndex = whitespaceIndex | 0;\n\n\t\tconst afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n\n\t\tlet previousLinesHeight: number;\n\t\tif (afterLineNumber >= 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(afterLineNumber);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight: number;\n\t\tif (whitespaceIndex > 0) {\n\t\t\tpreviousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n\t\t} else {\n\t\t\tpreviousWhitespacesHeight = 0;\n\t\t}\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet minWhitespaceIndex = 0;\n\t\tlet maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (maxWhitespaceIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Special case: nothing to be found\n\t\tconst maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n\t\tconst maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\t\tif (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (minWhitespaceIndex < maxWhitespaceIndex) {\n\t\t\tconst midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n\n\t\t\tconst midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n\t\t\tconst midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n\t\t\tif (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n\t\t\t\t// vertical offset is after whitespace\n\t\t\t\tminWhitespaceIndex = midWhitespaceIndex + 1;\n\t\t\t} else if (verticalOffset >= midWhitespaceVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midWhitespaceIndex;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n\t\t\t\tmaxWhitespaceIndex = midWhitespaceIndex;\n\t\t\t}\n\t\t}\n\t\treturn minWhitespaceIndex;\n\t}\n\n\t/**\n\t * Get exactly the whitespace that is layouted at `verticalOffset`.\n\t *\n\t * @param verticalOffset The vertical offset.\n\t * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n\t */\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tconst candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n\t\tif (candidateIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (candidateIndex >= this.getWhitespacesCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n\t\tif (candidateTop > verticalOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n\t\tconst candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n\t\tconst candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n\n\t\treturn {\n\t\t\tid: candidateId,\n\t\t\tafterLineNumber: candidateAfterLineNumber,\n\t\t\tverticalOffset: candidateTop,\n\t\t\theight: candidateHeight\n\t\t};\n\t}\n\n\t/**\n\t * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n\t */\n\tpublic getWhitespaceViewportData(verticalOffset1: number, verticalOffset2: number): IViewWhitespaceViewportData[] {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\tconst startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n\t\tconst endIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (startIndex < 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IViewWhitespaceViewportData[] = [];\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst top = this.getVerticalOffsetForWhitespaceIndex(i);\n\t\t\tconst height = this.getHeightForWhitespaceIndex(i);\n\t\t\tif (top >= verticalOffset2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tid: this.getIdForWhitespaceIndex(i),\n\t\t\t\tafterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n\t\t\t\tverticalOffset: top,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._arr.slice(0);\n\t}\n\n\t/**\n\t * The number of whitespaces.\n\t */\n\tpublic getWhitespacesCount(): number {\n\t\treturn this._arr.length;\n\t}\n\n\t/**\n\t * Get the `id` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `id` of whitespace at `index`.\n\t */\n\tpublic getIdForWhitespaceIndex(index: number): string {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].id;\n\t}\n\n\t/**\n\t * Get the `afterLineNumber` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `afterLineNumber` of whitespace at `index`.\n\t */\n\tpublic getAfterLineNumberForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].afterLineNumber;\n\t}\n\n\t/**\n\t * Get the `height` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `height` of whitespace at `index`.\n\t */\n\tpublic getHeightForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].height;\n\t}\n}\n"]}