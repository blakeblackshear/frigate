{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelTokens.ts","vs/editor/common/model/textModelTokens.ts"],"names":[],"mappings":"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","file":"textModelTokens.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { ITextModel } from '../model.js';\nimport { FixedArray } from './fixedArray.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.initialState = this.tokenizationSupport.getInitialState() as TState;\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst lineStartState: IState | null = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst result: LineTokens[] = [];\n\n\t\tlet state = lineStartState;\n\t\tfor (const line of lines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n\t\t\tresult.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet { likelyRelevantLines, initialState } = findLikelyRelevantLines(this._textModel, lineNumber, this);\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nexport function findLikelyRelevantLines(model: ITextModel, lineNumber: number, store?: TokenizerWithStateStore): { likelyRelevantLines: string[]; initialState?: IState } {\n\tlet nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\tconst likelyRelevantLines: string[] = [];\n\tlet initialState: IState | null | undefined = null;\n\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\tconst newNonWhitespaceIndex = model.getLineFirstNonWhitespaceColumn(i);\n\t\t// Ignore lines full of whitespace\n\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\tlikelyRelevantLines.push(model.getLineContent(i));\n\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\tinitialState = store?.getStartState(i);\n\t\t\tif (initialState) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlikelyRelevantLines.reverse();\n\treturn { likelyRelevantLines, initialState: initialState ?? undefined };\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { ITextModel } from '../model.js';\nimport { FixedArray } from './fixedArray.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.initialState = this.tokenizationSupport.getInitialState() as TState;\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst lineStartState: IState | null = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst result: LineTokens[] = [];\n\n\t\tlet state = lineStartState;\n\t\tfor (const line of lines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n\t\t\tresult.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet { likelyRelevantLines, initialState } = findLikelyRelevantLines(this._textModel, lineNumber, this);\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nexport function findLikelyRelevantLines(model: ITextModel, lineNumber: number, store?: TokenizerWithStateStore): { likelyRelevantLines: string[]; initialState?: IState } {\n\tlet nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\tconst likelyRelevantLines: string[] = [];\n\tlet initialState: IState | null | undefined = null;\n\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\tconst newNonWhitespaceIndex = model.getLineFirstNonWhitespaceColumn(i);\n\t\t// Ignore lines full of whitespace\n\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\tlikelyRelevantLines.push(model.getLineContent(i));\n\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\tinitialState = store?.getStartState(i);\n\t\t\tif (initialState) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlikelyRelevantLines.reverse();\n\treturn { likelyRelevantLines, initialState: initialState ?? undefined };\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n"]}