{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/model/graph.ts","vs/editor/contrib/inlineCompletions/browser/model/graph.ts"],"names":[],"mappings":"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","file":"graph.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class DirectedGraph<T> {\n\tprivate readonly _nodes = new Set<T>();\n\tprivate readonly _outgoingEdges = new Map<T, Set<T>>();\n\n\tpublic static from<T>(nodes: readonly T[], getOutgoing: (node: T) => readonly T[]): DirectedGraph<T> {\n\t\tconst graph = new DirectedGraph<T>();\n\n\t\tfor (const node of nodes) {\n\t\t\tgraph._nodes.add(node);\n\t\t}\n\n\t\tfor (const node of nodes) {\n\t\t\tconst outgoing = getOutgoing(node);\n\t\t\tif (outgoing.length > 0) {\n\t\t\t\tconst outgoingSet = new Set<T>();\n\t\t\t\tfor (const target of outgoing) {\n\t\t\t\t\toutgoingSet.add(target);\n\t\t\t\t}\n\t\t\t\tgraph._outgoingEdges.set(node, outgoingSet);\n\t\t\t}\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\t/**\n\t * After this, the graph is guaranteed to have no cycles.\n\t */\n\tremoveCycles(): { foundCycles: T[] } {\n\t\tconst foundCycles: T[] = [];\n\t\tconst visited = new Set<T>();\n\t\tconst recursionStack = new Set<T>();\n\t\tconst toRemove: Array<{ from: T; to: T }> = [];\n\n\t\tconst dfs = (node: T): void => {\n\t\t\tvisited.add(node);\n\t\t\trecursionStack.add(node);\n\n\t\t\tconst outgoing = this._outgoingEdges.get(node);\n\t\t\tif (outgoing) {\n\t\t\t\tfor (const neighbor of outgoing) {\n\t\t\t\t\tif (!visited.has(neighbor)) {\n\t\t\t\t\t\tdfs(neighbor);\n\t\t\t\t\t} else if (recursionStack.has(neighbor)) {\n\t\t\t\t\t\t// Found a cycle\n\t\t\t\t\t\tfoundCycles.push(neighbor);\n\t\t\t\t\t\ttoRemove.push({ from: node, to: neighbor });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecursionStack.delete(node);\n\t\t};\n\n\t\t// Run DFS from all unvisited nodes\n\t\tfor (const node of this._nodes) {\n\t\t\tif (!visited.has(node)) {\n\t\t\t\tdfs(node);\n\t\t\t}\n\t\t}\n\n\t\t// Remove edges that cause cycles\n\t\tfor (const { from, to } of toRemove) {\n\t\t\tconst outgoingSet = this._outgoingEdges.get(from);\n\t\t\tif (outgoingSet) {\n\t\t\t\toutgoingSet.delete(to);\n\t\t\t}\n\t\t}\n\n\t\treturn { foundCycles };\n\t}\n\n\tgetOutgoing(node: T): readonly T[] {\n\t\tconst outgoing = this._outgoingEdges.get(node);\n\t\treturn outgoing ? Array.from(outgoing) : [];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class DirectedGraph<T> {\n\tprivate readonly _nodes = new Set<T>();\n\tprivate readonly _outgoingEdges = new Map<T, Set<T>>();\n\n\tpublic static from<T>(nodes: readonly T[], getOutgoing: (node: T) => readonly T[]): DirectedGraph<T> {\n\t\tconst graph = new DirectedGraph<T>();\n\n\t\tfor (const node of nodes) {\n\t\t\tgraph._nodes.add(node);\n\t\t}\n\n\t\tfor (const node of nodes) {\n\t\t\tconst outgoing = getOutgoing(node);\n\t\t\tif (outgoing.length > 0) {\n\t\t\t\tconst outgoingSet = new Set<T>();\n\t\t\t\tfor (const target of outgoing) {\n\t\t\t\t\toutgoingSet.add(target);\n\t\t\t\t}\n\t\t\t\tgraph._outgoingEdges.set(node, outgoingSet);\n\t\t\t}\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\t/**\n\t * After this, the graph is guaranteed to have no cycles.\n\t */\n\tremoveCycles(): { foundCycles: T[] } {\n\t\tconst foundCycles: T[] = [];\n\t\tconst visited = new Set<T>();\n\t\tconst recursionStack = new Set<T>();\n\t\tconst toRemove: Array<{ from: T; to: T }> = [];\n\n\t\tconst dfs = (node: T): void => {\n\t\t\tvisited.add(node);\n\t\t\trecursionStack.add(node);\n\n\t\t\tconst outgoing = this._outgoingEdges.get(node);\n\t\t\tif (outgoing) {\n\t\t\t\tfor (const neighbor of outgoing) {\n\t\t\t\t\tif (!visited.has(neighbor)) {\n\t\t\t\t\t\tdfs(neighbor);\n\t\t\t\t\t} else if (recursionStack.has(neighbor)) {\n\t\t\t\t\t\t// Found a cycle\n\t\t\t\t\t\tfoundCycles.push(neighbor);\n\t\t\t\t\t\ttoRemove.push({ from: node, to: neighbor });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecursionStack.delete(node);\n\t\t};\n\n\t\t// Run DFS from all unvisited nodes\n\t\tfor (const node of this._nodes) {\n\t\t\tif (!visited.has(node)) {\n\t\t\t\tdfs(node);\n\t\t\t}\n\t\t}\n\n\t\t// Remove edges that cause cycles\n\t\tfor (const { from, to } of toRemove) {\n\t\t\tconst outgoingSet = this._outgoingEdges.get(from);\n\t\t\tif (outgoingSet) {\n\t\t\t\toutgoingSet.delete(to);\n\t\t\t}\n\t\t}\n\n\t\treturn { foundCycles };\n\t}\n\n\tgetOutgoing(node: T): readonly T[] {\n\t\tconst outgoing = this._outgoingEdges.get(node);\n\t\treturn outgoing ? Array.from(outgoing) : [];\n\t}\n}\n"]}