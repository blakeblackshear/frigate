{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/cursorUtils.ts","vs/editor/common/model/tokens/treeSitter/cursorUtils.ts"],"names":[],"mappings":"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","file":"cursorUtils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\n\nexport function gotoNextSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoNextSibling();\n\tconst o = oldCursor.gotoNextSibling();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoParent(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoParent();\n\tconst o = oldCursor.gotoParent();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoNthChild(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor, index: number) {\n\tconst n = newCursor.gotoFirstChild();\n\tconst o = oldCursor.gotoFirstChild();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\tif (index === 0) {\n\t\treturn n && o;\n\t}\n\tfor (let i = 1; i <= index; i++) {\n\t\tconst nn = newCursor.gotoNextSibling();\n\t\tconst oo = oldCursor.gotoNextSibling();\n\t\tif (nn !== oo) {\n\t\t\tthrow new Error('Trees are out of sync');\n\t\t}\n\t\tif (!nn || !oo) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn n && o;\n}\n\nexport function nextSiblingOrParentSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tdo {\n\t\tif (newCursor.currentNode.nextSibling) {\n\t\t\treturn gotoNextSibling(newCursor, oldCursor);\n\t\t}\n\t\tif (newCursor.currentNode.parent) {\n\t\t\tgotoParent(newCursor, oldCursor);\n\t\t}\n\t} while (newCursor.currentNode.nextSibling || newCursor.currentNode.parent);\n\treturn false;\n}\n\nexport function getClosestPreviousNodes(cursor: TreeSitter.TreeCursor, tree: TreeSitter.Tree): TreeSitter.Node | undefined {\n\t// Go up parents until the end of the parent is before the start of the current.\n\tconst findPrev = tree.walk();\n\tfindPrev.resetTo(cursor);\n\n\tconst startingNode = cursor.currentNode;\n\tdo {\n\t\tif (findPrev.currentNode.previousSibling && ((findPrev.currentNode.endIndex - findPrev.currentNode.startIndex) !== 0)) {\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t} else {\n\t\t\twhile (!findPrev.currentNode.previousSibling && findPrev.currentNode.parent) {\n\t\t\t\tfindPrev.gotoParent();\n\t\t\t}\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t}\n\t} while ((findPrev.currentNode.endIndex > startingNode.startIndex)\n\t&& (findPrev.currentNode.parent || findPrev.currentNode.previousSibling)\n\n\t\t&& (findPrev.currentNode.id !== startingNode.id));\n\n\tif ((findPrev.currentNode.id !== startingNode.id) && findPrev.currentNode.endIndex <= startingNode.startIndex) {\n\t\treturn findPrev.currentNode;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\n\nexport function gotoNextSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoNextSibling();\n\tconst o = oldCursor.gotoNextSibling();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoParent(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoParent();\n\tconst o = oldCursor.gotoParent();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoNthChild(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor, index: number) {\n\tconst n = newCursor.gotoFirstChild();\n\tconst o = oldCursor.gotoFirstChild();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\tif (index === 0) {\n\t\treturn n && o;\n\t}\n\tfor (let i = 1; i <= index; i++) {\n\t\tconst nn = newCursor.gotoNextSibling();\n\t\tconst oo = oldCursor.gotoNextSibling();\n\t\tif (nn !== oo) {\n\t\t\tthrow new Error('Trees are out of sync');\n\t\t}\n\t\tif (!nn || !oo) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn n && o;\n}\n\nexport function nextSiblingOrParentSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tdo {\n\t\tif (newCursor.currentNode.nextSibling) {\n\t\t\treturn gotoNextSibling(newCursor, oldCursor);\n\t\t}\n\t\tif (newCursor.currentNode.parent) {\n\t\t\tgotoParent(newCursor, oldCursor);\n\t\t}\n\t} while (newCursor.currentNode.nextSibling || newCursor.currentNode.parent);\n\treturn false;\n}\n\nexport function getClosestPreviousNodes(cursor: TreeSitter.TreeCursor, tree: TreeSitter.Tree): TreeSitter.Node | undefined {\n\t// Go up parents until the end of the parent is before the start of the current.\n\tconst findPrev = tree.walk();\n\tfindPrev.resetTo(cursor);\n\n\tconst startingNode = cursor.currentNode;\n\tdo {\n\t\tif (findPrev.currentNode.previousSibling && ((findPrev.currentNode.endIndex - findPrev.currentNode.startIndex) !== 0)) {\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t} else {\n\t\t\twhile (!findPrev.currentNode.previousSibling && findPrev.currentNode.parent) {\n\t\t\t\tfindPrev.gotoParent();\n\t\t\t}\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t}\n\t} while ((findPrev.currentNode.endIndex > startingNode.startIndex)\n\t&& (findPrev.currentNode.parent || findPrev.currentNode.previousSibling)\n\n\t\t&& (findPrev.currentNode.id !== startingNode.id));\n\n\tif ((findPrev.currentNode.id !== startingNode.id) && findPrev.currentNode.endIndex <= startingNode.startIndex) {\n\t\treturn findPrev.currentNode;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n"]}