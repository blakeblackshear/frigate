{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/objectCollectionBuffer.ts","vs/editor/browser/gpu/objectCollectionBuffer.ts"],"names":[],"mappings":"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","file":"objectCollectionBuffer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { BufferDirtyTracker, type IBufferDirtyTrackerReader } from './bufferDirtyTracker.js';\n\nexport interface ObjectCollectionBufferPropertySpec {\n\tname: string;\n}\n\nexport type ObjectCollectionPropertyValues<T extends ObjectCollectionBufferPropertySpec[]> = {\n\t[K in T[number]['name']]: number;\n};\n\nexport interface IObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\t/**\n\t * The underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly buffer: ArrayBufferLike;\n\t/**\n\t * A view of the underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly view: Float32Array;\n\t/**\n\t * The number of entries in the buffer.\n\t */\n\treadonly entryCount: number;\n\n\t/**\n\t * A tracker for dirty regions in the buffer.\n\t */\n\treadonly dirtyTracker: IBufferDirtyTrackerReader;\n\n\t/**\n\t * Fires when the buffer is recreated.\n\t */\n\treadonly onDidChangeBuffer: Event<void>;\n\n\t/**\n\t * Creates an entry in the collection. This will return a managed object that can be modified\n\t * which will update the underlying buffer.\n\t * @param data The data of the entry.\n\t */\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T>;\n}\n\n/**\n * An entry in an {@link ObjectCollectionBuffer}. Property values on the entry can be changed and\n * their values will be updated automatically in the buffer.\n */\nexport interface IObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\tsetRaw(data: ArrayLike<number>): void;\n}\n\nexport function createObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]>(\n\tpropertySpecs: T,\n\tcapacity: number\n): IObjectCollectionBuffer<T> {\n\treturn new ObjectCollectionBuffer<T>(propertySpecs, capacity);\n}\n\nclass ObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBuffer<T> {\n\tbuffer: ArrayBufferLike;\n\tview: Float32Array;\n\tget entryCount() {\n\t\treturn this._entries.size;\n\t}\n\n\tprivate _dirtyTracker = new BufferDirtyTracker();\n\tget dirtyTracker(): IBufferDirtyTrackerReader { return this._dirtyTracker; }\n\n\tprivate readonly _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }> = new Map();\n\tprivate readonly _entrySize: number;\n\tprivate readonly _entries: LinkedList<ObjectCollectionBufferEntry<T>> = new LinkedList();\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tprivate readonly _onDidChangeBuffer = this._register(new Emitter<void>());\n\treadonly onDidChangeBuffer = this._onDidChangeBuffer.event;\n\n\tconstructor(\n\t\tpublic propertySpecs: T,\n\t\tpublic capacity: number\n\t) {\n\t\tsuper();\n\n\t\tthis.view = new Float32Array(capacity * propertySpecs.length);\n\t\tthis.buffer = this.view.buffer;\n\t\tthis._entrySize = propertySpecs.length;\n\t\tfor (let i = 0; i < propertySpecs.length; i++) {\n\t\t\tconst spec = {\n\t\t\t\toffset: i,\n\t\t\t\t...propertySpecs[i]\n\t\t\t};\n\t\t\tthis._propertySpecsMap.set(spec.name, spec);\n\t\t}\n\t\tthis._register(toDisposable(() => dispose(this._entries)));\n\t}\n\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T> {\n\t\tif (this._entries.size === this.capacity) {\n\t\t\tthis._expandBuffer();\n\t\t\tthis._onDidChangeBuffer.fire();\n\t\t}\n\n\t\tconst value = new ObjectCollectionBufferEntry(this.view, this._propertySpecsMap, this._dirtyTracker, this._entries.size, data);\n\t\tconst removeFromEntries = this._entries.push(value);\n\t\tconst listeners: IDisposable[] = [];\n\t\tlisteners.push(Event.forward(value.onDidChange, this._onDidChange));\n\t\tlisteners.push(value.onWillDispose(() => {\n\t\t\tconst deletedEntryIndex = value.i;\n\t\t\tremoveFromEntries();\n\n\t\t\t// Shift all entries after the deleted entry to the left\n\t\t\tthis.view.set(this.view.subarray(deletedEntryIndex * this._entrySize + 2, this._entries.size * this._entrySize + 2), deletedEntryIndex * this._entrySize);\n\n\t\t\t// Update entries to reflect the new i\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.i > deletedEntryIndex) {\n\t\t\t\t\tentry.i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyTracker.flag(deletedEntryIndex, (this._entries.size - deletedEntryIndex) * this._entrySize);\n\t\t\tdispose(listeners);\n\t\t}));\n\t\treturn value;\n\t}\n\n\tprivate _expandBuffer() {\n\t\tthis.capacity *= 2;\n\t\tconst newView = new Float32Array(this.capacity * this._entrySize);\n\t\tnewView.set(this.view);\n\t\tthis.view = newView;\n\t\tthis.buffer = this.view.buffer;\n\t}\n}\n\nclass ObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBufferEntry<T> {\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\treadonly onDidChange = this._onDidChange.event;\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\tconstructor(\n\t\tprivate _view: Float32Array,\n\t\tprivate _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }>,\n\t\tprivate _dirtyTracker: BufferDirtyTracker,\n\t\tpublic i: number,\n\t\tdata: ObjectCollectionPropertyValues<T>,\n\t) {\n\t\tsuper();\n\t\tfor (const propertySpec of this._propertySpecsMap.values()) {\n\t\t\tthis._view[this.i * this._propertySpecsMap.size + propertySpec.offset] = data[propertySpec.name as keyof typeof data];\n\t\t}\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n\n\toverride dispose() {\n\t\tthis._onWillDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tsetRaw(data: ArrayLike<number>): void {\n\t\tif (data.length !== this._propertySpecsMap.size) {\n\t\t\tthrow new Error(`Data length ${data.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);\n\t\t}\n\t\tthis._view.set(data, this.i * this._propertySpecsMap.size);\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { BufferDirtyTracker, type IBufferDirtyTrackerReader } from './bufferDirtyTracker.js';\n\nexport interface ObjectCollectionBufferPropertySpec {\n\tname: string;\n}\n\nexport type ObjectCollectionPropertyValues<T extends ObjectCollectionBufferPropertySpec[]> = {\n\t[K in T[number]['name']]: number;\n};\n\nexport interface IObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\t/**\n\t * The underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly buffer: ArrayBufferLike;\n\t/**\n\t * A view of the underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly view: Float32Array;\n\t/**\n\t * The number of entries in the buffer.\n\t */\n\treadonly entryCount: number;\n\n\t/**\n\t * A tracker for dirty regions in the buffer.\n\t */\n\treadonly dirtyTracker: IBufferDirtyTrackerReader;\n\n\t/**\n\t * Fires when the buffer is recreated.\n\t */\n\treadonly onDidChangeBuffer: Event<void>;\n\n\t/**\n\t * Creates an entry in the collection. This will return a managed object that can be modified\n\t * which will update the underlying buffer.\n\t * @param data The data of the entry.\n\t */\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T>;\n}\n\n/**\n * An entry in an {@link ObjectCollectionBuffer}. Property values on the entry can be changed and\n * their values will be updated automatically in the buffer.\n */\nexport interface IObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\tsetRaw(data: ArrayLike<number>): void;\n}\n\nexport function createObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]>(\n\tpropertySpecs: T,\n\tcapacity: number\n): IObjectCollectionBuffer<T> {\n\treturn new ObjectCollectionBuffer<T>(propertySpecs, capacity);\n}\n\nclass ObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBuffer<T> {\n\tbuffer: ArrayBufferLike;\n\tview: Float32Array;\n\tget entryCount() {\n\t\treturn this._entries.size;\n\t}\n\n\tprivate _dirtyTracker = new BufferDirtyTracker();\n\tget dirtyTracker(): IBufferDirtyTrackerReader { return this._dirtyTracker; }\n\n\tprivate readonly _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }> = new Map();\n\tprivate readonly _entrySize: number;\n\tprivate readonly _entries: LinkedList<ObjectCollectionBufferEntry<T>> = new LinkedList();\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tprivate readonly _onDidChangeBuffer = this._register(new Emitter<void>());\n\treadonly onDidChangeBuffer = this._onDidChangeBuffer.event;\n\n\tconstructor(\n\t\tpublic propertySpecs: T,\n\t\tpublic capacity: number\n\t) {\n\t\tsuper();\n\n\t\tthis.view = new Float32Array(capacity * propertySpecs.length);\n\t\tthis.buffer = this.view.buffer;\n\t\tthis._entrySize = propertySpecs.length;\n\t\tfor (let i = 0; i < propertySpecs.length; i++) {\n\t\t\tconst spec = {\n\t\t\t\toffset: i,\n\t\t\t\t...propertySpecs[i]\n\t\t\t};\n\t\t\tthis._propertySpecsMap.set(spec.name, spec);\n\t\t}\n\t\tthis._register(toDisposable(() => dispose(this._entries)));\n\t}\n\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T> {\n\t\tif (this._entries.size === this.capacity) {\n\t\t\tthis._expandBuffer();\n\t\t\tthis._onDidChangeBuffer.fire();\n\t\t}\n\n\t\tconst value = new ObjectCollectionBufferEntry(this.view, this._propertySpecsMap, this._dirtyTracker, this._entries.size, data);\n\t\tconst removeFromEntries = this._entries.push(value);\n\t\tconst listeners: IDisposable[] = [];\n\t\tlisteners.push(Event.forward(value.onDidChange, this._onDidChange));\n\t\tlisteners.push(value.onWillDispose(() => {\n\t\t\tconst deletedEntryIndex = value.i;\n\t\t\tremoveFromEntries();\n\n\t\t\t// Shift all entries after the deleted entry to the left\n\t\t\tthis.view.set(this.view.subarray(deletedEntryIndex * this._entrySize + 2, this._entries.size * this._entrySize + 2), deletedEntryIndex * this._entrySize);\n\n\t\t\t// Update entries to reflect the new i\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.i > deletedEntryIndex) {\n\t\t\t\t\tentry.i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyTracker.flag(deletedEntryIndex, (this._entries.size - deletedEntryIndex) * this._entrySize);\n\t\t\tdispose(listeners);\n\t\t}));\n\t\treturn value;\n\t}\n\n\tprivate _expandBuffer() {\n\t\tthis.capacity *= 2;\n\t\tconst newView = new Float32Array(this.capacity * this._entrySize);\n\t\tnewView.set(this.view);\n\t\tthis.view = newView;\n\t\tthis.buffer = this.view.buffer;\n\t}\n}\n\nclass ObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBufferEntry<T> {\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\treadonly onDidChange = this._onDidChange.event;\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\tconstructor(\n\t\tprivate _view: Float32Array,\n\t\tprivate _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }>,\n\t\tprivate _dirtyTracker: BufferDirtyTracker,\n\t\tpublic i: number,\n\t\tdata: ObjectCollectionPropertyValues<T>,\n\t) {\n\t\tsuper();\n\t\tfor (const propertySpec of this._propertySpecsMap.values()) {\n\t\t\tthis._view[this.i * this._propertySpecsMap.size + propertySpec.offset] = data[propertySpec.name as keyof typeof data];\n\t\t}\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n\n\toverride dispose() {\n\t\tthis._onWillDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tsetRaw(data: ArrayLike<number>): void {\n\t\tif (data.length !== this._propertySpecsMap.size) {\n\t\t\tthrow new Error(`Data length ${data.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);\n\t\t}\n\t\tthis._view.set(data, this.i * this._propertySpecsMap.size);\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n}\n"]}