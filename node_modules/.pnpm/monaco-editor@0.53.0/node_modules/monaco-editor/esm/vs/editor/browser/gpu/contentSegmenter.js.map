{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/contentSegmenter.ts","vs/editor/browser/gpu/contentSegmenter.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,QAAQ,EAAE,MAAM,8BAA8B,CAAC;AAcxD,MAAM,UAAU,sBAAsB,CAAC,QAA+B,EAAE,OAAwB;IAC/F,IAAI,QAAQ,CAAC,YAAY,IAAI,OAAO,CAAC,yBAAyB,EAAE,CAAC;QAChE,OAAO,IAAI,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IAC5C,CAAC;IACD,OAAO,IAAI,wBAAwB,CAAC,QAAQ,CAAC,CAAC;AAC/C,CAAC;AAED,MAAM,qBAAqB;IAG1B,YAAY,QAA+B;QAC1C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;IAClC,CAAC;IAED,iBAAiB,CAAC,KAAa;QAC9B,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;CACD;AAED;;;GAGG;AACH,MAAM,wBAAwB;IAG7B,YAAY,QAA+B;QAF1B,cAAS,GAAqC,EAAE,CAAC;QAGjE,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;QACjC,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,EAAE,WAAW,EAAE,UAAU,EAAE,CAAC,CAAC,KAAK,CAAC;QACnF,MAAM,gBAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;QAChE,IAAI,cAAc,GAAG,CAAC,CAAC;QAEvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,MAAM,OAAO,GAAG,gBAAgB,CAAC,cAAc,CAAC,CAAC;YAEjD,oEAAoE;YACpE,IAAI,CAAC,OAAO,EAAE,CAAC;gBACd,MAAM;YACP,CAAC;YAED,8DAA8D;YAC9D,IAAI,OAAO,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC;gBACzB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,SAAS;YACV,CAAC;YAED,cAAc,EAAE,CAAC;YACjB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC9B,CAAC;IACF,CAAC;IAED,iBAAiB,CAAC,KAAa;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC;IACvC,CAAC;CACD","file":"contentSegmenter.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from '../../../base/common/date.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { ViewLineOptions } from '../viewParts/viewLines/viewLineOptions.js';\n\nexport interface IContentSegmenter {\n\t/**\n\t * Gets the content segment at an index within the line data's contents. This will be undefined\n\t * when the index should not be rendered, ie. when it's part of an earlier segment like the tail\n\t * end of an emoji, or when the line is not that long.\n\t * @param index The index within the line data's content string.\n\t */\n\tgetSegmentAtIndex(index: number): string | undefined;\n}\n\nexport function createContentSegmenter(lineData: ViewLineRenderingData, options: ViewLineOptions): IContentSegmenter {\n\tif (lineData.isBasicASCII && options.useMonospaceOptimizations) {\n\t\treturn new AsciiContentSegmenter(lineData);\n\t}\n\treturn new GraphemeContentSegmenter(lineData);\n}\n\nclass AsciiContentSegmenter implements IContentSegmenter {\n\tprivate readonly _content: string;\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tthis._content = lineData.content;\n\t}\n\n\tgetSegmentAtIndex(index: number): string {\n\t\treturn this._content[index];\n\t}\n}\n\n/**\n * This is a more modern version of {@link GraphemeIterator}, relying on browser APIs instead of a\n * manual table approach.\n */\nclass GraphemeContentSegmenter implements IContentSegmenter {\n\tprivate readonly _segments: (Intl.SegmentData | undefined)[] = [];\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tconst content = lineData.content;\n\t\tconst segmenter = safeIntl.Segmenter(undefined, { granularity: 'grapheme' }).value;\n\t\tconst segmentedContent = Array.from(segmenter.segment(content));\n\t\tlet segmenterIndex = 0;\n\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst segment = segmentedContent[segmenterIndex];\n\n\t\t\t// No more segments in the string (eg. an emoji is the last segment)\n\t\t\tif (!segment) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The segment isn't renderable (eg. the tail end of an emoji)\n\t\t\tif (segment.index !== x) {\n\t\t\t\tthis._segments.push(undefined);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsegmenterIndex++;\n\t\t\tthis._segments.push(segment);\n\t\t}\n\t}\n\n\tgetSegmentAtIndex(index: number): string | undefined {\n\t\treturn this._segments[index]?.segment;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from '../../../base/common/date.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { ViewLineOptions } from '../viewParts/viewLines/viewLineOptions.js';\n\nexport interface IContentSegmenter {\n\t/**\n\t * Gets the content segment at an index within the line data's contents. This will be undefined\n\t * when the index should not be rendered, ie. when it's part of an earlier segment like the tail\n\t * end of an emoji, or when the line is not that long.\n\t * @param index The index within the line data's content string.\n\t */\n\tgetSegmentAtIndex(index: number): string | undefined;\n}\n\nexport function createContentSegmenter(lineData: ViewLineRenderingData, options: ViewLineOptions): IContentSegmenter {\n\tif (lineData.isBasicASCII && options.useMonospaceOptimizations) {\n\t\treturn new AsciiContentSegmenter(lineData);\n\t}\n\treturn new GraphemeContentSegmenter(lineData);\n}\n\nclass AsciiContentSegmenter implements IContentSegmenter {\n\tprivate readonly _content: string;\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tthis._content = lineData.content;\n\t}\n\n\tgetSegmentAtIndex(index: number): string {\n\t\treturn this._content[index];\n\t}\n}\n\n/**\n * This is a more modern version of {@link GraphemeIterator}, relying on browser APIs instead of a\n * manual table approach.\n */\nclass GraphemeContentSegmenter implements IContentSegmenter {\n\tprivate readonly _segments: (Intl.SegmentData | undefined)[] = [];\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tconst content = lineData.content;\n\t\tconst segmenter = safeIntl.Segmenter(undefined, { granularity: 'grapheme' }).value;\n\t\tconst segmentedContent = Array.from(segmenter.segment(content));\n\t\tlet segmenterIndex = 0;\n\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst segment = segmentedContent[segmenterIndex];\n\n\t\t\t// No more segments in the string (eg. an emoji is the last segment)\n\t\t\tif (!segment) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The segment isn't renderable (eg. the tail end of an emoji)\n\t\t\tif (segment.index !== x) {\n\t\t\t\tthis._segments.push(undefined);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsegmenterIndex++;\n\t\t\tthis._segments.push(segment);\n\t\t}\n\t}\n\n\tgetSegmentAtIndex(index: number): string | undefined {\n\t\treturn this._segments[index]?.segment;\n\t}\n}\n"]}