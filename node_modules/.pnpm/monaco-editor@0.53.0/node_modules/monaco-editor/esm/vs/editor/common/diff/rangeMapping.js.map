{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/rangeMapping.ts","vs/editor/common/diff/rangeMapping.ts"],"names":[],"mappings":"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","file":"rangeMapping.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n"]}