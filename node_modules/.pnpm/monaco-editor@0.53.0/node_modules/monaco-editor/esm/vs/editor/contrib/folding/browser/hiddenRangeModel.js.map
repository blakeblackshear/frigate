{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/folding/browser/hiddenRangeModel.ts","vs/editor/contrib/folding/browser/hiddenRangeModel.ts"],"names":[],"mappings":"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","file":"hiddenRangeModel.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IRange, Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IModelContentChangedEvent } from '../../../common/textModelEvents.js';\nimport { countEOL } from '../../../common/core/misc/eolCounter.js';\nimport { FoldingModel } from './foldingModel.js';\n\nexport class HiddenRangeModel {\n\n\tprivate readonly _foldingModel: FoldingModel;\n\tprivate _hiddenRanges: IRange[];\n\tprivate _foldingModelListener: IDisposable | null;\n\tprivate readonly _updateEventEmitter = new Emitter<IRange[]>();\n\tprivate _hasLineChanges: boolean = false;\n\n\tpublic get onDidChange(): Event<IRange[]> { return this._updateEventEmitter.event; }\n\tpublic get hiddenRanges() { return this._hiddenRanges; }\n\n\tpublic constructor(model: FoldingModel) {\n\t\tthis._foldingModel = model;\n\t\tthis._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n\t\tthis._hiddenRanges = [];\n\t\tif (model.regions.length) {\n\t\t\tthis.updateHiddenRanges();\n\t\t}\n\t}\n\n\tpublic notifyChangeModelContent(e: IModelContentChangedEvent) {\n\t\tif (this._hiddenRanges.length && !this._hasLineChanges) {\n\t\t\tthis._hasLineChanges = e.changes.some(change => {\n\t\t\t\treturn change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate updateHiddenRanges(): void {\n\t\tlet updateHiddenAreas = false;\n\t\tconst newHiddenAreas: IRange[] = [];\n\t\tlet i = 0; // index into hidden\n\t\tlet k = 0;\n\n\t\tlet lastCollapsedStart = Number.MAX_VALUE;\n\t\tlet lastCollapsedEnd = -1;\n\n\t\tconst ranges = this._foldingModel.regions;\n\t\tfor (; i < ranges.length; i++) {\n\t\t\tif (!ranges.isCollapsed(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n\t\t\tconst endLineNumber = ranges.getEndLineNumber(i);\n\t\t\tif (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n\t\t\t\t// ignore ranges contained in collapsed regions\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n\t\t\t\t// reuse the old ranges\n\t\t\t\tnewHiddenAreas.push(this._hiddenRanges[k]);\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tupdateHiddenAreas = true;\n\t\t\t\tnewHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n\t\t\t}\n\t\t\tlastCollapsedStart = startLineNumber;\n\t\t\tlastCollapsedEnd = endLineNumber;\n\t\t}\n\t\tif (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n\t\t\tthis.applyHiddenRanges(newHiddenAreas);\n\t\t}\n\t}\n\n\tprivate applyHiddenRanges(newHiddenAreas: IRange[]) {\n\t\tthis._hiddenRanges = newHiddenAreas;\n\t\tthis._hasLineChanges = false;\n\t\tthis._updateEventEmitter.fire(newHiddenAreas);\n\t}\n\n\tpublic hasRanges() {\n\t\treturn this._hiddenRanges.length > 0;\n\t}\n\n\tpublic isHidden(line: number): boolean {\n\t\treturn findRange(this._hiddenRanges, line) !== null;\n\t}\n\n\tpublic adjustSelections(selections: Selection[]): boolean {\n\t\tlet hasChanges = false;\n\t\tconst editorModel = this._foldingModel.textModel;\n\t\tlet lastRange: IRange | null = null;\n\n\t\tconst adjustLine = (line: number) => {\n\t\t\tif (!lastRange || !isInside(line, lastRange)) {\n\t\t\t\tlastRange = findRange(this._hiddenRanges, line);\n\t\t\t}\n\t\t\tif (lastRange) {\n\t\t\t\treturn lastRange.startLineNumber - 1;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet selection = selections[i];\n\t\t\tconst adjustedStartLine = adjustLine(selection.startLineNumber);\n\t\t\tif (adjustedStartLine) {\n\t\t\t\tselection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tconst adjustedEndLine = adjustLine(selection.endLineNumber);\n\t\t\tif (adjustedEndLine) {\n\t\t\t\tselection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tselections[i] = selection;\n\t\t}\n\t\treturn hasChanges;\n\t}\n\n\n\tpublic dispose() {\n\t\tif (this.hiddenRanges.length > 0) {\n\t\t\tthis._hiddenRanges = [];\n\t\t\tthis._updateEventEmitter.fire(this._hiddenRanges);\n\t\t}\n\t\tif (this._foldingModelListener) {\n\t\t\tthis._foldingModelListener.dispose();\n\t\t\tthis._foldingModelListener = null;\n\t\t}\n\t}\n}\n\nfunction isInside(line: number, range: IRange) {\n\treturn line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges: IRange[], line: number): IRange | null {\n\tconst i = findFirstIdxMonotonousOrArrLen(ranges, r => line < r.startLineNumber) - 1;\n\tif (i >= 0 && ranges[i].endLineNumber >= line) {\n\t\treturn ranges[i];\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\n\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport { IRange, Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IModelContentChangedEvent } from '../../../common/textModelEvents.js';\nimport { countEOL } from '../../../common/core/misc/eolCounter.js';\nimport { FoldingModel } from './foldingModel.js';\n\nexport class HiddenRangeModel {\n\n\tprivate readonly _foldingModel: FoldingModel;\n\tprivate _hiddenRanges: IRange[];\n\tprivate _foldingModelListener: IDisposable | null;\n\tprivate readonly _updateEventEmitter = new Emitter<IRange[]>();\n\tprivate _hasLineChanges: boolean = false;\n\n\tpublic get onDidChange(): Event<IRange[]> { return this._updateEventEmitter.event; }\n\tpublic get hiddenRanges() { return this._hiddenRanges; }\n\n\tpublic constructor(model: FoldingModel) {\n\t\tthis._foldingModel = model;\n\t\tthis._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n\t\tthis._hiddenRanges = [];\n\t\tif (model.regions.length) {\n\t\t\tthis.updateHiddenRanges();\n\t\t}\n\t}\n\n\tpublic notifyChangeModelContent(e: IModelContentChangedEvent) {\n\t\tif (this._hiddenRanges.length && !this._hasLineChanges) {\n\t\t\tthis._hasLineChanges = e.changes.some(change => {\n\t\t\t\treturn change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate updateHiddenRanges(): void {\n\t\tlet updateHiddenAreas = false;\n\t\tconst newHiddenAreas: IRange[] = [];\n\t\tlet i = 0; // index into hidden\n\t\tlet k = 0;\n\n\t\tlet lastCollapsedStart = Number.MAX_VALUE;\n\t\tlet lastCollapsedEnd = -1;\n\n\t\tconst ranges = this._foldingModel.regions;\n\t\tfor (; i < ranges.length; i++) {\n\t\t\tif (!ranges.isCollapsed(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n\t\t\tconst endLineNumber = ranges.getEndLineNumber(i);\n\t\t\tif (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n\t\t\t\t// ignore ranges contained in collapsed regions\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n\t\t\t\t// reuse the old ranges\n\t\t\t\tnewHiddenAreas.push(this._hiddenRanges[k]);\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tupdateHiddenAreas = true;\n\t\t\t\tnewHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n\t\t\t}\n\t\t\tlastCollapsedStart = startLineNumber;\n\t\t\tlastCollapsedEnd = endLineNumber;\n\t\t}\n\t\tif (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n\t\t\tthis.applyHiddenRanges(newHiddenAreas);\n\t\t}\n\t}\n\n\tprivate applyHiddenRanges(newHiddenAreas: IRange[]) {\n\t\tthis._hiddenRanges = newHiddenAreas;\n\t\tthis._hasLineChanges = false;\n\t\tthis._updateEventEmitter.fire(newHiddenAreas);\n\t}\n\n\tpublic hasRanges() {\n\t\treturn this._hiddenRanges.length > 0;\n\t}\n\n\tpublic isHidden(line: number): boolean {\n\t\treturn findRange(this._hiddenRanges, line) !== null;\n\t}\n\n\tpublic adjustSelections(selections: Selection[]): boolean {\n\t\tlet hasChanges = false;\n\t\tconst editorModel = this._foldingModel.textModel;\n\t\tlet lastRange: IRange | null = null;\n\n\t\tconst adjustLine = (line: number) => {\n\t\t\tif (!lastRange || !isInside(line, lastRange)) {\n\t\t\t\tlastRange = findRange(this._hiddenRanges, line);\n\t\t\t}\n\t\t\tif (lastRange) {\n\t\t\t\treturn lastRange.startLineNumber - 1;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet selection = selections[i];\n\t\t\tconst adjustedStartLine = adjustLine(selection.startLineNumber);\n\t\t\tif (adjustedStartLine) {\n\t\t\t\tselection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tconst adjustedEndLine = adjustLine(selection.endLineNumber);\n\t\t\tif (adjustedEndLine) {\n\t\t\t\tselection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tselections[i] = selection;\n\t\t}\n\t\treturn hasChanges;\n\t}\n\n\n\tpublic dispose() {\n\t\tif (this.hiddenRanges.length > 0) {\n\t\t\tthis._hiddenRanges = [];\n\t\t\tthis._updateEventEmitter.fire(this._hiddenRanges);\n\t\t}\n\t\tif (this._foldingModelListener) {\n\t\t\tthis._foldingModelListener.dispose();\n\t\t\tthis._foldingModelListener = null;\n\t\t}\n\t}\n}\n\nfunction isInside(line: number, range: IRange) {\n\treturn line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges: IRange[], line: number): IRange | null {\n\tconst i = findFirstIdxMonotonousOrArrLen(ranges, r => line < r.startLineNumber) - 1;\n\tif (i >= 0 && ranges[i].endLineNumber >= line) {\n\t\treturn ranges[i];\n\t}\n\treturn null;\n}\n"]}