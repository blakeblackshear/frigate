{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlasPage.ts","vs/editor/browser/gpu/atlas/textureAtlasPage.ts"],"names":[],"mappings":"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","file":"textureAtlasPage.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { IBoundingBox, IGlyphRasterizer } from '../raster/raster.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasAllocator, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\nexport type AllocatorType = 'shelf' | 'slab' | ((canvas: OffscreenCanvas, textureIndex: number) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage extends Disposable implements IReadableTextureAtlasPage {\n\n\tprivate _version: number = 0;\n\tget version(): number { return this._version; }\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> { return this._usedArea; }\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas { return this._canvas; }\n\n\tprivate readonly _glyphMap: GlyphMap<ITextureAtlasPageGlyph> = new NKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\t\tthis._colorMap = themeService.getColorTheme().tokenColorMap;\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn this._glyphMap.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? this._createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _createGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, this._colorMap);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\t// TODO: undefined here can mean the glyph was too large for a slab on the page, this\n\t\t\t// can lead to big problems if we don't handle it properly https://github.com/microsoft/vscode/issues/232984\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(glyph, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n\t\tthis._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace('New glyph', {\n\t\t\t\tchars,\n\t\t\t\ttokenMetadata,\n\t\t\t\tdecorationStyleSetId,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { IBoundingBox, IGlyphRasterizer } from '../raster/raster.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasAllocator, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\nexport type AllocatorType = 'shelf' | 'slab' | ((canvas: OffscreenCanvas, textureIndex: number) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage extends Disposable implements IReadableTextureAtlasPage {\n\n\tprivate _version: number = 0;\n\tget version(): number { return this._version; }\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> { return this._usedArea; }\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas { return this._canvas; }\n\n\tprivate readonly _glyphMap: GlyphMap<ITextureAtlasPageGlyph> = new NKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\t\tthis._colorMap = themeService.getColorTheme().tokenColorMap;\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn this._glyphMap.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? this._createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _createGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, this._colorMap);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\t// TODO: undefined here can mean the glyph was too large for a slab on the page, this\n\t\t\t// can lead to big problems if we don't handle it properly https://github.com/microsoft/vscode/issues/232984\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(glyph, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n\t\tthis._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace('New glyph', {\n\t\t\t\tchars,\n\t\t\t\ttokenMetadata,\n\t\t\t\tdecorationStyleSetId,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n"]}