{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/tokens/tokenWithTextArray.ts","vs/editor/common/tokens/tokenWithTextArray.ts"],"names":[],"mappings":"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","file":"tokenWithTextArray.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { LineTokens } from './lineTokens.js';\n\n/**\n * This class represents a sequence of tokens.\n * Conceptually, each token has a length and a metadata number.\n * A token array might be used to annotate a string with metadata.\n * Use {@link TokenWithTextArrayBuilder} to efficiently create a token array.\n *\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenWithTextArray {\n\tpublic static fromLineTokens(lineTokens: LineTokens): TokenWithTextArray {\n\t\tconst tokenInfo: TokenWithTextInfo[] = [];\n\t\tfor (let i = 0; i < lineTokens.getCount(); i++) {\n\t\t\ttokenInfo.push(new TokenWithTextInfo(lineTokens.getTokenText(i), lineTokens.getMetadata(i)));\n\t\t}\n\t\treturn TokenWithTextArray.create(tokenInfo);\n\t}\n\n\tpublic static create(tokenInfo: TokenWithTextInfo[]): TokenWithTextArray {\n\t\treturn new TokenWithTextArray(tokenInfo);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly _tokenInfo: TokenWithTextInfo[],\n\t) { }\n\n\tpublic toLineTokens(decoder: ILanguageIdCodec): LineTokens {\n\t\treturn LineTokens.createFromTextAndMetadata(this.map((_r, t) => ({ text: t.text, metadata: t.metadata })), decoder);\n\t}\n\n\tpublic map<T>(cb: (range: OffsetRange, tokenInfo: TokenWithTextInfo) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.text.length);\n\t\t\tresult.push(cb(range, tokenInfo));\n\t\t\tlengthSum += tokenInfo.text.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic slice(range: OffsetRange): TokenWithTextArray {\n\t\tconst result: TokenWithTextInfo[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst tokenStart = lengthSum;\n\t\t\tconst tokenEndEx = tokenStart + tokenInfo.text.length;\n\t\t\tif (tokenEndEx > range.start) {\n\t\t\t\tif (tokenStart >= range.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst deltaBefore = Math.max(0, range.start - tokenStart);\n\t\t\t\tconst deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);\n\n\t\t\t\tresult.push(new TokenWithTextInfo(tokenInfo.text.slice(deltaBefore, tokenInfo.text.length - deltaAfter), tokenInfo.metadata));\n\t\t\t}\n\n\t\t\tlengthSum += tokenInfo.text.length;\n\t\t}\n\t\treturn TokenWithTextArray.create(result);\n\t}\n\n\tpublic append(other: TokenWithTextArray): TokenWithTextArray {\n\t\tconst result: TokenWithTextInfo[] = this._tokenInfo.concat(other._tokenInfo);\n\t\treturn TokenWithTextArray.create(result);\n\t}\n}\n\nexport type TokenMetadata = number;\n\nexport class TokenWithTextInfo {\n\tconstructor(\n\t\tpublic readonly text: string,\n\t\tpublic readonly metadata: TokenMetadata,\n\t) { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { ILanguageIdCodec } from '../languages.js';\nimport { LineTokens } from './lineTokens.js';\n\n/**\n * This class represents a sequence of tokens.\n * Conceptually, each token has a length and a metadata number.\n * A token array might be used to annotate a string with metadata.\n * Use {@link TokenWithTextArrayBuilder} to efficiently create a token array.\n *\n * TODO: Make this class more efficient (e.g. by using a Int32Array).\n*/\nexport class TokenWithTextArray {\n\tpublic static fromLineTokens(lineTokens: LineTokens): TokenWithTextArray {\n\t\tconst tokenInfo: TokenWithTextInfo[] = [];\n\t\tfor (let i = 0; i < lineTokens.getCount(); i++) {\n\t\t\ttokenInfo.push(new TokenWithTextInfo(lineTokens.getTokenText(i), lineTokens.getMetadata(i)));\n\t\t}\n\t\treturn TokenWithTextArray.create(tokenInfo);\n\t}\n\n\tpublic static create(tokenInfo: TokenWithTextInfo[]): TokenWithTextArray {\n\t\treturn new TokenWithTextArray(tokenInfo);\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly _tokenInfo: TokenWithTextInfo[],\n\t) { }\n\n\tpublic toLineTokens(decoder: ILanguageIdCodec): LineTokens {\n\t\treturn LineTokens.createFromTextAndMetadata(this.map((_r, t) => ({ text: t.text, metadata: t.metadata })), decoder);\n\t}\n\n\tpublic map<T>(cb: (range: OffsetRange, tokenInfo: TokenWithTextInfo) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst range = new OffsetRange(lengthSum, lengthSum + tokenInfo.text.length);\n\t\t\tresult.push(cb(range, tokenInfo));\n\t\t\tlengthSum += tokenInfo.text.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic slice(range: OffsetRange): TokenWithTextArray {\n\t\tconst result: TokenWithTextInfo[] = [];\n\t\tlet lengthSum = 0;\n\t\tfor (const tokenInfo of this._tokenInfo) {\n\t\t\tconst tokenStart = lengthSum;\n\t\t\tconst tokenEndEx = tokenStart + tokenInfo.text.length;\n\t\t\tif (tokenEndEx > range.start) {\n\t\t\t\tif (tokenStart >= range.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst deltaBefore = Math.max(0, range.start - tokenStart);\n\t\t\t\tconst deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);\n\n\t\t\t\tresult.push(new TokenWithTextInfo(tokenInfo.text.slice(deltaBefore, tokenInfo.text.length - deltaAfter), tokenInfo.metadata));\n\t\t\t}\n\n\t\t\tlengthSum += tokenInfo.text.length;\n\t\t}\n\t\treturn TokenWithTextArray.create(result);\n\t}\n\n\tpublic append(other: TokenWithTextArray): TokenWithTextArray {\n\t\tconst result: TokenWithTextInfo[] = this._tokenInfo.concat(other._tokenInfo);\n\t\treturn TokenWithTextArray.create(result);\n\t}\n}\n\nexport type TokenMetadata = number;\n\nexport class TokenWithTextInfo {\n\tconstructor(\n\t\tpublic readonly text: string,\n\t\tpublic readonly metadata: TokenMetadata,\n\t) { }\n}\n"]}