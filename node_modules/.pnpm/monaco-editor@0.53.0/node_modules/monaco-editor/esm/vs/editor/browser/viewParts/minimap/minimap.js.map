{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/viewParts/minimap/minimap.ts","vs/editor/browser/viewParts/minimap/minimap.ts"],"names":[],"mappings":"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","file":"minimap.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { FastDomNode, createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { IDisposable, Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { ILine, RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprint, PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { RenderMinimap, EditorOption, MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/misc/rgba.js';\nimport { ScrollType } from '../../../common/editorCommon.js';\nimport { IEditorConfiguration } from '../../../common/config/editorConfiguration.js';\nimport { ColorId } from '../../../common/encodedTokenAttributes.js';\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { Constants } from './minimapCharSheet.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { RenderingContext, RestrictedRenderingContext } from '../../view/renderingContext.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { EditorTheme } from '../../../common/editorTheme.js';\nimport * as viewEvents from '../../../common/viewEvents.js';\nimport { ViewLineData } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { ModelDecorationMinimapOptions } from '../../../common/model/textModel.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { GestureEvent, EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition, MinimapSectionHeaderStyle, TextModelResolvedOptions } from '../../../common/model.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModelDecoration.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\n\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\n\nconst GUTTER_DECORATION_WIDTH = 2;\n\nclass MinimapOptions {\n\n\tpublic readonly renderMinimap: RenderMinimap;\n\tpublic readonly size: 'proportional' | 'fill' | 'fit';\n\tpublic readonly minimapHeightIsEditorHeight: boolean;\n\tpublic readonly scrollBeyondLastLine: boolean;\n\tpublic readonly paddingTop: number;\n\tpublic readonly paddingBottom: number;\n\tpublic readonly showSlider: 'always' | 'mouseover';\n\tpublic readonly autohide: 'none' | 'mouseover' | 'scroll';\n\tpublic readonly pixelRatio: number;\n\tpublic readonly typicalHalfwidthCharacterWidth: number;\n\tpublic readonly lineHeight: number;\n\t/**\n\t * container dom node left position (in CSS px)\n\t */\n\tpublic readonly minimapLeft: number;\n\t/**\n\t * container dom node width (in CSS px)\n\t */\n\tpublic readonly minimapWidth: number;\n\t/**\n\t * container dom node height (in CSS px)\n\t */\n\tpublic readonly minimapHeight: number;\n\t/**\n\t * canvas backing store width (in device px)\n\t */\n\tpublic readonly canvasInnerWidth: number;\n\t/**\n\t * canvas backing store height (in device px)\n\t */\n\tpublic readonly canvasInnerHeight: number;\n\t/**\n\t * canvas width (in CSS px)\n\t */\n\tpublic readonly canvasOuterWidth: number;\n\t/**\n\t * canvas height (in CSS px)\n\t */\n\tpublic readonly canvasOuterHeight: number;\n\n\tpublic readonly isSampling: boolean;\n\tpublic readonly editorHeight: number;\n\tpublic readonly fontScale: number;\n\tpublic readonly minimapLineHeight: number;\n\tpublic readonly minimapCharWidth: number;\n\tpublic readonly sectionHeaderFontFamily: string;\n\tpublic readonly sectionHeaderFontSize: number;\n\t/**\n\t * Space in between the characters of the section header (in CSS px)\n\t */\n\tpublic readonly sectionHeaderLetterSpacing: number;\n\tpublic readonly sectionHeaderFontColor: RGBA8;\n\n\tpublic readonly charRenderer: () => MinimapCharRenderer;\n\tpublic readonly defaultBackgroundColor: RGBA8;\n\tpublic readonly backgroundColor: RGBA8;\n\t/**\n\t * foreground alpha: integer in [0-255]\n\t */\n\tpublic readonly foregroundAlpha: number;\n\n\tconstructor(configuration: IEditorConfiguration, theme: EditorTheme, tokensColorTracker: MinimapTokensColorTracker) {\n\t\tconst options = configuration.options;\n\t\tconst pixelRatio = options.get(EditorOption.pixelRatio);\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tconst minimapLayout = layoutInfo.minimap;\n\t\tconst fontInfo = options.get(EditorOption.fontInfo);\n\t\tconst minimapOpts = options.get(EditorOption.minimap);\n\n\t\tthis.renderMinimap = minimapLayout.renderMinimap;\n\t\tthis.size = minimapOpts.size;\n\t\tthis.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n\t\tthis.scrollBeyondLastLine = options.get(EditorOption.scrollBeyondLastLine);\n\t\tthis.paddingTop = options.get(EditorOption.padding).top;\n\t\tthis.paddingBottom = options.get(EditorOption.padding).bottom;\n\t\tthis.showSlider = minimapOpts.showSlider;\n\t\tthis.autohide = minimapOpts.autohide;\n\t\tthis.pixelRatio = pixelRatio;\n\t\tthis.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n\t\tthis.lineHeight = options.get(EditorOption.lineHeight);\n\t\tthis.minimapLeft = minimapLayout.minimapLeft;\n\t\tthis.minimapWidth = minimapLayout.minimapWidth;\n\t\tthis.minimapHeight = layoutInfo.height;\n\n\t\tthis.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n\t\tthis.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n\t\tthis.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n\t\tthis.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n\n\t\tthis.isSampling = minimapLayout.minimapIsSampling;\n\t\tthis.editorHeight = layoutInfo.height;\n\t\tthis.fontScale = minimapLayout.minimapScale;\n\t\tthis.minimapLineHeight = minimapLayout.minimapLineHeight;\n\t\tthis.minimapCharWidth = Constants.BASE_CHAR_WIDTH * this.fontScale;\n\t\tthis.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n\t\tthis.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n\t\tthis.sectionHeaderLetterSpacing = minimapOpts.sectionHeaderLetterSpacing; // intentionally not multiplying by pixelRatio\n\t\tthis.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(ColorId.DefaultForeground));\n\n\t\tthis.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n\t\tthis.defaultBackgroundColor = tokensColorTracker.getColor(ColorId.DefaultBackground);\n\t\tthis.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n\t\tthis.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n\t}\n\n\tprivate static _getMinimapBackground(theme: EditorTheme, defaultBackgroundColor: RGBA8): RGBA8 {\n\t\tconst themeColor = theme.getColor(minimapBackground);\n\t\tif (themeColor) {\n\t\t\treturn new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn defaultBackgroundColor;\n\t}\n\n\tprivate static _getMinimapForegroundOpacity(theme: EditorTheme): number {\n\t\tconst themeColor = theme.getColor(minimapForegroundOpacity);\n\t\tif (themeColor) {\n\t\t\treturn RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn 255;\n\t}\n\n\tprivate static _getSectionHeaderColor(theme: EditorTheme, defaultForegroundColor: RGBA8): RGBA8 {\n\t\tconst themeColor = theme.getColor(editorForeground);\n\t\tif (themeColor) {\n\t\t\treturn new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn defaultForegroundColor;\n\t}\n\n\tpublic equals(other: MinimapOptions): boolean {\n\t\treturn (this.renderMinimap === other.renderMinimap\n\t\t\t&& this.size === other.size\n\t\t\t&& this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n\t\t\t&& this.scrollBeyondLastLine === other.scrollBeyondLastLine\n\t\t\t&& this.paddingTop === other.paddingTop\n\t\t\t&& this.paddingBottom === other.paddingBottom\n\t\t\t&& this.showSlider === other.showSlider\n\t\t\t&& this.autohide === other.autohide\n\t\t\t&& this.pixelRatio === other.pixelRatio\n\t\t\t&& this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n\t\t\t&& this.lineHeight === other.lineHeight\n\t\t\t&& this.minimapLeft === other.minimapLeft\n\t\t\t&& this.minimapWidth === other.minimapWidth\n\t\t\t&& this.minimapHeight === other.minimapHeight\n\t\t\t&& this.canvasInnerWidth === other.canvasInnerWidth\n\t\t\t&& this.canvasInnerHeight === other.canvasInnerHeight\n\t\t\t&& this.canvasOuterWidth === other.canvasOuterWidth\n\t\t\t&& this.canvasOuterHeight === other.canvasOuterHeight\n\t\t\t&& this.isSampling === other.isSampling\n\t\t\t&& this.editorHeight === other.editorHeight\n\t\t\t&& this.fontScale === other.fontScale\n\t\t\t&& this.minimapLineHeight === other.minimapLineHeight\n\t\t\t&& this.minimapCharWidth === other.minimapCharWidth\n\t\t\t&& this.sectionHeaderFontSize === other.sectionHeaderFontSize\n\t\t\t&& this.sectionHeaderLetterSpacing === other.sectionHeaderLetterSpacing\n\t\t\t&& this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n\t\t\t&& this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n\t\t\t&& this.foregroundAlpha === other.foregroundAlpha\n\t\t);\n\t}\n}\n\nclass MinimapLayout {\n\n\tconstructor(\n\t\t/**\n\t\t * The given editor scrollTop (input).\n\t\t */\n\t\tpublic readonly scrollTop: number,\n\t\t/**\n\t\t * The given editor scrollHeight (input).\n\t\t */\n\t\tpublic readonly scrollHeight: number,\n\t\tpublic readonly sliderNeeded: boolean,\n\t\tprivate readonly _computedSliderRatio: number,\n\t\t/**\n\t\t * slider dom node top (in CSS px)\n\t\t */\n\t\tpublic readonly sliderTop: number,\n\t\t/**\n\t\t * slider dom node height (in CSS px)\n\t\t */\n\t\tpublic readonly sliderHeight: number,\n\t\t/**\n\t\t * empty lines to reserve at the top of the minimap.\n\t\t */\n\t\tpublic readonly topPaddingLineCount: number,\n\t\t/**\n\t\t * minimap render start line number.\n\t\t */\n\t\tpublic readonly startLineNumber: number,\n\t\t/**\n\t\t * minimap render end line number.\n\t\t */\n\t\tpublic readonly endLineNumber: number\n\t) { }\n\n\t/**\n\t * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n\t */\n\tpublic getDesiredScrollTopFromDelta(delta: number): number {\n\t\treturn Math.round(this.scrollTop + delta / this._computedSliderRatio);\n\t}\n\n\tpublic getDesiredScrollTopFromTouchLocation(pageY: number): number {\n\t\treturn Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n\t}\n\n\t/**\n\t * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n\t */\n\tpublic intersectWithViewport(range: Range): [number, number] | null {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n\t\tconst endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n\t\tif (startLineNumber > endLineNumber) {\n\t\t\t// entirely outside minimap's viewport\n\t\t\treturn null;\n\t\t}\n\t\treturn [startLineNumber, endLineNumber];\n\t}\n\n\t/**\n\t * Get the inner minimap y coordinate for a line number.\n\t */\n\tpublic getYForLineNumber(lineNumber: number, minimapLineHeight: number): number {\n\t\treturn + (lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n\t}\n\n\tpublic static create(\n\t\toptions: MinimapOptions,\n\t\tviewportStartLineNumber: number,\n\t\tviewportEndLineNumber: number,\n\t\tviewportStartLineNumberVerticalOffset: number,\n\t\tviewportHeight: number,\n\t\tviewportContainsWhitespaceGaps: boolean,\n\t\tlineCount: number,\n\t\trealLineCount: number,\n\t\tscrollTop: number,\n\t\tscrollHeight: number,\n\t\tpreviousLayout: MinimapLayout | null\n\t): MinimapLayout {\n\t\tconst pixelRatio = options.pixelRatio;\n\t\tconst minimapLineHeight = options.minimapLineHeight;\n\t\tconst minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n\t\tconst lineHeight = options.lineHeight;\n\n\t\tif (options.minimapHeightIsEditorHeight) {\n\t\t\tlet logicalScrollHeight = (\n\t\t\t\trealLineCount * options.lineHeight\n\t\t\t\t+ options.paddingTop\n\t\t\t\t+ options.paddingBottom\n\t\t\t);\n\t\t\tif (options.scrollBeyondLastLine) {\n\t\t\t\tlogicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n\t\t\t}\n\t\t\tconst sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n\t\t\tconst maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n\t\t\t// The slider can move from 0 to `maxMinimapSliderTop`\n\t\t\t// in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\t\t\tconst computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n\t\t\tconst sliderTop = (scrollTop * computedSliderRatio);\n\t\t\tconst sliderNeeded = (maxMinimapSliderTop > 0);\n\t\t\tconst maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n\t\t\tconst topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n\t\t}\n\n\t\t// The visible line count in a viewport can change due to a number of reasons:\n\t\t//  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n\t\t//    e.g. for a line height of 20, and a viewport height of 600\n\t\t//          * scrollTop = 0  => visible lines are [1, 30]\n\t\t//          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n\t\t//          * scrollTop = 20 => visible lines are [2, 31]\n\t\t//  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n\t\t//  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n\n\t\t// We must first establish a desirable slider height.\n\t\tlet sliderHeight: number;\n\t\tif (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n\t\t\t// case b) from above: there are whitespace gaps in the viewport.\n\t\t\t// In this case, the height of the slider directly reflects the visible line count.\n\t\t\tconst viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n\t\t\tsliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n\t\t} else {\n\t\t\t// The slider has a stable height\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\tsliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n\t\t}\n\n\t\tconst extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n\t\tlet extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n\t\tif (options.scrollBeyondLastLine) {\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\textraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n\t\t}\n\n\t\tlet maxMinimapSliderTop: number;\n\t\tif (extraLinesAtTheBottom > 0) {\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\t// The minimap slider, when dragged all the way down, will contain the last line at its top\n\t\t\tmaxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n\t\t} else {\n\t\t\t// The minimap slider, when dragged all the way down, will contain the last line at its bottom\n\t\t\tmaxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n\t\t}\n\t\tmaxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n\n\t\t// The slider can move from 0 to `maxMinimapSliderTop`\n\t\t// in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\t\tconst computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n\t\tconst sliderTop = (scrollTop * computedSliderRatio);\n\n\t\tif (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n\t\t\t// All lines fit in the minimap\n\t\t\tconst sliderNeeded = (maxMinimapSliderTop > 0);\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n\t\t} else {\n\t\t\tlet consideringStartLineNumber: number;\n\t\t\tif (viewportStartLineNumber > 1) {\n\t\t\t\tconsideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n\t\t\t} else {\n\t\t\t\tconsideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n\t\t\t}\n\n\t\t\tlet topPaddingLineCount: number;\n\t\t\tlet startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n\t\t\tif (startLineNumber < extraLinesAtTheTop) {\n\t\t\t\ttopPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n\t\t\t\tstartLineNumber = 1;\n\t\t\t} else {\n\t\t\t\ttopPaddingLineCount = 0;\n\t\t\t\tstartLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n\t\t\t}\n\n\t\t\t// Avoid flickering caused by a partial viewport start line\n\t\t\t// by being consistent w.r.t. the previous layout decision\n\t\t\tif (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n\t\t\t\tif (previousLayout.scrollTop > scrollTop) {\n\t\t\t\t\t// Scrolling up => never increase `startLineNumber`\n\t\t\t\t\tstartLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n\t\t\t\t\ttopPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n\t\t\t\t}\n\t\t\t\tif (previousLayout.scrollTop < scrollTop) {\n\t\t\t\t\t// Scrolling down => never decrease `startLineNumber`\n\t\t\t\t\tstartLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n\t\t\t\t\ttopPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n\t\t\tconst partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n\n\t\t\tlet sliderTopAligned: number;\n\t\t\tif (scrollTop >= options.paddingTop) {\n\t\t\t\tsliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n\t\t\t} else {\n\t\t\t\tsliderTopAligned = (scrollTop / options.paddingTop) * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n\t\t\t}\n\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n\t\t}\n\t}\n}\n\nclass MinimapLine implements ILine {\n\n\tpublic static readonly INVALID = new MinimapLine(-1);\n\n\tdy: number;\n\n\tconstructor(dy: number) {\n\t\tthis.dy = dy;\n\t}\n\n\tpublic onContentChanged(): void {\n\t\tthis.dy = -1;\n\t}\n\n\tpublic onTokensChanged(): void {\n\t\tthis.dy = -1;\n\t}\n}\n\nclass RenderData {\n\t/**\n\t * last rendered layout.\n\t */\n\tpublic readonly renderedLayout: MinimapLayout;\n\tprivate readonly _imageData: ImageData;\n\tprivate readonly _renderedLines: RenderedLinesCollection<MinimapLine>;\n\n\tconstructor(\n\t\trenderedLayout: MinimapLayout,\n\t\timageData: ImageData,\n\t\tlines: MinimapLine[]\n\t) {\n\t\tthis.renderedLayout = renderedLayout;\n\t\tthis._imageData = imageData;\n\t\tthis._renderedLines = new RenderedLinesCollection({\n\t\t\tcreateLine: () => MinimapLine.INVALID\n\t\t});\n\t\tthis._renderedLines._set(renderedLayout.startLineNumber, lines);\n\t}\n\n\t/**\n\t * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n\t */\n\tpublic linesEquals(layout: MinimapLayout): boolean {\n\t\tif (!this.scrollEquals(layout)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tmp = this._renderedLines._get();\n\t\tconst lines = tmp.lines;\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].dy === -1) {\n\t\t\t\t// This line is invalid\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if the current RenderData matches the new layout's scroll position\n\t */\n\tpublic scrollEquals(layout: MinimapLayout): boolean {\n\t\treturn this.renderedLayout.startLineNumber === layout.startLineNumber\n\t\t\t&& this.renderedLayout.endLineNumber === layout.endLineNumber;\n\t}\n\n\t_get(): { imageData: ImageData; rendLineNumberStart: number; lines: MinimapLine[] } {\n\t\tconst tmp = this._renderedLines._get();\n\t\treturn {\n\t\t\timageData: this._imageData,\n\t\t\trendLineNumberStart: tmp.rendLineNumberStart,\n\t\t\tlines: tmp.lines\n\t\t};\n\t}\n\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\treturn this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n\t}\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): void {\n\t\tthis._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n\t}\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): void {\n\t\tthis._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n\t}\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\treturn this._renderedLines.onTokensChanged(ranges);\n\t}\n}\n\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n\n\tprivate readonly _backgroundFillData: Uint8ClampedArray;\n\tprivate readonly _buffers: [ImageData, ImageData];\n\tprivate _lastUsedBuffer: number;\n\n\tconstructor(ctx: CanvasRenderingContext2D, WIDTH: number, HEIGHT: number, background: RGBA8) {\n\t\tthis._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n\t\tthis._buffers = [\n\t\t\tctx.createImageData(WIDTH, HEIGHT),\n\t\t\tctx.createImageData(WIDTH, HEIGHT)\n\t\t];\n\t\tthis._lastUsedBuffer = 0;\n\t}\n\n\tpublic getBuffer(): ImageData {\n\t\t// rotate buffers\n\t\tthis._lastUsedBuffer = 1 - this._lastUsedBuffer;\n\t\tconst result = this._buffers[this._lastUsedBuffer];\n\n\t\t// fill with background color\n\t\tresult.data.set(this._backgroundFillData);\n\n\t\treturn result;\n\t}\n\n\tprivate static _createBackgroundFillData(WIDTH: number, HEIGHT: number, background: RGBA8): Uint8ClampedArray {\n\t\tconst backgroundR = background.r;\n\t\tconst backgroundG = background.g;\n\t\tconst backgroundB = background.b;\n\t\tconst backgroundA = background.a;\n\n\t\tconst result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n\t\tlet offset = 0;\n\t\tfor (let i = 0; i < HEIGHT; i++) {\n\t\t\tfor (let j = 0; j < WIDTH; j++) {\n\t\t\t\tresult[offset] = backgroundR;\n\t\t\t\tresult[offset + 1] = backgroundG;\n\t\t\t\tresult[offset + 2] = backgroundB;\n\t\t\t\tresult[offset + 3] = backgroundA;\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport interface IMinimapModel {\n\treadonly tokensColorTracker: MinimapTokensColorTracker;\n\treadonly options: MinimapOptions;\n\n\tgetLineCount(): number;\n\tgetRealLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): (ViewLineData | null)[];\n\tgetSelections(): Selection[];\n\tgetMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[];\n\tgetSectionHeaderDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[];\n\tgetSectionHeaderText(decoration: ViewModelDecoration, fitWidth: (s: string) => string): string | null;\n\tgetOptions(): TextModelResolvedOptions;\n\trevealLineNumber(lineNumber: number): void;\n\tsetScrollTop(scrollTop: number): void;\n}\n\ninterface IMinimapRenderingContext {\n\treadonly viewportContainsWhitespaceGaps: boolean;\n\n\treadonly scrollWidth: number;\n\treadonly scrollHeight: number;\n\n\treadonly viewportStartLineNumber: number;\n\treadonly viewportEndLineNumber: number;\n\treadonly viewportStartLineNumberVerticalOffset: number;\n\n\treadonly scrollTop: number;\n\treadonly scrollLeft: number;\n\n\treadonly viewportWidth: number;\n\treadonly viewportHeight: number;\n}\n\ninterface SamplingStateLinesDeletedEvent {\n\ttype: 'deleted';\n\t_oldIndex: number;\n\tdeleteFromLineNumber: number;\n\tdeleteToLineNumber: number;\n}\n\ninterface SamplingStateLinesInsertedEvent {\n\ttype: 'inserted';\n\t_i: number;\n\tinsertFromLineNumber: number;\n\tinsertToLineNumber: number;\n}\n\ninterface SamplingStateFlushEvent {\n\ttype: 'flush';\n}\n\ntype SamplingStateEvent = SamplingStateLinesInsertedEvent | SamplingStateLinesDeletedEvent | SamplingStateFlushEvent;\n\nclass MinimapSamplingState {\n\n\tpublic static compute(options: MinimapOptions, viewLineCount: number, oldSamplingState: MinimapSamplingState | null): [MinimapSamplingState | null, SamplingStateEvent[]] {\n\t\tif (options.renderMinimap === RenderMinimap.None || !options.isSampling) {\n\t\t\treturn [null, []];\n\t\t}\n\n\t\t// ratio is intentionally not part of the layout to avoid the layout changing all the time\n\t\t// so we need to recompute it again...\n\t\tconst { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n\t\t\tviewLineCount: viewLineCount,\n\t\t\tscrollBeyondLastLine: options.scrollBeyondLastLine,\n\t\t\tpaddingTop: options.paddingTop,\n\t\t\tpaddingBottom: options.paddingBottom,\n\t\t\theight: options.editorHeight,\n\t\t\tlineHeight: options.lineHeight,\n\t\t\tpixelRatio: options.pixelRatio\n\t\t});\n\t\tconst ratio = viewLineCount / minimapLineCount;\n\t\tconst halfRatio = ratio / 2;\n\n\t\tif (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n\t\t\tconst result: number[] = [];\n\t\t\tresult[0] = 1;\n\t\t\tif (minimapLineCount > 1) {\n\t\t\t\tfor (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n\t\t\t\t\tresult[i] = Math.round(i * ratio + halfRatio);\n\t\t\t\t}\n\t\t\t\tresult[minimapLineCount - 1] = viewLineCount;\n\t\t\t}\n\t\t\treturn [new MinimapSamplingState(ratio, result), []];\n\t\t}\n\n\t\tconst oldMinimapLines = oldSamplingState.minimapLines;\n\t\tconst oldLength = oldMinimapLines.length;\n\t\tconst result: number[] = [];\n\t\tlet oldIndex = 0;\n\t\tlet oldDeltaLineCount = 0;\n\t\tlet minViewLineNumber = 1;\n\t\tconst MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n\t\tlet events: SamplingStateEvent[] = [];\n\t\tlet lastEvent: SamplingStateEvent | null = null;\n\t\tfor (let i = 0; i < minimapLineCount; i++) {\n\t\t\tconst fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n\t\t\tconst toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n\n\t\t\twhile (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n\t\t\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\t\tif (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n\t\t\t\t\t\tlastEvent.deleteToLineNumber++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t\t}\n\t\t\t\t\toldDeltaLineCount--;\n\t\t\t\t}\n\t\t\t\toldIndex++;\n\t\t\t}\n\n\t\t\tlet selectedViewLineNumber: number;\n\t\t\tif (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n\t\t\t\t// reuse the old sampled line\n\t\t\t\tselectedViewLineNumber = oldMinimapLines[oldIndex];\n\t\t\t\toldIndex++;\n\t\t\t} else {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tselectedViewLineNumber = 1;\n\t\t\t\t} else if (i + 1 === minimapLineCount) {\n\t\t\t\t\tselectedViewLineNumber = viewLineCount;\n\t\t\t\t} else {\n\t\t\t\t\tselectedViewLineNumber = Math.round(i * ratio + halfRatio);\n\t\t\t\t}\n\t\t\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\t\tif (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n\t\t\t\t\t\tlastEvent.insertToLineNumber++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t\t}\n\t\t\t\t\toldDeltaLineCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult[i] = selectedViewLineNumber;\n\t\t\tminViewLineNumber = selectedViewLineNumber;\n\t\t}\n\n\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\twhile (oldIndex < oldLength) {\n\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\tif (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n\t\t\t\t\tlastEvent.deleteToLineNumber++;\n\t\t\t\t} else {\n\t\t\t\t\tlastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t}\n\t\t\t\toldDeltaLineCount--;\n\t\t\t\toldIndex++;\n\t\t\t}\n\t\t} else {\n\t\t\t// too many events, just give up\n\t\t\tevents = [{ type: 'flush' }];\n\t\t}\n\n\t\treturn [new MinimapSamplingState(ratio, result), events];\n\t}\n\n\tconstructor(\n\t\tpublic readonly samplingRatio: number,\n\t\tpublic readonly minimapLines: number[]\t// a map of 0-based minimap line indexes to 1-based view line numbers\n\t) {\n\t}\n\n\tpublic modelLineToMinimapLine(lineNumber: number): number {\n\t\treturn Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n\t}\n\n\t/**\n\t * Will return null if the model line ranges are not intersecting with a sampled model line.\n\t */\n\tpublic modelLineRangeToMinimapLineRange(fromLineNumber: number, toLineNumber: number): [number, number] | null {\n\t\tlet fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n\t\twhile (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n\t\t\tfromLineIndex--;\n\t\t}\n\t\tlet toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n\t\twhile (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n\t\t\ttoLineIndex++;\n\t\t}\n\t\tif (fromLineIndex === toLineIndex) {\n\t\t\tconst sampledLineNumber = this.minimapLines[fromLineIndex];\n\t\t\tif (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n\t\t\t\t// This line is not part of the sampled lines ==> nothing to do\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn [fromLineIndex + 1, toLineIndex + 1];\n\t}\n\n\t/**\n\t * Will always return a range, even if it is not intersecting with a sampled model line.\n\t */\n\tpublic decorationLineRangeToMinimapLineRange(startLineNumber: number, endLineNumber: number): [number, number] {\n\t\tlet minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n\t\tlet minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n\t\tif (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n\t\t\tif (minimapLineEnd === this.minimapLines.length) {\n\t\t\t\tif (minimapLineStart > 1) {\n\t\t\t\t\tminimapLineStart--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tminimapLineEnd++;\n\t\t\t}\n\t\t}\n\t\treturn [minimapLineStart, minimapLineEnd];\n\t}\n\n\tpublic onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): [number, number] {\n\t\t// have the mapping be sticky\n\t\tconst deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\t\tlet changeStartIndex = this.minimapLines.length;\n\t\tlet changeEndIndex = 0;\n\t\tfor (let i = this.minimapLines.length - 1; i >= 0; i--) {\n\t\t\tif (this.minimapLines[i] < e.fromLineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (this.minimapLines[i] <= e.toLineNumber) {\n\t\t\t\t// this line got deleted => move to previous available\n\t\t\t\tthis.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n\t\t\t\tchangeStartIndex = Math.min(changeStartIndex, i);\n\t\t\t\tchangeEndIndex = Math.max(changeEndIndex, i);\n\t\t\t} else {\n\t\t\t\tthis.minimapLines[i] -= deletedLineCount;\n\t\t\t}\n\t\t}\n\t\treturn [changeStartIndex, changeEndIndex];\n\t}\n\n\tpublic onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): void {\n\t\t// have the mapping be sticky\n\t\tconst insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\t\tfor (let i = this.minimapLines.length - 1; i >= 0; i--) {\n\t\t\tif (this.minimapLines[i] < e.fromLineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.minimapLines[i] += insertedLineCount;\n\t\t}\n\t}\n}\n\n/**\n * The minimap appears beside the editor scroll bar and visualizes a zoomed out\n * view of the file.\n */\nexport class Minimap extends ViewPart implements IMinimapModel {\n\n\tpublic readonly tokensColorTracker: MinimapTokensColorTracker;\n\n\tprivate _selections: Selection[];\n\tprivate _minimapSelections: Selection[] | null;\n\n\tpublic options: MinimapOptions;\n\n\tprivate _samplingState: MinimapSamplingState | null;\n\tprivate _shouldCheckSampling: boolean;\n\n\tprivate _sectionHeaderCache = new LRUCache<string, string>(10, 1.5);\n\n\tprivate _actual: InnerMinimap;\n\n\tconstructor(context: ViewContext) {\n\t\tsuper(context);\n\n\t\tthis.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n\n\t\tthis._selections = [];\n\t\tthis._minimapSelections = null;\n\n\t\tthis.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\t\tconst [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n\t\tthis._samplingState = samplingState;\n\t\tthis._shouldCheckSampling = false;\n\n\t\tthis._actual = new InnerMinimap(context.theme, this);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._actual.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tpublic getDomNode(): FastDomNode<HTMLElement> {\n\t\treturn this._actual.getDomNode();\n\t}\n\n\tprivate _onOptionsMaybeChanged(): boolean {\n\t\tconst opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\t\tif (this.options.equals(opts)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.options = opts;\n\t\tthis._recreateLineSampling();\n\t\tthis._actual.onDidChangeOptions();\n\t\treturn true;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic override onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\treturn this._onOptionsMaybeChanged();\n\t}\n\tpublic override onCursorStateChanged(e: viewEvents.ViewCursorStateChangedEvent): boolean {\n\t\tthis._selections = e.selections;\n\t\tthis._minimapSelections = null;\n\t\treturn this._actual.onSelectionChanged();\n\t}\n\tpublic override onDecorationsChanged(e: viewEvents.ViewDecorationsChangedEvent): boolean {\n\t\tif (e.affectsMinimap) {\n\t\t\treturn this._actual.onDecorationsChanged();\n\t\t}\n\t\treturn false;\n\t}\n\tpublic override onFlushed(e: viewEvents.ViewFlushedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tthis._shouldCheckSampling = true;\n\t\t}\n\t\treturn this._actual.onFlushed();\n\t}\n\tpublic override onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n\t\t\tif (minimapLineRange) {\n\t\t\t\treturn this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._actual.onLinesChanged(e.fromLineNumber, e.count);\n\t\t}\n\t}\n\tpublic override onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n\t\t\tif (changeStartIndex <= changeEndIndex) {\n\t\t\t\tthis._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n\t\t\t}\n\t\t\tthis._shouldCheckSampling = true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\t\t}\n\t}\n\tpublic override onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tthis._samplingState.onLinesInserted(e);\n\t\t\tthis._shouldCheckSampling = true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\t\t}\n\t}\n\tpublic override onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\treturn this._actual.onScrollChanged(e);\n\t}\n\tpublic override onThemeChanged(e: viewEvents.ViewThemeChangedEvent): boolean {\n\t\tthis._actual.onThemeChanged();\n\t\tthis._onOptionsMaybeChanged();\n\t\treturn true;\n\t}\n\tpublic override onTokensChanged(e: viewEvents.ViewTokensChangedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst ranges: { fromLineNumber: number; toLineNumber: number }[] = [];\n\t\t\tfor (const range of e.ranges) {\n\t\t\t\tconst minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t\t\tif (minimapLineRange) {\n\t\t\t\t\tranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ranges.length) {\n\t\t\t\treturn this._actual.onTokensChanged(ranges);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._actual.onTokensChanged(e.ranges);\n\t\t}\n\t}\n\tpublic override onTokensColorsChanged(e: viewEvents.ViewTokensColorsChangedEvent): boolean {\n\t\tthis._onOptionsMaybeChanged();\n\t\treturn this._actual.onTokensColorsChanged();\n\t}\n\tpublic override onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean {\n\t\treturn this._actual.onZonesChanged();\n\t}\n\n\t// --- end event handlers\n\n\tpublic prepareRender(ctx: RenderingContext): void {\n\t\tif (this._shouldCheckSampling) {\n\t\t\tthis._shouldCheckSampling = false;\n\t\t\tthis._recreateLineSampling();\n\t\t}\n\t}\n\n\tpublic render(ctx: RestrictedRenderingContext): void {\n\t\tlet viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n\t\tlet viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n\n\t\tif (this._samplingState) {\n\t\t\tviewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n\t\t\tviewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n\t\t}\n\n\t\tconst minimapCtx: IMinimapRenderingContext = {\n\t\t\tviewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n\n\t\t\tscrollWidth: ctx.scrollWidth,\n\t\t\tscrollHeight: ctx.scrollHeight,\n\n\t\t\tviewportStartLineNumber: viewportStartLineNumber,\n\t\t\tviewportEndLineNumber: viewportEndLineNumber,\n\t\t\tviewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n\n\t\t\tscrollTop: ctx.scrollTop,\n\t\t\tscrollLeft: ctx.scrollLeft,\n\n\t\t\tviewportWidth: ctx.viewportWidth,\n\t\t\tviewportHeight: ctx.viewportHeight,\n\t\t};\n\t\tthis._actual.render(minimapCtx);\n\t}\n\n\t//#region IMinimapModel\n\n\tprivate _recreateLineSampling(): void {\n\t\tthis._minimapSelections = null;\n\n\t\tconst wasSampling = Boolean(this._samplingState);\n\t\tconst [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n\t\tthis._samplingState = samplingState;\n\n\t\tif (wasSampling && this._samplingState) {\n\t\t\t// was sampling, is sampling\n\t\t\tfor (const event of events) {\n\t\t\t\tswitch (event.type) {\n\t\t\t\t\tcase 'deleted':\n\t\t\t\t\t\tthis._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'inserted':\n\t\t\t\t\t\tthis._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flush':\n\t\t\t\t\t\tthis._actual.onFlushed();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getLineCount(): number {\n\t\tif (this._samplingState) {\n\t\t\treturn this._samplingState.minimapLines.length;\n\t\t}\n\t\treturn this._context.viewModel.getLineCount();\n\t}\n\n\tpublic getRealLineCount(): number {\n\t\treturn this._context.viewModel.getLineCount();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._samplingState) {\n\t\t\treturn this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n\t\t}\n\t\treturn this._context.viewModel.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\tif (this._samplingState) {\n\t\t\treturn this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n\t\t}\n\t\treturn this._context.viewModel.getLineMaxColumn(lineNumber);\n\t}\n\n\tpublic getMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): (ViewLineData | null)[] {\n\t\tif (this._samplingState) {\n\t\t\tconst result: (ViewLineData | null)[] = [];\n\t\t\tfor (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n\t\t\t\tif (needed[lineIndex]) {\n\t\t\t\t\tresult[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tresult[lineIndex] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\tif (this._minimapSelections === null) {\n\t\t\tif (this._samplingState) {\n\t\t\t\tthis._minimapSelections = [];\n\t\t\t\tfor (const selection of this._selections) {\n\t\t\t\t\tconst [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n\t\t\t\t\tthis._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._minimapSelections = this._selections;\n\t\t\t}\n\t\t}\n\t\treturn this._minimapSelections;\n\t}\n\n\tpublic getMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[] {\n\t\treturn this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n\t\t\t.filter(decoration => !decoration.options.minimap?.sectionHeaderStyle);\n\t}\n\n\tpublic getSectionHeaderDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[] {\n\t\tconst headerHeightInMinimapLines = this.options.sectionHeaderFontSize / this.options.minimapLineHeight;\n\t\tstartLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n\t\treturn this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n\t\t\t.filter(decoration => !!decoration.options.minimap?.sectionHeaderStyle);\n\t}\n\n\tprivate _getMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number) {\n\t\tlet visibleRange: Range;\n\t\tif (this._samplingState) {\n\t\t\tconst modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n\t\t\tconst modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n\t\t\tvisibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n\t\t} else {\n\t\t\tvisibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n\t\t}\n\t\tconst decorations = this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n\n\t\tif (this._samplingState) {\n\t\t\tconst result: ViewModelDecoration[] = [];\n\t\t\tfor (const decoration of decorations) {\n\t\t\t\tif (!decoration.options.minimap) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst range = decoration.range;\n\t\t\t\tconst minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n\t\t\t\tconst minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n\t\t\t\tresult.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\treturn decorations;\n\t}\n\n\tpublic getSectionHeaderText(decoration: ViewModelDecoration, fitWidth: (s: string) => string): string | null {\n\t\tconst headerText = decoration.options.minimap?.sectionHeaderText;\n\t\tif (!headerText) {\n\t\t\treturn null;\n\t\t}\n\t\tconst cachedText = this._sectionHeaderCache.get(headerText);\n\t\tif (cachedText) {\n\t\t\treturn cachedText;\n\t\t}\n\t\tconst fittedText = fitWidth(headerText);\n\t\tthis._sectionHeaderCache.set(headerText, fittedText);\n\t\treturn fittedText;\n\t}\n\n\tpublic getOptions(): TextModelResolvedOptions {\n\t\treturn this._context.viewModel.model.getOptions();\n\t}\n\n\tpublic revealLineNumber(lineNumber: number): void {\n\t\tif (this._samplingState) {\n\t\t\tlineNumber = this._samplingState.minimapLines[lineNumber - 1];\n\t\t}\n\t\tthis._context.viewModel.revealRange(\n\t\t\t'mouse',\n\t\t\tfalse,\n\t\t\tnew Range(lineNumber, 1, lineNumber, 1),\n\t\t\tviewEvents.VerticalRevealType.Center,\n\t\t\tScrollType.Smooth\n\t\t);\n\t}\n\n\tpublic setScrollTop(scrollTop: number): void {\n\t\tthis._context.viewModel.viewLayout.setScrollPosition({\n\t\t\tscrollTop: scrollTop\n\t\t}, ScrollType.Immediate);\n\t}\n\n\t//#endregion\n}\n\nclass InnerMinimap extends Disposable {\n\n\tprivate readonly _theme: EditorTheme;\n\tprivate readonly _model: IMinimapModel;\n\n\tprivate readonly _domNode: FastDomNode<HTMLElement>;\n\tprivate readonly _shadow: FastDomNode<HTMLElement>;\n\tprivate readonly _canvas: FastDomNode<HTMLCanvasElement>;\n\tprivate readonly _decorationsCanvas: FastDomNode<HTMLCanvasElement>;\n\tprivate readonly _slider: FastDomNode<HTMLElement>;\n\tprivate readonly _sliderHorizontal: FastDomNode<HTMLElement>;\n\tprivate readonly _pointerDownListener: IDisposable;\n\tprivate readonly _sliderPointerMoveMonitor: GlobalPointerMoveMonitor;\n\tprivate readonly _sliderPointerDownListener: IDisposable;\n\tprivate readonly _gestureDisposable: IDisposable;\n\tprivate readonly _sliderTouchStartListener: IDisposable;\n\tprivate readonly _sliderTouchMoveListener: IDisposable;\n\tprivate readonly _sliderTouchEndListener: IDisposable;\n\n\tprivate _lastRenderData: RenderData | null;\n\tprivate _selectionColor: Color | undefined;\n\tprivate _renderDecorations: boolean = false;\n\tprivate _gestureInProgress: boolean = false;\n\tprivate _buffers: MinimapBuffers | null;\n\tprivate _isMouseOverMinimap: boolean = false;\n\tprivate _hideDelayedScheduler: RunOnceScheduler;\n\n\tconstructor(\n\t\ttheme: EditorTheme,\n\t\tmodel: IMinimapModel\n\t) {\n\t\tsuper();\n\n\t\tthis._theme = theme;\n\t\tthis._model = model;\n\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\tthis._selectionColor = this._theme.getColor(minimapSelection);\n\n\t\tthis._domNode = createFastDomNode(document.createElement('div'));\n\t\tPartFingerprints.write(this._domNode, PartFingerprint.Minimap);\n\t\tthis._domNode.setClassName(this._getMinimapDomNodeClassName());\n\t\tthis._domNode.setPosition('absolute');\n\t\tthis._domNode.setAttribute('role', 'presentation');\n\t\tthis._domNode.setAttribute('aria-hidden', 'true');\n\n\t\tthis._shadow = createFastDomNode(document.createElement('div'));\n\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\tthis._domNode.appendChild(this._shadow);\n\n\t\tthis._canvas = createFastDomNode(document.createElement('canvas'));\n\t\tthis._canvas.setPosition('absolute');\n\t\tthis._canvas.setLeft(0);\n\t\tthis._domNode.appendChild(this._canvas);\n\n\t\tthis._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n\t\tthis._decorationsCanvas.setPosition('absolute');\n\t\tthis._decorationsCanvas.setClassName('minimap-decorations-layer');\n\t\tthis._decorationsCanvas.setLeft(0);\n\t\tthis._domNode.appendChild(this._decorationsCanvas);\n\n\t\tthis._slider = createFastDomNode(document.createElement('div'));\n\t\tthis._slider.setPosition('absolute');\n\t\tthis._slider.setClassName('minimap-slider');\n\t\tthis._slider.setLayerHinting(true);\n\t\tthis._slider.setContain('strict');\n\t\tthis._domNode.appendChild(this._slider);\n\n\t\tthis._sliderHorizontal = createFastDomNode(document.createElement('div'));\n\t\tthis._sliderHorizontal.setPosition('absolute');\n\t\tthis._sliderHorizontal.setClassName('minimap-slider-horizontal');\n\t\tthis._slider.appendChild(this._sliderHorizontal);\n\n\t\tthis._applyLayout();\n\n\t\tthis._hideDelayedScheduler = this._register(new RunOnceScheduler(() => this._hideImmediatelyIfMouseIsOutside(), 500));\n\n\t\tthis._register(dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.MOUSE_OVER, () => {\n\t\t\tthis._isMouseOverMinimap = true;\n\t\t}));\n\t\tthis._register(dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.MOUSE_LEAVE, () => {\n\t\t\tthis._isMouseOverMinimap = false;\n\t\t}));\n\n\t\tthis._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n\t\t\te.preventDefault();\n\n\t\t\tconst isMouse = (e.pointerType === 'mouse');\n\t\t\tconst isLeftClick = (e.button === 0);\n\n\t\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\t\tif (renderMinimap === RenderMinimap.None) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this._lastRenderData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._model.options.size !== 'proportional') {\n\t\t\t\tif (isLeftClick && this._lastRenderData) {\n\t\t\t\t\t// pretend the click occurred in the center of the slider\n\t\t\t\t\tconst position = dom.getDomNodePagePosition(this._slider.domNode);\n\t\t\t\t\tconst initialPosY = position.top + position.height / 2;\n\t\t\t\t\tthis._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isLeftClick || !isMouse) {\n\t\t\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\t\t\tconst internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n\t\t\t\tconst lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n\n\t\t\t\tlet lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n\t\t\t\tlineNumber = Math.min(lineNumber, this._model.getLineCount());\n\n\t\t\t\tthis._model.revealLineNumber(lineNumber);\n\t\t\t}\n\t\t});\n\n\t\tthis._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n\n\t\tthis._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (e.button === 0 && this._lastRenderData) {\n\t\t\t\tthis._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n\t\t\t}\n\t\t});\n\n\t\tthis._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n\t\tthis._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (this._lastRenderData) {\n\t\t\t\tthis._slider.toggleClassName('active', true);\n\t\t\t\tthis._gestureInProgress = true;\n\t\t\t\tthis.scrollDueToTouchEvent(e);\n\t\t\t}\n\t\t}, { passive: false });\n\n\t\tthis._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (this._lastRenderData && this._gestureInProgress) {\n\t\t\t\tthis.scrollDueToTouchEvent(e);\n\t\t\t}\n\t\t}, { passive: false });\n\n\t\tthis._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis._gestureInProgress = false;\n\t\t\tthis._slider.toggleClassName('active', false);\n\t\t});\n\t}\n\n\tprivate _hideSoon() {\n\t\tthis._hideDelayedScheduler.cancel();\n\t\tthis._hideDelayedScheduler.schedule();\n\t}\n\n\tprivate _hideImmediatelyIfMouseIsOutside() {\n\t\tif (this._isMouseOverMinimap) {\n\t\t\tthis._hideSoon();\n\t\t\treturn;\n\t\t}\n\t\tthis._domNode.toggleClassName('active', false);\n\t}\n\n\tprivate _startSliderDragging(e: PointerEvent, initialPosY: number, initialSliderState: MinimapLayout): void {\n\t\tif (!e.target || !(e.target instanceof Element)) {\n\t\t\treturn;\n\t\t}\n\t\tconst initialPosX = e.pageX;\n\n\t\tthis._slider.toggleClassName('active', true);\n\n\t\tconst handlePointerMove = (posy: number, posx: number) => {\n\t\t\tconst minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n\t\t\tconst pointerOrthogonalDelta = Math.min(\n\t\t\t\tMath.abs(posx - initialPosX),\n\t\t\t\tMath.abs(posx - minimapPosition.left),\n\t\t\t\tMath.abs(posx - minimapPosition.left - minimapPosition.width)\n\t\t\t);\n\n\t\t\tif (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n\t\t\t\t// The pointer has wondered away from the scrollbar => reset dragging\n\t\t\t\tthis._model.setScrollTop(initialSliderState.scrollTop);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst pointerDelta = posy - initialPosY;\n\t\t\tthis._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n\t\t};\n\n\t\tif (e.pageY !== initialPosY) {\n\t\t\thandlePointerMove(e.pageY, initialPosX);\n\t\t}\n\n\t\tthis._sliderPointerMoveMonitor.startMonitoring(\n\t\t\te.target,\n\t\t\te.pointerId,\n\t\t\te.buttons,\n\t\t\tpointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX),\n\t\t\t() => {\n\t\t\t\tthis._slider.toggleClassName('active', false);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate scrollDueToTouchEvent(touch: GestureEvent) {\n\t\tconst startY = this._domNode.domNode.getBoundingClientRect().top;\n\t\tconst scrollTop = this._lastRenderData!.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n\t\tthis._model.setScrollTop(scrollTop);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._pointerDownListener.dispose();\n\t\tthis._sliderPointerMoveMonitor.dispose();\n\t\tthis._sliderPointerDownListener.dispose();\n\t\tthis._gestureDisposable.dispose();\n\t\tthis._sliderTouchStartListener.dispose();\n\t\tthis._sliderTouchMoveListener.dispose();\n\t\tthis._sliderTouchEndListener.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tprivate _getMinimapDomNodeClassName(): string {\n\t\tconst class_ = ['minimap'];\n\t\tif (this._model.options.showSlider === 'always') {\n\t\t\tclass_.push('slider-always');\n\t\t} else {\n\t\t\tclass_.push('slider-mouseover');\n\t\t}\n\n\t\tif (this._model.options.autohide === 'mouseover') {\n\t\t\tclass_.push('minimap-autohide-mouseover');\n\t\t} else if (this._model.options.autohide === 'scroll') {\n\t\t\tclass_.push('minimap-autohide-scroll');\n\t\t}\n\n\t\treturn class_.join(' ');\n\t}\n\n\tpublic getDomNode(): FastDomNode<HTMLElement> {\n\t\treturn this._domNode;\n\t}\n\n\tprivate _applyLayout(): void {\n\t\tthis._domNode.setLeft(this._model.options.minimapLeft);\n\t\tthis._domNode.setWidth(this._model.options.minimapWidth);\n\t\tthis._domNode.setHeight(this._model.options.minimapHeight);\n\t\tthis._shadow.setHeight(this._model.options.minimapHeight);\n\n\t\tthis._canvas.setWidth(this._model.options.canvasOuterWidth);\n\t\tthis._canvas.setHeight(this._model.options.canvasOuterHeight);\n\t\tthis._canvas.domNode.width = this._model.options.canvasInnerWidth;\n\t\tthis._canvas.domNode.height = this._model.options.canvasInnerHeight;\n\n\t\tthis._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n\t\tthis._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n\t\tthis._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n\t\tthis._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n\n\t\tthis._slider.setWidth(this._model.options.minimapWidth);\n\t}\n\n\tprivate _getBuffer(): ImageData | null {\n\t\tif (!this._buffers) {\n\t\t\tif (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n\t\t\t\tthis._buffers = new MinimapBuffers(\n\t\t\t\t\tthis._canvas.domNode.getContext('2d')!,\n\t\t\t\t\tthis._model.options.canvasInnerWidth,\n\t\t\t\t\tthis._model.options.canvasInnerHeight,\n\t\t\t\t\tthis._model.options.backgroundColor\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn this._buffers ? this._buffers.getBuffer() : null;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onDidChangeOptions(): void {\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\tthis._applyLayout();\n\t\tthis._domNode.setClassName(this._getMinimapDomNodeClassName());\n\t}\n\tpublic onSelectionChanged(): boolean {\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onDecorationsChanged(): boolean {\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onFlushed(): boolean {\n\t\tthis._lastRenderData = null;\n\t\treturn true;\n\t}\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\tif (this._lastRenderData) {\n\t\t\treturn this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): boolean {\n\t\tthis._lastRenderData?.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n\t\treturn true;\n\t}\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): boolean {\n\t\tthis._lastRenderData?.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n\t\treturn true;\n\t}\n\tpublic onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\tif (this._model.options.autohide === 'scroll' && (e.scrollTopChanged || e.scrollHeightChanged)) {\n\t\t\tthis._domNode.toggleClassName('active', true);\n\t\t\tthis._hideSoon();\n\t\t}\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onThemeChanged(): boolean {\n\t\tthis._selectionColor = this._theme.getColor(minimapSelection);\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\tif (this._lastRenderData) {\n\t\t\treturn this._lastRenderData.onTokensChanged(ranges);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic onTokensColorsChanged(): boolean {\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\treturn true;\n\t}\n\tpublic onZonesChanged(): boolean {\n\t\tthis._lastRenderData = null;\n\t\treturn true;\n\t}\n\n\t// --- end event handlers\n\n\tpublic render(renderingCtx: IMinimapRenderingContext): void {\n\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\tif (renderMinimap === RenderMinimap.None) {\n\t\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\t\tthis._sliderHorizontal.setWidth(0);\n\t\t\tthis._sliderHorizontal.setHeight(0);\n\t\t\treturn;\n\t\t}\n\t\tif (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n\t\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\t} else {\n\t\t\tthis._shadow.setClassName('minimap-shadow-visible');\n\t\t}\n\n\t\tconst layout = MinimapLayout.create(\n\t\t\tthis._model.options,\n\t\t\trenderingCtx.viewportStartLineNumber,\n\t\t\trenderingCtx.viewportEndLineNumber,\n\t\t\trenderingCtx.viewportStartLineNumberVerticalOffset,\n\t\t\trenderingCtx.viewportHeight,\n\t\t\trenderingCtx.viewportContainsWhitespaceGaps,\n\t\t\tthis._model.getLineCount(),\n\t\t\tthis._model.getRealLineCount(),\n\t\t\trenderingCtx.scrollTop,\n\t\t\trenderingCtx.scrollHeight,\n\t\t\tthis._lastRenderData ? this._lastRenderData.renderedLayout : null\n\t\t);\n\t\tthis._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n\t\tthis._slider.setTop(layout.sliderTop);\n\t\tthis._slider.setHeight(layout.sliderHeight);\n\n\t\t// Compute horizontal slider coordinates\n\t\tthis._sliderHorizontal.setLeft(0);\n\t\tthis._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n\t\tthis._sliderHorizontal.setTop(0);\n\t\tthis._sliderHorizontal.setHeight(layout.sliderHeight);\n\n\t\tthis.renderDecorations(layout);\n\t\tthis._lastRenderData = this.renderLines(layout);\n\t}\n\n\tprivate renderDecorations(layout: MinimapLayout) {\n\t\tif (this._renderDecorations) {\n\t\t\tthis._renderDecorations = false;\n\t\t\tconst selections = this._model.getSelections();\n\t\t\tselections.sort(Range.compareRangesUsingStarts);\n\n\t\t\tconst decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\t\t\tdecorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n\n\t\t\tconst { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n\t\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\t\tconst minimapCharWidth = this._model.options.minimapCharWidth;\n\t\t\tconst tabSize = this._model.getOptions().tabSize;\n\t\t\tconst canvasContext = this._decorationsCanvas.domNode.getContext('2d')!;\n\n\t\t\tcanvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n\n\t\t\t// We first need to render line highlights and then render decorations on top of those.\n\t\t\t// But we need to pick a single color for each line, and use that as a line highlight.\n\t\t\t// This needs to be the color of the decoration with the highest `zIndex`, but priority\n\t\t\t// is given to the selection.\n\n\t\t\tconst highlightedLines = new ContiguousLineMap<boolean>(layout.startLineNumber, layout.endLineNumber, false);\n\t\t\tthis._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n\t\t\tthis._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n\n\t\t\tconst lineOffsetMap = new ContiguousLineMap<number[] | null>(layout.startLineNumber, layout.endLineNumber, null);\n\t\t\tthis._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n\t\t\tthis._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n\t\t\tthis._renderSectionHeaders(layout);\n\t\t}\n\t}\n\n\tprivate _renderSelectionLineHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tselections: Selection[],\n\t\thighlightedLines: ContiguousLineMap<boolean>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number\n\t): void {\n\t\tif (!this._selectionColor || this._selectionColor.isTransparent()) {\n\t\t\treturn;\n\t\t}\n\n\t\tcanvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n\n\t\tlet y1 = 0;\n\t\tlet y2 = 0;\n\n\t\tfor (const selection of selections) {\n\t\t\tconst intersection = layout.intersectWithViewport(selection);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\thighlightedLines.set(line, true);\n\t\t\t}\n\n\t\t\tconst yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n\t\t\tconst yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n\n\t\t\tif (y2 >= yy1) {\n\t\t\t\t// merge into previous\n\t\t\t\ty2 = yy2;\n\t\t\t} else {\n\t\t\t\tif (y2 > y1) {\n\t\t\t\t\t// flush\n\t\t\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n\t\t\t\t}\n\t\t\t\ty1 = yy1;\n\t\t\t\ty2 = yy2;\n\t\t\t}\n\t\t}\n\n\t\tif (y2 > y1) {\n\t\t\t// flush\n\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n\t\t}\n\t}\n\n\tprivate _renderDecorationsLineHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tdecorations: ViewModelDecoration[],\n\t\thighlightedLines: ContiguousLineMap<boolean>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number\n\t): void {\n\n\t\tconst highlightColors = new Map<string, string>();\n\n\t\t// Loop backwards to hit first decorations with higher `zIndex`\n\t\tfor (let i = decorations.length - 1; i >= 0; i--) {\n\t\t\tconst decoration = decorations[i];\n\n\t\t\tconst minimapOptions = <ModelDecorationMinimapOptions | null | undefined>decoration.options.minimap;\n\t\t\tif (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst intersection = layout.intersectWithViewport(decoration.range);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tconst decorationColor = minimapOptions.getColor(this._theme.value);\n\t\t\tif (!decorationColor || decorationColor.isTransparent()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet highlightColor = highlightColors.get(decorationColor.toString());\n\t\t\tif (!highlightColor) {\n\t\t\t\thighlightColor = decorationColor.transparent(0.5).toString();\n\t\t\t\thighlightColors.set(decorationColor.toString(), highlightColor);\n\t\t\t}\n\n\t\t\tcanvasContext.fillStyle = highlightColor;\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tif (highlightedLines.has(line)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thighlightedLines.set(line, true);\n\t\t\t\tconst y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n\t\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _renderSelectionsHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tselections: Selection[],\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlayout: MinimapLayout,\n\t\tlineHeight: number,\n\t\ttabSize: number,\n\t\tcharacterWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\tif (!this._selectionColor || this._selectionColor.isTransparent()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const selection of selections) {\n\t\t\tconst intersection = layout.intersectWithViewport(selection);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tthis.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _renderDecorationsHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tdecorations: ViewModelDecoration[],\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number,\n\t\ttabSize: number,\n\t\tcharacterWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\t// Loop forwards to hit first decorations with lower `zIndex`\n\t\tfor (const decoration of decorations) {\n\n\t\t\tconst minimapOptions = <ModelDecorationMinimapOptions | null | undefined>decoration.options.minimap;\n\t\t\tif (!minimapOptions) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst intersection = layout.intersectWithViewport(decoration.range);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tconst decorationColor = minimapOptions.getColor(this._theme.value);\n\t\t\tif (!decorationColor || decorationColor.isTransparent()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tswitch (minimapOptions.position) {\n\n\t\t\t\t\tcase MinimapPosition.Inline:\n\t\t\t\t\t\tthis.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase MinimapPosition.Gutter: {\n\t\t\t\t\t\tconst y = layout.getYForLineNumber(line, minimapLineHeight);\n\t\t\t\t\t\tconst x = 2;\n\t\t\t\t\t\tthis.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate renderDecorationOnLine(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tdecorationRange: Range,\n\t\tdecorationColor: Color | undefined,\n\t\tlayout: MinimapLayout,\n\t\tlineNumber: number,\n\t\theight: number,\n\t\tminimapLineHeight: number,\n\t\ttabSize: number,\n\t\tcharWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\tconst y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n\n\t\t// Skip rendering the line if it's vertically outside our viewport\n\t\tif (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { startLineNumber, endLineNumber } = decorationRange;\n\t\tconst startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n\t\tconst endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n\n\t\tconst x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n\t\tconst x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n\n\t\tthis.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n\t}\n\n\tprivate getXOffsetForPosition(\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlineNumber: number,\n\t\tcolumn: number,\n\t\ttabSize: number,\n\t\tcharWidth: number,\n\t\tcanvasInnerWidth: number\n\t): number {\n\t\tif (column === 1) {\n\t\t\treturn MINIMAP_GUTTER_WIDTH;\n\t\t}\n\n\t\tconst minimumXOffset = (column - 1) * charWidth;\n\t\tif (minimumXOffset >= canvasInnerWidth) {\n\t\t\t// there is no need to look at actual characters,\n\t\t\t// as this column is certainly after the minimap width\n\t\t\treturn canvasInnerWidth;\n\t\t}\n\n\t\t// Cache line offset data so that it is only read once per line\n\t\tlet lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n\t\tif (!lineIndexToXOffset) {\n\t\t\tconst lineData = this._model.getLineContent(lineNumber);\n\t\t\tlineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n\t\t\tlet prevx = MINIMAP_GUTTER_WIDTH;\n\t\t\tfor (let i = 1; i < lineData.length + 1; i++) {\n\t\t\t\tconst charCode = lineData.charCodeAt(i - 1);\n\t\t\t\tconst dx = charCode === CharCode.Tab\n\t\t\t\t\t? tabSize * charWidth\n\t\t\t\t\t: strings.isFullWidthCharacter(charCode)\n\t\t\t\t\t\t? 2 * charWidth\n\t\t\t\t\t\t: charWidth;\n\n\t\t\t\tconst x = prevx + dx;\n\t\t\t\tif (x >= canvasInnerWidth) {\n\t\t\t\t\t// no need to keep on going, as we've hit the canvas width\n\t\t\t\t\tlineIndexToXOffset[i] = canvasInnerWidth;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlineIndexToXOffset[i] = x;\n\t\t\t\tprevx = x;\n\t\t\t}\n\n\t\t\tlineOffsetMap.set(lineNumber, lineIndexToXOffset);\n\t\t}\n\n\t\tif (column - 1 < lineIndexToXOffset.length) {\n\t\t\treturn lineIndexToXOffset[column - 1];\n\t\t}\n\t\t// goes over the canvas width\n\t\treturn canvasInnerWidth;\n\t}\n\n\tprivate renderDecoration(canvasContext: CanvasRenderingContext2D, decorationColor: Color | undefined, x: number, y: number, width: number, height: number) {\n\t\tcanvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n\t\tcanvasContext.fillRect(x, y, width, height);\n\t}\n\n\tprivate _renderSectionHeaders(layout: MinimapLayout) {\n\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\tconst sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n\t\tconst sectionHeaderLetterSpacing = this._model.options.sectionHeaderLetterSpacing;\n\t\tconst backgroundFillHeight = sectionHeaderFontSize * 1.5;\n\t\tconst { canvasInnerWidth } = this._model.options;\n\n\t\tconst backgroundColor = this._model.options.backgroundColor;\n\t\tconst backgroundFill = `rgb(${backgroundColor.r} ${backgroundColor.g} ${backgroundColor.b} / .7)`;\n\t\tconst foregroundColor = this._model.options.sectionHeaderFontColor;\n\t\tconst foregroundFill = `rgb(${foregroundColor.r} ${foregroundColor.g} ${foregroundColor.b})`;\n\t\tconst separatorStroke = foregroundFill;\n\n\t\tconst canvasContext = this._decorationsCanvas.domNode.getContext('2d')!;\n\t\tcanvasContext.letterSpacing = sectionHeaderLetterSpacing + 'px';\n\t\tcanvasContext.font = '500 ' + sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n\t\tcanvasContext.strokeStyle = separatorStroke;\n\t\tcanvasContext.lineWidth = 0.4;\n\n\t\tconst decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\t\tdecorations.sort((a, b) => a.range.startLineNumber - b.range.startLineNumber);\n\n\t\tconst fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext,\n\t\t\tcanvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n\n\t\tfor (const decoration of decorations) {\n\t\t\tconst y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n\t\t\tconst backgroundFillY = y - sectionHeaderFontSize;\n\t\t\tconst separatorY = backgroundFillY + 2;\n\t\t\tconst headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n\n\t\t\tInnerMinimap._renderSectionLabel(\n\t\t\t\tcanvasContext,\n\t\t\t\theaderText,\n\t\t\t\tdecoration.options.minimap?.sectionHeaderStyle === MinimapSectionHeaderStyle.Underlined,\n\t\t\t\tbackgroundFill,\n\t\t\t\tforegroundFill,\n\t\t\t\tcanvasInnerWidth,\n\t\t\t\tbackgroundFillY,\n\t\t\t\tbackgroundFillHeight,\n\t\t\t\ty,\n\t\t\t\tseparatorY);\n\t\t}\n\t}\n\n\tprivate static _fitSectionHeader(\n\t\ttarget: CanvasRenderingContext2D,\n\t\tmaxWidth: number,\n\t\theaderText: string,\n\t): string {\n\t\tif (!headerText) {\n\t\t\treturn headerText;\n\t\t}\n\n\t\tconst ellipsis = '';\n\t\tconst width = target.measureText(headerText).width;\n\t\tconst ellipsisWidth = target.measureText(ellipsis).width;\n\n\t\tif (width <= maxWidth || width <= ellipsisWidth) {\n\t\t\treturn headerText;\n\t\t}\n\n\t\tconst len = headerText.length;\n\t\tconst averageCharWidth = width / headerText.length;\n\t\tconst maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n\n\t\t// Find a halfway point that isn't after whitespace\n\t\tlet halfCharCount = Math.ceil(maxCharCount / 2);\n\t\twhile (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n\t\t\t--halfCharCount;\n\t\t}\n\n\t\t// Split with ellipsis\n\t\treturn headerText.substring(0, halfCharCount)\n\t\t\t+ ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n\t}\n\n\tprivate static _renderSectionLabel(\n\t\ttarget: CanvasRenderingContext2D,\n\t\theaderText: string | null,\n\t\thasSeparatorLine: boolean,\n\t\tbackgroundFill: string,\n\t\tforegroundFill: string,\n\t\tminimapWidth: number,\n\t\tbackgroundFillY: number,\n\t\tbackgroundFillHeight: number,\n\t\ttextY: number,\n\t\tseparatorY: number\n\t): void {\n\t\tif (headerText) {\n\t\t\ttarget.fillStyle = backgroundFill;\n\t\t\ttarget.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n\n\t\t\ttarget.fillStyle = foregroundFill;\n\t\t\ttarget.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n\t\t}\n\n\t\tif (hasSeparatorLine) {\n\t\t\ttarget.beginPath();\n\t\t\ttarget.moveTo(0, separatorY);\n\t\t\ttarget.lineTo(minimapWidth, separatorY);\n\t\t\ttarget.closePath();\n\t\t\ttarget.stroke();\n\t\t}\n\t}\n\n\tprivate renderLines(layout: MinimapLayout): RenderData | null {\n\t\tconst startLineNumber = layout.startLineNumber;\n\t\tconst endLineNumber = layout.endLineNumber;\n\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\n\t\t// Check if nothing changed w.r.t. lines from last frame\n\t\tif (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n\t\t\tconst _lastData = this._lastRenderData._get();\n\t\t\t// Nice!! Nothing changed from last frame\n\t\t\treturn new RenderData(layout, _lastData.imageData, _lastData.lines);\n\t\t}\n\n\t\t// Oh well!! We need to repaint some lines...\n\n\t\tconst imageData = this._getBuffer();\n\t\tif (!imageData) {\n\t\t\t// 0 width or 0 height canvas, nothing to do\n\t\t\treturn null;\n\t\t}\n\n\t\t// Render untouched lines by using last rendered data.\n\t\tconst [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(\n\t\t\timageData,\n\t\t\tlayout.topPaddingLineCount,\n\t\t\tstartLineNumber,\n\t\t\tendLineNumber,\n\t\t\tminimapLineHeight,\n\t\t\tthis._lastRenderData\n\t\t);\n\n\t\t// Fetch rendering info from view model for rest of lines that need rendering.\n\t\tconst lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n\t\tconst tabSize = this._model.getOptions().tabSize;\n\t\tconst defaultBackground = this._model.options.defaultBackgroundColor;\n\t\tconst background = this._model.options.backgroundColor;\n\t\tconst foregroundAlpha = this._model.options.foregroundAlpha;\n\t\tconst tokensColorTracker = this._model.tokensColorTracker;\n\t\tconst useLighterFont = tokensColorTracker.backgroundIsLight();\n\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\tconst charRenderer = this._model.options.charRenderer();\n\t\tconst fontScale = this._model.options.fontScale;\n\t\tconst minimapCharWidth = this._model.options.minimapCharWidth;\n\n\t\tconst baseCharHeight = (renderMinimap === RenderMinimap.Text ? Constants.BASE_CHAR_HEIGHT : Constants.BASE_CHAR_HEIGHT + 1);\n\t\tconst renderMinimapLineHeight = baseCharHeight * fontScale;\n\t\tconst innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n\n\t\t// Render the rest of lines\n\t\tconst backgroundA = background.a / 255;\n\t\tconst renderBackground = new RGBA8(\n\t\t\tMath.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r),\n\t\t\tMath.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g),\n\t\t\tMath.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b),\n\t\t\t255\n\t\t);\n\t\tlet dy = layout.topPaddingLineCount * minimapLineHeight;\n\t\tconst renderedLines: MinimapLine[] = [];\n\t\tfor (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n\t\t\tif (needed[lineIndex]) {\n\t\t\t\tInnerMinimap._renderLine(\n\t\t\t\t\timageData,\n\t\t\t\t\trenderBackground,\n\t\t\t\t\tbackground.a,\n\t\t\t\t\tuseLighterFont,\n\t\t\t\t\trenderMinimap,\n\t\t\t\t\tminimapCharWidth,\n\t\t\t\t\ttokensColorTracker,\n\t\t\t\t\tforegroundAlpha,\n\t\t\t\t\tcharRenderer,\n\t\t\t\t\tdy,\n\t\t\t\t\tinnerLinePadding,\n\t\t\t\t\ttabSize,\n\t\t\t\t\tlineInfo[lineIndex]!,\n\t\t\t\t\tfontScale,\n\t\t\t\t\tminimapLineHeight\n\t\t\t\t);\n\t\t\t}\n\t\t\trenderedLines[lineIndex] = new MinimapLine(dy);\n\t\t\tdy += minimapLineHeight;\n\t\t}\n\n\t\tconst dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n\t\tconst dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n\t\tconst dirtyHeight = dirtyY2 - dirtyY1;\n\n\t\t// Finally, paint to the canvas\n\t\tconst ctx = this._canvas.domNode.getContext('2d')!;\n\t\tctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n\n\t\t// Save rendered data for reuse on next frame if possible\n\t\treturn new RenderData(\n\t\t\tlayout,\n\t\t\timageData,\n\t\t\trenderedLines\n\t\t);\n\t}\n\n\tprivate static _renderUntouchedLines(\n\t\ttarget: ImageData,\n\t\ttopPaddingLineCount: number,\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tminimapLineHeight: number,\n\t\tlastRenderData: RenderData | null,\n\t): [number, number, boolean[]] {\n\n\t\tconst needed: boolean[] = [];\n\t\tif (!lastRenderData) {\n\t\t\tfor (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n\t\t\t\tneeded[i] = true;\n\t\t\t}\n\t\t\treturn [-1, -1, needed];\n\t\t}\n\n\t\tconst _lastData = lastRenderData._get();\n\t\tconst lastTargetData = _lastData.imageData.data;\n\t\tconst lastStartLineNumber = _lastData.rendLineNumberStart;\n\t\tconst lastLines = _lastData.lines;\n\t\tconst lastLinesLength = lastLines.length;\n\t\tconst WIDTH = target.width;\n\t\tconst targetData = target.data;\n\n\t\tconst maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n\t\tlet dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n\t\tlet dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n\n\t\tlet copySourceStart = -1;\n\t\tlet copySourceEnd = -1;\n\t\tlet copyDestStart = -1;\n\t\tlet copyDestEnd = -1;\n\n\t\tlet dest_dy = topPaddingLineCount * minimapLineHeight;\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineIndex = lineNumber - startLineNumber;\n\t\t\tconst lastLineIndex = lineNumber - lastStartLineNumber;\n\t\t\tconst source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n\n\t\t\tif (source_dy === -1) {\n\t\t\t\tneeded[lineIndex] = true;\n\t\t\t\tdest_dy += minimapLineHeight;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst sourceStart = source_dy * WIDTH * 4;\n\t\t\tconst sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n\t\t\tconst destStart = dest_dy * WIDTH * 4;\n\t\t\tconst destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n\n\t\t\tif (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n\t\t\t\t// contiguous zone => extend copy request\n\t\t\t\tcopySourceEnd = sourceEnd;\n\t\t\t\tcopyDestEnd = destEnd;\n\t\t\t} else {\n\t\t\t\tif (copySourceStart !== -1) {\n\t\t\t\t\t// flush existing copy request\n\t\t\t\t\ttargetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\t\t\t\t\tif (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n\t\t\t\t\t\tdirtyPixel1 = copySourceEnd;\n\t\t\t\t\t}\n\t\t\t\t\tif (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n\t\t\t\t\t\tdirtyPixel2 = copySourceStart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopySourceStart = sourceStart;\n\t\t\t\tcopySourceEnd = sourceEnd;\n\t\t\t\tcopyDestStart = destStart;\n\t\t\t\tcopyDestEnd = destEnd;\n\t\t\t}\n\n\t\t\tneeded[lineIndex] = false;\n\t\t\tdest_dy += minimapLineHeight;\n\t\t}\n\n\t\tif (copySourceStart !== -1) {\n\t\t\t// flush existing copy request\n\t\t\ttargetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\t\t\tif (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n\t\t\t\tdirtyPixel1 = copySourceEnd;\n\t\t\t}\n\t\t\tif (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n\t\t\t\tdirtyPixel2 = copySourceStart;\n\t\t\t}\n\t\t}\n\n\t\tconst dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n\t\tconst dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n\n\t\treturn [dirtyY1, dirtyY2, needed];\n\t}\n\n\tprivate static _renderLine(\n\t\ttarget: ImageData,\n\t\tbackgroundColor: RGBA8,\n\t\tbackgroundAlpha: number,\n\t\tuseLighterFont: boolean,\n\t\trenderMinimap: RenderMinimap,\n\t\tcharWidth: number,\n\t\tcolorTracker: MinimapTokensColorTracker,\n\t\tforegroundAlpha: number,\n\t\tminimapCharRenderer: MinimapCharRenderer,\n\t\tdy: number,\n\t\tinnerLinePadding: number,\n\t\ttabSize: number,\n\t\tlineData: ViewLineData,\n\t\tfontScale: number,\n\t\tminimapLineHeight: number\n\t): void {\n\t\tconst content = lineData.content;\n\t\tconst tokens = lineData.tokens;\n\t\tconst maxDx = target.width - charWidth;\n\t\tconst force1pxHeight = (minimapLineHeight === 1);\n\n\t\tlet dx = MINIMAP_GUTTER_WIDTH;\n\t\tlet charIndex = 0;\n\t\tlet tabsCharDelta = 0;\n\n\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\tconst tokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\tconst tokenColorId = tokens.getForeground(tokenIndex);\n\t\t\tconst tokenColor = colorTracker.getColor(tokenColorId);\n\n\t\t\tfor (; charIndex < tokenEndIndex; charIndex++) {\n\t\t\t\tif (dx > maxDx) {\n\t\t\t\t\t// hit edge of minimap\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst charCode = content.charCodeAt(charIndex);\n\n\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\tconst insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\t// No need to render anything since tab is invisible\n\t\t\t\t\tdx += insertSpacesCount * charWidth;\n\t\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\t\t// No need to render anything since space is invisible\n\t\t\t\t\tdx += charWidth;\n\t\t\t\t} else {\n\t\t\t\t\t// Render twice for a full width character\n\t\t\t\t\tconst count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\t\tif (renderMinimap === RenderMinimap.Blocks) {\n\t\t\t\t\t\t\tminimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n\t\t\t\t\t\t} else { // RenderMinimap.Text\n\t\t\t\t\t\t\tminimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdx += charWidth;\n\n\t\t\t\t\t\tif (dx > maxDx) {\n\t\t\t\t\t\t\t// hit edge of minimap\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ContiguousLineMap<T> {\n\n\tprivate readonly _startLineNumber: number;\n\tprivate readonly _endLineNumber: number;\n\tprivate readonly _defaultValue: T;\n\tprivate readonly _values: T[];\n\n\tconstructor(startLineNumber: number, endLineNumber: number, defaultValue: T) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._endLineNumber = endLineNumber;\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._values = [];\n\t\tfor (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n\t\t\tthis._values[i] = defaultValue;\n\t\t}\n\t}\n\n\tpublic has(lineNumber: number): boolean {\n\t\treturn (this.get(lineNumber) !== this._defaultValue);\n\t}\n\n\tpublic set(lineNumber: number, value: T): void {\n\t\tif (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n\t\t\treturn;\n\t\t}\n\t\tthis._values[lineNumber - this._startLineNumber] = value;\n\t}\n\n\tpublic get(lineNumber: number): T {\n\t\tif (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n\t\t\treturn this._defaultValue;\n\t\t}\n\t\treturn this._values[lineNumber - this._startLineNumber];\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { FastDomNode, createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { IDisposable, Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { ILine, RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprint, PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { RenderMinimap, EditorOption, MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/misc/rgba.js';\nimport { ScrollType } from '../../../common/editorCommon.js';\nimport { IEditorConfiguration } from '../../../common/config/editorConfiguration.js';\nimport { ColorId } from '../../../common/encodedTokenAttributes.js';\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { Constants } from './minimapCharSheet.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { RenderingContext, RestrictedRenderingContext } from '../../view/renderingContext.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { EditorTheme } from '../../../common/editorTheme.js';\nimport * as viewEvents from '../../../common/viewEvents.js';\nimport { ViewLineData } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { ModelDecorationMinimapOptions } from '../../../common/model/textModel.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { GestureEvent, EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition, MinimapSectionHeaderStyle, TextModelResolvedOptions } from '../../../common/model.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModelDecoration.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\n\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\n\nconst GUTTER_DECORATION_WIDTH = 2;\n\nclass MinimapOptions {\n\n\tpublic readonly renderMinimap: RenderMinimap;\n\tpublic readonly size: 'proportional' | 'fill' | 'fit';\n\tpublic readonly minimapHeightIsEditorHeight: boolean;\n\tpublic readonly scrollBeyondLastLine: boolean;\n\tpublic readonly paddingTop: number;\n\tpublic readonly paddingBottom: number;\n\tpublic readonly showSlider: 'always' | 'mouseover';\n\tpublic readonly autohide: 'none' | 'mouseover' | 'scroll';\n\tpublic readonly pixelRatio: number;\n\tpublic readonly typicalHalfwidthCharacterWidth: number;\n\tpublic readonly lineHeight: number;\n\t/**\n\t * container dom node left position (in CSS px)\n\t */\n\tpublic readonly minimapLeft: number;\n\t/**\n\t * container dom node width (in CSS px)\n\t */\n\tpublic readonly minimapWidth: number;\n\t/**\n\t * container dom node height (in CSS px)\n\t */\n\tpublic readonly minimapHeight: number;\n\t/**\n\t * canvas backing store width (in device px)\n\t */\n\tpublic readonly canvasInnerWidth: number;\n\t/**\n\t * canvas backing store height (in device px)\n\t */\n\tpublic readonly canvasInnerHeight: number;\n\t/**\n\t * canvas width (in CSS px)\n\t */\n\tpublic readonly canvasOuterWidth: number;\n\t/**\n\t * canvas height (in CSS px)\n\t */\n\tpublic readonly canvasOuterHeight: number;\n\n\tpublic readonly isSampling: boolean;\n\tpublic readonly editorHeight: number;\n\tpublic readonly fontScale: number;\n\tpublic readonly minimapLineHeight: number;\n\tpublic readonly minimapCharWidth: number;\n\tpublic readonly sectionHeaderFontFamily: string;\n\tpublic readonly sectionHeaderFontSize: number;\n\t/**\n\t * Space in between the characters of the section header (in CSS px)\n\t */\n\tpublic readonly sectionHeaderLetterSpacing: number;\n\tpublic readonly sectionHeaderFontColor: RGBA8;\n\n\tpublic readonly charRenderer: () => MinimapCharRenderer;\n\tpublic readonly defaultBackgroundColor: RGBA8;\n\tpublic readonly backgroundColor: RGBA8;\n\t/**\n\t * foreground alpha: integer in [0-255]\n\t */\n\tpublic readonly foregroundAlpha: number;\n\n\tconstructor(configuration: IEditorConfiguration, theme: EditorTheme, tokensColorTracker: MinimapTokensColorTracker) {\n\t\tconst options = configuration.options;\n\t\tconst pixelRatio = options.get(EditorOption.pixelRatio);\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tconst minimapLayout = layoutInfo.minimap;\n\t\tconst fontInfo = options.get(EditorOption.fontInfo);\n\t\tconst minimapOpts = options.get(EditorOption.minimap);\n\n\t\tthis.renderMinimap = minimapLayout.renderMinimap;\n\t\tthis.size = minimapOpts.size;\n\t\tthis.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n\t\tthis.scrollBeyondLastLine = options.get(EditorOption.scrollBeyondLastLine);\n\t\tthis.paddingTop = options.get(EditorOption.padding).top;\n\t\tthis.paddingBottom = options.get(EditorOption.padding).bottom;\n\t\tthis.showSlider = minimapOpts.showSlider;\n\t\tthis.autohide = minimapOpts.autohide;\n\t\tthis.pixelRatio = pixelRatio;\n\t\tthis.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n\t\tthis.lineHeight = options.get(EditorOption.lineHeight);\n\t\tthis.minimapLeft = minimapLayout.minimapLeft;\n\t\tthis.minimapWidth = minimapLayout.minimapWidth;\n\t\tthis.minimapHeight = layoutInfo.height;\n\n\t\tthis.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n\t\tthis.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n\t\tthis.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n\t\tthis.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n\n\t\tthis.isSampling = minimapLayout.minimapIsSampling;\n\t\tthis.editorHeight = layoutInfo.height;\n\t\tthis.fontScale = minimapLayout.minimapScale;\n\t\tthis.minimapLineHeight = minimapLayout.minimapLineHeight;\n\t\tthis.minimapCharWidth = Constants.BASE_CHAR_WIDTH * this.fontScale;\n\t\tthis.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n\t\tthis.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n\t\tthis.sectionHeaderLetterSpacing = minimapOpts.sectionHeaderLetterSpacing; // intentionally not multiplying by pixelRatio\n\t\tthis.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(ColorId.DefaultForeground));\n\n\t\tthis.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n\t\tthis.defaultBackgroundColor = tokensColorTracker.getColor(ColorId.DefaultBackground);\n\t\tthis.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n\t\tthis.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n\t}\n\n\tprivate static _getMinimapBackground(theme: EditorTheme, defaultBackgroundColor: RGBA8): RGBA8 {\n\t\tconst themeColor = theme.getColor(minimapBackground);\n\t\tif (themeColor) {\n\t\t\treturn new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn defaultBackgroundColor;\n\t}\n\n\tprivate static _getMinimapForegroundOpacity(theme: EditorTheme): number {\n\t\tconst themeColor = theme.getColor(minimapForegroundOpacity);\n\t\tif (themeColor) {\n\t\t\treturn RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn 255;\n\t}\n\n\tprivate static _getSectionHeaderColor(theme: EditorTheme, defaultForegroundColor: RGBA8): RGBA8 {\n\t\tconst themeColor = theme.getColor(editorForeground);\n\t\tif (themeColor) {\n\t\t\treturn new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n\t\t}\n\t\treturn defaultForegroundColor;\n\t}\n\n\tpublic equals(other: MinimapOptions): boolean {\n\t\treturn (this.renderMinimap === other.renderMinimap\n\t\t\t&& this.size === other.size\n\t\t\t&& this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n\t\t\t&& this.scrollBeyondLastLine === other.scrollBeyondLastLine\n\t\t\t&& this.paddingTop === other.paddingTop\n\t\t\t&& this.paddingBottom === other.paddingBottom\n\t\t\t&& this.showSlider === other.showSlider\n\t\t\t&& this.autohide === other.autohide\n\t\t\t&& this.pixelRatio === other.pixelRatio\n\t\t\t&& this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n\t\t\t&& this.lineHeight === other.lineHeight\n\t\t\t&& this.minimapLeft === other.minimapLeft\n\t\t\t&& this.minimapWidth === other.minimapWidth\n\t\t\t&& this.minimapHeight === other.minimapHeight\n\t\t\t&& this.canvasInnerWidth === other.canvasInnerWidth\n\t\t\t&& this.canvasInnerHeight === other.canvasInnerHeight\n\t\t\t&& this.canvasOuterWidth === other.canvasOuterWidth\n\t\t\t&& this.canvasOuterHeight === other.canvasOuterHeight\n\t\t\t&& this.isSampling === other.isSampling\n\t\t\t&& this.editorHeight === other.editorHeight\n\t\t\t&& this.fontScale === other.fontScale\n\t\t\t&& this.minimapLineHeight === other.minimapLineHeight\n\t\t\t&& this.minimapCharWidth === other.minimapCharWidth\n\t\t\t&& this.sectionHeaderFontSize === other.sectionHeaderFontSize\n\t\t\t&& this.sectionHeaderLetterSpacing === other.sectionHeaderLetterSpacing\n\t\t\t&& this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n\t\t\t&& this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n\t\t\t&& this.foregroundAlpha === other.foregroundAlpha\n\t\t);\n\t}\n}\n\nclass MinimapLayout {\n\n\tconstructor(\n\t\t/**\n\t\t * The given editor scrollTop (input).\n\t\t */\n\t\tpublic readonly scrollTop: number,\n\t\t/**\n\t\t * The given editor scrollHeight (input).\n\t\t */\n\t\tpublic readonly scrollHeight: number,\n\t\tpublic readonly sliderNeeded: boolean,\n\t\tprivate readonly _computedSliderRatio: number,\n\t\t/**\n\t\t * slider dom node top (in CSS px)\n\t\t */\n\t\tpublic readonly sliderTop: number,\n\t\t/**\n\t\t * slider dom node height (in CSS px)\n\t\t */\n\t\tpublic readonly sliderHeight: number,\n\t\t/**\n\t\t * empty lines to reserve at the top of the minimap.\n\t\t */\n\t\tpublic readonly topPaddingLineCount: number,\n\t\t/**\n\t\t * minimap render start line number.\n\t\t */\n\t\tpublic readonly startLineNumber: number,\n\t\t/**\n\t\t * minimap render end line number.\n\t\t */\n\t\tpublic readonly endLineNumber: number\n\t) { }\n\n\t/**\n\t * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n\t */\n\tpublic getDesiredScrollTopFromDelta(delta: number): number {\n\t\treturn Math.round(this.scrollTop + delta / this._computedSliderRatio);\n\t}\n\n\tpublic getDesiredScrollTopFromTouchLocation(pageY: number): number {\n\t\treturn Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n\t}\n\n\t/**\n\t * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n\t */\n\tpublic intersectWithViewport(range: Range): [number, number] | null {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n\t\tconst endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n\t\tif (startLineNumber > endLineNumber) {\n\t\t\t// entirely outside minimap's viewport\n\t\t\treturn null;\n\t\t}\n\t\treturn [startLineNumber, endLineNumber];\n\t}\n\n\t/**\n\t * Get the inner minimap y coordinate for a line number.\n\t */\n\tpublic getYForLineNumber(lineNumber: number, minimapLineHeight: number): number {\n\t\treturn + (lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n\t}\n\n\tpublic static create(\n\t\toptions: MinimapOptions,\n\t\tviewportStartLineNumber: number,\n\t\tviewportEndLineNumber: number,\n\t\tviewportStartLineNumberVerticalOffset: number,\n\t\tviewportHeight: number,\n\t\tviewportContainsWhitespaceGaps: boolean,\n\t\tlineCount: number,\n\t\trealLineCount: number,\n\t\tscrollTop: number,\n\t\tscrollHeight: number,\n\t\tpreviousLayout: MinimapLayout | null\n\t): MinimapLayout {\n\t\tconst pixelRatio = options.pixelRatio;\n\t\tconst minimapLineHeight = options.minimapLineHeight;\n\t\tconst minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n\t\tconst lineHeight = options.lineHeight;\n\n\t\tif (options.minimapHeightIsEditorHeight) {\n\t\t\tlet logicalScrollHeight = (\n\t\t\t\trealLineCount * options.lineHeight\n\t\t\t\t+ options.paddingTop\n\t\t\t\t+ options.paddingBottom\n\t\t\t);\n\t\t\tif (options.scrollBeyondLastLine) {\n\t\t\t\tlogicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n\t\t\t}\n\t\t\tconst sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n\t\t\tconst maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n\t\t\t// The slider can move from 0 to `maxMinimapSliderTop`\n\t\t\t// in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\t\t\tconst computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n\t\t\tconst sliderTop = (scrollTop * computedSliderRatio);\n\t\t\tconst sliderNeeded = (maxMinimapSliderTop > 0);\n\t\t\tconst maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n\t\t\tconst topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n\t\t}\n\n\t\t// The visible line count in a viewport can change due to a number of reasons:\n\t\t//  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n\t\t//    e.g. for a line height of 20, and a viewport height of 600\n\t\t//          * scrollTop = 0  => visible lines are [1, 30]\n\t\t//          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n\t\t//          * scrollTop = 20 => visible lines are [2, 31]\n\t\t//  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n\t\t//  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n\n\t\t// We must first establish a desirable slider height.\n\t\tlet sliderHeight: number;\n\t\tif (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n\t\t\t// case b) from above: there are whitespace gaps in the viewport.\n\t\t\t// In this case, the height of the slider directly reflects the visible line count.\n\t\t\tconst viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n\t\t\tsliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n\t\t} else {\n\t\t\t// The slider has a stable height\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\tsliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n\t\t}\n\n\t\tconst extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n\t\tlet extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n\t\tif (options.scrollBeyondLastLine) {\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\textraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n\t\t}\n\n\t\tlet maxMinimapSliderTop: number;\n\t\tif (extraLinesAtTheBottom > 0) {\n\t\t\tconst expectedViewportLineCount = viewportHeight / lineHeight;\n\t\t\t// The minimap slider, when dragged all the way down, will contain the last line at its top\n\t\t\tmaxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n\t\t} else {\n\t\t\t// The minimap slider, when dragged all the way down, will contain the last line at its bottom\n\t\t\tmaxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n\t\t}\n\t\tmaxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n\n\t\t// The slider can move from 0 to `maxMinimapSliderTop`\n\t\t// in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\t\tconst computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n\t\tconst sliderTop = (scrollTop * computedSliderRatio);\n\n\t\tif (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n\t\t\t// All lines fit in the minimap\n\t\t\tconst sliderNeeded = (maxMinimapSliderTop > 0);\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n\t\t} else {\n\t\t\tlet consideringStartLineNumber: number;\n\t\t\tif (viewportStartLineNumber > 1) {\n\t\t\t\tconsideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n\t\t\t} else {\n\t\t\t\tconsideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n\t\t\t}\n\n\t\t\tlet topPaddingLineCount: number;\n\t\t\tlet startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n\t\t\tif (startLineNumber < extraLinesAtTheTop) {\n\t\t\t\ttopPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n\t\t\t\tstartLineNumber = 1;\n\t\t\t} else {\n\t\t\t\ttopPaddingLineCount = 0;\n\t\t\t\tstartLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n\t\t\t}\n\n\t\t\t// Avoid flickering caused by a partial viewport start line\n\t\t\t// by being consistent w.r.t. the previous layout decision\n\t\t\tif (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n\t\t\t\tif (previousLayout.scrollTop > scrollTop) {\n\t\t\t\t\t// Scrolling up => never increase `startLineNumber`\n\t\t\t\t\tstartLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n\t\t\t\t\ttopPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n\t\t\t\t}\n\t\t\t\tif (previousLayout.scrollTop < scrollTop) {\n\t\t\t\t\t// Scrolling down => never decrease `startLineNumber`\n\t\t\t\t\tstartLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n\t\t\t\t\ttopPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n\t\t\tconst partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n\n\t\t\tlet sliderTopAligned: number;\n\t\t\tif (scrollTop >= options.paddingTop) {\n\t\t\t\tsliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n\t\t\t} else {\n\t\t\t\tsliderTopAligned = (scrollTop / options.paddingTop) * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n\t\t\t}\n\n\t\t\treturn new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n\t\t}\n\t}\n}\n\nclass MinimapLine implements ILine {\n\n\tpublic static readonly INVALID = new MinimapLine(-1);\n\n\tdy: number;\n\n\tconstructor(dy: number) {\n\t\tthis.dy = dy;\n\t}\n\n\tpublic onContentChanged(): void {\n\t\tthis.dy = -1;\n\t}\n\n\tpublic onTokensChanged(): void {\n\t\tthis.dy = -1;\n\t}\n}\n\nclass RenderData {\n\t/**\n\t * last rendered layout.\n\t */\n\tpublic readonly renderedLayout: MinimapLayout;\n\tprivate readonly _imageData: ImageData;\n\tprivate readonly _renderedLines: RenderedLinesCollection<MinimapLine>;\n\n\tconstructor(\n\t\trenderedLayout: MinimapLayout,\n\t\timageData: ImageData,\n\t\tlines: MinimapLine[]\n\t) {\n\t\tthis.renderedLayout = renderedLayout;\n\t\tthis._imageData = imageData;\n\t\tthis._renderedLines = new RenderedLinesCollection({\n\t\t\tcreateLine: () => MinimapLine.INVALID\n\t\t});\n\t\tthis._renderedLines._set(renderedLayout.startLineNumber, lines);\n\t}\n\n\t/**\n\t * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n\t */\n\tpublic linesEquals(layout: MinimapLayout): boolean {\n\t\tif (!this.scrollEquals(layout)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tmp = this._renderedLines._get();\n\t\tconst lines = tmp.lines;\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].dy === -1) {\n\t\t\t\t// This line is invalid\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if the current RenderData matches the new layout's scroll position\n\t */\n\tpublic scrollEquals(layout: MinimapLayout): boolean {\n\t\treturn this.renderedLayout.startLineNumber === layout.startLineNumber\n\t\t\t&& this.renderedLayout.endLineNumber === layout.endLineNumber;\n\t}\n\n\t_get(): { imageData: ImageData; rendLineNumberStart: number; lines: MinimapLine[] } {\n\t\tconst tmp = this._renderedLines._get();\n\t\treturn {\n\t\t\timageData: this._imageData,\n\t\t\trendLineNumberStart: tmp.rendLineNumberStart,\n\t\t\tlines: tmp.lines\n\t\t};\n\t}\n\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\treturn this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n\t}\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): void {\n\t\tthis._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n\t}\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): void {\n\t\tthis._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n\t}\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\treturn this._renderedLines.onTokensChanged(ranges);\n\t}\n}\n\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n\n\tprivate readonly _backgroundFillData: Uint8ClampedArray;\n\tprivate readonly _buffers: [ImageData, ImageData];\n\tprivate _lastUsedBuffer: number;\n\n\tconstructor(ctx: CanvasRenderingContext2D, WIDTH: number, HEIGHT: number, background: RGBA8) {\n\t\tthis._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n\t\tthis._buffers = [\n\t\t\tctx.createImageData(WIDTH, HEIGHT),\n\t\t\tctx.createImageData(WIDTH, HEIGHT)\n\t\t];\n\t\tthis._lastUsedBuffer = 0;\n\t}\n\n\tpublic getBuffer(): ImageData {\n\t\t// rotate buffers\n\t\tthis._lastUsedBuffer = 1 - this._lastUsedBuffer;\n\t\tconst result = this._buffers[this._lastUsedBuffer];\n\n\t\t// fill with background color\n\t\tresult.data.set(this._backgroundFillData);\n\n\t\treturn result;\n\t}\n\n\tprivate static _createBackgroundFillData(WIDTH: number, HEIGHT: number, background: RGBA8): Uint8ClampedArray {\n\t\tconst backgroundR = background.r;\n\t\tconst backgroundG = background.g;\n\t\tconst backgroundB = background.b;\n\t\tconst backgroundA = background.a;\n\n\t\tconst result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n\t\tlet offset = 0;\n\t\tfor (let i = 0; i < HEIGHT; i++) {\n\t\t\tfor (let j = 0; j < WIDTH; j++) {\n\t\t\t\tresult[offset] = backgroundR;\n\t\t\t\tresult[offset + 1] = backgroundG;\n\t\t\t\tresult[offset + 2] = backgroundB;\n\t\t\t\tresult[offset + 3] = backgroundA;\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport interface IMinimapModel {\n\treadonly tokensColorTracker: MinimapTokensColorTracker;\n\treadonly options: MinimapOptions;\n\n\tgetLineCount(): number;\n\tgetRealLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): (ViewLineData | null)[];\n\tgetSelections(): Selection[];\n\tgetMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[];\n\tgetSectionHeaderDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[];\n\tgetSectionHeaderText(decoration: ViewModelDecoration, fitWidth: (s: string) => string): string | null;\n\tgetOptions(): TextModelResolvedOptions;\n\trevealLineNumber(lineNumber: number): void;\n\tsetScrollTop(scrollTop: number): void;\n}\n\ninterface IMinimapRenderingContext {\n\treadonly viewportContainsWhitespaceGaps: boolean;\n\n\treadonly scrollWidth: number;\n\treadonly scrollHeight: number;\n\n\treadonly viewportStartLineNumber: number;\n\treadonly viewportEndLineNumber: number;\n\treadonly viewportStartLineNumberVerticalOffset: number;\n\n\treadonly scrollTop: number;\n\treadonly scrollLeft: number;\n\n\treadonly viewportWidth: number;\n\treadonly viewportHeight: number;\n}\n\ninterface SamplingStateLinesDeletedEvent {\n\ttype: 'deleted';\n\t_oldIndex: number;\n\tdeleteFromLineNumber: number;\n\tdeleteToLineNumber: number;\n}\n\ninterface SamplingStateLinesInsertedEvent {\n\ttype: 'inserted';\n\t_i: number;\n\tinsertFromLineNumber: number;\n\tinsertToLineNumber: number;\n}\n\ninterface SamplingStateFlushEvent {\n\ttype: 'flush';\n}\n\ntype SamplingStateEvent = SamplingStateLinesInsertedEvent | SamplingStateLinesDeletedEvent | SamplingStateFlushEvent;\n\nclass MinimapSamplingState {\n\n\tpublic static compute(options: MinimapOptions, viewLineCount: number, oldSamplingState: MinimapSamplingState | null): [MinimapSamplingState | null, SamplingStateEvent[]] {\n\t\tif (options.renderMinimap === RenderMinimap.None || !options.isSampling) {\n\t\t\treturn [null, []];\n\t\t}\n\n\t\t// ratio is intentionally not part of the layout to avoid the layout changing all the time\n\t\t// so we need to recompute it again...\n\t\tconst { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n\t\t\tviewLineCount: viewLineCount,\n\t\t\tscrollBeyondLastLine: options.scrollBeyondLastLine,\n\t\t\tpaddingTop: options.paddingTop,\n\t\t\tpaddingBottom: options.paddingBottom,\n\t\t\theight: options.editorHeight,\n\t\t\tlineHeight: options.lineHeight,\n\t\t\tpixelRatio: options.pixelRatio\n\t\t});\n\t\tconst ratio = viewLineCount / minimapLineCount;\n\t\tconst halfRatio = ratio / 2;\n\n\t\tif (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n\t\t\tconst result: number[] = [];\n\t\t\tresult[0] = 1;\n\t\t\tif (minimapLineCount > 1) {\n\t\t\t\tfor (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n\t\t\t\t\tresult[i] = Math.round(i * ratio + halfRatio);\n\t\t\t\t}\n\t\t\t\tresult[minimapLineCount - 1] = viewLineCount;\n\t\t\t}\n\t\t\treturn [new MinimapSamplingState(ratio, result), []];\n\t\t}\n\n\t\tconst oldMinimapLines = oldSamplingState.minimapLines;\n\t\tconst oldLength = oldMinimapLines.length;\n\t\tconst result: number[] = [];\n\t\tlet oldIndex = 0;\n\t\tlet oldDeltaLineCount = 0;\n\t\tlet minViewLineNumber = 1;\n\t\tconst MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n\t\tlet events: SamplingStateEvent[] = [];\n\t\tlet lastEvent: SamplingStateEvent | null = null;\n\t\tfor (let i = 0; i < minimapLineCount; i++) {\n\t\t\tconst fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n\t\t\tconst toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n\n\t\t\twhile (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n\t\t\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\t\tif (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n\t\t\t\t\t\tlastEvent.deleteToLineNumber++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t\t}\n\t\t\t\t\toldDeltaLineCount--;\n\t\t\t\t}\n\t\t\t\toldIndex++;\n\t\t\t}\n\n\t\t\tlet selectedViewLineNumber: number;\n\t\t\tif (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n\t\t\t\t// reuse the old sampled line\n\t\t\t\tselectedViewLineNumber = oldMinimapLines[oldIndex];\n\t\t\t\toldIndex++;\n\t\t\t} else {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tselectedViewLineNumber = 1;\n\t\t\t\t} else if (i + 1 === minimapLineCount) {\n\t\t\t\t\tselectedViewLineNumber = viewLineCount;\n\t\t\t\t} else {\n\t\t\t\t\tselectedViewLineNumber = Math.round(i * ratio + halfRatio);\n\t\t\t\t}\n\t\t\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\t\tif (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n\t\t\t\t\t\tlastEvent.insertToLineNumber++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t\t}\n\t\t\t\t\toldDeltaLineCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult[i] = selectedViewLineNumber;\n\t\t\tminViewLineNumber = selectedViewLineNumber;\n\t\t}\n\n\t\tif (events.length < MAX_EVENT_COUNT) {\n\t\t\twhile (oldIndex < oldLength) {\n\t\t\t\tconst oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\t\t\t\tif (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n\t\t\t\t\tlastEvent.deleteToLineNumber++;\n\t\t\t\t} else {\n\t\t\t\t\tlastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n\t\t\t\t\tevents.push(lastEvent);\n\t\t\t\t}\n\t\t\t\toldDeltaLineCount--;\n\t\t\t\toldIndex++;\n\t\t\t}\n\t\t} else {\n\t\t\t// too many events, just give up\n\t\t\tevents = [{ type: 'flush' }];\n\t\t}\n\n\t\treturn [new MinimapSamplingState(ratio, result), events];\n\t}\n\n\tconstructor(\n\t\tpublic readonly samplingRatio: number,\n\t\tpublic readonly minimapLines: number[]\t// a map of 0-based minimap line indexes to 1-based view line numbers\n\t) {\n\t}\n\n\tpublic modelLineToMinimapLine(lineNumber: number): number {\n\t\treturn Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n\t}\n\n\t/**\n\t * Will return null if the model line ranges are not intersecting with a sampled model line.\n\t */\n\tpublic modelLineRangeToMinimapLineRange(fromLineNumber: number, toLineNumber: number): [number, number] | null {\n\t\tlet fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n\t\twhile (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n\t\t\tfromLineIndex--;\n\t\t}\n\t\tlet toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n\t\twhile (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n\t\t\ttoLineIndex++;\n\t\t}\n\t\tif (fromLineIndex === toLineIndex) {\n\t\t\tconst sampledLineNumber = this.minimapLines[fromLineIndex];\n\t\t\tif (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n\t\t\t\t// This line is not part of the sampled lines ==> nothing to do\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn [fromLineIndex + 1, toLineIndex + 1];\n\t}\n\n\t/**\n\t * Will always return a range, even if it is not intersecting with a sampled model line.\n\t */\n\tpublic decorationLineRangeToMinimapLineRange(startLineNumber: number, endLineNumber: number): [number, number] {\n\t\tlet minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n\t\tlet minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n\t\tif (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n\t\t\tif (minimapLineEnd === this.minimapLines.length) {\n\t\t\t\tif (minimapLineStart > 1) {\n\t\t\t\t\tminimapLineStart--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tminimapLineEnd++;\n\t\t\t}\n\t\t}\n\t\treturn [minimapLineStart, minimapLineEnd];\n\t}\n\n\tpublic onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): [number, number] {\n\t\t// have the mapping be sticky\n\t\tconst deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\t\tlet changeStartIndex = this.minimapLines.length;\n\t\tlet changeEndIndex = 0;\n\t\tfor (let i = this.minimapLines.length - 1; i >= 0; i--) {\n\t\t\tif (this.minimapLines[i] < e.fromLineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (this.minimapLines[i] <= e.toLineNumber) {\n\t\t\t\t// this line got deleted => move to previous available\n\t\t\t\tthis.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n\t\t\t\tchangeStartIndex = Math.min(changeStartIndex, i);\n\t\t\t\tchangeEndIndex = Math.max(changeEndIndex, i);\n\t\t\t} else {\n\t\t\t\tthis.minimapLines[i] -= deletedLineCount;\n\t\t\t}\n\t\t}\n\t\treturn [changeStartIndex, changeEndIndex];\n\t}\n\n\tpublic onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): void {\n\t\t// have the mapping be sticky\n\t\tconst insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\t\tfor (let i = this.minimapLines.length - 1; i >= 0; i--) {\n\t\t\tif (this.minimapLines[i] < e.fromLineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.minimapLines[i] += insertedLineCount;\n\t\t}\n\t}\n}\n\n/**\n * The minimap appears beside the editor scroll bar and visualizes a zoomed out\n * view of the file.\n */\nexport class Minimap extends ViewPart implements IMinimapModel {\n\n\tpublic readonly tokensColorTracker: MinimapTokensColorTracker;\n\n\tprivate _selections: Selection[];\n\tprivate _minimapSelections: Selection[] | null;\n\n\tpublic options: MinimapOptions;\n\n\tprivate _samplingState: MinimapSamplingState | null;\n\tprivate _shouldCheckSampling: boolean;\n\n\tprivate _sectionHeaderCache = new LRUCache<string, string>(10, 1.5);\n\n\tprivate _actual: InnerMinimap;\n\n\tconstructor(context: ViewContext) {\n\t\tsuper(context);\n\n\t\tthis.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n\n\t\tthis._selections = [];\n\t\tthis._minimapSelections = null;\n\n\t\tthis.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\t\tconst [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n\t\tthis._samplingState = samplingState;\n\t\tthis._shouldCheckSampling = false;\n\n\t\tthis._actual = new InnerMinimap(context.theme, this);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._actual.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tpublic getDomNode(): FastDomNode<HTMLElement> {\n\t\treturn this._actual.getDomNode();\n\t}\n\n\tprivate _onOptionsMaybeChanged(): boolean {\n\t\tconst opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\t\tif (this.options.equals(opts)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.options = opts;\n\t\tthis._recreateLineSampling();\n\t\tthis._actual.onDidChangeOptions();\n\t\treturn true;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic override onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\treturn this._onOptionsMaybeChanged();\n\t}\n\tpublic override onCursorStateChanged(e: viewEvents.ViewCursorStateChangedEvent): boolean {\n\t\tthis._selections = e.selections;\n\t\tthis._minimapSelections = null;\n\t\treturn this._actual.onSelectionChanged();\n\t}\n\tpublic override onDecorationsChanged(e: viewEvents.ViewDecorationsChangedEvent): boolean {\n\t\tif (e.affectsMinimap) {\n\t\t\treturn this._actual.onDecorationsChanged();\n\t\t}\n\t\treturn false;\n\t}\n\tpublic override onFlushed(e: viewEvents.ViewFlushedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tthis._shouldCheckSampling = true;\n\t\t}\n\t\treturn this._actual.onFlushed();\n\t}\n\tpublic override onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n\t\t\tif (minimapLineRange) {\n\t\t\t\treturn this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._actual.onLinesChanged(e.fromLineNumber, e.count);\n\t\t}\n\t}\n\tpublic override onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n\t\t\tif (changeStartIndex <= changeEndIndex) {\n\t\t\t\tthis._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n\t\t\t}\n\t\t\tthis._shouldCheckSampling = true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\t\t}\n\t}\n\tpublic override onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tthis._samplingState.onLinesInserted(e);\n\t\t\tthis._shouldCheckSampling = true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\t\t}\n\t}\n\tpublic override onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\treturn this._actual.onScrollChanged(e);\n\t}\n\tpublic override onThemeChanged(e: viewEvents.ViewThemeChangedEvent): boolean {\n\t\tthis._actual.onThemeChanged();\n\t\tthis._onOptionsMaybeChanged();\n\t\treturn true;\n\t}\n\tpublic override onTokensChanged(e: viewEvents.ViewTokensChangedEvent): boolean {\n\t\tif (this._samplingState) {\n\t\t\tconst ranges: { fromLineNumber: number; toLineNumber: number }[] = [];\n\t\t\tfor (const range of e.ranges) {\n\t\t\t\tconst minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t\t\tif (minimapLineRange) {\n\t\t\t\t\tranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ranges.length) {\n\t\t\t\treturn this._actual.onTokensChanged(ranges);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._actual.onTokensChanged(e.ranges);\n\t\t}\n\t}\n\tpublic override onTokensColorsChanged(e: viewEvents.ViewTokensColorsChangedEvent): boolean {\n\t\tthis._onOptionsMaybeChanged();\n\t\treturn this._actual.onTokensColorsChanged();\n\t}\n\tpublic override onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean {\n\t\treturn this._actual.onZonesChanged();\n\t}\n\n\t// --- end event handlers\n\n\tpublic prepareRender(ctx: RenderingContext): void {\n\t\tif (this._shouldCheckSampling) {\n\t\t\tthis._shouldCheckSampling = false;\n\t\t\tthis._recreateLineSampling();\n\t\t}\n\t}\n\n\tpublic render(ctx: RestrictedRenderingContext): void {\n\t\tlet viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n\t\tlet viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n\n\t\tif (this._samplingState) {\n\t\t\tviewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n\t\t\tviewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n\t\t}\n\n\t\tconst minimapCtx: IMinimapRenderingContext = {\n\t\t\tviewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n\n\t\t\tscrollWidth: ctx.scrollWidth,\n\t\t\tscrollHeight: ctx.scrollHeight,\n\n\t\t\tviewportStartLineNumber: viewportStartLineNumber,\n\t\t\tviewportEndLineNumber: viewportEndLineNumber,\n\t\t\tviewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n\n\t\t\tscrollTop: ctx.scrollTop,\n\t\t\tscrollLeft: ctx.scrollLeft,\n\n\t\t\tviewportWidth: ctx.viewportWidth,\n\t\t\tviewportHeight: ctx.viewportHeight,\n\t\t};\n\t\tthis._actual.render(minimapCtx);\n\t}\n\n\t//#region IMinimapModel\n\n\tprivate _recreateLineSampling(): void {\n\t\tthis._minimapSelections = null;\n\n\t\tconst wasSampling = Boolean(this._samplingState);\n\t\tconst [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n\t\tthis._samplingState = samplingState;\n\n\t\tif (wasSampling && this._samplingState) {\n\t\t\t// was sampling, is sampling\n\t\t\tfor (const event of events) {\n\t\t\t\tswitch (event.type) {\n\t\t\t\t\tcase 'deleted':\n\t\t\t\t\t\tthis._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'inserted':\n\t\t\t\t\t\tthis._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flush':\n\t\t\t\t\t\tthis._actual.onFlushed();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getLineCount(): number {\n\t\tif (this._samplingState) {\n\t\t\treturn this._samplingState.minimapLines.length;\n\t\t}\n\t\treturn this._context.viewModel.getLineCount();\n\t}\n\n\tpublic getRealLineCount(): number {\n\t\treturn this._context.viewModel.getLineCount();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._samplingState) {\n\t\t\treturn this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n\t\t}\n\t\treturn this._context.viewModel.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\tif (this._samplingState) {\n\t\t\treturn this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n\t\t}\n\t\treturn this._context.viewModel.getLineMaxColumn(lineNumber);\n\t}\n\n\tpublic getMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): (ViewLineData | null)[] {\n\t\tif (this._samplingState) {\n\t\t\tconst result: (ViewLineData | null)[] = [];\n\t\t\tfor (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n\t\t\t\tif (needed[lineIndex]) {\n\t\t\t\t\tresult[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tresult[lineIndex] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\tif (this._minimapSelections === null) {\n\t\t\tif (this._samplingState) {\n\t\t\t\tthis._minimapSelections = [];\n\t\t\t\tfor (const selection of this._selections) {\n\t\t\t\t\tconst [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n\t\t\t\t\tthis._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._minimapSelections = this._selections;\n\t\t\t}\n\t\t}\n\t\treturn this._minimapSelections;\n\t}\n\n\tpublic getMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[] {\n\t\treturn this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n\t\t\t.filter(decoration => !decoration.options.minimap?.sectionHeaderStyle);\n\t}\n\n\tpublic getSectionHeaderDecorationsInViewport(startLineNumber: number, endLineNumber: number): ViewModelDecoration[] {\n\t\tconst headerHeightInMinimapLines = this.options.sectionHeaderFontSize / this.options.minimapLineHeight;\n\t\tstartLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n\t\treturn this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n\t\t\t.filter(decoration => !!decoration.options.minimap?.sectionHeaderStyle);\n\t}\n\n\tprivate _getMinimapDecorationsInViewport(startLineNumber: number, endLineNumber: number) {\n\t\tlet visibleRange: Range;\n\t\tif (this._samplingState) {\n\t\t\tconst modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n\t\t\tconst modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n\t\t\tvisibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n\t\t} else {\n\t\t\tvisibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n\t\t}\n\t\tconst decorations = this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n\n\t\tif (this._samplingState) {\n\t\t\tconst result: ViewModelDecoration[] = [];\n\t\t\tfor (const decoration of decorations) {\n\t\t\t\tif (!decoration.options.minimap) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst range = decoration.range;\n\t\t\t\tconst minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n\t\t\t\tconst minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n\t\t\t\tresult.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\treturn decorations;\n\t}\n\n\tpublic getSectionHeaderText(decoration: ViewModelDecoration, fitWidth: (s: string) => string): string | null {\n\t\tconst headerText = decoration.options.minimap?.sectionHeaderText;\n\t\tif (!headerText) {\n\t\t\treturn null;\n\t\t}\n\t\tconst cachedText = this._sectionHeaderCache.get(headerText);\n\t\tif (cachedText) {\n\t\t\treturn cachedText;\n\t\t}\n\t\tconst fittedText = fitWidth(headerText);\n\t\tthis._sectionHeaderCache.set(headerText, fittedText);\n\t\treturn fittedText;\n\t}\n\n\tpublic getOptions(): TextModelResolvedOptions {\n\t\treturn this._context.viewModel.model.getOptions();\n\t}\n\n\tpublic revealLineNumber(lineNumber: number): void {\n\t\tif (this._samplingState) {\n\t\t\tlineNumber = this._samplingState.minimapLines[lineNumber - 1];\n\t\t}\n\t\tthis._context.viewModel.revealRange(\n\t\t\t'mouse',\n\t\t\tfalse,\n\t\t\tnew Range(lineNumber, 1, lineNumber, 1),\n\t\t\tviewEvents.VerticalRevealType.Center,\n\t\t\tScrollType.Smooth\n\t\t);\n\t}\n\n\tpublic setScrollTop(scrollTop: number): void {\n\t\tthis._context.viewModel.viewLayout.setScrollPosition({\n\t\t\tscrollTop: scrollTop\n\t\t}, ScrollType.Immediate);\n\t}\n\n\t//#endregion\n}\n\nclass InnerMinimap extends Disposable {\n\n\tprivate readonly _theme: EditorTheme;\n\tprivate readonly _model: IMinimapModel;\n\n\tprivate readonly _domNode: FastDomNode<HTMLElement>;\n\tprivate readonly _shadow: FastDomNode<HTMLElement>;\n\tprivate readonly _canvas: FastDomNode<HTMLCanvasElement>;\n\tprivate readonly _decorationsCanvas: FastDomNode<HTMLCanvasElement>;\n\tprivate readonly _slider: FastDomNode<HTMLElement>;\n\tprivate readonly _sliderHorizontal: FastDomNode<HTMLElement>;\n\tprivate readonly _pointerDownListener: IDisposable;\n\tprivate readonly _sliderPointerMoveMonitor: GlobalPointerMoveMonitor;\n\tprivate readonly _sliderPointerDownListener: IDisposable;\n\tprivate readonly _gestureDisposable: IDisposable;\n\tprivate readonly _sliderTouchStartListener: IDisposable;\n\tprivate readonly _sliderTouchMoveListener: IDisposable;\n\tprivate readonly _sliderTouchEndListener: IDisposable;\n\n\tprivate _lastRenderData: RenderData | null;\n\tprivate _selectionColor: Color | undefined;\n\tprivate _renderDecorations: boolean = false;\n\tprivate _gestureInProgress: boolean = false;\n\tprivate _buffers: MinimapBuffers | null;\n\tprivate _isMouseOverMinimap: boolean = false;\n\tprivate _hideDelayedScheduler: RunOnceScheduler;\n\n\tconstructor(\n\t\ttheme: EditorTheme,\n\t\tmodel: IMinimapModel\n\t) {\n\t\tsuper();\n\n\t\tthis._theme = theme;\n\t\tthis._model = model;\n\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\tthis._selectionColor = this._theme.getColor(minimapSelection);\n\n\t\tthis._domNode = createFastDomNode(document.createElement('div'));\n\t\tPartFingerprints.write(this._domNode, PartFingerprint.Minimap);\n\t\tthis._domNode.setClassName(this._getMinimapDomNodeClassName());\n\t\tthis._domNode.setPosition('absolute');\n\t\tthis._domNode.setAttribute('role', 'presentation');\n\t\tthis._domNode.setAttribute('aria-hidden', 'true');\n\n\t\tthis._shadow = createFastDomNode(document.createElement('div'));\n\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\tthis._domNode.appendChild(this._shadow);\n\n\t\tthis._canvas = createFastDomNode(document.createElement('canvas'));\n\t\tthis._canvas.setPosition('absolute');\n\t\tthis._canvas.setLeft(0);\n\t\tthis._domNode.appendChild(this._canvas);\n\n\t\tthis._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n\t\tthis._decorationsCanvas.setPosition('absolute');\n\t\tthis._decorationsCanvas.setClassName('minimap-decorations-layer');\n\t\tthis._decorationsCanvas.setLeft(0);\n\t\tthis._domNode.appendChild(this._decorationsCanvas);\n\n\t\tthis._slider = createFastDomNode(document.createElement('div'));\n\t\tthis._slider.setPosition('absolute');\n\t\tthis._slider.setClassName('minimap-slider');\n\t\tthis._slider.setLayerHinting(true);\n\t\tthis._slider.setContain('strict');\n\t\tthis._domNode.appendChild(this._slider);\n\n\t\tthis._sliderHorizontal = createFastDomNode(document.createElement('div'));\n\t\tthis._sliderHorizontal.setPosition('absolute');\n\t\tthis._sliderHorizontal.setClassName('minimap-slider-horizontal');\n\t\tthis._slider.appendChild(this._sliderHorizontal);\n\n\t\tthis._applyLayout();\n\n\t\tthis._hideDelayedScheduler = this._register(new RunOnceScheduler(() => this._hideImmediatelyIfMouseIsOutside(), 500));\n\n\t\tthis._register(dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.MOUSE_OVER, () => {\n\t\t\tthis._isMouseOverMinimap = true;\n\t\t}));\n\t\tthis._register(dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.MOUSE_LEAVE, () => {\n\t\t\tthis._isMouseOverMinimap = false;\n\t\t}));\n\n\t\tthis._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n\t\t\te.preventDefault();\n\n\t\t\tconst isMouse = (e.pointerType === 'mouse');\n\t\t\tconst isLeftClick = (e.button === 0);\n\n\t\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\t\tif (renderMinimap === RenderMinimap.None) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this._lastRenderData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._model.options.size !== 'proportional') {\n\t\t\t\tif (isLeftClick && this._lastRenderData) {\n\t\t\t\t\t// pretend the click occurred in the center of the slider\n\t\t\t\t\tconst position = dom.getDomNodePagePosition(this._slider.domNode);\n\t\t\t\t\tconst initialPosY = position.top + position.height / 2;\n\t\t\t\t\tthis._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isLeftClick || !isMouse) {\n\t\t\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\t\t\tconst internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n\t\t\t\tconst lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n\n\t\t\t\tlet lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n\t\t\t\tlineNumber = Math.min(lineNumber, this._model.getLineCount());\n\n\t\t\t\tthis._model.revealLineNumber(lineNumber);\n\t\t\t}\n\t\t});\n\n\t\tthis._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n\n\t\tthis._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (e.button === 0 && this._lastRenderData) {\n\t\t\t\tthis._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n\t\t\t}\n\t\t});\n\n\t\tthis._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n\t\tthis._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (this._lastRenderData) {\n\t\t\t\tthis._slider.toggleClassName('active', true);\n\t\t\t\tthis._gestureInProgress = true;\n\t\t\t\tthis.scrollDueToTouchEvent(e);\n\t\t\t}\n\t\t}, { passive: false });\n\n\t\tthis._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tif (this._lastRenderData && this._gestureInProgress) {\n\t\t\t\tthis.scrollDueToTouchEvent(e);\n\t\t\t}\n\t\t}, { passive: false });\n\n\t\tthis._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e: GestureEvent) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis._gestureInProgress = false;\n\t\t\tthis._slider.toggleClassName('active', false);\n\t\t});\n\t}\n\n\tprivate _hideSoon() {\n\t\tthis._hideDelayedScheduler.cancel();\n\t\tthis._hideDelayedScheduler.schedule();\n\t}\n\n\tprivate _hideImmediatelyIfMouseIsOutside() {\n\t\tif (this._isMouseOverMinimap) {\n\t\t\tthis._hideSoon();\n\t\t\treturn;\n\t\t}\n\t\tthis._domNode.toggleClassName('active', false);\n\t}\n\n\tprivate _startSliderDragging(e: PointerEvent, initialPosY: number, initialSliderState: MinimapLayout): void {\n\t\tif (!e.target || !(e.target instanceof Element)) {\n\t\t\treturn;\n\t\t}\n\t\tconst initialPosX = e.pageX;\n\n\t\tthis._slider.toggleClassName('active', true);\n\n\t\tconst handlePointerMove = (posy: number, posx: number) => {\n\t\t\tconst minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n\t\t\tconst pointerOrthogonalDelta = Math.min(\n\t\t\t\tMath.abs(posx - initialPosX),\n\t\t\t\tMath.abs(posx - minimapPosition.left),\n\t\t\t\tMath.abs(posx - minimapPosition.left - minimapPosition.width)\n\t\t\t);\n\n\t\t\tif (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n\t\t\t\t// The pointer has wondered away from the scrollbar => reset dragging\n\t\t\t\tthis._model.setScrollTop(initialSliderState.scrollTop);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst pointerDelta = posy - initialPosY;\n\t\t\tthis._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n\t\t};\n\n\t\tif (e.pageY !== initialPosY) {\n\t\t\thandlePointerMove(e.pageY, initialPosX);\n\t\t}\n\n\t\tthis._sliderPointerMoveMonitor.startMonitoring(\n\t\t\te.target,\n\t\t\te.pointerId,\n\t\t\te.buttons,\n\t\t\tpointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX),\n\t\t\t() => {\n\t\t\t\tthis._slider.toggleClassName('active', false);\n\t\t\t}\n\t\t);\n\t}\n\n\tprivate scrollDueToTouchEvent(touch: GestureEvent) {\n\t\tconst startY = this._domNode.domNode.getBoundingClientRect().top;\n\t\tconst scrollTop = this._lastRenderData!.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n\t\tthis._model.setScrollTop(scrollTop);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._pointerDownListener.dispose();\n\t\tthis._sliderPointerMoveMonitor.dispose();\n\t\tthis._sliderPointerDownListener.dispose();\n\t\tthis._gestureDisposable.dispose();\n\t\tthis._sliderTouchStartListener.dispose();\n\t\tthis._sliderTouchMoveListener.dispose();\n\t\tthis._sliderTouchEndListener.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tprivate _getMinimapDomNodeClassName(): string {\n\t\tconst class_ = ['minimap'];\n\t\tif (this._model.options.showSlider === 'always') {\n\t\t\tclass_.push('slider-always');\n\t\t} else {\n\t\t\tclass_.push('slider-mouseover');\n\t\t}\n\n\t\tif (this._model.options.autohide === 'mouseover') {\n\t\t\tclass_.push('minimap-autohide-mouseover');\n\t\t} else if (this._model.options.autohide === 'scroll') {\n\t\t\tclass_.push('minimap-autohide-scroll');\n\t\t}\n\n\t\treturn class_.join(' ');\n\t}\n\n\tpublic getDomNode(): FastDomNode<HTMLElement> {\n\t\treturn this._domNode;\n\t}\n\n\tprivate _applyLayout(): void {\n\t\tthis._domNode.setLeft(this._model.options.minimapLeft);\n\t\tthis._domNode.setWidth(this._model.options.minimapWidth);\n\t\tthis._domNode.setHeight(this._model.options.minimapHeight);\n\t\tthis._shadow.setHeight(this._model.options.minimapHeight);\n\n\t\tthis._canvas.setWidth(this._model.options.canvasOuterWidth);\n\t\tthis._canvas.setHeight(this._model.options.canvasOuterHeight);\n\t\tthis._canvas.domNode.width = this._model.options.canvasInnerWidth;\n\t\tthis._canvas.domNode.height = this._model.options.canvasInnerHeight;\n\n\t\tthis._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n\t\tthis._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n\t\tthis._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n\t\tthis._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n\n\t\tthis._slider.setWidth(this._model.options.minimapWidth);\n\t}\n\n\tprivate _getBuffer(): ImageData | null {\n\t\tif (!this._buffers) {\n\t\t\tif (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n\t\t\t\tthis._buffers = new MinimapBuffers(\n\t\t\t\t\tthis._canvas.domNode.getContext('2d')!,\n\t\t\t\t\tthis._model.options.canvasInnerWidth,\n\t\t\t\t\tthis._model.options.canvasInnerHeight,\n\t\t\t\t\tthis._model.options.backgroundColor\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn this._buffers ? this._buffers.getBuffer() : null;\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onDidChangeOptions(): void {\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\tthis._applyLayout();\n\t\tthis._domNode.setClassName(this._getMinimapDomNodeClassName());\n\t}\n\tpublic onSelectionChanged(): boolean {\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onDecorationsChanged(): boolean {\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onFlushed(): boolean {\n\t\tthis._lastRenderData = null;\n\t\treturn true;\n\t}\n\tpublic onLinesChanged(changeFromLineNumber: number, changeCount: number): boolean {\n\t\tif (this._lastRenderData) {\n\t\t\treturn this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic onLinesDeleted(deleteFromLineNumber: number, deleteToLineNumber: number): boolean {\n\t\tthis._lastRenderData?.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n\t\treturn true;\n\t}\n\tpublic onLinesInserted(insertFromLineNumber: number, insertToLineNumber: number): boolean {\n\t\tthis._lastRenderData?.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n\t\treturn true;\n\t}\n\tpublic onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\tif (this._model.options.autohide === 'scroll' && (e.scrollTopChanged || e.scrollHeightChanged)) {\n\t\t\tthis._domNode.toggleClassName('active', true);\n\t\t\tthis._hideSoon();\n\t\t}\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onThemeChanged(): boolean {\n\t\tthis._selectionColor = this._theme.getColor(minimapSelection);\n\t\tthis._renderDecorations = true;\n\t\treturn true;\n\t}\n\tpublic onTokensChanged(ranges: { fromLineNumber: number; toLineNumber: number }[]): boolean {\n\t\tif (this._lastRenderData) {\n\t\t\treturn this._lastRenderData.onTokensChanged(ranges);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic onTokensColorsChanged(): boolean {\n\t\tthis._lastRenderData = null;\n\t\tthis._buffers = null;\n\t\treturn true;\n\t}\n\tpublic onZonesChanged(): boolean {\n\t\tthis._lastRenderData = null;\n\t\treturn true;\n\t}\n\n\t// --- end event handlers\n\n\tpublic render(renderingCtx: IMinimapRenderingContext): void {\n\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\tif (renderMinimap === RenderMinimap.None) {\n\t\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\t\tthis._sliderHorizontal.setWidth(0);\n\t\t\tthis._sliderHorizontal.setHeight(0);\n\t\t\treturn;\n\t\t}\n\t\tif (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n\t\t\tthis._shadow.setClassName('minimap-shadow-hidden');\n\t\t} else {\n\t\t\tthis._shadow.setClassName('minimap-shadow-visible');\n\t\t}\n\n\t\tconst layout = MinimapLayout.create(\n\t\t\tthis._model.options,\n\t\t\trenderingCtx.viewportStartLineNumber,\n\t\t\trenderingCtx.viewportEndLineNumber,\n\t\t\trenderingCtx.viewportStartLineNumberVerticalOffset,\n\t\t\trenderingCtx.viewportHeight,\n\t\t\trenderingCtx.viewportContainsWhitespaceGaps,\n\t\t\tthis._model.getLineCount(),\n\t\t\tthis._model.getRealLineCount(),\n\t\t\trenderingCtx.scrollTop,\n\t\t\trenderingCtx.scrollHeight,\n\t\t\tthis._lastRenderData ? this._lastRenderData.renderedLayout : null\n\t\t);\n\t\tthis._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n\t\tthis._slider.setTop(layout.sliderTop);\n\t\tthis._slider.setHeight(layout.sliderHeight);\n\n\t\t// Compute horizontal slider coordinates\n\t\tthis._sliderHorizontal.setLeft(0);\n\t\tthis._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n\t\tthis._sliderHorizontal.setTop(0);\n\t\tthis._sliderHorizontal.setHeight(layout.sliderHeight);\n\n\t\tthis.renderDecorations(layout);\n\t\tthis._lastRenderData = this.renderLines(layout);\n\t}\n\n\tprivate renderDecorations(layout: MinimapLayout) {\n\t\tif (this._renderDecorations) {\n\t\t\tthis._renderDecorations = false;\n\t\t\tconst selections = this._model.getSelections();\n\t\t\tselections.sort(Range.compareRangesUsingStarts);\n\n\t\t\tconst decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\t\t\tdecorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n\n\t\t\tconst { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n\t\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\t\tconst minimapCharWidth = this._model.options.minimapCharWidth;\n\t\t\tconst tabSize = this._model.getOptions().tabSize;\n\t\t\tconst canvasContext = this._decorationsCanvas.domNode.getContext('2d')!;\n\n\t\t\tcanvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n\n\t\t\t// We first need to render line highlights and then render decorations on top of those.\n\t\t\t// But we need to pick a single color for each line, and use that as a line highlight.\n\t\t\t// This needs to be the color of the decoration with the highest `zIndex`, but priority\n\t\t\t// is given to the selection.\n\n\t\t\tconst highlightedLines = new ContiguousLineMap<boolean>(layout.startLineNumber, layout.endLineNumber, false);\n\t\t\tthis._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n\t\t\tthis._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n\n\t\t\tconst lineOffsetMap = new ContiguousLineMap<number[] | null>(layout.startLineNumber, layout.endLineNumber, null);\n\t\t\tthis._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n\t\t\tthis._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n\t\t\tthis._renderSectionHeaders(layout);\n\t\t}\n\t}\n\n\tprivate _renderSelectionLineHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tselections: Selection[],\n\t\thighlightedLines: ContiguousLineMap<boolean>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number\n\t): void {\n\t\tif (!this._selectionColor || this._selectionColor.isTransparent()) {\n\t\t\treturn;\n\t\t}\n\n\t\tcanvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n\n\t\tlet y1 = 0;\n\t\tlet y2 = 0;\n\n\t\tfor (const selection of selections) {\n\t\t\tconst intersection = layout.intersectWithViewport(selection);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\thighlightedLines.set(line, true);\n\t\t\t}\n\n\t\t\tconst yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n\t\t\tconst yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n\n\t\t\tif (y2 >= yy1) {\n\t\t\t\t// merge into previous\n\t\t\t\ty2 = yy2;\n\t\t\t} else {\n\t\t\t\tif (y2 > y1) {\n\t\t\t\t\t// flush\n\t\t\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n\t\t\t\t}\n\t\t\t\ty1 = yy1;\n\t\t\t\ty2 = yy2;\n\t\t\t}\n\t\t}\n\n\t\tif (y2 > y1) {\n\t\t\t// flush\n\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n\t\t}\n\t}\n\n\tprivate _renderDecorationsLineHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tdecorations: ViewModelDecoration[],\n\t\thighlightedLines: ContiguousLineMap<boolean>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number\n\t): void {\n\n\t\tconst highlightColors = new Map<string, string>();\n\n\t\t// Loop backwards to hit first decorations with higher `zIndex`\n\t\tfor (let i = decorations.length - 1; i >= 0; i--) {\n\t\t\tconst decoration = decorations[i];\n\n\t\t\tconst minimapOptions = <ModelDecorationMinimapOptions | null | undefined>decoration.options.minimap;\n\t\t\tif (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst intersection = layout.intersectWithViewport(decoration.range);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tconst decorationColor = minimapOptions.getColor(this._theme.value);\n\t\t\tif (!decorationColor || decorationColor.isTransparent()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet highlightColor = highlightColors.get(decorationColor.toString());\n\t\t\tif (!highlightColor) {\n\t\t\t\thighlightColor = decorationColor.transparent(0.5).toString();\n\t\t\t\thighlightColors.set(decorationColor.toString(), highlightColor);\n\t\t\t}\n\n\t\t\tcanvasContext.fillStyle = highlightColor;\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tif (highlightedLines.has(line)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thighlightedLines.set(line, true);\n\t\t\t\tconst y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n\t\t\t\tcanvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _renderSelectionsHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tselections: Selection[],\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlayout: MinimapLayout,\n\t\tlineHeight: number,\n\t\ttabSize: number,\n\t\tcharacterWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\tif (!this._selectionColor || this._selectionColor.isTransparent()) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const selection of selections) {\n\t\t\tconst intersection = layout.intersectWithViewport(selection);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tthis.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _renderDecorationsHighlights(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tdecorations: ViewModelDecoration[],\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlayout: MinimapLayout,\n\t\tminimapLineHeight: number,\n\t\ttabSize: number,\n\t\tcharacterWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\t// Loop forwards to hit first decorations with lower `zIndex`\n\t\tfor (const decoration of decorations) {\n\n\t\t\tconst minimapOptions = <ModelDecorationMinimapOptions | null | undefined>decoration.options.minimap;\n\t\t\tif (!minimapOptions) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst intersection = layout.intersectWithViewport(decoration.range);\n\t\t\tif (!intersection) {\n\t\t\t\t// entirely outside minimap's viewport\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [startLineNumber, endLineNumber] = intersection;\n\n\t\t\tconst decorationColor = minimapOptions.getColor(this._theme.value);\n\t\t\tif (!decorationColor || decorationColor.isTransparent()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (let line = startLineNumber; line <= endLineNumber; line++) {\n\t\t\t\tswitch (minimapOptions.position) {\n\n\t\t\t\t\tcase MinimapPosition.Inline:\n\t\t\t\t\t\tthis.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase MinimapPosition.Gutter: {\n\t\t\t\t\t\tconst y = layout.getYForLineNumber(line, minimapLineHeight);\n\t\t\t\t\t\tconst x = 2;\n\t\t\t\t\t\tthis.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate renderDecorationOnLine(\n\t\tcanvasContext: CanvasRenderingContext2D,\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tdecorationRange: Range,\n\t\tdecorationColor: Color | undefined,\n\t\tlayout: MinimapLayout,\n\t\tlineNumber: number,\n\t\theight: number,\n\t\tminimapLineHeight: number,\n\t\ttabSize: number,\n\t\tcharWidth: number,\n\t\tcanvasInnerWidth: number\n\t): void {\n\t\tconst y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n\n\t\t// Skip rendering the line if it's vertically outside our viewport\n\t\tif (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { startLineNumber, endLineNumber } = decorationRange;\n\t\tconst startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n\t\tconst endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n\n\t\tconst x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n\t\tconst x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n\n\t\tthis.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n\t}\n\n\tprivate getXOffsetForPosition(\n\t\tlineOffsetMap: ContiguousLineMap<number[] | null>,\n\t\tlineNumber: number,\n\t\tcolumn: number,\n\t\ttabSize: number,\n\t\tcharWidth: number,\n\t\tcanvasInnerWidth: number\n\t): number {\n\t\tif (column === 1) {\n\t\t\treturn MINIMAP_GUTTER_WIDTH;\n\t\t}\n\n\t\tconst minimumXOffset = (column - 1) * charWidth;\n\t\tif (minimumXOffset >= canvasInnerWidth) {\n\t\t\t// there is no need to look at actual characters,\n\t\t\t// as this column is certainly after the minimap width\n\t\t\treturn canvasInnerWidth;\n\t\t}\n\n\t\t// Cache line offset data so that it is only read once per line\n\t\tlet lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n\t\tif (!lineIndexToXOffset) {\n\t\t\tconst lineData = this._model.getLineContent(lineNumber);\n\t\t\tlineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n\t\t\tlet prevx = MINIMAP_GUTTER_WIDTH;\n\t\t\tfor (let i = 1; i < lineData.length + 1; i++) {\n\t\t\t\tconst charCode = lineData.charCodeAt(i - 1);\n\t\t\t\tconst dx = charCode === CharCode.Tab\n\t\t\t\t\t? tabSize * charWidth\n\t\t\t\t\t: strings.isFullWidthCharacter(charCode)\n\t\t\t\t\t\t? 2 * charWidth\n\t\t\t\t\t\t: charWidth;\n\n\t\t\t\tconst x = prevx + dx;\n\t\t\t\tif (x >= canvasInnerWidth) {\n\t\t\t\t\t// no need to keep on going, as we've hit the canvas width\n\t\t\t\t\tlineIndexToXOffset[i] = canvasInnerWidth;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlineIndexToXOffset[i] = x;\n\t\t\t\tprevx = x;\n\t\t\t}\n\n\t\t\tlineOffsetMap.set(lineNumber, lineIndexToXOffset);\n\t\t}\n\n\t\tif (column - 1 < lineIndexToXOffset.length) {\n\t\t\treturn lineIndexToXOffset[column - 1];\n\t\t}\n\t\t// goes over the canvas width\n\t\treturn canvasInnerWidth;\n\t}\n\n\tprivate renderDecoration(canvasContext: CanvasRenderingContext2D, decorationColor: Color | undefined, x: number, y: number, width: number, height: number) {\n\t\tcanvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n\t\tcanvasContext.fillRect(x, y, width, height);\n\t}\n\n\tprivate _renderSectionHeaders(layout: MinimapLayout) {\n\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\t\tconst sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n\t\tconst sectionHeaderLetterSpacing = this._model.options.sectionHeaderLetterSpacing;\n\t\tconst backgroundFillHeight = sectionHeaderFontSize * 1.5;\n\t\tconst { canvasInnerWidth } = this._model.options;\n\n\t\tconst backgroundColor = this._model.options.backgroundColor;\n\t\tconst backgroundFill = `rgb(${backgroundColor.r} ${backgroundColor.g} ${backgroundColor.b} / .7)`;\n\t\tconst foregroundColor = this._model.options.sectionHeaderFontColor;\n\t\tconst foregroundFill = `rgb(${foregroundColor.r} ${foregroundColor.g} ${foregroundColor.b})`;\n\t\tconst separatorStroke = foregroundFill;\n\n\t\tconst canvasContext = this._decorationsCanvas.domNode.getContext('2d')!;\n\t\tcanvasContext.letterSpacing = sectionHeaderLetterSpacing + 'px';\n\t\tcanvasContext.font = '500 ' + sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n\t\tcanvasContext.strokeStyle = separatorStroke;\n\t\tcanvasContext.lineWidth = 0.4;\n\n\t\tconst decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\t\tdecorations.sort((a, b) => a.range.startLineNumber - b.range.startLineNumber);\n\n\t\tconst fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext,\n\t\t\tcanvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n\n\t\tfor (const decoration of decorations) {\n\t\t\tconst y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n\t\t\tconst backgroundFillY = y - sectionHeaderFontSize;\n\t\t\tconst separatorY = backgroundFillY + 2;\n\t\t\tconst headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n\n\t\t\tInnerMinimap._renderSectionLabel(\n\t\t\t\tcanvasContext,\n\t\t\t\theaderText,\n\t\t\t\tdecoration.options.minimap?.sectionHeaderStyle === MinimapSectionHeaderStyle.Underlined,\n\t\t\t\tbackgroundFill,\n\t\t\t\tforegroundFill,\n\t\t\t\tcanvasInnerWidth,\n\t\t\t\tbackgroundFillY,\n\t\t\t\tbackgroundFillHeight,\n\t\t\t\ty,\n\t\t\t\tseparatorY);\n\t\t}\n\t}\n\n\tprivate static _fitSectionHeader(\n\t\ttarget: CanvasRenderingContext2D,\n\t\tmaxWidth: number,\n\t\theaderText: string,\n\t): string {\n\t\tif (!headerText) {\n\t\t\treturn headerText;\n\t\t}\n\n\t\tconst ellipsis = '';\n\t\tconst width = target.measureText(headerText).width;\n\t\tconst ellipsisWidth = target.measureText(ellipsis).width;\n\n\t\tif (width <= maxWidth || width <= ellipsisWidth) {\n\t\t\treturn headerText;\n\t\t}\n\n\t\tconst len = headerText.length;\n\t\tconst averageCharWidth = width / headerText.length;\n\t\tconst maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n\n\t\t// Find a halfway point that isn't after whitespace\n\t\tlet halfCharCount = Math.ceil(maxCharCount / 2);\n\t\twhile (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n\t\t\t--halfCharCount;\n\t\t}\n\n\t\t// Split with ellipsis\n\t\treturn headerText.substring(0, halfCharCount)\n\t\t\t+ ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n\t}\n\n\tprivate static _renderSectionLabel(\n\t\ttarget: CanvasRenderingContext2D,\n\t\theaderText: string | null,\n\t\thasSeparatorLine: boolean,\n\t\tbackgroundFill: string,\n\t\tforegroundFill: string,\n\t\tminimapWidth: number,\n\t\tbackgroundFillY: number,\n\t\tbackgroundFillHeight: number,\n\t\ttextY: number,\n\t\tseparatorY: number\n\t): void {\n\t\tif (headerText) {\n\t\t\ttarget.fillStyle = backgroundFill;\n\t\t\ttarget.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n\n\t\t\ttarget.fillStyle = foregroundFill;\n\t\t\ttarget.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n\t\t}\n\n\t\tif (hasSeparatorLine) {\n\t\t\ttarget.beginPath();\n\t\t\ttarget.moveTo(0, separatorY);\n\t\t\ttarget.lineTo(minimapWidth, separatorY);\n\t\t\ttarget.closePath();\n\t\t\ttarget.stroke();\n\t\t}\n\t}\n\n\tprivate renderLines(layout: MinimapLayout): RenderData | null {\n\t\tconst startLineNumber = layout.startLineNumber;\n\t\tconst endLineNumber = layout.endLineNumber;\n\t\tconst minimapLineHeight = this._model.options.minimapLineHeight;\n\n\t\t// Check if nothing changed w.r.t. lines from last frame\n\t\tif (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n\t\t\tconst _lastData = this._lastRenderData._get();\n\t\t\t// Nice!! Nothing changed from last frame\n\t\t\treturn new RenderData(layout, _lastData.imageData, _lastData.lines);\n\t\t}\n\n\t\t// Oh well!! We need to repaint some lines...\n\n\t\tconst imageData = this._getBuffer();\n\t\tif (!imageData) {\n\t\t\t// 0 width or 0 height canvas, nothing to do\n\t\t\treturn null;\n\t\t}\n\n\t\t// Render untouched lines by using last rendered data.\n\t\tconst [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(\n\t\t\timageData,\n\t\t\tlayout.topPaddingLineCount,\n\t\t\tstartLineNumber,\n\t\t\tendLineNumber,\n\t\t\tminimapLineHeight,\n\t\t\tthis._lastRenderData\n\t\t);\n\n\t\t// Fetch rendering info from view model for rest of lines that need rendering.\n\t\tconst lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n\t\tconst tabSize = this._model.getOptions().tabSize;\n\t\tconst defaultBackground = this._model.options.defaultBackgroundColor;\n\t\tconst background = this._model.options.backgroundColor;\n\t\tconst foregroundAlpha = this._model.options.foregroundAlpha;\n\t\tconst tokensColorTracker = this._model.tokensColorTracker;\n\t\tconst useLighterFont = tokensColorTracker.backgroundIsLight();\n\t\tconst renderMinimap = this._model.options.renderMinimap;\n\t\tconst charRenderer = this._model.options.charRenderer();\n\t\tconst fontScale = this._model.options.fontScale;\n\t\tconst minimapCharWidth = this._model.options.minimapCharWidth;\n\n\t\tconst baseCharHeight = (renderMinimap === RenderMinimap.Text ? Constants.BASE_CHAR_HEIGHT : Constants.BASE_CHAR_HEIGHT + 1);\n\t\tconst renderMinimapLineHeight = baseCharHeight * fontScale;\n\t\tconst innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n\n\t\t// Render the rest of lines\n\t\tconst backgroundA = background.a / 255;\n\t\tconst renderBackground = new RGBA8(\n\t\t\tMath.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r),\n\t\t\tMath.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g),\n\t\t\tMath.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b),\n\t\t\t255\n\t\t);\n\t\tlet dy = layout.topPaddingLineCount * minimapLineHeight;\n\t\tconst renderedLines: MinimapLine[] = [];\n\t\tfor (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n\t\t\tif (needed[lineIndex]) {\n\t\t\t\tInnerMinimap._renderLine(\n\t\t\t\t\timageData,\n\t\t\t\t\trenderBackground,\n\t\t\t\t\tbackground.a,\n\t\t\t\t\tuseLighterFont,\n\t\t\t\t\trenderMinimap,\n\t\t\t\t\tminimapCharWidth,\n\t\t\t\t\ttokensColorTracker,\n\t\t\t\t\tforegroundAlpha,\n\t\t\t\t\tcharRenderer,\n\t\t\t\t\tdy,\n\t\t\t\t\tinnerLinePadding,\n\t\t\t\t\ttabSize,\n\t\t\t\t\tlineInfo[lineIndex]!,\n\t\t\t\t\tfontScale,\n\t\t\t\t\tminimapLineHeight\n\t\t\t\t);\n\t\t\t}\n\t\t\trenderedLines[lineIndex] = new MinimapLine(dy);\n\t\t\tdy += minimapLineHeight;\n\t\t}\n\n\t\tconst dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n\t\tconst dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n\t\tconst dirtyHeight = dirtyY2 - dirtyY1;\n\n\t\t// Finally, paint to the canvas\n\t\tconst ctx = this._canvas.domNode.getContext('2d')!;\n\t\tctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n\n\t\t// Save rendered data for reuse on next frame if possible\n\t\treturn new RenderData(\n\t\t\tlayout,\n\t\t\timageData,\n\t\t\trenderedLines\n\t\t);\n\t}\n\n\tprivate static _renderUntouchedLines(\n\t\ttarget: ImageData,\n\t\ttopPaddingLineCount: number,\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tminimapLineHeight: number,\n\t\tlastRenderData: RenderData | null,\n\t): [number, number, boolean[]] {\n\n\t\tconst needed: boolean[] = [];\n\t\tif (!lastRenderData) {\n\t\t\tfor (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n\t\t\t\tneeded[i] = true;\n\t\t\t}\n\t\t\treturn [-1, -1, needed];\n\t\t}\n\n\t\tconst _lastData = lastRenderData._get();\n\t\tconst lastTargetData = _lastData.imageData.data;\n\t\tconst lastStartLineNumber = _lastData.rendLineNumberStart;\n\t\tconst lastLines = _lastData.lines;\n\t\tconst lastLinesLength = lastLines.length;\n\t\tconst WIDTH = target.width;\n\t\tconst targetData = target.data;\n\n\t\tconst maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n\t\tlet dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n\t\tlet dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n\n\t\tlet copySourceStart = -1;\n\t\tlet copySourceEnd = -1;\n\t\tlet copyDestStart = -1;\n\t\tlet copyDestEnd = -1;\n\n\t\tlet dest_dy = topPaddingLineCount * minimapLineHeight;\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineIndex = lineNumber - startLineNumber;\n\t\t\tconst lastLineIndex = lineNumber - lastStartLineNumber;\n\t\t\tconst source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n\n\t\t\tif (source_dy === -1) {\n\t\t\t\tneeded[lineIndex] = true;\n\t\t\t\tdest_dy += minimapLineHeight;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst sourceStart = source_dy * WIDTH * 4;\n\t\t\tconst sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n\t\t\tconst destStart = dest_dy * WIDTH * 4;\n\t\t\tconst destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n\n\t\t\tif (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n\t\t\t\t// contiguous zone => extend copy request\n\t\t\t\tcopySourceEnd = sourceEnd;\n\t\t\t\tcopyDestEnd = destEnd;\n\t\t\t} else {\n\t\t\t\tif (copySourceStart !== -1) {\n\t\t\t\t\t// flush existing copy request\n\t\t\t\t\ttargetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\t\t\t\t\tif (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n\t\t\t\t\t\tdirtyPixel1 = copySourceEnd;\n\t\t\t\t\t}\n\t\t\t\t\tif (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n\t\t\t\t\t\tdirtyPixel2 = copySourceStart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopySourceStart = sourceStart;\n\t\t\t\tcopySourceEnd = sourceEnd;\n\t\t\t\tcopyDestStart = destStart;\n\t\t\t\tcopyDestEnd = destEnd;\n\t\t\t}\n\n\t\t\tneeded[lineIndex] = false;\n\t\t\tdest_dy += minimapLineHeight;\n\t\t}\n\n\t\tif (copySourceStart !== -1) {\n\t\t\t// flush existing copy request\n\t\t\ttargetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\t\t\tif (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n\t\t\t\tdirtyPixel1 = copySourceEnd;\n\t\t\t}\n\t\t\tif (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n\t\t\t\tdirtyPixel2 = copySourceStart;\n\t\t\t}\n\t\t}\n\n\t\tconst dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n\t\tconst dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n\n\t\treturn [dirtyY1, dirtyY2, needed];\n\t}\n\n\tprivate static _renderLine(\n\t\ttarget: ImageData,\n\t\tbackgroundColor: RGBA8,\n\t\tbackgroundAlpha: number,\n\t\tuseLighterFont: boolean,\n\t\trenderMinimap: RenderMinimap,\n\t\tcharWidth: number,\n\t\tcolorTracker: MinimapTokensColorTracker,\n\t\tforegroundAlpha: number,\n\t\tminimapCharRenderer: MinimapCharRenderer,\n\t\tdy: number,\n\t\tinnerLinePadding: number,\n\t\ttabSize: number,\n\t\tlineData: ViewLineData,\n\t\tfontScale: number,\n\t\tminimapLineHeight: number\n\t): void {\n\t\tconst content = lineData.content;\n\t\tconst tokens = lineData.tokens;\n\t\tconst maxDx = target.width - charWidth;\n\t\tconst force1pxHeight = (minimapLineHeight === 1);\n\n\t\tlet dx = MINIMAP_GUTTER_WIDTH;\n\t\tlet charIndex = 0;\n\t\tlet tabsCharDelta = 0;\n\n\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\tconst tokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\tconst tokenColorId = tokens.getForeground(tokenIndex);\n\t\t\tconst tokenColor = colorTracker.getColor(tokenColorId);\n\n\t\t\tfor (; charIndex < tokenEndIndex; charIndex++) {\n\t\t\t\tif (dx > maxDx) {\n\t\t\t\t\t// hit edge of minimap\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst charCode = content.charCodeAt(charIndex);\n\n\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\tconst insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\t// No need to render anything since tab is invisible\n\t\t\t\t\tdx += insertSpacesCount * charWidth;\n\t\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\t\t// No need to render anything since space is invisible\n\t\t\t\t\tdx += charWidth;\n\t\t\t\t} else {\n\t\t\t\t\t// Render twice for a full width character\n\t\t\t\t\tconst count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n\n\t\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\t\tif (renderMinimap === RenderMinimap.Blocks) {\n\t\t\t\t\t\t\tminimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n\t\t\t\t\t\t} else { // RenderMinimap.Text\n\t\t\t\t\t\t\tminimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdx += charWidth;\n\n\t\t\t\t\t\tif (dx > maxDx) {\n\t\t\t\t\t\t\t// hit edge of minimap\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ContiguousLineMap<T> {\n\n\tprivate readonly _startLineNumber: number;\n\tprivate readonly _endLineNumber: number;\n\tprivate readonly _defaultValue: T;\n\tprivate readonly _values: T[];\n\n\tconstructor(startLineNumber: number, endLineNumber: number, defaultValue: T) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._endLineNumber = endLineNumber;\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._values = [];\n\t\tfor (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n\t\t\tthis._values[i] = defaultValue;\n\t\t}\n\t}\n\n\tpublic has(lineNumber: number): boolean {\n\t\treturn (this.get(lineNumber) !== this._defaultValue);\n\t}\n\n\tpublic set(lineNumber: number, value: T): void {\n\t\tif (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n\t\t\treturn;\n\t\t}\n\t\tthis._values[lineNumber - this._startLineNumber] = value;\n\t}\n\n\tpublic get(lineNumber: number): T {\n\t\tif (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n\t\t\treturn this._defaultValue;\n\t\t}\n\t\treturn this._values[lineNumber - this._startLineNumber];\n\t}\n}\n\n"]}