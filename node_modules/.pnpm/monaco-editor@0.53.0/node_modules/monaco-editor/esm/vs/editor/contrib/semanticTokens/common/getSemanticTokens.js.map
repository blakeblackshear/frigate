{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/semanticTokens/common/getSemanticTokens.ts","vs/editor/contrib/semanticTokens/common/getSemanticTokens.ts"],"names":[],"mappings":"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","file":"getSemanticTokens.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { DocumentSemanticTokensProvider, SemanticTokens, SemanticTokensEdits, SemanticTokensLegend, DocumentRangeSemanticTokensProvider } from '../../../common/languages.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\n\nexport function isSemanticTokens(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokens {\n\treturn v && !!((<SemanticTokens>v).data);\n}\n\nexport function isSemanticTokensEdits(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokensEdits {\n\treturn v && Array.isArray((<SemanticTokensEdits>v).edits);\n}\n\nexport class DocumentSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | SemanticTokensEdits | null,\n\t\tpublic readonly error: any\n\t) { }\n}\n\nexport function hasDocumentSemanticTokensProvider(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn registry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] {\n\tconst groups = registry.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentSemanticTokens(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel, lastProvider: DocumentSemanticTokensProvider | null, lastResultId: string | null, token: CancellationToken): Promise<DocumentSemanticTokensResult | null> {\n\tconst providers = getDocumentSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | SemanticTokensEdits | null | undefined;\n\t\tlet error: unknown = null;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentSemanticTokensResult(provider, result, error);\n\t}));\n\n\t// Try to return the first result with actual tokens or\n\t// the first result which threw an error (!!)\n\tfor (const result of results) {\n\t\tif (result.error) {\n\t\t\tthrow result.error;\n\t\t}\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] | null {\n\tconst result = registry.orderedGroups(model);\n\treturn (result.length > 0 ? result[0] : null);\n}\n\nclass DocumentRangeSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentRangeSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | null,\n\t) { }\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn providers.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): DocumentRangeSemanticTokensProvider[] {\n\tconst groups = providers.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentRangeSemanticTokens(registry: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel, range: Range, token: CancellationToken): Promise<DocumentRangeSemanticTokensResult | null> {\n\tconst providers = getDocumentRangeSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | null | undefined;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || !isSemanticTokens(result)) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentRangeSemanticTokensResult(provider, result);\n\t}));\n\n\t// Try to return the first result with actual tokens\n\tfor (const result of results) {\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n\tif (!providers) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n\t}\n\n\treturn providers[0].getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tif (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n\t}\n\n\tconst r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n\tif (!r) {\n\t\treturn undefined;\n\t}\n\n\tconst { provider, tokens } = r;\n\n\tif (!tokens || !isSemanticTokens(tokens)) {\n\t\treturn undefined;\n\t}\n\n\tconst buff = encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: tokens.data\n\t});\n\tif (tokens.resultId) {\n\t\tprovider.releaseDocumentSemanticTokens(tokens.resultId);\n\t}\n\treturn buff;\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tconst providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n\tif (providers.length === 0) {\n\t\t// no providers\n\t\treturn undefined;\n\t}\n\n\tif (providers.length === 1) {\n\t\t// straight forward case, just a single provider\n\t\treturn providers[0].getLegend();\n\t}\n\n\tif (!range || !Range.isIRange(range)) {\n\t\t// if no range is provided, we cannot support multiple providers\n\t\t// as we cannot fall back to the one which would give results\n\t\t// => return the first legend for backwards compatibility and print a warning\n\t\tconsole.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n\t\treturn providers[0].getLegend();\n\t}\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result) {\n\t\treturn undefined;\n\t}\n\n\treturn result.provider.getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\tassertType(Range.isIRange(range));\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result || !result.tokens) {\n\t\t// there is no provider or it didn't return tokens\n\t\treturn undefined;\n\t}\n\n\treturn encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: result.tokens.data\n\t});\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { ITextModel } from '../../../common/model.js';\nimport { DocumentSemanticTokensProvider, SemanticTokens, SemanticTokensEdits, SemanticTokensLegend, DocumentRangeSemanticTokensProvider } from '../../../common/languages.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\n\nexport function isSemanticTokens(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokens {\n\treturn v && !!((<SemanticTokens>v).data);\n}\n\nexport function isSemanticTokensEdits(v: SemanticTokens | SemanticTokensEdits): v is SemanticTokensEdits {\n\treturn v && Array.isArray((<SemanticTokensEdits>v).edits);\n}\n\nexport class DocumentSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | SemanticTokensEdits | null,\n\t\tpublic readonly error: any\n\t) { }\n}\n\nexport function hasDocumentSemanticTokensProvider(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn registry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] {\n\tconst groups = registry.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentSemanticTokens(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel, lastProvider: DocumentSemanticTokensProvider | null, lastResultId: string | null, token: CancellationToken): Promise<DocumentSemanticTokensResult | null> {\n\tconst providers = getDocumentSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | SemanticTokensEdits | null | undefined;\n\t\tlet error: unknown = null;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentSemanticTokensResult(provider, result, error);\n\t}));\n\n\t// Try to return the first result with actual tokens or\n\t// the first result which threw an error (!!)\n\tfor (const result of results) {\n\t\tif (result.error) {\n\t\t\tthrow result.error;\n\t\t}\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry: LanguageFeatureRegistry<DocumentSemanticTokensProvider>, model: ITextModel): DocumentSemanticTokensProvider[] | null {\n\tconst result = registry.orderedGroups(model);\n\treturn (result.length > 0 ? result[0] : null);\n}\n\nclass DocumentRangeSemanticTokensResult {\n\tconstructor(\n\t\tpublic readonly provider: DocumentRangeSemanticTokensProvider,\n\t\tpublic readonly tokens: SemanticTokens | null,\n\t) { }\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): boolean {\n\treturn providers.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(providers: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel): DocumentRangeSemanticTokensProvider[] {\n\tconst groups = providers.orderedGroups(model);\n\treturn (groups.length > 0 ? groups[0] : []);\n}\n\nexport async function getDocumentRangeSemanticTokens(registry: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>, model: ITextModel, range: Range, token: CancellationToken): Promise<DocumentRangeSemanticTokensResult | null> {\n\tconst providers = getDocumentRangeSemanticTokensProviders(registry, model);\n\n\t// Get tokens from all providers at the same time.\n\tconst results = await Promise.all(providers.map(async (provider) => {\n\t\tlet result: SemanticTokens | null | undefined;\n\t\ttry {\n\t\t\tresult = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n\t\t} catch (err) {\n\t\t\tonUnexpectedExternalError(err);\n\t\t\tresult = null;\n\t\t}\n\n\t\tif (!result || !isSemanticTokens(result)) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn new DocumentRangeSemanticTokensResult(provider, result);\n\t}));\n\n\t// Try to return the first result with actual tokens\n\tfor (const result of results) {\n\t\tif (result.tokens) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Return the first result, even if it doesn't have tokens\n\tif (results.length > 0) {\n\t\treturn results[0];\n\t}\n\n\treturn null;\n}\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n\tif (!providers) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n\t}\n\n\treturn providers[0].getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tif (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n\t\t// there is no provider => fall back to a document range semantic tokens provider\n\t\treturn accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n\t}\n\n\tconst r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n\tif (!r) {\n\t\treturn undefined;\n\t}\n\n\tconst { provider, tokens } = r;\n\n\tif (!tokens || !isSemanticTokens(tokens)) {\n\t\treturn undefined;\n\t}\n\n\tconst buff = encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: tokens.data\n\t});\n\tif (tokens.resultId) {\n\t\tprovider.releaseDocumentSemanticTokens(tokens.resultId);\n\t}\n\treturn buff;\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args): Promise<SemanticTokensLegend | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\tconst providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n\tif (providers.length === 0) {\n\t\t// no providers\n\t\treturn undefined;\n\t}\n\n\tif (providers.length === 1) {\n\t\t// straight forward case, just a single provider\n\t\treturn providers[0].getLegend();\n\t}\n\n\tif (!range || !Range.isIRange(range)) {\n\t\t// if no range is provided, we cannot support multiple providers\n\t\t// as we cannot fall back to the one which would give results\n\t\t// => return the first legend for backwards compatibility and print a warning\n\t\tconsole.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n\t\treturn providers[0].getLegend();\n\t}\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result) {\n\t\treturn undefined;\n\t}\n\n\treturn result.provider.getLegend();\n});\n\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args): Promise<VSBuffer | undefined> => {\n\tconst [uri, range] = args;\n\tassertType(uri instanceof URI);\n\tassertType(Range.isIRange(range));\n\n\tconst model = accessor.get(IModelService).getModel(uri);\n\tif (!model) {\n\t\treturn undefined;\n\t}\n\tconst { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n\n\tconst result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n\tif (!result || !result.tokens) {\n\t\t// there is no provider or it didn't return tokens\n\t\treturn undefined;\n\t}\n\n\treturn encodeSemanticTokensDto({\n\t\tid: 0,\n\t\ttype: 'full',\n\t\tdata: result.tokens.data\n\t});\n});\n"]}