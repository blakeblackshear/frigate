{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/taskQueue.ts","vs/editor/browser/gpu/taskQueue.ts"],"names":[],"mappings":"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","file":"taskQueue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\n\n/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport interface ITaskQueue extends IDisposable {\n\n\t/**\n\t * Clears any remaining tasks from the queue, these will not be run.\n\t */\n\tclear(): void;\n}\n\ninterface ITaskDeadline {\n\ttimeRemaining(): number;\n}\ntype CallbackWithDeadline = (deadline: ITaskDeadline) => void;\n\nabstract class TaskQueue extends Disposable implements ITaskQueue {\n\tprivate _tasks: (() => boolean | void)[] = [];\n\tprivate _idleCallback?: number;\n\tprivate _i = 0;\n\n\tconstructor(\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this.clear()));\n\t}\n\n\tprotected abstract _requestCallback(callback: CallbackWithDeadline): number;\n\tprotected abstract _cancelCallback(identifier: number): void;\n\n\tpublic enqueue(task: () => boolean | void): void {\n\t\tthis._tasks.push(task);\n\t\tthis._start();\n\t}\n\n\tpublic clear(): void {\n\t\tif (this._idleCallback) {\n\t\t\tthis._cancelCallback(this._idleCallback);\n\t\t\tthis._idleCallback = undefined;\n\t\t}\n\t\tthis._i = 0;\n\t\tthis._tasks.length = 0;\n\t}\n\n\tprivate _start(): void {\n\t\tif (!this._idleCallback) {\n\t\t\tthis._idleCallback = this._requestCallback(this._process.bind(this));\n\t\t}\n\t}\n\n\tprivate _process(deadline: ITaskDeadline): void {\n\t\tthis._idleCallback = undefined;\n\t\tlet taskDuration = 0;\n\t\tlet longestTask = 0;\n\t\tlet lastDeadlineRemaining = deadline.timeRemaining();\n\t\tlet deadlineRemaining = 0;\n\t\twhile (this._i < this._tasks.length) {\n\t\t\ttaskDuration = Date.now();\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t\t// other than performance.now, Date.now might not be stable (changes on wall clock changes),\n\t\t\t// this is not an issue here as a clock change during a short running task is very unlikely\n\t\t\t// in case it still happened and leads to negative duration, simply assume 1 msec\n\t\t\ttaskDuration = Math.max(1, Date.now() - taskDuration);\n\t\t\tlongestTask = Math.max(taskDuration, longestTask);\n\t\t\t// Guess the following task will take a similar time to the longest task in this batch, allow\n\t\t\t// additional room to try avoid exceeding the deadline\n\t\t\tdeadlineRemaining = deadline.timeRemaining();\n\t\t\tif (longestTask * 1.5 > deadlineRemaining) {\n\t\t\t\t// Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n\t\t\t\t// task should be split into sub-tasks to ensure the UI remains responsive.\n\t\t\t\tif (lastDeadlineRemaining - taskDuration < -20) {\n\t\t\t\t\tthis._logService.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n\t\t\t\t}\n\t\t\t\tthis._start();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastDeadlineRemaining = deadlineRemaining;\n\t\t}\n\t\tthis.clear();\n\t}\n}\n\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nexport class PriorityTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: CallbackWithDeadline): number {\n\t\treturn getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().clearTimeout(identifier);\n\t}\n\n\tprivate _createDeadline(duration: number): ITaskDeadline {\n\t\tconst end = Date.now() + duration;\n\t\treturn {\n\t\t\ttimeRemaining: () => Math.max(0, end - Date.now())\n\t\t};\n\t}\n}\n\nclass IdleTaskQueueInternal extends TaskQueue {\n\tprotected _requestCallback(callback: IdleRequestCallback): number {\n\t\treturn getActiveWindow().requestIdleCallback(callback);\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().cancelIdleCallback(identifier);\n\t}\n}\n\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n *\n * This reverts to a {@link PriorityTaskQueue} if the environment does not support idle callbacks.\n */\nexport const IdleTaskQueue = ('requestIdleCallback' in getActiveWindow()) ? IdleTaskQueueInternal : PriorityTaskQueue;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\n\n/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport interface ITaskQueue extends IDisposable {\n\n\t/**\n\t * Clears any remaining tasks from the queue, these will not be run.\n\t */\n\tclear(): void;\n}\n\ninterface ITaskDeadline {\n\ttimeRemaining(): number;\n}\ntype CallbackWithDeadline = (deadline: ITaskDeadline) => void;\n\nabstract class TaskQueue extends Disposable implements ITaskQueue {\n\tprivate _tasks: (() => boolean | void)[] = [];\n\tprivate _idleCallback?: number;\n\tprivate _i = 0;\n\n\tconstructor(\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this.clear()));\n\t}\n\n\tprotected abstract _requestCallback(callback: CallbackWithDeadline): number;\n\tprotected abstract _cancelCallback(identifier: number): void;\n\n\tpublic enqueue(task: () => boolean | void): void {\n\t\tthis._tasks.push(task);\n\t\tthis._start();\n\t}\n\n\tpublic clear(): void {\n\t\tif (this._idleCallback) {\n\t\t\tthis._cancelCallback(this._idleCallback);\n\t\t\tthis._idleCallback = undefined;\n\t\t}\n\t\tthis._i = 0;\n\t\tthis._tasks.length = 0;\n\t}\n\n\tprivate _start(): void {\n\t\tif (!this._idleCallback) {\n\t\t\tthis._idleCallback = this._requestCallback(this._process.bind(this));\n\t\t}\n\t}\n\n\tprivate _process(deadline: ITaskDeadline): void {\n\t\tthis._idleCallback = undefined;\n\t\tlet taskDuration = 0;\n\t\tlet longestTask = 0;\n\t\tlet lastDeadlineRemaining = deadline.timeRemaining();\n\t\tlet deadlineRemaining = 0;\n\t\twhile (this._i < this._tasks.length) {\n\t\t\ttaskDuration = Date.now();\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t\t// other than performance.now, Date.now might not be stable (changes on wall clock changes),\n\t\t\t// this is not an issue here as a clock change during a short running task is very unlikely\n\t\t\t// in case it still happened and leads to negative duration, simply assume 1 msec\n\t\t\ttaskDuration = Math.max(1, Date.now() - taskDuration);\n\t\t\tlongestTask = Math.max(taskDuration, longestTask);\n\t\t\t// Guess the following task will take a similar time to the longest task in this batch, allow\n\t\t\t// additional room to try avoid exceeding the deadline\n\t\t\tdeadlineRemaining = deadline.timeRemaining();\n\t\t\tif (longestTask * 1.5 > deadlineRemaining) {\n\t\t\t\t// Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n\t\t\t\t// task should be split into sub-tasks to ensure the UI remains responsive.\n\t\t\t\tif (lastDeadlineRemaining - taskDuration < -20) {\n\t\t\t\t\tthis._logService.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n\t\t\t\t}\n\t\t\t\tthis._start();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastDeadlineRemaining = deadlineRemaining;\n\t\t}\n\t\tthis.clear();\n\t}\n}\n\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nexport class PriorityTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: CallbackWithDeadline): number {\n\t\treturn getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().clearTimeout(identifier);\n\t}\n\n\tprivate _createDeadline(duration: number): ITaskDeadline {\n\t\tconst end = Date.now() + duration;\n\t\treturn {\n\t\t\ttimeRemaining: () => Math.max(0, end - Date.now())\n\t\t};\n\t}\n}\n\nclass IdleTaskQueueInternal extends TaskQueue {\n\tprotected _requestCallback(callback: IdleRequestCallback): number {\n\t\treturn getActiveWindow().requestIdleCallback(callback);\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().cancelIdleCallback(identifier);\n\t}\n}\n\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n *\n * This reverts to a {@link PriorityTaskQueue} if the environment does not support idle callbacks.\n */\nexport const IdleTaskQueue = ('requestIdleCallback' in getActiveWindow()) ? IdleTaskQueueInternal : PriorityTaskQueue;\n"]}