{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/standalone/common/monarch/monarchTypes.ts","vs/editor/standalone/common/monarch/monarchTypes.ts"],"names":[],"mappings":"AAAA;;;gGAGgG","file":"monarchTypes.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * Interface types for Monarch language definitions\n * These descriptions are really supposed to be JSON values but if using typescript\n * to describe them, these type definitions can help check the validity.\n */\n\n/**\n * A Monarch language definition\n */\nexport interface IMonarchLanguage {\n\t/**\n\t * map from string to ILanguageRule[]\n\t */\n\ttokenizer: { [name: string]: IMonarchLanguageRule[] };\n\t/**\n\t * is the language case insensitive?\n\t */\n\tignoreCase?: boolean;\n\t/**\n\t * is the language unicode-aware? (i.e., /\\u{1D306}/)\n\t */\n\tunicode?: boolean;\n\t/**\n\t * if no match in the tokenizer assign this token class (default 'source')\n\t */\n\tdefaultToken?: string;\n\t/**\n\t * for example [['{','}','delimiter.curly']]\n\t */\n\tbrackets?: IMonarchLanguageBracket[];\n\t/**\n\t * start symbol in the tokenizer (by default the first entry is used)\n\t */\n\tstart?: string;\n\t/**\n\t * attach this to every token class (by default '.' + name)\n\t */\n\ttokenPostfix?: string;\n\t/**\n\t * include line feeds (in the form of a \\n character) at the end of lines\n\t * Defaults to false\n\t */\n\tincludeLF?: boolean;\n\t/**\n\t * Other keys that can be referred to by the tokenizer.\n\t */\n\t[key: string]: any;\n}\n\n/**\n * A rule is either a regular expression and an action\n * \t\tshorthands: [reg,act] == { regex: reg, action: act}\n *\t\tand       : [reg,act,nxt] == { regex: reg, action: act{ next: nxt }}\n */\nexport type IShortMonarchLanguageRule1 = [string | RegExp, IMonarchLanguageAction];\n\nexport type IShortMonarchLanguageRule2 = [string | RegExp, IMonarchLanguageAction, string];\n\nexport interface IExpandedMonarchLanguageRule {\n\t/**\n\t * match tokens\n\t */\n\tregex?: string | RegExp;\n\t/**\n\t * action to take on match\n\t */\n\taction?: IMonarchLanguageAction;\n\n\t/**\n\t * or an include rule. include all rules from the included state\n\t */\n\tinclude?: string;\n}\n\nexport type IMonarchLanguageRule = IShortMonarchLanguageRule1\n\t| IShortMonarchLanguageRule2\n\t| IExpandedMonarchLanguageRule;\n\n/**\n * An action is either an array of actions...\n * ... or a case statement with guards...\n * ... or a basic action with a token value.\n */\nexport type IShortMonarchLanguageAction = string;\n\nexport interface IExpandedMonarchLanguageAction {\n\t/**\n\t * array of actions for each parenthesized match group\n\t */\n\tgroup?: IMonarchLanguageAction[];\n\t/**\n\t * map from string to ILanguageAction\n\t */\n\tcases?: Object;\n\t/**\n\t * token class (ie. css class) (or \"@brackets\" or \"@rematch\")\n\t */\n\ttoken?: string;\n\t/**\n\t * the next state to push, or \"@push\", \"@pop\", \"@popall\"\n\t */\n\tnext?: string;\n\t/**\n\t * switch to this state\n\t */\n\tswitchTo?: string;\n\t/**\n\t * go back n characters in the stream\n\t */\n\tgoBack?: number;\n\t/**\n\t * @open or @close\n\t */\n\tbracket?: string;\n\t/**\n\t * switch to embedded language (using the mimetype) or get out using \"@pop\"\n\t */\n\tnextEmbedded?: string;\n\t/**\n\t * log a message to the browser console window\n\t */\n\tlog?: string;\n}\n\nexport type IMonarchLanguageAction = IShortMonarchLanguageAction | IExpandedMonarchLanguageAction | (IShortMonarchLanguageAction | IExpandedMonarchLanguageAction)[];\n\n/**\n * This interface can be shortened as an array, ie. ['{','}','delimiter.curly']\n */\nexport interface IMonarchLanguageBracket {\n\t/**\n\t * open bracket\n\t */\n\topen: string;\n\t/**\n\t * closing bracket\n\t */\n\tclose: string;\n\t/**\n\t * token class\n\t */\n\ttoken: string;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * Interface types for Monarch language definitions\n * These descriptions are really supposed to be JSON values but if using typescript\n * to describe them, these type definitions can help check the validity.\n */\n\n/**\n * A Monarch language definition\n */\nexport interface IMonarchLanguage {\n\t/**\n\t * map from string to ILanguageRule[]\n\t */\n\ttokenizer: { [name: string]: IMonarchLanguageRule[] };\n\t/**\n\t * is the language case insensitive?\n\t */\n\tignoreCase?: boolean;\n\t/**\n\t * is the language unicode-aware? (i.e., /\\u{1D306}/)\n\t */\n\tunicode?: boolean;\n\t/**\n\t * if no match in the tokenizer assign this token class (default 'source')\n\t */\n\tdefaultToken?: string;\n\t/**\n\t * for example [['{','}','delimiter.curly']]\n\t */\n\tbrackets?: IMonarchLanguageBracket[];\n\t/**\n\t * start symbol in the tokenizer (by default the first entry is used)\n\t */\n\tstart?: string;\n\t/**\n\t * attach this to every token class (by default '.' + name)\n\t */\n\ttokenPostfix?: string;\n\t/**\n\t * include line feeds (in the form of a \\n character) at the end of lines\n\t * Defaults to false\n\t */\n\tincludeLF?: boolean;\n\t/**\n\t * Other keys that can be referred to by the tokenizer.\n\t */\n\t[key: string]: any;\n}\n\n/**\n * A rule is either a regular expression and an action\n * \t\tshorthands: [reg,act] == { regex: reg, action: act}\n *\t\tand       : [reg,act,nxt] == { regex: reg, action: act{ next: nxt }}\n */\nexport type IShortMonarchLanguageRule1 = [string | RegExp, IMonarchLanguageAction];\n\nexport type IShortMonarchLanguageRule2 = [string | RegExp, IMonarchLanguageAction, string];\n\nexport interface IExpandedMonarchLanguageRule {\n\t/**\n\t * match tokens\n\t */\n\tregex?: string | RegExp;\n\t/**\n\t * action to take on match\n\t */\n\taction?: IMonarchLanguageAction;\n\n\t/**\n\t * or an include rule. include all rules from the included state\n\t */\n\tinclude?: string;\n}\n\nexport type IMonarchLanguageRule = IShortMonarchLanguageRule1\n\t| IShortMonarchLanguageRule2\n\t| IExpandedMonarchLanguageRule;\n\n/**\n * An action is either an array of actions...\n * ... or a case statement with guards...\n * ... or a basic action with a token value.\n */\nexport type IShortMonarchLanguageAction = string;\n\nexport interface IExpandedMonarchLanguageAction {\n\t/**\n\t * array of actions for each parenthesized match group\n\t */\n\tgroup?: IMonarchLanguageAction[];\n\t/**\n\t * map from string to ILanguageAction\n\t */\n\tcases?: Object;\n\t/**\n\t * token class (ie. css class) (or \"@brackets\" or \"@rematch\")\n\t */\n\ttoken?: string;\n\t/**\n\t * the next state to push, or \"@push\", \"@pop\", \"@popall\"\n\t */\n\tnext?: string;\n\t/**\n\t * switch to this state\n\t */\n\tswitchTo?: string;\n\t/**\n\t * go back n characters in the stream\n\t */\n\tgoBack?: number;\n\t/**\n\t * @open or @close\n\t */\n\tbracket?: string;\n\t/**\n\t * switch to embedded language (using the mimetype) or get out using \"@pop\"\n\t */\n\tnextEmbedded?: string;\n\t/**\n\t * log a message to the browser console window\n\t */\n\tlog?: string;\n}\n\nexport type IMonarchLanguageAction = IShortMonarchLanguageAction | IExpandedMonarchLanguageAction | (IShortMonarchLanguageAction | IExpandedMonarchLanguageAction)[];\n\n/**\n * This interface can be shortened as an array, ie. ['{','}','delimiter.curly']\n */\nexport interface IMonarchLanguageBracket {\n\t/**\n\t * open bracket\n\t */\n\topen: string;\n\t/**\n\t * closing bracket\n\t */\n\tclose: string;\n\t/**\n\t * token class\n\t */\n\ttoken: string;\n}\n"]}