{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/tokens/sparseMultilineTokens.ts","vs/editor/common/tokens/sparseMultilineTokens.ts"],"names":[],"mappings":"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","file":"sparseMultilineTokens.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { ITextModel } from '../model.js';\nimport { RateLimiter } from './common.js';\n\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n\n\tpublic static create(startLineNumber: number, tokens: Uint32Array): SparseMultilineTokens {\n\t\treturn new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n\t}\n\n\tprivate _startLineNumber: number;\n\tprivate _endLineNumber: number;\n\tprivate readonly _tokens: SparseMultilineTokensStorage;\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._endLineNumber;\n\t}\n\n\tprivate constructor(startLineNumber: number, tokens: SparseMultilineTokensStorage) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._tokens.toString(this._startLineNumber);\n\t}\n\n\tprivate _updateEndLineNumber(): void {\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._tokens.isEmpty();\n\t}\n\n\tpublic getLineTokens(lineNumber: number): SparseLineTokens | null {\n\t\tif (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n\t\t\treturn this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst deltaRange = this._tokens.getRange();\n\t\tif (!deltaRange) {\n\t\t\treturn deltaRange;\n\t\t}\n\t\treturn new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n\t}\n\n\tpublic removeTokens(range: Range): void {\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tthis._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tpublic split(range: Range): [SparseMultilineTokens, SparseMultilineTokens] {\n\t\t// split tokens to two:\n\t\t// a) all the tokens before `range`\n\t\t// b) all the tokens after `range`\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tconst [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\treturn [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tthis.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : CharCode.Null);\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (firstLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0) {\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\tthis._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n\t\t} else {\n\t\t\tthis._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (lineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t}\n\n\tpublic reportIfInvalid(model: ITextModel): void {\n\t\tthis._tokens.reportIfInvalid(model, this._startLineNumber);\n\t}\n}\n\nclass SparseMultilineTokensStorage {\n\t/**\n\t * The encoding of tokens is:\n\t *  4*i    deltaLine (from `startLineNumber`)\n\t *  4*i+1  startCharacter (from the line start)\n\t *  4*i+2  endCharacter (from the line start)\n\t *  4*i+3  metadata\n\t */\n\tprivate readonly _tokens: Uint32Array;\n\tprivate _tokenCount: number;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokenCount = tokens.length / 4;\n\t}\n\n\tpublic toString(startLineNumber: number): string {\n\t\tconst pieces: string[] = [];\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tpieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n\t\t}\n\t\treturn `[${pieces.join(',')}]`;\n\t}\n\n\tpublic getMaxDeltaLine(): number {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this._getDeltaLine(tokenCount - 1);\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startChar = this._getStartCharacter(0);\n\t\tconst maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\t\tconst endChar = this._getEndCharacter(tokenCount - 1);\n\t\treturn new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n\t}\n\n\tprivate _getTokenCount(): number {\n\t\treturn this._tokenCount;\n\t}\n\n\tprivate _getDeltaLine(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex];\n\t}\n\n\tprivate _getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tprivate _getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._getTokenCount() === 0);\n\t}\n\n\tpublic getLineTokens(deltaLine: number): SparseLineTokens | null {\n\t\tlet low = 0;\n\t\tlet high = this._getTokenCount() - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst midDeltaLine = this._getDeltaLine(mid);\n\n\t\t\tif (midDeltaLine < deltaLine) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midDeltaLine > deltaLine) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlet min = mid;\n\t\t\t\twhile (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n\t\t\t\t\tmin--;\n\t\t\t\t}\n\t\t\t\tlet max = mid;\n\t\t\t\twhile (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n\t\t\t}\n\t\t}\n\n\t\tif (this._getDeltaLine(low) === deltaLine) {\n\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic clear(): void {\n\t\tthis._tokenCount = 0;\n\t}\n\n\tpublic removeTokens(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): number {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tlet firstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\t(tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n\t\t\t\t&& (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))\n\t\t\t) {\n\t\t\t\thasDeletedTokens = true;\n\t\t\t} else {\n\t\t\t\tif (newTokenCount === 0) {\n\t\t\t\t\tfirstDeltaLine = tokenDeltaLine;\n\t\t\t\t}\n\t\t\t\tif (hasDeletedTokens) {\n\t\t\t\t\t// must move the token to the left\n\t\t\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\t\t\ttokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n\t\t\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\t\t}\n\t\t\t\tnewTokenCount++;\n\t\t\t}\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\n\t\treturn firstDeltaLine;\n\t}\n\n\tpublic split(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): [SparseMultilineTokensStorage, SparseMultilineTokensStorage, number] {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst aTokens: number[] = [];\n\t\tconst bTokens: number[] = [];\n\t\tlet destTokens: number[] = aTokens;\n\t\tlet destOffset = 0;\n\t\tlet destFirstDeltaLine: number = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n\t\t\t\tif ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n\t\t\t\t\t// this token is touching the range\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// this token is after the range\n\t\t\t\t\tif (destTokens !== bTokens) {\n\t\t\t\t\t\t// this token is the first token after the range\n\t\t\t\t\t\tdestTokens = bTokens;\n\t\t\t\t\t\tdestOffset = 0;\n\t\t\t\t\t\tdestFirstDeltaLine = tokenDeltaLine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n\t\t\tdestTokens[destOffset++] = tokenStartCharacter;\n\t\t\tdestTokens[destOffset++] = tokenEndCharacter;\n\t\t\tdestTokens[destOffset++] = tokenMetadata;\n\t\t}\n\n\t\treturn [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n\t}\n\n\tpublic acceptDeleteRange(horizontalShiftForFirstLineTokens: number, startDeltaLine: number, startCharacter: number, endDeltaLine: number, endCharacter: number): void {\n\t\t// This is a bit complex, here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token starts before the deletion range\n\t\t// 1a. The token is completely before the deletion range\n\t\t//               -----------\n\t\t//                          xxxxxxxxxxx\n\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t//               -----------\n\t\t//                      xxxxxxxxxxx\n\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t//               ---------------\n\t\t//                      xxxxxxxx\n\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t//               ---------------\n\t\t//                    xxxxx\n\t\t//\n\t\t// 2. The token starts at the same position with the deletion range\n\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t//               -------\n\t\t//               xxxxxxxxxxx\n\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t//               ----------\n\t\t//               xxxxxxxxxx\n\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t//               -------------\n\t\t//               xxxxxxx\n\t\t//\n\t\t// 3. The token starts inside the deletion range\n\t\t// 3a. The token is inside the deletion range\n\t\t//                -------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t//                ----------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t//                ------------\n\t\t//             xxxxxxxxxxx\n\t\t//\n\t\t// 4. The token starts after the deletion range\n\t\t//                  -----------\n\t\t//          xxxxxxxx\n\t\t//\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst deletedLineCount = (endDeltaLine - startDeltaLine);\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[srcOffset];\n\t\t\tlet tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tlet tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n\t\t\t\t// 1a. The token is completely before the deletion range\n\t\t\t\t// => nothing to do\n\t\t\t\tnewTokenCount++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n\t\t\t\t// 1b, 1c, 1d\n\t\t\t\t// => the token survives, but it needs to shrink\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t\t\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t\t\t\t// => the token shrinks its ending to the deletion start\n\t\t\t\t\ttokenEndCharacter = startCharacter;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n\t\t\t\t// 2a, 2b, 2c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t\t\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n\t\t\t\t// 3a, 3b, 3c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t\t\t\t// => the token moves to continue right after the deletion\n\t\t\t\t\ttokenDeltaLine = startDeltaLine;\n\t\t\t\t\ttokenStartCharacter = startCharacter;\n\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 3a. The token is inside the deletion range\n\t\t\t\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine > endDeltaLine) {\n\t\t\t\t// 4. (partial) The token starts after the deletion range, on a line below...\n\t\t\t\tif (deletedLineCount === 0 && !hasDeletedTokens) {\n\t\t\t\t\t// early stop, there is no need to walk all the tokens and do nothing...\n\t\t\t\t\tnewTokenCount = tokenCount;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t} else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n\t\t\t\t// 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n\t\t\t\tif (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n\t\t\t\t\ttokenStartCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t\ttokenEndCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t\ttokenStartCharacter -= (endCharacter - startCharacter);\n\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Not possible!`);\n\t\t\t}\n\n\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\ttokens[destOffset] = tokenDeltaLine;\n\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\tnewTokenCount++;\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\t}\n\n\tpublic acceptInsertText(deltaLine: number, character: number, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\t// Here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token is completely before the insertion point\n\t\t//            -----------   |\n\t\t// 2. The token ends precisely at the insertion point\n\t\t//            -----------|\n\t\t// 3. The token contains the insertion point\n\t\t//            -----|------\n\t\t// 4. The token starts precisely at the insertion point\n\t\t//            |-----------\n\t\t// 5. The token is completely after the insertion point\n\t\t//            |   -----------\n\t\t//\n\t\tconst isInsertingPreciselyOneWordCharacter = (\n\t\t\teolCount === 0\n\t\t\t&& firstLineLength === 1\n\t\t\t&& (\n\t\t\t\t(firstCharCode >= CharCode.Digit0 && firstCharCode <= CharCode.Digit9)\n\t\t\t\t|| (firstCharCode >= CharCode.A && firstCharCode <= CharCode.Z)\n\t\t\t\t|| (firstCharCode >= CharCode.a && firstCharCode <= CharCode.z)\n\t\t\t)\n\t\t);\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst offset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[offset];\n\t\t\tlet tokenStartCharacter = tokens[offset + 1];\n\t\t\tlet tokenEndCharacter = tokens[offset + 2];\n\n\t\t\tif (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n\t\t\t\t// 1. The token is completely before the insertion point\n\t\t\t\t// => nothing to do\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n\t\t\t\t// 2. The token ends precisely at the insertion point\n\t\t\t\t// => expand the end character only if inserting precisely one character that is a word character\n\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\ttokenEndCharacter += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n\t\t\t\t// 3. The token contains the insertion point\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t// => just expand the end character\n\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t} else {\n\t\t\t\t\t// => cut off the token\n\t\t\t\t\ttokenEndCharacter = character;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 4. or 5.\n\t\t\t\tif (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n\t\t\t\t\t// 4. The token starts precisely at the insertion point\n\t\t\t\t\t// => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n\t\t\t\t\t// => otherwise behave as in case 5.\n\t\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// => the token must move and keep its size constant\n\t\t\t\tif (tokenDeltaLine === deltaLine) {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t\t// this token is on the line where the insertion is taking place\n\t\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t\ttokenStartCharacter += firstLineLength;\n\t\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst tokenLength = tokenEndCharacter - tokenStartCharacter;\n\t\t\t\t\t\ttokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + tokenLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokens[offset] = tokenDeltaLine;\n\t\t\ttokens[offset + 1] = tokenStartCharacter;\n\t\t\ttokens[offset + 2] = tokenEndCharacter;\n\t\t}\n\t}\n\n\tprivate static _rateLimiter = new RateLimiter(10 / 60); // limit to 10 times per minute\n\n\tpublic reportIfInvalid(model: ITextModel, startLineNumber: number): void {\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tconst lineNumber = this._getDeltaLine(i) + startLineNumber;\n\n\t\t\tif (lineNumber < 1) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: lineNumber < 1');\n\t\t\t\t});\n\t\t\t} else if (lineNumber > model.getLineCount()) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: lineNumber > model.getLineCount()');\n\t\t\t\t});\n\t\t\t} else if (this._getEndCharacter(i) > model.getLineLength(lineNumber)) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: end character > model.getLineLength(lineNumber)');\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class SparseLineTokens {\n\n\tprivate readonly _tokens: Uint32Array;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokens.length / 4;\n\t}\n\n\tpublic getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tpublic getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 3];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { ITextModel } from '../model.js';\nimport { RateLimiter } from './common.js';\n\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n\n\tpublic static create(startLineNumber: number, tokens: Uint32Array): SparseMultilineTokens {\n\t\treturn new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n\t}\n\n\tprivate _startLineNumber: number;\n\tprivate _endLineNumber: number;\n\tprivate readonly _tokens: SparseMultilineTokensStorage;\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._endLineNumber;\n\t}\n\n\tprivate constructor(startLineNumber: number, tokens: SparseMultilineTokensStorage) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._tokens.toString(this._startLineNumber);\n\t}\n\n\tprivate _updateEndLineNumber(): void {\n\t\tthis._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this._tokens.isEmpty();\n\t}\n\n\tpublic getLineTokens(lineNumber: number): SparseLineTokens | null {\n\t\tif (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n\t\t\treturn this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst deltaRange = this._tokens.getRange();\n\t\tif (!deltaRange) {\n\t\t\treturn deltaRange;\n\t\t}\n\t\treturn new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n\t}\n\n\tpublic removeTokens(range: Range): void {\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tthis._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tpublic split(range: Range): [SparseMultilineTokens, SparseMultilineTokens] {\n\t\t// split tokens to two:\n\t\t// a) all the tokens before `range`\n\t\t// b) all the tokens after `range`\n\t\tconst startLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tconst [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\treturn [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tthis.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : CharCode.Null);\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (firstLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0) {\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\tthis._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n\t\t} else {\n\t\t\tthis._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n\t\tif (lineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t}\n\n\tpublic reportIfInvalid(model: ITextModel): void {\n\t\tthis._tokens.reportIfInvalid(model, this._startLineNumber);\n\t}\n}\n\nclass SparseMultilineTokensStorage {\n\t/**\n\t * The encoding of tokens is:\n\t *  4*i    deltaLine (from `startLineNumber`)\n\t *  4*i+1  startCharacter (from the line start)\n\t *  4*i+2  endCharacter (from the line start)\n\t *  4*i+3  metadata\n\t */\n\tprivate readonly _tokens: Uint32Array;\n\tprivate _tokenCount: number;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokenCount = tokens.length / 4;\n\t}\n\n\tpublic toString(startLineNumber: number): string {\n\t\tconst pieces: string[] = [];\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tpieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n\t\t}\n\t\treturn `[${pieces.join(',')}]`;\n\t}\n\n\tpublic getMaxDeltaLine(): number {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this._getDeltaLine(tokenCount - 1);\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startChar = this._getStartCharacter(0);\n\t\tconst maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\t\tconst endChar = this._getEndCharacter(tokenCount - 1);\n\t\treturn new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n\t}\n\n\tprivate _getTokenCount(): number {\n\t\treturn this._tokenCount;\n\t}\n\n\tprivate _getDeltaLine(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex];\n\t}\n\n\tprivate _getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tprivate _getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._getTokenCount() === 0);\n\t}\n\n\tpublic getLineTokens(deltaLine: number): SparseLineTokens | null {\n\t\tlet low = 0;\n\t\tlet high = this._getTokenCount() - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst midDeltaLine = this._getDeltaLine(mid);\n\n\t\t\tif (midDeltaLine < deltaLine) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midDeltaLine > deltaLine) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlet min = mid;\n\t\t\t\twhile (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n\t\t\t\t\tmin--;\n\t\t\t\t}\n\t\t\t\tlet max = mid;\n\t\t\t\twhile (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n\t\t\t}\n\t\t}\n\n\t\tif (this._getDeltaLine(low) === deltaLine) {\n\t\t\treturn new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic clear(): void {\n\t\tthis._tokenCount = 0;\n\t}\n\n\tpublic removeTokens(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): number {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tlet firstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\t(tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n\t\t\t\t&& (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))\n\t\t\t) {\n\t\t\t\thasDeletedTokens = true;\n\t\t\t} else {\n\t\t\t\tif (newTokenCount === 0) {\n\t\t\t\t\tfirstDeltaLine = tokenDeltaLine;\n\t\t\t\t}\n\t\t\t\tif (hasDeletedTokens) {\n\t\t\t\t\t// must move the token to the left\n\t\t\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\t\t\ttokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n\t\t\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\t\t}\n\t\t\t\tnewTokenCount++;\n\t\t\t}\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\n\t\treturn firstDeltaLine;\n\t}\n\n\tpublic split(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): [SparseMultilineTokensStorage, SparseMultilineTokensStorage, number] {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst aTokens: number[] = [];\n\t\tconst bTokens: number[] = [];\n\t\tlet destTokens: number[] = aTokens;\n\t\tlet destOffset = 0;\n\t\tlet destFirstDeltaLine: number = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n\t\t\t\tif ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n\t\t\t\t\t// this token is touching the range\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// this token is after the range\n\t\t\t\t\tif (destTokens !== bTokens) {\n\t\t\t\t\t\t// this token is the first token after the range\n\t\t\t\t\t\tdestTokens = bTokens;\n\t\t\t\t\t\tdestOffset = 0;\n\t\t\t\t\t\tdestFirstDeltaLine = tokenDeltaLine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n\t\t\tdestTokens[destOffset++] = tokenStartCharacter;\n\t\t\tdestTokens[destOffset++] = tokenEndCharacter;\n\t\t\tdestTokens[destOffset++] = tokenMetadata;\n\t\t}\n\n\t\treturn [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n\t}\n\n\tpublic acceptDeleteRange(horizontalShiftForFirstLineTokens: number, startDeltaLine: number, startCharacter: number, endDeltaLine: number, endCharacter: number): void {\n\t\t// This is a bit complex, here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token starts before the deletion range\n\t\t// 1a. The token is completely before the deletion range\n\t\t//               -----------\n\t\t//                          xxxxxxxxxxx\n\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t//               -----------\n\t\t//                      xxxxxxxxxxx\n\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t//               ---------------\n\t\t//                      xxxxxxxx\n\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t//               ---------------\n\t\t//                    xxxxx\n\t\t//\n\t\t// 2. The token starts at the same position with the deletion range\n\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t//               -------\n\t\t//               xxxxxxxxxxx\n\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t//               ----------\n\t\t//               xxxxxxxxxx\n\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t//               -------------\n\t\t//               xxxxxxx\n\t\t//\n\t\t// 3. The token starts inside the deletion range\n\t\t// 3a. The token is inside the deletion range\n\t\t//                -------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t//                ----------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t//                ------------\n\t\t//             xxxxxxxxxxx\n\t\t//\n\t\t// 4. The token starts after the deletion range\n\t\t//                  -----------\n\t\t//          xxxxxxxx\n\t\t//\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst deletedLineCount = (endDeltaLine - startDeltaLine);\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[srcOffset];\n\t\t\tlet tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tlet tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n\t\t\t\t// 1a. The token is completely before the deletion range\n\t\t\t\t// => nothing to do\n\t\t\t\tnewTokenCount++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n\t\t\t\t// 1b, 1c, 1d\n\t\t\t\t// => the token survives, but it needs to shrink\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t\t\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t\t\t\t// => the token shrinks its ending to the deletion start\n\t\t\t\t\ttokenEndCharacter = startCharacter;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n\t\t\t\t// 2a, 2b, 2c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t\t\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n\t\t\t\t// 3a, 3b, 3c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t\t\t\t// => the token moves to continue right after the deletion\n\t\t\t\t\ttokenDeltaLine = startDeltaLine;\n\t\t\t\t\ttokenStartCharacter = startCharacter;\n\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 3a. The token is inside the deletion range\n\t\t\t\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine > endDeltaLine) {\n\t\t\t\t// 4. (partial) The token starts after the deletion range, on a line below...\n\t\t\t\tif (deletedLineCount === 0 && !hasDeletedTokens) {\n\t\t\t\t\t// early stop, there is no need to walk all the tokens and do nothing...\n\t\t\t\t\tnewTokenCount = tokenCount;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t} else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n\t\t\t\t// 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n\t\t\t\tif (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n\t\t\t\t\ttokenStartCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t\ttokenEndCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t\ttokenStartCharacter -= (endCharacter - startCharacter);\n\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Not possible!`);\n\t\t\t}\n\n\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\ttokens[destOffset] = tokenDeltaLine;\n\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\tnewTokenCount++;\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\t}\n\n\tpublic acceptInsertText(deltaLine: number, character: number, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\t// Here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token is completely before the insertion point\n\t\t//            -----------   |\n\t\t// 2. The token ends precisely at the insertion point\n\t\t//            -----------|\n\t\t// 3. The token contains the insertion point\n\t\t//            -----|------\n\t\t// 4. The token starts precisely at the insertion point\n\t\t//            |-----------\n\t\t// 5. The token is completely after the insertion point\n\t\t//            |   -----------\n\t\t//\n\t\tconst isInsertingPreciselyOneWordCharacter = (\n\t\t\teolCount === 0\n\t\t\t&& firstLineLength === 1\n\t\t\t&& (\n\t\t\t\t(firstCharCode >= CharCode.Digit0 && firstCharCode <= CharCode.Digit9)\n\t\t\t\t|| (firstCharCode >= CharCode.A && firstCharCode <= CharCode.Z)\n\t\t\t\t|| (firstCharCode >= CharCode.a && firstCharCode <= CharCode.z)\n\t\t\t)\n\t\t);\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst offset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[offset];\n\t\t\tlet tokenStartCharacter = tokens[offset + 1];\n\t\t\tlet tokenEndCharacter = tokens[offset + 2];\n\n\t\t\tif (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n\t\t\t\t// 1. The token is completely before the insertion point\n\t\t\t\t// => nothing to do\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n\t\t\t\t// 2. The token ends precisely at the insertion point\n\t\t\t\t// => expand the end character only if inserting precisely one character that is a word character\n\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\ttokenEndCharacter += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n\t\t\t\t// 3. The token contains the insertion point\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t// => just expand the end character\n\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t} else {\n\t\t\t\t\t// => cut off the token\n\t\t\t\t\ttokenEndCharacter = character;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 4. or 5.\n\t\t\t\tif (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n\t\t\t\t\t// 4. The token starts precisely at the insertion point\n\t\t\t\t\t// => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n\t\t\t\t\t// => otherwise behave as in case 5.\n\t\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// => the token must move and keep its size constant\n\t\t\t\tif (tokenDeltaLine === deltaLine) {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t\t// this token is on the line where the insertion is taking place\n\t\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t\ttokenStartCharacter += firstLineLength;\n\t\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst tokenLength = tokenEndCharacter - tokenStartCharacter;\n\t\t\t\t\t\ttokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + tokenLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokens[offset] = tokenDeltaLine;\n\t\t\ttokens[offset + 1] = tokenStartCharacter;\n\t\t\ttokens[offset + 2] = tokenEndCharacter;\n\t\t}\n\t}\n\n\tprivate static _rateLimiter = new RateLimiter(10 / 60); // limit to 10 times per minute\n\n\tpublic reportIfInvalid(model: ITextModel, startLineNumber: number): void {\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tconst lineNumber = this._getDeltaLine(i) + startLineNumber;\n\n\t\t\tif (lineNumber < 1) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: lineNumber < 1');\n\t\t\t\t});\n\t\t\t} else if (lineNumber > model.getLineCount()) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: lineNumber > model.getLineCount()');\n\t\t\t\t});\n\t\t\t} else if (this._getEndCharacter(i) > model.getLineLength(lineNumber)) {\n\t\t\t\tSparseMultilineTokensStorage._rateLimiter.runIfNotLimited(() => {\n\t\t\t\t\tconsole.error('Invalid Semantic Tokens Data From Extension: end character > model.getLineLength(lineNumber)');\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class SparseLineTokens {\n\n\tprivate readonly _tokens: Uint32Array;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokens.length / 4;\n\t}\n\n\tpublic getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tpublic getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 3];\n\t}\n}\n"]}