{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/fixedArray.ts","vs/editor/common/model/fixedArray.ts"],"names":[],"mappings":"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","file":"fixedArray.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n"]}