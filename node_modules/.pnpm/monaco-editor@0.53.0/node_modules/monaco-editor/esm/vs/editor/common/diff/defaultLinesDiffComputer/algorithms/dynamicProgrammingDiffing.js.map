{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts","vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts"],"names":[],"mappings":"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","file":"dynamicProgrammingDiffing.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n"]}