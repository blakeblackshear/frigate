{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/languages/supports/richEditBrackets.ts","vs/editor/common/languages/supports/richEditBrackets.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,KAAK,OAAO,MAAM,oCAAoC,CAAC;AAC9D,OAAO,KAAK,aAAa,MAAM,6BAA6B,CAAC;AAC7D,OAAO,EAAE,KAAK,EAAE,MAAM,qBAAqB,CAAC;AAQ5C;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,eAAe;IAiD3B,YAAY,UAAkB,EAAE,KAAa,EAAE,IAAc,EAAE,KAAe,EAAE,YAAoB,EAAE,aAAqB;QAhD3H,0BAAqB,GAAS,SAAS,CAAC;QAiDvC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,CAAC,SAAS,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACrD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,IAAY;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,IAAY;QAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC;IAEO,MAAM,CAAC,MAAM,CAAC,GAAa;QAClC,MAAM,MAAM,GAAG,IAAI,GAAG,EAAU,CAAC;QACjC,KAAK,MAAM,OAAO,IAAI,GAAG,EAAE,CAAC;YAC3B,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACrB,CAAC;QACD,OAAO,MAAM,CAAC;IACf,CAAC;CACD;AAED;;;;;;;;;;;;GAYG;AACH,SAAS,kBAAkB,CAAC,QAAkC;IAC7D,MAAM,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC;IAE1B,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAEvE,MAAM,KAAK,GAAa,EAAE,CAAC;IAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACd,CAAC;IAED,MAAM,cAAc,GAAG,CAAC,CAAgB,EAAE,CAAgB,EAAE,EAAE;QAC7D,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;QAC1B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;QAC1B,OAAO,CAAC,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,MAAM,CAAC,CAAC;IACvF,CAAC,CAAC;IAEF,MAAM,WAAW,GAAG,CAAC,EAAU,EAAE,EAAU,EAAE,EAAE;QAC9C,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5B,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;gBACvB,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACjB,CAAC;QACF,CAAC;IACF,CAAC,CAAC;IAEF,6EAA6E;IAC7E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACtB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAChC,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;gBAC1B,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACjC,CAAC;QACF,CAAC;IACF,CAAC;IAED,MAAM,MAAM,GAAsB,EAAE,CAAC;IACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,MAAM,WAAW,GAAa,EAAE,CAAC;QACjC,MAAM,YAAY,GAAa,EAAE,CAAC;QAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5B,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;gBACpB,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC1B,CAAC;QACF,CAAC;QACD,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC;gBACX,IAAI,EAAE,WAAW;gBACjB,KAAK,EAAE,YAAY;aACnB,CAAC,CAAC;QACJ,CAAC;IACF,CAAC;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAED,MAAM,OAAO,gBAAgB;IAgC5B,YAAY,UAAkB,EAAE,SAAmC;QA/BnE,2BAAsB,GAAS,SAAS,CAAC;QAgCxC,MAAM,QAAQ,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;QAE/C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;YACzC,OAAO,IAAI,eAAe,CACzB,UAAU,EACV,KAAK,EACL,CAAC,CAAC,IAAI,EACN,CAAC,CAAC,KAAK,EACP,sBAAsB,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,CAAC,EACxD,8BAA8B,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,CAAC,CAChE,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,GAAG,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,CAAC,aAAa,GAAG,2BAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEhE,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAE5B,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC1B,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;gBACjC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;gBACnC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;gBACpC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YACtE,CAAC;YACD,KAAK,MAAM,KAAK,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;gBACnC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC;gBACpC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;gBACtC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YACvE,CAAC;QACF,CAAC;IACF,CAAC;CACD;AAED,SAAS,mBAAmB,CAAC,GAAW,EAAE,QAA2B,EAAE,YAAoB,EAAE,IAAc;IAC1G,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;QACrD,IAAI,CAAC,KAAK,YAAY,EAAE,CAAC;YACxB,SAAS;QACV,CAAC;QACD,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC5B,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;YACjC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACjB,CAAC;QACF,CAAC;QACD,KAAK,MAAM,KAAK,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACnC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC7B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClB,CAAC;QACF,CAAC;IACF,CAAC;AACF,CAAC;AAED,SAAS,SAAS,CAAC,CAAS,EAAE,CAAS;IACtC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AAC5B,CAAC;AAED,SAAS,MAAM,CAAC,GAAa;IAC5B,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;QACrB,OAAO,GAAG,CAAC;IACZ,CAAC;IACD,MAAM,MAAM,GAAa,EAAE,CAAC;IAC5B,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;IAC/B,KAAK,MAAM,OAAO,IAAI,GAAG,EAAE,CAAC;QAC3B,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;YACvB,SAAS;QACV,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACnB,CAAC;IACD,OAAO,MAAM,CAAC;AACf,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,SAAS,sBAAsB,CAAC,IAAc,EAAE,KAAe,EAAE,QAA2B,EAAE,YAAoB;IACjH,qFAAqF;IACrF,IAAI,MAAM,GAAa,EAAE,CAAC;IAC1B,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7B,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;QACnD,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,CAAC,CAAC;IAChE,CAAC;IACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;IACxB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACvB,MAAM,CAAC,OAAO,EAAE,CAAC;IACjB,OAAO,qBAAqB,CAAC,MAAM,CAAC,CAAC;AACtC,CAAC;AAED;;;;;;;;;GASG;AACH,SAAS,8BAA8B,CAAC,IAAc,EAAE,KAAe,EAAE,QAA2B,EAAE,YAAoB;IACzH,qFAAqF;IACrF,IAAI,MAAM,GAAa,EAAE,CAAC;IAC1B,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7B,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;QACnD,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,CAAC,CAAC;IAChE,CAAC;IACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;IACxB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACvB,MAAM,CAAC,OAAO,EAAE,CAAC;IACjB,OAAO,qBAAqB,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC;AAC5D,CAAC;AAED;;;;;;;;;GASG;AACH,SAAS,mBAAmB,CAAC,QAA2B;IACvD,IAAI,MAAM,GAAa,EAAE,CAAC;IAC1B,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;QAChC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;YACjC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnB,CAAC;QACD,KAAK,MAAM,KAAK,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACnC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;IACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;IACxB,OAAO,qBAAqB,CAAC,MAAM,CAAC,CAAC;AACtC,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAS,2BAA2B,CAAC,QAA2B;IAC/D,IAAI,MAAM,GAAa,EAAE,CAAC;IAC1B,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;QAChC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;YACjC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnB,CAAC;QACD,KAAK,MAAM,KAAK,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACnC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;IACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;IACxB,OAAO,qBAAqB,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC;AAC5D,CAAC;AAED,SAAS,uBAAuB,CAAC,GAAW;IAC3C,2DAA2D;IAC3D,MAAM,oBAAoB,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACpD,GAAG,GAAG,OAAO,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC;IAC1C,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AACtD,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAC,MAAgB,EAAE,OAA+B;IACtF,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;IACxE,OAAO,OAAO,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AACtD,CAAC;AAED,MAAM,gBAAgB,GAAG,CAAC;IAEzB,SAAS,OAAO,CAAC,GAAW;QAC3B,qEAAqE;QACrE,MAAM,GAAG,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACnC,CAAC;QACD,OAAO,aAAa,CAAC,sBAAsB,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC3D,CAAC;IAED,IAAI,SAAS,GAAkB,IAAI,CAAC;IACpC,IAAI,UAAU,GAAkB,IAAI,CAAC;IACrC,OAAO,SAAS,gBAAgB,CAAC,GAAW;QAC3C,IAAI,SAAS,KAAK,GAAG,EAAE,CAAC;YACvB,SAAS,GAAG,GAAG,CAAC;YAChB,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;QACjC,CAAC;QACD,OAAO,UAAW,CAAC;IACpB,CAAC,CAAC;AACH,CAAC,CAAC,EAAE,CAAC;AAEL,MAAM,OAAO,aAAa;IAEjB,MAAM,CAAC,sBAAsB,CAAC,oBAA4B,EAAE,UAAkB,EAAE,YAAoB,EAAE,MAAc;QAC3H,MAAM,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;QAEnD,IAAI,CAAC,CAAC,EAAE,CAAC;YACR,OAAO,IAAI,CAAC;QACb,CAAC;QAED,MAAM,WAAW,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;QACzD,MAAM,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAChC,MAAM,mBAAmB,GAAG,MAAM,GAAG,WAAW,CAAC;QAEjD,OAAO,IAAI,KAAK,CAAC,UAAU,EAAE,mBAAmB,GAAG,WAAW,GAAG,CAAC,EAAE,UAAU,EAAE,mBAAmB,GAAG,CAAC,CAAC,CAAC;IAC1G,CAAC;IAEM,MAAM,CAAC,sBAAsB,CAAC,oBAA4B,EAAE,UAAkB,EAAE,QAAgB,EAAE,WAAmB,EAAE,SAAiB;QAC9I,uHAAuH;QACvH,MAAM,gBAAgB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACpD,MAAM,cAAc,GAAG,gBAAgB,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,GAAG,SAAS,EAAE,QAAQ,CAAC,MAAM,GAAG,WAAW,CAAC,CAAC;QAC9G,OAAO,IAAI,CAAC,sBAAsB,CAAC,oBAAoB,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;IACnG,CAAC;IAEM,MAAM,CAAC,qBAAqB,CAAC,YAAoB,EAAE,UAAkB,EAAE,IAAY,EAAE,MAAc;QACzG,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QAEnC,IAAI,CAAC,CAAC,EAAE,CAAC;YACR,OAAO,IAAI,CAAC;QACb,CAAC;QAED,MAAM,WAAW,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;QACjC,MAAM,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAChC,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,MAAM,mBAAmB,GAAG,MAAM,GAAG,WAAW,CAAC;QAEjD,OAAO,IAAI,KAAK,CAAC,UAAU,EAAE,mBAAmB,GAAG,CAAC,EAAE,UAAU,EAAE,mBAAmB,GAAG,CAAC,GAAG,WAAW,CAAC,CAAC;IAC1G,CAAC;IAEM,MAAM,CAAC,sBAAsB,CAAC,YAAoB,EAAE,UAAkB,EAAE,QAAgB,EAAE,WAAmB,EAAE,SAAiB;QACtI,MAAM,MAAM,GAAG,QAAQ,CAAC,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC,qBAAqB,CAAC,YAAY,EAAE,UAAU,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;IAClF,CAAC;CACD","file":"richEditBrackets.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\nimport { CharacterPair } from '../languageConfiguration.js';\n\ninterface InternalBracket {\n\topen: string[];\n\tclose: string[];\n}\n\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n\t_richEditBracketBrand: void = undefined;\n\n\treadonly languageId: string;\n\t/**\n\t * A 0-based consecutive unique identifier for this bracket pair.\n\t * If a language has 5 bracket pairs, out of which 2 are grouped together,\n\t * it is expected that the `index` goes from 0 to 4.\n\t */\n\treadonly index: number;\n\t/**\n\t * The open sequence for each bracket pair contained in this group.\n\t *\n\t * The open sequence at a specific index corresponds to the\n\t * closing sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly open: string[];\n\t/**\n\t * The close sequence for each bracket pair contained in this group.\n\t *\n\t * The close sequence at a specific index corresponds to the\n\t * opening sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly close: string[];\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine details in `getRegexForBracketPair`.\n\t */\n\treadonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string backwards.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine defails in `getReversedRegexForBracketPair`.\n\t */\n\treadonly reversedRegex: RegExp;\n\tprivate readonly _openSet: Set<string>;\n\tprivate readonly _closeSet: Set<string>;\n\n\tconstructor(languageId: string, index: number, open: string[], close: string[], forwardRegex: RegExp, reversedRegex: RegExp) {\n\t\tthis.languageId = languageId;\n\t\tthis.index = index;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\t\tthis.forwardRegex = forwardRegex;\n\t\tthis.reversedRegex = reversedRegex;\n\t\tthis._openSet = RichEditBracket._toSet(this.open);\n\t\tthis._closeSet = RichEditBracket._toSet(this.close);\n\t}\n\n\t/**\n\t * Check if the provided `text` is an open bracket in this group.\n\t */\n\tpublic isOpen(text: string) {\n\t\treturn this._openSet.has(text);\n\t}\n\n\t/**\n\t * Check if the provided `text` is a close bracket in this group.\n\t */\n\tpublic isClose(text: string) {\n\t\treturn this._closeSet.has(text);\n\t}\n\n\tprivate static _toSet(arr: string[]): Set<string> {\n\t\tconst result = new Set<string>();\n\t\tfor (const element of arr) {\n\t\t\tresult.add(element);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets: readonly CharacterPair[]): InternalBracket[] {\n\tconst N = brackets.length;\n\n\tbrackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n\n\tconst group: number[] = [];\n\tfor (let i = 0; i < N; i++) {\n\t\tgroup[i] = i;\n\t}\n\n\tconst areOverlapping = (a: CharacterPair, b: CharacterPair) => {\n\t\tconst [aOpen, aClose] = a;\n\t\tconst [bOpen, bClose] = b;\n\t\treturn (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n\t};\n\n\tconst mergeGroups = (g1: number, g2: number) => {\n\t\tconst newG = Math.min(g1, g2);\n\t\tconst oldG = Math.max(g1, g2);\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === oldG) {\n\t\t\t\tgroup[i] = newG;\n\t\t\t}\n\t\t}\n\t};\n\n\t// group together brackets that have the same open or the same close sequence\n\tfor (let i = 0; i < N; i++) {\n\t\tconst a = brackets[i];\n\t\tfor (let j = i + 1; j < N; j++) {\n\t\t\tconst b = brackets[j];\n\t\t\tif (areOverlapping(a, b)) {\n\t\t\t\tmergeGroups(group[i], group[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result: InternalBracket[] = [];\n\tfor (let g = 0; g < N; g++) {\n\t\tconst currentOpen: string[] = [];\n\t\tconst currentClose: string[] = [];\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === g) {\n\t\t\t\tconst [open, close] = brackets[i];\n\t\t\t\tcurrentOpen.push(open);\n\t\t\t\tcurrentClose.push(close);\n\t\t\t}\n\t\t}\n\t\tif (currentOpen.length > 0) {\n\t\t\tresult.push({\n\t\t\t\topen: currentOpen,\n\t\t\t\tclose: currentClose\n\t\t\t});\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class RichEditBrackets {\n\t_richEditBracketsBrand: void = undefined;\n\n\t/**\n\t * All groups of brackets defined for this language.\n\t */\n\tpublic readonly brackets: RichEditBracket[];\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string.\n\t *\n\t * See the fine details in `getRegexForBrackets`.\n\t */\n\tpublic readonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string backwards.\n\t *\n\t * See the fine details in `getReversedRegexForBrackets`.\n\t */\n\tpublic readonly reversedRegex: RegExp;\n\t/**\n\t * The length (i.e. str.length) for the longest bracket pair.\n\t */\n\tpublic readonly maxBracketLength: number;\n\t/**\n\t * A map useful for decoding a regex match and finding which bracket group was matched.\n\t */\n\tpublic readonly textIsBracket: { [text: string]: RichEditBracket };\n\t/**\n\t * A set useful for decoding if a regex match is the open bracket of a bracket pair.\n\t */\n\tpublic readonly textIsOpenBracket: { [text: string]: boolean };\n\n\tconstructor(languageId: string, _brackets: readonly CharacterPair[]) {\n\t\tconst brackets = groupFuzzyBrackets(_brackets);\n\n\t\tthis.brackets = brackets.map((b, index) => {\n\t\t\treturn new RichEditBracket(\n\t\t\t\tlanguageId,\n\t\t\t\tindex,\n\t\t\t\tb.open,\n\t\t\t\tb.close,\n\t\t\t\tgetRegexForBracketPair(b.open, b.close, brackets, index),\n\t\t\t\tgetReversedRegexForBracketPair(b.open, b.close, brackets, index)\n\t\t\t);\n\t\t});\n\n\t\tthis.forwardRegex = getRegexForBrackets(this.brackets);\n\t\tthis.reversedRegex = getReversedRegexForBrackets(this.brackets);\n\n\t\tthis.textIsBracket = {};\n\t\tthis.textIsOpenBracket = {};\n\n\t\tthis.maxBracketLength = 0;\n\t\tfor (const bracket of this.brackets) {\n\t\t\tfor (const open of bracket.open) {\n\t\t\t\tthis.textIsBracket[open] = bracket;\n\t\t\t\tthis.textIsOpenBracket[open] = true;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n\t\t\t}\n\t\t\tfor (const close of bracket.close) {\n\t\t\t\tthis.textIsBracket[close] = bracket;\n\t\t\t\tthis.textIsOpenBracket[close] = false;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction collectSuperstrings(str: string, brackets: InternalBracket[], currentIndex: number, dest: string[]): void {\n\tfor (let i = 0, len = brackets.length; i < len; i++) {\n\t\tif (i === currentIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bracket = brackets[i];\n\t\tfor (const open of bracket.open) {\n\t\t\tif (open.indexOf(str) >= 0) {\n\t\t\t\tdest.push(open);\n\t\t\t}\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tif (close.indexOf(str) >= 0) {\n\t\t\t\tdest.push(close);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction lengthcmp(a: string, b: string) {\n\treturn a.length - b.length;\n}\n\nfunction unique(arr: string[]): string[] {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\tconst result: string[] = [];\n\tconst seen = new Set<string>();\n\tfor (const element of arr) {\n\t\tif (seen.has(element)) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(element);\n\t\tseen.add(element);\n\t}\n\treturn result;\n}\n\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\t// This bracket pair uses letters like e.g. \"begin\" - \"end\"\n\tconst insertWordBoundaries = (/^[\\w ]+$/.test(str));\n\tstr = strings.escapeRegExpCharacters(str);\n\treturn (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\n\nexport function createBracketOrRegExp(pieces: string[], options?: strings.RegExpOptions): RegExp {\n\tconst regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n\treturn strings.createRegExp(regexStr, true, options);\n}\n\nconst toReversedString = (function () {\n\n\tfunction reverse(str: string): string {\n\t\t// create a Uint16Array and then use a TextDecoder to create a string\n\t\tconst arr = new Uint16Array(str.length);\n\t\tlet offset = 0;\n\t\tfor (let i = str.length - 1; i >= 0; i--) {\n\t\t\tarr[offset++] = str.charCodeAt(i);\n\t\t}\n\t\treturn stringBuilder.getPlatformTextDecoder().decode(arr);\n\t}\n\n\tlet lastInput: string | null = null;\n\tlet lastOutput: string | null = null;\n\treturn function toReversedString(str: string): string {\n\t\tif (lastInput !== str) {\n\t\t\tlastInput = str;\n\t\t\tlastOutput = reverse(lastInput);\n\t\t}\n\t\treturn lastOutput!;\n\t};\n})();\n\nexport class BracketsUtils {\n\n\tprivate static _findPrevBracketInText(reversedBracketRegex: RegExp, lineNumber: number, reversedText: string, offset: number): Range | null {\n\t\tconst m = reversedText.match(reversedBracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = reversedText.length - (m.index || 0);\n\t\tconst matchLength = m[0].length;\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n\t}\n\n\tpublic static findPrevBracketInRange(reversedBracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\t// Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n\t\tconst reversedLineText = toReversedString(lineText);\n\t\tconst reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n\t\treturn this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n\t}\n\n\tpublic static findNextBracketInText(bracketRegex: RegExp, lineNumber: number, text: string, offset: number): Range | null {\n\t\tconst m = text.match(bracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = m.index || 0;\n\t\tconst matchLength = m[0].length;\n\t\tif (matchLength === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n\t}\n\n\tpublic static findNextBracketInRange(bracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\tconst substr = lineText.substring(startOffset, endOffset);\n\t\treturn this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\nimport { CharacterPair } from '../languageConfiguration.js';\n\ninterface InternalBracket {\n\topen: string[];\n\tclose: string[];\n}\n\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n\t_richEditBracketBrand: void = undefined;\n\n\treadonly languageId: string;\n\t/**\n\t * A 0-based consecutive unique identifier for this bracket pair.\n\t * If a language has 5 bracket pairs, out of which 2 are grouped together,\n\t * it is expected that the `index` goes from 0 to 4.\n\t */\n\treadonly index: number;\n\t/**\n\t * The open sequence for each bracket pair contained in this group.\n\t *\n\t * The open sequence at a specific index corresponds to the\n\t * closing sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly open: string[];\n\t/**\n\t * The close sequence for each bracket pair contained in this group.\n\t *\n\t * The close sequence at a specific index corresponds to the\n\t * opening sequence at the same index.\n\t *\n\t * [ open[i], closed[i] ] represent a bracket pair.\n\t */\n\treadonly close: string[];\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine details in `getRegexForBracketPair`.\n\t */\n\treadonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for this bracket pair group in a string backwards.\n\t *\n\t * This regular expression is built in a way that it is aware of the other bracket\n\t * pairs defined for the language, so it might match brackets from other groups.\n\t *\n\t * See the fine defails in `getReversedRegexForBracketPair`.\n\t */\n\treadonly reversedRegex: RegExp;\n\tprivate readonly _openSet: Set<string>;\n\tprivate readonly _closeSet: Set<string>;\n\n\tconstructor(languageId: string, index: number, open: string[], close: string[], forwardRegex: RegExp, reversedRegex: RegExp) {\n\t\tthis.languageId = languageId;\n\t\tthis.index = index;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\t\tthis.forwardRegex = forwardRegex;\n\t\tthis.reversedRegex = reversedRegex;\n\t\tthis._openSet = RichEditBracket._toSet(this.open);\n\t\tthis._closeSet = RichEditBracket._toSet(this.close);\n\t}\n\n\t/**\n\t * Check if the provided `text` is an open bracket in this group.\n\t */\n\tpublic isOpen(text: string) {\n\t\treturn this._openSet.has(text);\n\t}\n\n\t/**\n\t * Check if the provided `text` is a close bracket in this group.\n\t */\n\tpublic isClose(text: string) {\n\t\treturn this._closeSet.has(text);\n\t}\n\n\tprivate static _toSet(arr: string[]): Set<string> {\n\t\tconst result = new Set<string>();\n\t\tfor (const element of arr) {\n\t\t\tresult.add(element);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets: readonly CharacterPair[]): InternalBracket[] {\n\tconst N = brackets.length;\n\n\tbrackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n\n\tconst group: number[] = [];\n\tfor (let i = 0; i < N; i++) {\n\t\tgroup[i] = i;\n\t}\n\n\tconst areOverlapping = (a: CharacterPair, b: CharacterPair) => {\n\t\tconst [aOpen, aClose] = a;\n\t\tconst [bOpen, bClose] = b;\n\t\treturn (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n\t};\n\n\tconst mergeGroups = (g1: number, g2: number) => {\n\t\tconst newG = Math.min(g1, g2);\n\t\tconst oldG = Math.max(g1, g2);\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === oldG) {\n\t\t\t\tgroup[i] = newG;\n\t\t\t}\n\t\t}\n\t};\n\n\t// group together brackets that have the same open or the same close sequence\n\tfor (let i = 0; i < N; i++) {\n\t\tconst a = brackets[i];\n\t\tfor (let j = i + 1; j < N; j++) {\n\t\t\tconst b = brackets[j];\n\t\t\tif (areOverlapping(a, b)) {\n\t\t\t\tmergeGroups(group[i], group[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result: InternalBracket[] = [];\n\tfor (let g = 0; g < N; g++) {\n\t\tconst currentOpen: string[] = [];\n\t\tconst currentClose: string[] = [];\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tif (group[i] === g) {\n\t\t\t\tconst [open, close] = brackets[i];\n\t\t\t\tcurrentOpen.push(open);\n\t\t\t\tcurrentClose.push(close);\n\t\t\t}\n\t\t}\n\t\tif (currentOpen.length > 0) {\n\t\t\tresult.push({\n\t\t\t\topen: currentOpen,\n\t\t\t\tclose: currentClose\n\t\t\t});\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class RichEditBrackets {\n\t_richEditBracketsBrand: void = undefined;\n\n\t/**\n\t * All groups of brackets defined for this language.\n\t */\n\tpublic readonly brackets: RichEditBracket[];\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string.\n\t *\n\t * See the fine details in `getRegexForBrackets`.\n\t */\n\tpublic readonly forwardRegex: RegExp;\n\t/**\n\t * A regular expression that is useful to search for all bracket pairs in a string backwards.\n\t *\n\t * See the fine details in `getReversedRegexForBrackets`.\n\t */\n\tpublic readonly reversedRegex: RegExp;\n\t/**\n\t * The length (i.e. str.length) for the longest bracket pair.\n\t */\n\tpublic readonly maxBracketLength: number;\n\t/**\n\t * A map useful for decoding a regex match and finding which bracket group was matched.\n\t */\n\tpublic readonly textIsBracket: { [text: string]: RichEditBracket };\n\t/**\n\t * A set useful for decoding if a regex match is the open bracket of a bracket pair.\n\t */\n\tpublic readonly textIsOpenBracket: { [text: string]: boolean };\n\n\tconstructor(languageId: string, _brackets: readonly CharacterPair[]) {\n\t\tconst brackets = groupFuzzyBrackets(_brackets);\n\n\t\tthis.brackets = brackets.map((b, index) => {\n\t\t\treturn new RichEditBracket(\n\t\t\t\tlanguageId,\n\t\t\t\tindex,\n\t\t\t\tb.open,\n\t\t\t\tb.close,\n\t\t\t\tgetRegexForBracketPair(b.open, b.close, brackets, index),\n\t\t\t\tgetReversedRegexForBracketPair(b.open, b.close, brackets, index)\n\t\t\t);\n\t\t});\n\n\t\tthis.forwardRegex = getRegexForBrackets(this.brackets);\n\t\tthis.reversedRegex = getReversedRegexForBrackets(this.brackets);\n\n\t\tthis.textIsBracket = {};\n\t\tthis.textIsOpenBracket = {};\n\n\t\tthis.maxBracketLength = 0;\n\t\tfor (const bracket of this.brackets) {\n\t\t\tfor (const open of bracket.open) {\n\t\t\t\tthis.textIsBracket[open] = bracket;\n\t\t\t\tthis.textIsOpenBracket[open] = true;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n\t\t\t}\n\t\t\tfor (const close of bracket.close) {\n\t\t\t\tthis.textIsBracket[close] = bracket;\n\t\t\t\tthis.textIsOpenBracket[close] = false;\n\t\t\t\tthis.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction collectSuperstrings(str: string, brackets: InternalBracket[], currentIndex: number, dest: string[]): void {\n\tfor (let i = 0, len = brackets.length; i < len; i++) {\n\t\tif (i === currentIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bracket = brackets[i];\n\t\tfor (const open of bracket.open) {\n\t\t\tif (open.indexOf(str) >= 0) {\n\t\t\t\tdest.push(open);\n\t\t\t}\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tif (close.indexOf(str) >= 0) {\n\t\t\t\tdest.push(close);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction lengthcmp(a: string, b: string) {\n\treturn a.length - b.length;\n}\n\nfunction unique(arr: string[]): string[] {\n\tif (arr.length <= 1) {\n\t\treturn arr;\n\t}\n\tconst result: string[] = [];\n\tconst seen = new Set<string>();\n\tfor (const element of arr) {\n\t\tif (seen.has(element)) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(element);\n\t\tseen.add(element);\n\t}\n\treturn result;\n}\n\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open: string[], close: string[], brackets: InternalBracket[], currentIndex: number): RegExp {\n\t// search in all brackets for other brackets that are a superstring of these brackets\n\tlet pieces: string[] = [];\n\tpieces = pieces.concat(open);\n\tpieces = pieces.concat(close);\n\tfor (let i = 0, len = pieces.length; i < len; i++) {\n\t\tcollectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n\t}\n\tpieces = unique(pieces);\n\tpieces.sort(lengthcmp);\n\tpieces.reverse();\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces);\n}\n\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets: RichEditBracket[]): RegExp {\n\tlet pieces: string[] = [];\n\tfor (const bracket of brackets) {\n\t\tfor (const open of bracket.open) {\n\t\t\tpieces.push(open);\n\t\t}\n\t\tfor (const close of bracket.close) {\n\t\t\tpieces.push(close);\n\t\t}\n\t}\n\tpieces = unique(pieces);\n\treturn createBracketOrRegExp(pieces.map(toReversedString));\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\t// This bracket pair uses letters like e.g. \"begin\" - \"end\"\n\tconst insertWordBoundaries = (/^[\\w ]+$/.test(str));\n\tstr = strings.escapeRegExpCharacters(str);\n\treturn (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\n\nexport function createBracketOrRegExp(pieces: string[], options?: strings.RegExpOptions): RegExp {\n\tconst regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n\treturn strings.createRegExp(regexStr, true, options);\n}\n\nconst toReversedString = (function () {\n\n\tfunction reverse(str: string): string {\n\t\t// create a Uint16Array and then use a TextDecoder to create a string\n\t\tconst arr = new Uint16Array(str.length);\n\t\tlet offset = 0;\n\t\tfor (let i = str.length - 1; i >= 0; i--) {\n\t\t\tarr[offset++] = str.charCodeAt(i);\n\t\t}\n\t\treturn stringBuilder.getPlatformTextDecoder().decode(arr);\n\t}\n\n\tlet lastInput: string | null = null;\n\tlet lastOutput: string | null = null;\n\treturn function toReversedString(str: string): string {\n\t\tif (lastInput !== str) {\n\t\t\tlastInput = str;\n\t\t\tlastOutput = reverse(lastInput);\n\t\t}\n\t\treturn lastOutput!;\n\t};\n})();\n\nexport class BracketsUtils {\n\n\tprivate static _findPrevBracketInText(reversedBracketRegex: RegExp, lineNumber: number, reversedText: string, offset: number): Range | null {\n\t\tconst m = reversedText.match(reversedBracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = reversedText.length - (m.index || 0);\n\t\tconst matchLength = m[0].length;\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n\t}\n\n\tpublic static findPrevBracketInRange(reversedBracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\t// Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n\t\tconst reversedLineText = toReversedString(lineText);\n\t\tconst reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n\t\treturn this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n\t}\n\n\tpublic static findNextBracketInText(bracketRegex: RegExp, lineNumber: number, text: string, offset: number): Range | null {\n\t\tconst m = text.match(bracketRegex);\n\n\t\tif (!m) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchOffset = m.index || 0;\n\t\tconst matchLength = m[0].length;\n\t\tif (matchLength === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst absoluteMatchOffset = offset + matchOffset;\n\n\t\treturn new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n\t}\n\n\tpublic static findNextBracketInRange(bracketRegex: RegExp, lineNumber: number, lineText: string, startOffset: number, endOffset: number): Range | null {\n\t\tconst substr = lineText.substring(startOffset, endOffset);\n\t\treturn this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n\t}\n}\n"]}