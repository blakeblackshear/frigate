{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.ts","vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.ts"],"names":[],"mappings":"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","file":"textureAtlasSlabAllocator.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\nexport interface TextureAtlasSlabAllocatorOptions {\n\tslabW?: number;\n\tslabH?: number;\n}\n\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nexport class TextureAtlasSlabAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _slabs: ITextureAtlasSlab[] = [];\n\tprivate readonly _activeSlabsByDims: NKeyMap<ITextureAtlasSlab, [number, number]> = new NKeyMap();\n\n\tprivate readonly _unusedRects: ITextureAtlasSlabUnusedRect[] = [];\n\n\tprivate readonly _openRegionsByHeight: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\tprivate readonly _openRegionsByWidth: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _slabW: number;\n\tprivate _slabH: number;\n\tprivate _slabsPerRow: number;\n\tprivate _slabsPerColumn: number;\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t\toptions?: TextureAtlasSlabAllocatorOptions\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\n\t\tthis._slabW = Math.min(\n\t\t\toptions?.slabW ?? (64 << Math.max(Math.floor(getActiveWindow().devicePixelRatio) - 1, 0)),\n\t\t\tthis._canvas.width\n\t\t);\n\t\tthis._slabH = Math.min(\n\t\t\toptions?.slabH ?? this._slabW,\n\t\t\tthis._canvas.height\n\t\t);\n\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// Find ideal slab, creating it if there is none suitable\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\n\t\t// The glyph does not fit into the atlas page, glyphs should never be this large in practice\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// The glyph does not fit into a slab\n\t\tif (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n\t\t\t// Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n\t\t\tif (this._allocatedGlyphs.size > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n\t\t\t// wasted space outside the allocated slabs.\n\t\t\tlet sizeCandidate = this._canvas.width;\n\t\t\twhile (glyphWidth < sizeCandidate / 2 && glyphHeight < sizeCandidate / 2) {\n\t\t\t\tsizeCandidate /= 2;\n\t\t\t}\n\t\t\tthis._slabW = sizeCandidate;\n\t\t\tthis._slabH = sizeCandidate;\n\t\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t\t}\n\n\t\t// const dpr = getActiveWindow().devicePixelRatio;\n\n\t\t// TODO: Include font size as well as DPR in nearestXPixels calculation\n\n\t\t// Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr));\n\t\tconst desiredSlabSize = {\n\t\t\t// Nearest square number\n\t\t\t// TODO: This can probably be optimized\n\t\t\t// w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n\t\t\t// h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n\n\t\t\t// Nearest x px\n\t\t\t// w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n\t\t\t// h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n\n\t\t\t// Round odd numbers up\n\t\t\t// w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n\t\t\t// h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n\n\t\t\t// Exact number only\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t};\n\n\t\t// Get any existing slab\n\t\tlet slab = this._activeSlabsByDims.get(desiredSlabSize.w, desiredSlabSize.h);\n\n\t\t// Check if the slab is full\n\t\tif (slab) {\n\t\t\tconst glyphsPerSlab = Math.floor(this._slabW / slab.entryW) * Math.floor(this._slabH / slab.entryH);\n\t\t\tif (slab.count >= glyphsPerSlab) {\n\t\t\t\tslab = undefined;\n\t\t\t}\n\t\t}\n\n\t\tlet dx: number | undefined;\n\t\tlet dy: number | undefined;\n\n\t\t// Search for suitable space in unused rectangles\n\t\tif (!slab) {\n\t\t\t// Only check availability for the smallest side\n\t\t\tif (glyphWidth < glyphHeight) {\n\t\t\t\tconst openRegions = this._openRegionsByWidth.get(glyphWidth);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphWidth < r.w) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x + glyphWidth,\n\t\t\t\t\t\t\t\t\ty: r.y,\n\t\t\t\t\t\t\t\t\tw: r.w - glyphWidth,\n\t\t\t\t\t\t\t\t\th: glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.y += glyphHeight;\n\t\t\t\t\t\t\tr.h -= glyphHeight;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst openRegions = this._openRegionsByHeight.get(glyphHeight);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphHeight < r.h) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x,\n\t\t\t\t\t\t\t\t\ty: r.y + glyphHeight,\n\t\t\t\t\t\t\t\t\tw: glyphWidth,\n\t\t\t\t\t\t\t\t\th: r.h - glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.x += glyphWidth;\n\t\t\t\t\t\t\tr.w -= glyphWidth;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a new slab\n\t\tif (dx === undefined || dy === undefined) {\n\t\t\tif (!slab) {\n\t\t\t\tif (this._slabs.length >= this._slabsPerRow * this._slabsPerColumn) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tslab = {\n\t\t\t\t\tx: Math.floor(this._slabs.length % this._slabsPerRow) * this._slabW,\n\t\t\t\t\ty: Math.floor(this._slabs.length / this._slabsPerRow) * this._slabH,\n\t\t\t\t\tentryW: desiredSlabSize.w,\n\t\t\t\t\tentryH: desiredSlabSize.h,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t\t// Track unused regions to use for small glyphs\n\t\t\t\t// +-------------+----+\n\t\t\t\t// |             |    |\n\t\t\t\t// |             |    | <- Unused W region\n\t\t\t\t// |             |    |\n\t\t\t\t// |-------------+----+\n\t\t\t\t// |                  | <- Unused H region\n\t\t\t\t// +------------------+\n\t\t\t\tconst unusedW = this._slabW % slab.entryW;\n\t\t\t\tconst unusedH = this._slabH % slab.entryH;\n\t\t\t\tif (unusedW) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByWidth, unusedW, {\n\t\t\t\t\t\tx: slab.x + this._slabW - unusedW,\n\t\t\t\t\t\tw: unusedW,\n\t\t\t\t\t\ty: slab.y,\n\t\t\t\t\t\th: this._slabH - (unusedH ?? 0)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (unusedH) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByHeight, unusedH, {\n\t\t\t\t\t\tx: slab.x,\n\t\t\t\t\t\tw: this._slabW,\n\t\t\t\t\t\ty: slab.y + this._slabH - unusedH,\n\t\t\t\t\t\th: unusedH\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._slabs.push(slab);\n\t\t\t\tthis._activeSlabsByDims.set(slab, desiredSlabSize.w, desiredSlabSize.h);\n\t\t\t}\n\n\t\t\tconst glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n\t\t\tdx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n\t\t\tdy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n\n\t\t\t// Shift current row\n\t\t\tslab.count++;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: dx,\n\t\t\ty: dy,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Restricted;\n\t\t\tctx.fillRect(r.x, r.y, r.w, r.h);\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\n\t\t// Overlay actual glyphs on top\n\t\tctx.globalAlpha = 0.5;\n\t\tctx.drawImage(this._canvas, 0, 0);\n\t\tctx.globalAlpha = 1;\n\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tpublic getStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst totalPixels = w * h;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\tconst edgeUsedPixels = slabEdgePixels - restrictedPixels;\n\t\twastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n\n\t\t// usedPixels += slabEdgePixels - restrictedPixels;\n\t\tconst efficiency = usedPixels / (usedPixels + wastedPixels + restrictedPixels);\n\n\t\treturn [\n\t\t\t`page[${this._textureIndex}]:`,\n\t\t\t`     Total: ${totalPixels}px (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n\t\t\t`Efficiency: ${efficiency === 1 ? '100' : (efficiency * 100).toFixed(2)}%`,\n\t\t\t`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasSlab {\n\tx: number;\n\ty: number;\n\tentryH: number;\n\tentryW: number;\n\tcount: number;\n}\n\ninterface ITextureAtlasSlabUnusedRect {\n\tx: number;\n\ty: number;\n\tw: number;\n\th: number;\n}\n\nfunction addEntryToMapArray<K, V>(map: Map<K, V[]>, key: K, entry: V) {\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(entry);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\nexport interface TextureAtlasSlabAllocatorOptions {\n\tslabW?: number;\n\tslabH?: number;\n}\n\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nexport class TextureAtlasSlabAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _slabs: ITextureAtlasSlab[] = [];\n\tprivate readonly _activeSlabsByDims: NKeyMap<ITextureAtlasSlab, [number, number]> = new NKeyMap();\n\n\tprivate readonly _unusedRects: ITextureAtlasSlabUnusedRect[] = [];\n\n\tprivate readonly _openRegionsByHeight: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\tprivate readonly _openRegionsByWidth: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _slabW: number;\n\tprivate _slabH: number;\n\tprivate _slabsPerRow: number;\n\tprivate _slabsPerColumn: number;\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t\toptions?: TextureAtlasSlabAllocatorOptions\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\n\t\tthis._slabW = Math.min(\n\t\t\toptions?.slabW ?? (64 << Math.max(Math.floor(getActiveWindow().devicePixelRatio) - 1, 0)),\n\t\t\tthis._canvas.width\n\t\t);\n\t\tthis._slabH = Math.min(\n\t\t\toptions?.slabH ?? this._slabW,\n\t\t\tthis._canvas.height\n\t\t);\n\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// Find ideal slab, creating it if there is none suitable\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\n\t\t// The glyph does not fit into the atlas page, glyphs should never be this large in practice\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// The glyph does not fit into a slab\n\t\tif (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n\t\t\t// Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n\t\t\tif (this._allocatedGlyphs.size > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n\t\t\t// wasted space outside the allocated slabs.\n\t\t\tlet sizeCandidate = this._canvas.width;\n\t\t\twhile (glyphWidth < sizeCandidate / 2 && glyphHeight < sizeCandidate / 2) {\n\t\t\t\tsizeCandidate /= 2;\n\t\t\t}\n\t\t\tthis._slabW = sizeCandidate;\n\t\t\tthis._slabH = sizeCandidate;\n\t\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t\t}\n\n\t\t// const dpr = getActiveWindow().devicePixelRatio;\n\n\t\t// TODO: Include font size as well as DPR in nearestXPixels calculation\n\n\t\t// Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr));\n\t\tconst desiredSlabSize = {\n\t\t\t// Nearest square number\n\t\t\t// TODO: This can probably be optimized\n\t\t\t// w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n\t\t\t// h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n\n\t\t\t// Nearest x px\n\t\t\t// w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n\t\t\t// h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n\n\t\t\t// Round odd numbers up\n\t\t\t// w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n\t\t\t// h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n\n\t\t\t// Exact number only\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t};\n\n\t\t// Get any existing slab\n\t\tlet slab = this._activeSlabsByDims.get(desiredSlabSize.w, desiredSlabSize.h);\n\n\t\t// Check if the slab is full\n\t\tif (slab) {\n\t\t\tconst glyphsPerSlab = Math.floor(this._slabW / slab.entryW) * Math.floor(this._slabH / slab.entryH);\n\t\t\tif (slab.count >= glyphsPerSlab) {\n\t\t\t\tslab = undefined;\n\t\t\t}\n\t\t}\n\n\t\tlet dx: number | undefined;\n\t\tlet dy: number | undefined;\n\n\t\t// Search for suitable space in unused rectangles\n\t\tif (!slab) {\n\t\t\t// Only check availability for the smallest side\n\t\t\tif (glyphWidth < glyphHeight) {\n\t\t\t\tconst openRegions = this._openRegionsByWidth.get(glyphWidth);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphWidth < r.w) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x + glyphWidth,\n\t\t\t\t\t\t\t\t\ty: r.y,\n\t\t\t\t\t\t\t\t\tw: r.w - glyphWidth,\n\t\t\t\t\t\t\t\t\th: glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.y += glyphHeight;\n\t\t\t\t\t\t\tr.h -= glyphHeight;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst openRegions = this._openRegionsByHeight.get(glyphHeight);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphHeight < r.h) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x,\n\t\t\t\t\t\t\t\t\ty: r.y + glyphHeight,\n\t\t\t\t\t\t\t\t\tw: glyphWidth,\n\t\t\t\t\t\t\t\t\th: r.h - glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.x += glyphWidth;\n\t\t\t\t\t\t\tr.w -= glyphWidth;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a new slab\n\t\tif (dx === undefined || dy === undefined) {\n\t\t\tif (!slab) {\n\t\t\t\tif (this._slabs.length >= this._slabsPerRow * this._slabsPerColumn) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tslab = {\n\t\t\t\t\tx: Math.floor(this._slabs.length % this._slabsPerRow) * this._slabW,\n\t\t\t\t\ty: Math.floor(this._slabs.length / this._slabsPerRow) * this._slabH,\n\t\t\t\t\tentryW: desiredSlabSize.w,\n\t\t\t\t\tentryH: desiredSlabSize.h,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t\t// Track unused regions to use for small glyphs\n\t\t\t\t// +-------------+----+\n\t\t\t\t// |             |    |\n\t\t\t\t// |             |    | <- Unused W region\n\t\t\t\t// |             |    |\n\t\t\t\t// |-------------+----+\n\t\t\t\t// |                  | <- Unused H region\n\t\t\t\t// +------------------+\n\t\t\t\tconst unusedW = this._slabW % slab.entryW;\n\t\t\t\tconst unusedH = this._slabH % slab.entryH;\n\t\t\t\tif (unusedW) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByWidth, unusedW, {\n\t\t\t\t\t\tx: slab.x + this._slabW - unusedW,\n\t\t\t\t\t\tw: unusedW,\n\t\t\t\t\t\ty: slab.y,\n\t\t\t\t\t\th: this._slabH - (unusedH ?? 0)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (unusedH) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByHeight, unusedH, {\n\t\t\t\t\t\tx: slab.x,\n\t\t\t\t\t\tw: this._slabW,\n\t\t\t\t\t\ty: slab.y + this._slabH - unusedH,\n\t\t\t\t\t\th: unusedH\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._slabs.push(slab);\n\t\t\t\tthis._activeSlabsByDims.set(slab, desiredSlabSize.w, desiredSlabSize.h);\n\t\t\t}\n\n\t\t\tconst glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n\t\t\tdx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n\t\t\tdy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n\n\t\t\t// Shift current row\n\t\t\tslab.count++;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: dx,\n\t\t\ty: dy,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Restricted;\n\t\t\tctx.fillRect(r.x, r.y, r.w, r.h);\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\n\t\t// Overlay actual glyphs on top\n\t\tctx.globalAlpha = 0.5;\n\t\tctx.drawImage(this._canvas, 0, 0);\n\t\tctx.globalAlpha = 1;\n\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tpublic getStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst totalPixels = w * h;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\tconst edgeUsedPixels = slabEdgePixels - restrictedPixels;\n\t\twastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n\n\t\t// usedPixels += slabEdgePixels - restrictedPixels;\n\t\tconst efficiency = usedPixels / (usedPixels + wastedPixels + restrictedPixels);\n\n\t\treturn [\n\t\t\t`page[${this._textureIndex}]:`,\n\t\t\t`     Total: ${totalPixels}px (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n\t\t\t`Efficiency: ${efficiency === 1 ? '100' : (efficiency * 100).toFixed(2)}%`,\n\t\t\t`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasSlab {\n\tx: number;\n\ty: number;\n\tentryH: number;\n\tentryW: number;\n\tcount: number;\n}\n\ninterface ITextureAtlasSlabUnusedRect {\n\tx: number;\n\ty: number;\n\tw: number;\n\th: number;\n}\n\nfunction addEntryToMapArray<K, V>(map: Map<K, V[]>, key: K, entry: V) {\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(entry);\n}\n"]}