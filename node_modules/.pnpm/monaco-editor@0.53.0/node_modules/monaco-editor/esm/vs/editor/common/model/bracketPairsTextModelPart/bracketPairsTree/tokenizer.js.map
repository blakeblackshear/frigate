{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts"],"names":[],"mappings":"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","file":"tokenizer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { StandardTokenType, TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { IViewLineTokens } from '../../../tokens/lineTokens.js';\nimport { BracketAstNode, TextAstNode } from './ast.js';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader;\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\t\tthis._offset = lengthZero;\n\t\tthis.didPeek = false;\n\t\tthis.peeked = null;\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek;\n\tprivate peeked: Token | null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { StandardTokenType, TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { IViewLineTokens } from '../../../tokens/lineTokens.js';\nimport { BracketAstNode, TextAstNode } from './ast.js';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader;\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\t\tthis._offset = lengthZero;\n\t\tthis.didPeek = false;\n\t\tthis.peeked = null;\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek;\n\tprivate peeked: Token | null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n}\n"]}