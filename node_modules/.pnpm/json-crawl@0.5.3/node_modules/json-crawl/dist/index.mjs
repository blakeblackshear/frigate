/*!
 * json-crawl v0.5.3
 * Copyright (C) 2012-2024 Damir Yusipov
 * Date: Sat, 06 Jan 2024 08:16:05 GMT
 */
function e(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n}function t(e,t,n,o){return new(n||(n=Promise))((function(s,a){function r(e){try{u(o.next(e))}catch(e){a(e)}}function l(e){try{u(o.throw(e))}catch(e){a(e)}}function u(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,l)}u((o=o.apply(e,t||[])).next())}))}const n=(e={},t,n,o)=>{const s=`/${t}`,a="function"==typeof e["/**"]?e["/**"]({key:t,path:n,value:o}):e["/**"],r="function"==typeof e["/*"]?e["/*"]({key:t,path:n,value:o}):e["/*"];let l={};if(s in e)l=e[s];else if(!a&&!r)return;return l="function"==typeof l?l({key:t,path:n,value:o}):l,r&&(l=Object.assign(Object.assign({},r),l)),a?Object.assign(Object.assign({"/**":e["/**"]},a),l):l},o=e=>{const t={},n=e.reduce(((e,t)=>(Object.keys(t).forEach((t=>e.add(t))),e)),new Set);for(const s of n.keys()){const n=e.filter((e=>s in e));if(1!==n.length){if("/"!==s.charAt(0))throw new Error(`Cannot merge rules. Duplicate key: ${s}. Rules should not have same Rule key`);t[s]=(e,t)=>{const a=n.map((n=>"function"==typeof n[s]?n[s](e,t):n[s]));return o(a)}}else t[s]=n[0][s]}return t},s=e=>"object"==typeof e&&null!==e,a=e=>Array.isArray(e),r=(r,l,u={})=>t(void 0,void 0,void 0,(function*(){var t,i;l=a(l)?l:[l];const c=a(u.rules)?o(u.rules):u.rules,d=[{data:r,state:u.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const o=d[d.length-1];if(o.keyIndex>=o.keys.length){for(;null===(t=o.hooks)||void 0===t?void 0:t.length;)o.hooks.pop()();d.pop();continue}const r=o.keys[o.keyIndex++],[u,f,y]=d.length>1?[o.data[r],[...o.path,r],n(o.rules,r,[...o.path,r],o.data[r])]:[o.data,o.path,c];let v={value:u,path:f,key:r,state:o.state,rules:y};const p=[];for(const t of l){if(!t||"function"!=typeof t)continue;const n=null!==(i=yield t(v))&&void 0!==i?i:{},{terminate:o,done:s,exitHook:a}=n,r=e(n,["terminate","done","exitHook"]);if(o)return;if(v=Object.assign(Object.assign({},v),r),a&&p.push(a),s){v=null;break}}if(v&&s(v.value)){const e=a(v.value)?[...v.value.keys()]:Object.keys(v.value);d.push({hooks:p,state:v.state,data:v.value,path:f,keys:e,keyIndex:0,rules:v.rules})}else for(;p.length;)p.pop()()}})),l=(t,r,l={})=>{var u,i;r=a(r)?r:[r];const c=a(l.rules)?o(l.rules):l.rules,d=[{data:t,state:l.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const t=d[d.length-1];if(t.keyIndex>=t.keys.length){for(;null===(u=t.hooks)||void 0===u?void 0:u.length;)t.hooks.pop()();d.pop();continue}const o=t.keys[t.keyIndex++],[l,f,y]=d.length>1?[t.data[o],[...t.path,o],n(t.rules,o,[...t.path,o],t.data[o])]:[t.data,t.path,c];let v={value:l,path:f,key:o,state:t.state,rules:y};const p=[];for(const t of r){if(!t||"function"!=typeof t)continue;const n=null!==(i=t(v))&&void 0!==i?i:{},{terminate:o,done:s,exitHook:a}=n,r=e(n,["terminate","done","exitHook"]);if(o)return;if(a&&p.push(a),v=Object.assign(Object.assign({},v),r),s){v=null;break}}if(v&&s(v.value)){const e=a(v.value)?[...v.value.keys()]:Object.keys(v.value);d.push({hooks:p,state:v.state,data:v.value,path:f,keys:e,keyIndex:0,rules:v.rules})}else for(;p.length;)p.pop()()}},u=()=>{const e=new WeakMap;let t;return[({value:e})=>{t=e},({value:n,path:o,key:a,state:r})=>{if(a=o.length?a:"#",s(t)&&s(n)){if(e.has(t))return r.node[a]=e.get(t),{done:!0};const o=Array.isArray(n)?[]:{};r.node[a]=o,e.set(t,o)}else r.node[a]=n;return{value:n,state:Object.assign(Object.assign({},r),{node:r.node[a]})}}]},i=(e,n=[],o={})=>t(void 0,void 0,void 0,(function*(){var t;n=Array.isArray(n)?n:[n];const s={"#":void 0},a=Object.assign({state:Object.assign(Object.assign({},null!==(t=o.state)&&void 0!==t?t:{}),{root:s,node:s})},o.rules?{rules:o.rules}:{}),[l,i]=u();return yield r(e,[l,...n,i],a),s["#"]})),c=(e,t=[],n={})=>{var o;t=Array.isArray(t)?t:[t];const s={"#":void 0},a=Object.assign({state:Object.assign(Object.assign({},null!==(o=n.state)&&void 0!==o?o:{}),{root:s,node:s})},n.rules?{rules:n.rules}:{}),[r,i]=u();return l(e,[r,...t,i],a),s["#"]},d=(e,t)=>{if(e===t)return!0;let n=!0;return l(e,(({value:e,key:t,state:o})=>{const s=void 0===t?o.value:o.value[t],r={state:{value:s}};if(e===s)return r;if(n=!1,typeof e!=typeof s)return{done:!0};if(a(e)&&e.length!==s.length)return{terminate:!0};if("object"==typeof e&&null!==e){const t=Object.keys(e),n=Object.keys(s);if(t.length!==n.length||!t.every((e=>n.includes(e))))return{terminate:!0}}else if(e!==s)return{terminate:!0};return n=!0,r}),{state:{value:t}}),n},f=(e,n=[],o={})=>t(void 0,void 0,void 0,(function*(){var l;n=a(n)?n:[n];const u={"#":e},i=Object.assign({state:Object.assign(Object.assign({},null!==(l=o.state)&&void 0!==l?l:{}),{root:u,node:u})},o.rules?{rules:o.rules}:{});return yield r(e,[...n,({value:e,path:n,key:o,state:r})=>t(void 0,void 0,void 0,(function*(){return o=n.length?o:"#",void 0===e?a(r.node)&&"number"==typeof o?r.node.splice(o,1):s(r.node)&&o in r.node&&delete r.node[o]:s(r.node)&&(r.node[o]=e),{value:e,state:r}}))],i),u["#"]}));export{i as clone,r as crawl,d as equal,n as getNodeRules,a as isArray,s as isObject,o as mergeRules,c as syncClone,l as syncCrawl,f as transform};
//# sourceMappingURL=index.mjs.map
