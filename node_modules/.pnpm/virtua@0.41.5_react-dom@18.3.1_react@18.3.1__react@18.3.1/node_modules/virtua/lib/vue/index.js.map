{"version":3,"file":"index.js","sources":["../../src/src/core/utils.ts","../../src/src/core/cache.ts","../../src/src/core/environment.ts","../../src/src/core/store.ts","../../src/src/core/scroller.ts","../../src/src/core/resizer.ts","../../src/src/vue/ListItem.tsx","../../src/src/vue/utils.ts","../../src/src/vue/Virtualizer.tsx","../../src/src/vue/VList.tsx","../../src/src/vue/WindowVirtualizer.tsx"],"sourcesContent":["/** @internal */\nexport const NULL = null;\n\n/** @internal */\nexport const { min, max, abs, floor } = Math;\n\n/**\n * @internal\n */\nexport const clamp = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => min(maxValue, max(minValue, value));\n\n/**\n * @internal\n */\nexport const sort = <T extends number>(arr: readonly T[]): T[] => {\n  return [...arr].sort((a, b) => a - b);\n};\n\n/**\n * @internal\n */\nexport const microtask: (fn: () => void) => void =\n  typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : (fn) => {\n        Promise.resolve().then(fn);\n      };\n\n/**\n * @internal\n */\nexport const once = <T>(fn: () => T): (() => T) => {\n  let cache: T;\n\n  return () => {\n    if (fn) {\n      cache = fn();\n      fn = undefined!;\n    }\n    return cache;\n  };\n};\n","import { type InternalCacheSnapshot, type ItemsRange } from \"./types\";\nimport { clamp, floor, max, min, sort } from \"./utils\";\n\ntype Writeable<T> = {\n  -readonly [key in keyof T]: Writeable<T[key]>;\n};\n\n/** @internal */\nexport const UNCACHED = -1;\n\n/**\n * @internal\n */\nexport type Cache = {\n  readonly _length: number;\n  // sizes\n  readonly _sizes: number[];\n  readonly _defaultItemSize: number;\n  // offsets\n  readonly _computedOffsetIndex: number;\n  readonly _offsets: number[];\n};\n\nconst fill = (array: number[], length: number, prepend?: boolean): number[] => {\n  const key = prepend ? \"unshift\" : \"push\";\n  for (let i = 0; i < length; i++) {\n    array[key](UNCACHED);\n  }\n  return array;\n};\n\n/**\n * @internal\n */\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\n/**\n * @internal\n */\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._computedOffsetIndex = min(index, cache._computedOffsetIndex);\n  return isInitialMeasurement;\n};\n\n/**\n * @internal\n */\nexport const computeOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  if (!cache._length) return 0;\n  if (cache._computedOffsetIndex >= index) {\n    return cache._offsets[index]!;\n  }\n\n  if (cache._computedOffsetIndex < 0) {\n    // first offset must be 0 to avoid returning NaN, which can cause infinite rerender.\n    // https://github.com/inokawa/virtua/pull/160\n    cache._offsets[0] = 0;\n    cache._computedOffsetIndex = 0;\n  }\n  let i = cache._computedOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i < index) {\n    top += getItemSize(cache, i);\n    cache._offsets[++i] = top;\n  }\n  // mark as measured\n  cache._computedOffsetIndex = index;\n  return top;\n};\n\n/**\n * @internal\n */\nexport const computeTotalSize = (cache: Cache): number => {\n  if (!cache._length) return 0;\n  return (\n    computeOffset(cache, cache._length - 1) +\n    getItemSize(cache, cache._length - 1)\n  );\n};\n\n/**\n * Finds the index of an item in the cache whose computed offset is closest to the specified offset.\n *\n * @internal\n */\nexport const findIndex = (\n  cache: Cache,\n  offset: number,\n  low: number = 0,\n  high: number = cache._length - 1\n): number => {\n  // Find with binary search\n  while (low <= high) {\n    const mid = floor((low + high) / 2);\n    const itemOffset = computeOffset(cache, mid);\n    if (itemOffset <= offset) {\n      if (itemOffset + getItemSize(cache, mid) > offset) {\n        return mid;\n      }\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return clamp(low, 0, cache._length - 1);\n};\n\n/**\n * @internal\n */\nexport const computeRange = (\n  cache: Cache,\n  scrollOffset: number,\n  viewportSize: number,\n  prevStartIndex: number\n): ItemsRange => {\n  // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\n  prevStartIndex = min(prevStartIndex, cache._length - 1);\n\n  if (computeOffset(cache, prevStartIndex) <= scrollOffset) {\n    // search forward\n    // start <= end, prevStartIndex <= start\n    const end = findIndex(cache, scrollOffset + viewportSize, prevStartIndex);\n    return [findIndex(cache, scrollOffset, prevStartIndex, end), end];\n  } else {\n    // search backward\n    // start <= end, start <= prevStartIndex\n    const start = findIndex(cache, scrollOffset, undefined, prevStartIndex);\n    return [start, findIndex(cache, scrollOffset + viewportSize, start)];\n  }\n};\n\n/**\n * @internal\n */\nexport const estimateDefaultItemSize = (\n  cache: Writeable<Cache>,\n  startIndex: number\n): number => {\n  let measuredCountBeforeStart = 0;\n  // This function will be called after measurement so measured size array must be longer than 0\n  const measuredSizes: number[] = [];\n  cache._sizes.forEach((s, i) => {\n    if (s !== UNCACHED) {\n      measuredSizes.push(s);\n      if (i < startIndex) {\n        measuredCountBeforeStart++;\n      }\n    }\n  });\n\n  // Discard cache for now\n  cache._computedOffsetIndex = -1;\n\n  // Calculate median\n  const sorted = sort(measuredSizes);\n  const len = sorted.length;\n  const mid = (len / 2) | 0;\n  const median =\n    len % 2 === 0 ? (sorted[mid - 1]! + sorted[mid]!) / 2 : sorted[mid]!;\n\n  const prevDefaultItemSize = cache._defaultItemSize;\n\n  // Calculate diff of unmeasured items before start\n  return (\n    ((cache._defaultItemSize = median) - prevDefaultItemSize) *\n    max(startIndex - measuredCountBeforeStart, 0)\n  );\n};\n\n/**\n * @internal\n */\nexport const initCache = (\n  length: number,\n  itemSize: number,\n  snapshot?: InternalCacheSnapshot\n): Cache => {\n  return {\n    _defaultItemSize: snapshot ? snapshot[1] : itemSize,\n    _sizes:\n      snapshot && snapshot[0]\n        ? // https://github.com/inokawa/virtua/issues/441\n          fill(\n            snapshot[0].slice(0, min(length, snapshot[0].length)),\n            max(0, length - snapshot[0].length)\n          )\n        : fill([], length),\n    _length: length,\n    _computedOffsetIndex: -1,\n    _offsets: fill([], length),\n  };\n};\n\n/**\n * @internal\n */\nexport const takeCacheSnapshot = (cache: Cache): InternalCacheSnapshot => {\n  return [cache._sizes.slice(), cache._defaultItemSize];\n};\n\n/**\n * @internal\n */\nexport const updateCacheLength = (\n  cache: Writeable<Cache>,\n  length: number,\n  isShift?: boolean\n): number => {\n  const diff = length - cache._length;\n\n  cache._computedOffsetIndex = isShift\n    ? // Discard cache for now\n      -1\n    : min(length - 1, cache._computedOffsetIndex);\n  cache._length = length;\n\n  if (diff > 0) {\n    // Added\n    fill(cache._offsets, diff);\n    fill(cache._sizes, diff, isShift);\n    return cache._defaultItemSize * diff;\n  } else {\n    // Removed\n    cache._offsets.splice(diff);\n    return (\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\n    ).reduce(\n      (acc, removed) =>\n        acc - (removed === UNCACHED ? cache._defaultItemSize : removed),\n      0\n    );\n  }\n};\n","import { once } from \"./utils\";\n\n/**\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nconst getDocumentElement = () => document.documentElement;\n\n/**\n * @internal\n */\nexport const getCurrentDocument = (node: HTMLElement): Document =>\n  node.ownerDocument;\n\n/**\n * @internal\n */\nexport const getCurrentWindow = (doc: Document) => doc.defaultView!;\n\n/**\n * @internal\n */\nexport const isRTLDocument = /*#__PURE__*/ once((): boolean => {\n  // TODO support SSR in rtl\n  return isBrowser\n    ? getComputedStyle(getDocumentElement()).direction === \"rtl\"\n    : false;\n});\n\n/**\n * Currently, all browsers on iOS/iPadOS are WebKit, including WebView.\n * @internal\n */\nexport const isIOSWebKit = /*#__PURE__*/ once((): boolean => {\n  return /iP(hone|od|ad)/.test(navigator.userAgent);\n});\n\n/**\n * @internal\n */\nexport const isSmoothScrollSupported = /*#__PURE__*/ once((): boolean => {\n  return \"scrollBehavior\" in getDocumentElement().style;\n});\n","import {\n  initCache,\n  getItemSize as _getItemSize,\n  computeTotalSize,\n  computeOffset as computeStartOffset,\n  UNCACHED,\n  setItemSize,\n  estimateDefaultItemSize,\n  updateCacheLength,\n  computeRange,\n  takeCacheSnapshot,\n  findIndex,\n} from \"./cache\";\nimport { isIOSWebKit } from \"./environment\";\nimport type {\n  CacheSnapshot,\n  InternalCacheSnapshot,\n  ItemResize,\n  ItemsRange,\n} from \"./types\";\nimport { abs, max, min, NULL } from \"./utils\";\n\nconst MAX_INT_32 = 0x7fffffff;\n\nconst SCROLL_IDLE = 0;\nconst SCROLL_DOWN = 1;\nconst SCROLL_UP = 2;\ntype ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP;\n\nconst SCROLL_BY_NATIVE = 0;\nconst SCROLL_BY_MANUAL_SCROLL = 1;\nconst SCROLL_BY_SHIFT = 2;\ntype ScrollMode =\n  | typeof SCROLL_BY_NATIVE\n  | typeof SCROLL_BY_MANUAL_SCROLL\n  | typeof SCROLL_BY_SHIFT;\n\n/** @internal */\nexport const ACTION_SCROLL = 1;\n/** @internal */\nexport const ACTION_SCROLL_END = 2;\n/** @internal */\nexport const ACTION_ITEM_RESIZE = 3;\n/** @internal */\nexport const ACTION_VIEWPORT_RESIZE = 4;\n/** @internal */\nexport const ACTION_ITEMS_LENGTH_CHANGE = 5;\n/** @internal */\nexport const ACTION_START_OFFSET_CHANGE = 6;\n/** @internal */\nexport const ACTION_MANUAL_SCROLL = 7;\n/** @internal */\nexport const ACTION_BEFORE_MANUAL_SMOOTH_SCROLL = 8;\n\ntype Actions =\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: number]\n  | [\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\n      arg: [length: number, isShift?: boolean | undefined],\n    ]\n  | [type: typeof ACTION_START_OFFSET_CHANGE, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void]\n  | [type: typeof ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, offset: number];\n\n/** @internal */\nexport const UPDATE_VIRTUAL_STATE = 0b0001;\n/** @internal */\nexport const UPDATE_SIZE_EVENT = 0b0010;\n/** @internal */\nexport const UPDATE_SCROLL_EVENT = 0b0100;\n/** @internal */\nexport const UPDATE_SCROLL_END_EVENT = 0b1000;\n\n/**\n * @internal\n */\nexport const getScrollSize = (store: VirtualStore): number => {\n  return max(store.$getTotalSize(), store.$getViewportSize());\n};\n\n/**\n * @internal\n */\nexport const isInitialMeasurementDone = (store: VirtualStore): boolean => {\n  return !!store.$getViewportSize();\n};\n\ntype Subscriber = (sync?: boolean) => void;\n\n/** @internal */\nexport type StateVersion =\n  number & {} /* hack for typescript to pretend as not falsy */;\n\n/**\n * @internal\n */\nexport type VirtualStore = {\n  $getStateVersion(): StateVersion;\n  $getCacheSnapshot(): CacheSnapshot;\n  $getRange(): ItemsRange;\n  $findStartIndex(): number;\n  $findEndIndex(): number;\n  $isUnmeasuredItem(index: number): boolean;\n  $getItemOffset(index: number): number;\n  $getItemSize(index: number): number;\n  $getItemsLength(): number;\n  $getScrollOffset(): number;\n  $isScrolling(): boolean;\n  $getViewportSize(): number;\n  $getStartSpacerSize(): number;\n  $getTotalSize(): number;\n  _flushJump(): [number, boolean];\n  $subscribe(target: number, cb: Subscriber): () => void;\n  $update(...action: Actions): void;\n  _hasUnmeasuredItemsInFrozenRange(): boolean;\n};\n\n/**\n * @internal\n */\nexport const createVirtualStore = (\n  elementsCount: number,\n  itemSize: number = 40,\n  overscan: number = 4,\n  ssrCount: number = 0,\n  cacheSnapshot?: CacheSnapshot | undefined,\n  shouldAutoEstimateItemSize: boolean = false\n): VirtualStore => {\n  let isSSR = !!ssrCount;\n  let stateVersion: StateVersion = 1;\n  let viewportSize = 0;\n  let startSpacerSize = 0;\n  let scrollOffset = 0;\n  let jump = 0;\n  let pendingJump = 0;\n  let _flushedJump = 0;\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _scrollMode: ScrollMode = SCROLL_BY_NATIVE;\n  let _frozenRange: ItemsRange | null = isSSR\n    ? [0, max(ssrCount - 1, 0)]\n    : NULL;\n  let _prevRange: ItemsRange = [0, 0];\n  let _totalMeasuredSize = 0;\n\n  const cache = initCache(\n    elementsCount,\n    itemSize,\n    cacheSnapshot as unknown as InternalCacheSnapshot | undefined\n  );\n  const subscribers = new Set<[number, Subscriber]>();\n  const getRelativeScrollOffset = () => scrollOffset - startSpacerSize;\n  const getVisibleOffset = () => getRelativeScrollOffset() + pendingJump + jump;\n  const getRange = (offset: number) => {\n    return computeRange(cache, offset, viewportSize, _prevRange[0]);\n  };\n  const getTotalSize = (): number => computeTotalSize(cache);\n  const getItemOffset = (index: number): number => {\n    return computeStartOffset(cache, index) - pendingJump;\n  };\n  const getItemSize = (index: number): number => {\n    return _getItemSize(cache, index);\n  };\n\n  const applyJump = (j: number) => {\n    if (j) {\n      // In iOS WebKit browsers, updating scroll position will stop scrolling so it have to be deferred during scrolling.\n      if (isIOSWebKit() && _scrollDirection !== SCROLL_IDLE) {\n        pendingJump += j;\n      } else {\n        jump += j;\n      }\n    }\n  };\n\n  return {\n    $getStateVersion: () => stateVersion,\n    $getCacheSnapshot: () => {\n      return takeCacheSnapshot(cache) as unknown as CacheSnapshot;\n    },\n    $getRange: () => {\n      let startIndex: number;\n      let endIndex: number;\n      if (_flushedJump) {\n        // Return previous range for consistent render until next scroll event comes in.\n        // And it must be clamped. https://github.com/inokawa/virtua/issues/597\n        [startIndex, endIndex] = _prevRange;\n      } else {\n        [startIndex, endIndex] = _prevRange = getRange(\n          max(0, getVisibleOffset())\n        );\n        if (_frozenRange) {\n          startIndex = min(startIndex, _frozenRange[0]);\n          endIndex = max(endIndex, _frozenRange[1]);\n        }\n      }\n\n      if (_scrollDirection !== SCROLL_DOWN) {\n        startIndex -= max(0, overscan);\n      }\n      if (_scrollDirection !== SCROLL_UP) {\n        endIndex += max(0, overscan);\n      }\n      return [max(startIndex, 0), min(endIndex, cache._length - 1)];\n    },\n    $findStartIndex: () => findIndex(cache, getVisibleOffset()),\n    $findEndIndex: () => findIndex(cache, getVisibleOffset() + viewportSize),\n    $isUnmeasuredItem: (index) => cache._sizes[index] === UNCACHED,\n    _hasUnmeasuredItemsInFrozenRange: () => {\n      if (!_frozenRange) return false;\n      return cache._sizes\n        .slice(\n          max(0, _frozenRange[0] - 1),\n          min(cache._length - 1, _frozenRange[1] + 1) + 1\n        )\n        .includes(UNCACHED);\n    },\n    $getItemOffset: getItemOffset,\n    $getItemSize: getItemSize,\n    $getItemsLength: () => cache._length,\n    $getScrollOffset: () => scrollOffset,\n    $isScrolling: () => _scrollDirection !== SCROLL_IDLE,\n    $getViewportSize: () => viewportSize,\n    $getStartSpacerSize: () => startSpacerSize,\n    $getTotalSize: getTotalSize,\n    _flushJump: () => {\n      _flushedJump = jump;\n      jump = 0;\n      return [\n        _flushedJump,\n        // Use absolute position not to exceed scrollable bounds\n        _scrollMode === SCROLL_BY_SHIFT ||\n          // https://github.com/inokawa/virtua/discussions/475\n          getRelativeScrollOffset() + viewportSize >= getTotalSize(),\n      ];\n    },\n    $subscribe: (target, cb) => {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    $update: (type, payload): void => {\n      let shouldFlushPendingJump: boolean | undefined;\n      let shouldSync: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_SCROLL: {\n          const flushedJump = _flushedJump;\n          _flushedJump = 0;\n\n          const delta = payload - scrollOffset;\n          const distance = abs(delta);\n\n          // Scroll event after jump compensation is not reliable because it may result in the opposite direction.\n          // The delta of artificial scroll may not be equal with the jump because it may be batched with other scrolls.\n          // And at least in latest Chrome/Firefox/Safari in 2023, setting value to scrollTop/scrollLeft can lose subpixel because its integer (sometimes float probably depending on dpr).\n          const isJustJumped = flushedJump && distance < abs(flushedJump) + 1;\n\n          // Scroll events are dispatched enough so it's ok to skip some of them.\n          if (\n            !isJustJumped &&\n            // Ignore until manual scrolling\n            _scrollMode === SCROLL_BY_NATIVE\n          ) {\n            _scrollDirection = delta < 0 ? SCROLL_UP : SCROLL_DOWN;\n          }\n\n          // TODO This will cause glitch in reverse infinite scrolling. Disable this until better solution is found.\n          // if (\n          //   pendingJump &&\n          //   ((_scrollDirection === SCROLL_UP &&\n          //     payload - max(pendingJump, 0) <= 0) ||\n          //     (_scrollDirection === SCROLL_DOWN &&\n          //       payload - min(pendingJump, 0) >= getScrollOffsetMax()))\n          // ) {\n          //   // Flush if almost reached to start or end\n          //   shouldFlushPendingJump = true;\n          // }\n\n          if (isSSR) {\n            _frozenRange = NULL;\n            isSSR = false;\n          }\n\n          scrollOffset = payload;\n          mutated = UPDATE_SCROLL_EVENT;\n\n          // Skip if offset is not changed\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n          const relativeOffset = getRelativeScrollOffset();\n          if (\n            relativeOffset >= -viewportSize &&\n            relativeOffset <= getTotalSize()\n          ) {\n            mutated += UPDATE_VIRTUAL_STATE;\n\n            // Update synchronously if scrolled a lot\n            shouldSync = distance > viewportSize;\n          }\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          mutated = UPDATE_SCROLL_END_EVENT;\n          if (_scrollDirection !== SCROLL_IDLE) {\n            shouldFlushPendingJump = true;\n            mutated += UPDATE_VIRTUAL_STATE;\n          }\n          _scrollDirection = SCROLL_IDLE;\n          _scrollMode = SCROLL_BY_NATIVE;\n          _frozenRange = NULL;\n          break;\n        }\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          // Calculate jump by resize to minimize junks in appearance\n          applyJump(\n            updated.reduce((acc, [index, size]) => {\n              if (\n                // Keep distance from end during shifting\n                _scrollMode === SCROLL_BY_SHIFT ||\n                (_frozenRange\n                  ? // https://github.com/inokawa/virtua/issues/380\n                    // https://github.com/inokawa/virtua/issues/590\n                    !isSSR && index < _frozenRange[0]\n                  : // Otherwise we should maintain visible position\n                    getItemOffset(index) +\n                      // https://github.com/inokawa/virtua/issues/385\n                      (_scrollDirection === SCROLL_IDLE &&\n                      _scrollMode === SCROLL_BY_NATIVE\n                        ? getItemSize(index)\n                        : 0) <\n                    getRelativeScrollOffset())\n              ) {\n                acc += size - getItemSize(index);\n              }\n              return acc;\n            }, 0)\n          );\n\n          // Update item sizes\n          for (const [index, size] of updated) {\n            const prevSize = getItemSize(index);\n            const isInitialMeasurement = setItemSize(cache, index, size);\n\n            if (shouldAutoEstimateItemSize) {\n              _totalMeasuredSize += isInitialMeasurement\n                ? size\n                : size - prevSize;\n            }\n          }\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            viewportSize &&\n            // If the total size is lower than the viewport, the item may be a empty state\n            _totalMeasuredSize > viewportSize\n          ) {\n            applyJump(\n              estimateDefaultItemSize(\n                cache,\n                findIndex(cache, getVisibleOffset())\n              )\n            );\n            shouldAutoEstimateItemSize = false;\n          }\n\n          mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n\n          // Synchronous update is necessary in current design to minimize visible glitch in concurrent rendering.\n          // However this seems to be the main cause of the errors from ResizeObserver.\n          // https://github.com/inokawa/virtua/issues/470\n          //\n          // And in React, synchronous update with flushSync after asynchronous update will overtake the asynchronous one.\n          // If items resize happens just after scroll, race condition can occur depending on implementation.\n          shouldSync = true;\n          break;\n        }\n        case ACTION_VIEWPORT_RESIZE: {\n          if (viewportSize !== payload) {\n            viewportSize = payload;\n            mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n          }\n          break;\n        }\n        case ACTION_ITEMS_LENGTH_CHANGE: {\n          if (payload[1]) {\n            applyJump(updateCacheLength(cache, payload[0], true));\n            _scrollMode = SCROLL_BY_SHIFT;\n            mutated = UPDATE_VIRTUAL_STATE;\n          } else {\n            updateCacheLength(cache, payload[0]);\n            // https://github.com/inokawa/virtua/issues/552\n            // https://github.com/inokawa/virtua/issues/557\n            mutated = UPDATE_VIRTUAL_STATE;\n          }\n          break;\n        }\n        case ACTION_START_OFFSET_CHANGE: {\n          startSpacerSize = payload;\n          break;\n        }\n        case ACTION_MANUAL_SCROLL: {\n          _scrollMode = SCROLL_BY_MANUAL_SCROLL;\n          break;\n        }\n        case ACTION_BEFORE_MANUAL_SMOOTH_SCROLL: {\n          _frozenRange = getRange(payload);\n          mutated = UPDATE_VIRTUAL_STATE;\n          break;\n        }\n      }\n\n      if (mutated) {\n        stateVersion = (stateVersion & MAX_INT_32) + 1;\n\n        if (shouldFlushPendingJump && pendingJump) {\n          jump += pendingJump;\n          pendingJump = 0;\n        }\n\n        subscribers.forEach(([target, cb]) => {\n          // Early return to skip React's computation\n          if (!(mutated & target)) {\n            return;\n          }\n          // https://github.com/facebook/react/issues/25191\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\n          cb(shouldSync);\n        });\n      }\n    },\n  };\n};\n","import {\n  getCurrentDocument,\n  getCurrentWindow,\n  isIOSWebKit,\n  isRTLDocument,\n  isSmoothScrollSupported,\n} from \"./environment\";\nimport {\n  ACTION_SCROLL,\n  type VirtualStore,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE_EVENT,\n  ACTION_MANUAL_SCROLL,\n  ACTION_BEFORE_MANUAL_SMOOTH_SCROLL,\n  ACTION_START_OFFSET_CHANGE,\n  isInitialMeasurementDone,\n} from \"./store\";\nimport { type ScrollToIndexOpts } from \"./types\";\nimport { clamp, microtask, NULL } from \"./utils\";\n\nconst timeout = setTimeout;\n\nconst debounce = <T extends () => void>(fn: T, ms: number) => {\n  let id: ReturnType<typeof setTimeout> | undefined | null;\n\n  const cancel = () => {\n    if (id != NULL) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = NULL;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\n/**\n * scrollLeft is negative value in rtl direction.\n *\n * left  right\n * 0     100    spec compliant (ltr)\n * -100  0      spec compliant (rtl)\n * https://github.com/othree/jquery.rtl-scroll-type\n */\nconst normalizeOffset = (offset: number, isHorizontal: boolean): number => {\n  if (isHorizontal && isRTLDocument()) {\n    return -offset;\n  } else {\n    return offset;\n  }\n};\n\nconst createScrollObserver = (\n  store: VirtualStore,\n  viewport: HTMLElement | Window,\n  isHorizontal: boolean,\n  getScrollOffset: () => number,\n  updateScrollOffset: (\n    value: number,\n    shift: boolean,\n    isMomentumScrolling: boolean\n  ) => void,\n  getStartOffset?: () => number\n) => {\n  const now = Date.now;\n\n  let lastScrollTime = 0;\n  let wheeling = false;\n  let touching = false;\n  let justTouchEnded = false;\n  let stillMomentumScrolling = false;\n\n  const onScrollEnd = debounce(() => {\n    if (wheeling || touching) {\n      wheeling = false;\n\n      // Wait while wheeling or touching\n      onScrollEnd();\n      return;\n    }\n\n    justTouchEnded = false;\n\n    store.$update(ACTION_SCROLL_END);\n  }, 150);\n\n  const onScroll = () => {\n    lastScrollTime = now();\n\n    if (justTouchEnded) {\n      stillMomentumScrolling = true;\n    }\n\n    if (getStartOffset) {\n      store.$update(ACTION_START_OFFSET_CHANGE, getStartOffset());\n    }\n    store.$update(ACTION_SCROLL, getScrollOffset());\n\n    onScrollEnd();\n  };\n\n  // Infer scroll state also from wheel events\n  // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n  const onWheel = ((e: WheelEvent) => {\n    if (\n      wheeling ||\n      // Scroll start should be detected with scroll event\n      !store.$isScrolling() ||\n      // Probably a pinch-to-zoom gesture\n      e.ctrlKey\n    ) {\n      return;\n    }\n\n    const timeDelta = now() - lastScrollTime;\n    if (\n      // Check if wheel event occurs some time after scrolling\n      150 > timeDelta &&\n      50 < timeDelta &&\n      // Get delta before checking deltaMode for firefox behavior\n      // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n      (isHorizontal ? e.deltaX : e.deltaY)\n    ) {\n      wheeling = true;\n    }\n  }) as (e: Event) => void; // FIXME type error. why only here?\n\n  const onTouchStart = () => {\n    touching = true;\n    justTouchEnded = stillMomentumScrolling = false;\n  };\n  const onTouchEnd = () => {\n    touching = false;\n    if (isIOSWebKit()) {\n      justTouchEnded = true;\n    }\n  };\n\n  viewport.addEventListener(\"scroll\", onScroll);\n  viewport.addEventListener(\"wheel\", onWheel, { passive: true });\n  viewport.addEventListener(\"touchstart\", onTouchStart, { passive: true });\n  viewport.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n\n  return {\n    _dispose: () => {\n      viewport.removeEventListener(\"scroll\", onScroll);\n      viewport.removeEventListener(\"wheel\", onWheel);\n      viewport.removeEventListener(\"touchstart\", onTouchStart);\n      viewport.removeEventListener(\"touchend\", onTouchEnd);\n      onScrollEnd._cancel();\n    },\n    _fixScrollJump: () => {\n      const [jump, shift] = store._flushJump();\n      if (!jump) return;\n      updateScrollOffset(\n        normalizeOffset(jump, isHorizontal),\n        shift,\n        stillMomentumScrolling\n      );\n      stillMomentumScrolling = false;\n\n      if (shift && store.$getViewportSize() > store.$getTotalSize()) {\n        // In this case applying jump may not cause scroll.\n        // Current logic expects scroll event occurs after applying jump so we dispatch it manually.\n        store.$update(ACTION_SCROLL, getScrollOffset());\n      }\n    },\n  };\n};\n\ntype ScrollObserver = ReturnType<typeof createScrollObserver>;\n\n/**\n * @internal\n */\nexport type Scroller = {\n  $observe: (viewportElement: HTMLElement) => void;\n  $dispose(): void;\n  $scrollTo: (offset: number) => void;\n  $scrollBy: (offset: number) => void;\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): Scroller => {\n  let viewportElement: HTMLElement | undefined;\n  let scrollObserver: ScrollObserver | undefined;\n  let cancelScroll: (() => void) | undefined;\n  const scrollOffsetKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n  const overflowKey = isHorizontal ? \"overflowX\" : \"overflowY\";\n\n  // The given offset will be clamped by browser\n  // https://drafts.csswg.org/cssom-view/#dom-element-scrolltop\n  const scheduleImperativeScroll = async (\n    getTargetOffset: () => number,\n    smooth?: boolean\n  ) => {\n    if (!viewportElement) {\n      // Wait for element assign. The element may be undefined if scrollRef prop is used and scroll is scheduled on mount.\n      microtask(() => scheduleImperativeScroll(getTargetOffset, smooth));\n      return;\n    }\n\n    if (cancelScroll) {\n      // Cancel waiting scrollTo\n      cancelScroll();\n    }\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      // Wait for the scroll destination items to be measured.\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          cancelScroll = reject;\n\n          // Resize event may not happen when the window/tab is not visible, or during browser back in Safari.\n          // We have to wait for the initial measurement to avoid failing imperative scroll on mount.\n          // https://github.com/inokawa/virtua/issues/450\n          if (isInitialMeasurementDone(store)) {\n            // Reject when items around scroll destination completely measured\n            timeout(reject, 150);\n          }\n        }),\n        store.$subscribe(UPDATE_SIZE_EVENT, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store.$update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInFrozenRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          // canceled\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      viewportElement.scrollTo({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n          getTargetOffset(),\n          isHorizontal\n        ),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          viewportElement[scrollOffsetKey] = normalizeOffset(\n            getTargetOffset(),\n            isHorizontal\n          );\n          store.$update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          // canceled or finished\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    $observe(viewport) {\n      viewportElement = viewport;\n\n      scrollObserver = createScrollObserver(\n        store,\n        viewport,\n        isHorizontal,\n        () => normalizeOffset(viewport[scrollOffsetKey], isHorizontal),\n        (jump, shift, isMomentumScrolling) => {\n          // If we update scroll position while touching on iOS, the position will be reverted.\n          // However iOS WebKit fires touch events only once at the beginning of momentum scrolling.\n          // That means we have no reliable way to confirm still touched or not if user touches more than once during momentum scrolling...\n          // This is a hack for the suspectable situations, inspired by https://github.com/prud/ios-overflow-scroll-to-top\n          if (isMomentumScrolling) {\n            const style = viewport.style;\n            const prev = style[overflowKey];\n            style[overflowKey] = \"hidden\";\n            timeout(() => {\n              style[overflowKey] = prev;\n            });\n          }\n\n          if (shift) {\n            viewport[scrollOffsetKey] = store.$getScrollOffset() + jump;\n            // https://github.com/inokawa/virtua/issues/357\n            cancelScroll && cancelScroll();\n          } else {\n            viewport[scrollOffsetKey] += jump;\n          }\n        }\n      );\n    },\n    $dispose() {\n      scrollObserver && scrollObserver._dispose();\n    },\n    $scrollTo(offset) {\n      scheduleImperativeScroll(() => offset);\n    },\n    $scrollBy(offset) {\n      offset += store.$getScrollOffset();\n      scheduleImperativeScroll(() => offset);\n    },\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\n      index = clamp(index, 0, store.$getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store.$getItemOffset(index);\n        const scrollOffset = store.$getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store.$getItemSize(index) >\n          scrollOffset + store.$getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          // already completely visible\n          return;\n        }\n      }\n\n      scheduleImperativeScroll(() => {\n        return (\n          offset +\n          store.$getStartSpacerSize() +\n          store.$getItemOffset(index) +\n          (align === \"end\"\n            ? store.$getItemSize(index) - store.$getViewportSize()\n            : align === \"center\"\n              ? (store.$getItemSize(index) - store.$getViewportSize()) / 2\n              : 0)\n        );\n      }, smooth);\n    },\n    $fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type WindowScroller = {\n  $observe(containerElement: HTMLElement): void;\n  $dispose(): void;\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  let containerElement: HTMLElement | undefined;\n  let scrollObserver: ScrollObserver | undefined;\n  let cancelScroll: (() => void) | undefined;\n\n  const calcOffsetToViewport = (\n    node: HTMLElement,\n    viewport: HTMLElement,\n    window: Window,\n    isHorizontal: boolean,\n    offset: number = 0\n  ): number => {\n    // TODO calc offset only when it changes (maybe impossible)\n    const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n    const offsetSum =\n      offset +\n      (isHorizontal && isRTLDocument()\n        ? window.innerWidth - node[offsetKey] - node.offsetWidth\n        : node[offsetKey]);\n\n    const parent = node.offsetParent;\n    if (node === viewport || !parent) {\n      return offsetSum;\n    }\n\n    return calcOffsetToViewport(\n      parent as HTMLElement,\n      viewport,\n      window,\n      isHorizontal,\n      offsetSum\n    );\n  };\n\n  const scheduleImperativeScroll = async (\n    getTargetOffset: () => number,\n    smooth?: boolean\n  ) => {\n    if (!containerElement) {\n      // Wait for element assign\n      microtask(() => scheduleImperativeScroll(getTargetOffset, smooth));\n      return;\n    }\n\n    if (cancelScroll) {\n      cancelScroll();\n    }\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          cancelScroll = reject;\n\n          if (isInitialMeasurementDone(store)) {\n            timeout(reject, 150);\n          }\n        }),\n        store.$subscribe(UPDATE_SIZE_EVENT, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    const window = getCurrentWindow(getCurrentDocument(containerElement));\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store.$update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInFrozenRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      window.scroll({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n          getTargetOffset(),\n          isHorizontal\n        ),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          window.scroll({\n            [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n              getTargetOffset(),\n              isHorizontal\n            ),\n          });\n          store.$update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    $observe(container) {\n      containerElement = container;\n      const scrollOffsetKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n\n      const document = getCurrentDocument(container);\n      const window = getCurrentWindow(document);\n      const documentBody = document.body;\n\n      scrollObserver = createScrollObserver(\n        store,\n        window,\n        isHorizontal,\n        () => normalizeOffset(window[scrollOffsetKey], isHorizontal),\n        (jump, shift) => {\n          // TODO support case two window scrollers exist in the same view\n          if (shift) {\n            window.scroll({\n              [isHorizontal ? \"left\" : \"top\"]: store.$getScrollOffset() + jump,\n            });\n          } else {\n            window.scrollBy(isHorizontal ? jump : 0, isHorizontal ? 0 : jump);\n          }\n        },\n        () =>\n          calcOffsetToViewport(container, documentBody, window, isHorizontal)\n      );\n    },\n    $dispose() {\n      scrollObserver && scrollObserver._dispose();\n      containerElement = undefined;\n    },\n    $fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\n      if (!containerElement) return;\n\n      index = clamp(index, 0, store.$getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store.$getItemOffset(index);\n        const scrollOffset = store.$getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store.$getItemSize(index) >\n          scrollOffset + store.$getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          return;\n        }\n      }\n\n      const document = getCurrentDocument(containerElement);\n      const window = getCurrentWindow(document);\n      const html = document.documentElement;\n      const getScrollbarSize = () =>\n        store.$getViewportSize() -\n        (isHorizontal ? html.clientWidth : html.clientHeight);\n\n      scheduleImperativeScroll(() => {\n        return (\n          offset +\n          // Calculate target scroll position including container's offset from document\n          calcOffsetToViewport(\n            containerElement!,\n            document.body,\n            window,\n            isHorizontal\n          ) +\n          // store._getStartSpacerSize() +\n          store.$getItemOffset(index) +\n          (align === \"end\"\n            ? store.$getItemSize(index) -\n              (store.$getViewportSize() - getScrollbarSize())\n            : align === \"center\"\n              ? (store.$getItemSize(index) -\n                  (store.$getViewportSize() - getScrollbarSize())) /\n                2\n              : 0)\n        );\n      }, smooth);\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type GridScroller = {\n  $observe: (viewportElement: HTMLElement) => void;\n  $dispose(): void;\n  $scrollTo: (offsetX: number, offsetY: number) => void;\n  $scrollBy: (offsetX: number, offsetY: number) => void;\n  $scrollToIndex: (indexX: number, indexY: number) => void;\n  $fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createGridScroller = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n): GridScroller => {\n  const vScroller = createScroller(vStore, false);\n  const hScroller = createScroller(hStore, true);\n  return {\n    $observe(viewportElement) {\n      vScroller.$observe(viewportElement);\n      hScroller.$observe(viewportElement);\n    },\n    $dispose() {\n      vScroller.$dispose();\n      hScroller.$dispose();\n    },\n    $scrollTo(offsetX, offsetY) {\n      vScroller.$scrollTo(offsetY);\n      hScroller.$scrollTo(offsetX);\n    },\n    $scrollBy(offsetX, offsetY) {\n      vScroller.$scrollBy(offsetY);\n      hScroller.$scrollBy(offsetX);\n    },\n    $scrollToIndex(indexX, indexY) {\n      vScroller.$scrollToIndex(indexY);\n      hScroller.$scrollToIndex(indexX);\n    },\n    $fixScrollJump() {\n      vScroller.$fixScrollJump();\n      hScroller.$fixScrollJump();\n    },\n  };\n};\n","import { getCurrentDocument, getCurrentWindow } from \"./environment\";\nimport {\n  ACTION_ITEM_RESIZE,\n  ACTION_VIEWPORT_RESIZE,\n  type VirtualStore,\n} from \"./store\";\nimport { type ItemResize } from \"./types\";\nimport { max, NULL } from \"./utils\";\n\nconst createResizeObserver = (cb: ResizeObserverCallback) => {\n  let ro: ResizeObserver | undefined;\n\n  return {\n    _observe(e: HTMLElement) {\n      // Initialize ResizeObserver lazily for SSR\n      // https://www.w3.org/TR/resize-observer/#intro\n      (\n        ro ||\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1491739\n        (ro = new (getCurrentWindow(getCurrentDocument(e)).ResizeObserver)(cb))\n      ).observe(e);\n    },\n    _unobserve(e: HTMLElement) {\n      ro!.unobserve(e);\n    },\n    _dispose() {\n      ro && ro.disconnect();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type ItemResizeObserver = (el: HTMLElement, i: number) => () => void;\n\ninterface ListResizer {\n  $observeRoot(viewportElement: HTMLElement): void;\n  $observeItem: ItemResizeObserver;\n  $dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let viewportElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        store.$update(ACTION_VIEWPORT_RESIZE, contentRect[sizeKey]);\n      } else {\n        const index = mountedIndexes.get(target);\n        if (index != NULL) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n    }\n\n    if (resizes.length) {\n      store.$update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  return {\n    $observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    $observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose: resizeObserver._dispose,\n  };\n};\n\ninterface WindowListResizer {\n  $observeRoot(container: HTMLElement): void;\n  $observeItem: ItemResizeObserver;\n  $dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      const index = mountedIndexes.get(target);\n      if (index != NULL) {\n        resizes.push([index, contentRect[sizeKey]]);\n      }\n    }\n\n    if (resizes.length) {\n      store.$update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  let cleanupOnWindowResize: (() => void) | undefined;\n\n  return {\n    $observeRoot(container) {\n      const window = getCurrentWindow(getCurrentDocument(container));\n      const onWindowResize = () => {\n        store.$update(ACTION_VIEWPORT_RESIZE, window[windowSizeKey]);\n      };\n      window.addEventListener(\"resize\", onWindowResize);\n      onWindowResize();\n\n      cleanupOnWindowResize = () => {\n        window.removeEventListener(\"resize\", onWindowResize);\n      };\n    },\n    $observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose() {\n      cleanupOnWindowResize && cleanupOnWindowResize();\n      resizeObserver._dispose();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let viewportElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizedRows = new Set<number>();\n    const resizedCols = new Set<number>();\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        vStore.$update(ACTION_VIEWPORT_RESIZE, contentRect[heightKey]);\n        hStore.$update(ACTION_VIEWPORT_RESIZE, contentRect[widthKey]);\n      } else {\n        const cell = mountedIndexes.get(target);\n        if (cell) {\n          const [rowIndex, colIndex] = cell;\n          const key = getKey(rowIndex, colIndex);\n          const prevSize = sizeCache.get(key);\n          const size: CellSize = [\n            contentRect[heightKey],\n            contentRect[widthKey],\n          ];\n          let rowResized: boolean | undefined;\n          let colResized: boolean | undefined;\n          if (!prevSize) {\n            rowResized = colResized = true;\n          } else {\n            if (prevSize[0] !== size[0]) {\n              rowResized = true;\n            }\n            if (prevSize[1] !== size[1]) {\n              colResized = true;\n            }\n          }\n          if (rowResized) {\n            resizedRows.add(rowIndex);\n          }\n          if (colResized) {\n            resizedCols.add(colIndex);\n          }\n          if (rowResized || colResized) {\n            sizeCache.set(key, size);\n          }\n        }\n      }\n    }\n\n    if (resizedRows.size) {\n      const heightResizes: ItemResize[] = [];\n      resizedRows.forEach((rowIndex) => {\n        let maxHeight = 0;\n        maybeCachedColIndexes.forEach((colIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxHeight = max(maxHeight, size[0]);\n          }\n        });\n        if (maxHeight) {\n          heightResizes.push([rowIndex, maxHeight]);\n        }\n      });\n      vStore.$update(ACTION_ITEM_RESIZE, heightResizes);\n    }\n    if (resizedCols.size) {\n      const widthResizes: ItemResize[] = [];\n      resizedCols.forEach((colIndex) => {\n        let maxWidth = 0;\n        maybeCachedRowIndexes.forEach((rowIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxWidth = max(maxWidth, size[1]);\n          }\n        });\n        if (maxWidth) {\n          widthResizes.push([colIndex, maxWidth]);\n        }\n      });\n      hStore.$update(ACTION_ITEM_RESIZE, widthResizes);\n    }\n  });\n\n  return {\n    $observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    $observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    $dispose: resizeObserver._dispose,\n  };\n};\n\n/**\n * @internal\n */\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  defineComponent,\n  watch,\n  StyleValue,\n  PropType,\n  VNode,\n  NativeElements,\n  computed,\n  Ref,\n} from \"vue\";\nimport {\n  ItemResizeObserver,\n  isRTLDocument,\n  StateVersion,\n  VirtualStore,\n} from \"../core\";\nimport { ItemProps } from \"./utils\";\n\n/**\n * @internal\n */\nexport const ListItem = /*#__PURE__*/ defineComponent({\n  props: {\n    _stateVersion: {\n      type: Object as PropType<Ref<StateVersion>>,\n      required: true,\n    },\n    _store: { type: Object as PropType<VirtualStore>, required: true },\n    _children: { type: Object as PropType<VNode>, required: true },\n    _resizer: {\n      type: Function as PropType<ItemResizeObserver>,\n      required: true,\n    },\n    _index: { type: Number, required: true },\n    _isHorizontal: { type: Boolean },\n    _isSSR: { type: Boolean },\n    _as: { type: String as PropType<keyof NativeElements>, required: true },\n    _itemProps: Object as PropType<ReturnType<ItemProps>>,\n  },\n  setup(props) {\n    const elementRef = ref<HTMLDivElement>();\n\n    const offset = computed(\n      () =>\n        props._stateVersion.value && props._store.$getItemOffset(props._index)\n    );\n    const hide = computed(\n      () =>\n        props._stateVersion.value &&\n        props._store.$isUnmeasuredItem(props._index)\n    );\n\n    // The index may be changed if elements are inserted to or removed from the start of props.children\n    watch(\n      () => elementRef.value && props._index,\n      (_, __, onCleanup) => {\n        onCleanup(props._resizer(elementRef.value!, props._index));\n      },\n      {\n        flush: \"post\",\n      }\n    );\n\n    return () => {\n      const {\n        _children: children,\n        _isHorizontal: isHorizontal,\n        _isSSR: isSSR,\n        _as: Element,\n      } = props;\n      const isHide = hide.value;\n\n      const { style: styleProp, ...rest } = props._itemProps ?? {};\n\n      const style: StyleValue = {\n        position: isHide && isSSR ? undefined : \"absolute\",\n        [isHorizontal ? \"height\" : \"width\"]: \"100%\",\n        [isHorizontal ? \"top\" : \"left\"]: \"0px\",\n        [isHorizontal ? (isRTLDocument() ? \"right\" : \"left\") : \"top\"]:\n          offset.value + \"px\",\n        visibility: !isHide || isSSR ? \"visible\" : \"hidden\",\n        ...styleProp,\n      };\n      if (isHorizontal) {\n        style.display = \"flex\";\n      }\n\n      return (\n        <Element ref={elementRef} style={style} {...rest}>\n          {children}\n        </Element>\n      );\n    };\n  },\n});\n","import { CSSProperties, VNode } from \"vue\";\nimport { ItemsRange } from \"../core\";\n\n/**\n * @internal\n */\nexport const getKey = (e: VNode, i: number): Exclude<VNode[\"key\"], null> => {\n  const key = e.key;\n  return key != null ? key : \"_\" + i;\n};\n\n/**\n * @internal\n */\nexport const isSameRange = (prev: ItemsRange, next: ItemsRange): boolean => {\n  return prev[0] === next[0] && prev[1] === next[1];\n};\n\nexport type ItemProps = (payload: {\n  item: any;\n  index: number;\n}) => { [key: string]: any; style?: CSSProperties; class?: string } | undefined;\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  onMounted,\n  defineComponent,\n  onUnmounted,\n  VNode,\n  watch,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  PropType,\n  NativeElements,\n  computed,\n} from \"vue\";\nimport {\n  UPDATE_SCROLL_EVENT,\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  getScrollSize,\n  ACTION_START_OFFSET_CHANGE,\n  createResizer,\n  createScroller,\n  ItemsRange,\n  ScrollToIndexOpts,\n  microtask,\n  sort,\n} from \"../core\";\nimport { ListItem } from \"./ListItem\";\nimport { getKey, isSameRange, ItemProps } from \"./utils\";\n\nexport interface VirtualizerHandle {\n  /**\n   * Get current scrollTop, or scrollLeft if horizontal: true.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight, or scrollWidth if horizontal: true.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight, or offsetWidth if horizontal: true.\n   */\n  readonly viewportSize: number;\n  /**\n   * Find the start index of visible range of items.\n   */\n  findStartIndex: () => number;\n  /**\n   * Find the end index of visible range of items.\n   */\n  findEndIndex: () => number;\n  /**\n   * Get item offset from start.\n   * @param index index of item\n   */\n  getItemOffset(index: number): number;\n  /**\n   * Get item size.\n   * @param index index of item\n   */\n  getItemSize(index: number): number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param opts options\n   */\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: Number,\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * If you put an element before virtualizer, you have to define its height with this prop.\n   */\n  startMargin: { type: Number, default: 0 },\n  /**\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.\n   */\n  ssrCount: Number,\n  /**\n   * Reference to the scrollable element. The default will get the direct parent element of virtualizer.\n   */\n  scrollRef: Object as PropType<HTMLElement>,\n  /**\n   * Component or element type for container element.\n   * @defaultValue \"div\"\n   */\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n  /**\n   * Component or element type for item element.\n   * @defaultValue \"div\"\n   */\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n  /**\n   * A function that provides properties/attributes for item element\n   *\n   * **This prop will be merged into `item` prop in the future**\n   */\n  itemProps: Function as PropType<ItemProps>,\n  /**\n   * List of indexes that should be always mounted, even when off screen.\n   */\n  keepMounted: Array as PropType<number[]>,\n} satisfies ComponentObjectPropsOptions;\n\nexport const Virtualizer = /*#__PURE__*/ defineComponent({\n  props: props,\n  emits: [\"scroll\", \"scrollEnd\"],\n  setup(props, { emit, expose, slots }) {\n    let isSSR = !!props.ssrCount;\n\n    const isHorizontal = props.horizontal;\n    const containerRef = ref<HTMLDivElement>();\n    const store = createVirtualStore(\n      props.data.length,\n      props.itemSize,\n      props.overscan,\n      props.ssrCount,\n      undefined,\n      !props.itemSize\n    );\n    const resizer = createResizer(store, isHorizontal);\n    const scroller = createScroller(store, isHorizontal);\n\n    const stateVersion = ref(store.$getStateVersion());\n    const unsubscribeStore = store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\n      stateVersion.value = store.$getStateVersion();\n    });\n\n    const unsubscribeOnScroll = store.$subscribe(UPDATE_SCROLL_EVENT, () => {\n      emit(\"scroll\", store.$getScrollOffset());\n    });\n    const unsubscribeOnScrollEnd = store.$subscribe(\n      UPDATE_SCROLL_END_EVENT,\n      () => {\n        emit(\"scrollEnd\");\n      }\n    );\n\n    const range = computed<ItemsRange>((prev) => {\n      stateVersion.value;\n      const next = store.$getRange();\n      if (prev && isSameRange(prev, next)) {\n        return prev;\n      }\n      return next;\n    });\n    const isScrolling = computed(\n      () => stateVersion.value && store.$isScrolling()\n    );\n    const totalSize = computed(\n      () => stateVersion.value && store.$getTotalSize()\n    );\n\n    onMounted(() => {\n      isSSR = false;\n\n      microtask(() => {\n        const assignScrollableElement = (e: HTMLElement) => {\n          resizer.$observeRoot(e);\n          scroller.$observe(e);\n        };\n        if (props.scrollRef) {\n          // parent's ref doesn't exist when onMounted is called\n          assignScrollableElement(props.scrollRef!);\n        } else {\n          assignScrollableElement(containerRef.value!.parentElement!);\n        }\n      });\n    });\n    onUnmounted(() => {\n      unsubscribeStore();\n      unsubscribeOnScroll();\n      unsubscribeOnScrollEnd();\n      resizer.$dispose();\n      scroller.$dispose();\n    });\n\n    watch(\n      () => props.data.length,\n      (count) => {\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    );\n    watch(\n      () => props.startMargin,\n      (value) => {\n        store.$update(ACTION_START_OFFSET_CHANGE, value);\n      },\n      { immediate: true }\n    );\n\n    watch(\n      [stateVersion],\n      () => {\n        scroller.$fixScrollJump();\n      },\n      { flush: \"post\" }\n    );\n\n    expose({\n      get scrollOffset() {\n        return store.$getScrollOffset();\n      },\n      get scrollSize() {\n        return getScrollSize(store);\n      },\n      get viewportSize() {\n        return store.$getViewportSize();\n      },\n      findStartIndex: store.$findStartIndex,\n      findEndIndex: store.$findEndIndex,\n      getItemOffset: store.$getItemOffset,\n      getItemSize: store.$getItemSize,\n      scrollToIndex: scroller.$scrollToIndex,\n      scrollTo: scroller.$scrollTo,\n      scrollBy: scroller.$scrollBy,\n    } satisfies VirtualizerHandle);\n\n    return () => {\n      const Element = props.as;\n      const ItemElement = props.item;\n\n      const [startIndex, endIndex] = range.value;\n      const total = totalSize.value;\n\n      const items: VNode[] = [];\n\n      function getListItem(i: number) {\n        const e = slots.default({ item: props.data![i]!, index: i })[0]!;\n        return (\n          <ListItem\n            key={getKey(e, i)}\n            _stateVersion={stateVersion}\n            _store={store}\n            _resizer={resizer.$observeItem}\n            _index={i}\n            _children={e}\n            _isHorizontal={isHorizontal}\n            _isSSR={isSSR}\n            _as={ItemElement}\n            _itemProps={props.itemProps?.({ item: props.data![i]!, index: i })}\n          />\n        );\n      }\n      for (let i = startIndex, j = endIndex; i <= j; i++) {\n        items.push(getListItem(i));\n      }\n\n      if (props.keepMounted) {\n        const startItems: VNode[] = [];\n        const endItems: VNode[] = [];\n        sort(props.keepMounted).forEach((index) => {\n          if (index < startIndex) {\n            startItems.push(getListItem(index));\n          }\n          if (index > endIndex) {\n            endItems.push(getListItem(index));\n          }\n        });\n\n        items.unshift(...startItems);\n        items.push(...endItems);\n      }\n\n      return (\n        <Element\n          ref={containerRef}\n          style={{\n            // contain: \"content\",\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n            flex: \"none\", // flex style can break layout\n            position: \"relative\",\n            visibility: \"hidden\", // TODO replace with other optimization methods\n            width: isHorizontal ? total + \"px\" : \"100%\",\n            height: isHorizontal ? \"100%\" : total + \"px\",\n            pointerEvents: isScrolling.value ? \"none\" : undefined,\n          }}\n        >\n          {items}\n        </Element>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  VirtualizerHandle,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked whenever scroll offset changes.\n     * @param offset Current scrollTop, or scrollLeft if horizontal: true.\n     */\n    scroll: (offset: number) => void;\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\n>);\n","/** @jsxImportSource vue */\nimport {\n  defineComponent,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  ref,\n  VNode,\n  PropType,\n} from \"vue\";\nimport { Virtualizer, VirtualizerHandle } from \"./Virtualizer\";\nimport { ItemProps } from \"./utils\";\n\ninterface VListHandle extends VirtualizerHandle {}\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: Number,\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.\n   */\n  ssrCount: Number,\n  /**\n   * A function that provides properties/attributes for item element\n   *\n   * **This prop will be merged into `item` prop in the future**\n   */\n  itemProps: Function as PropType<ItemProps>,\n  /**\n   * List of indexes that should be always mounted, even when off screen.\n   */\n  keepMounted: Array as PropType<number[]>,\n} satisfies ComponentObjectPropsOptions;\n\nexport const VList = /*#__PURE__*/ defineComponent({\n  props: props,\n  emits: [\"scroll\", \"scrollEnd\"],\n  setup(props, { emit, expose, slots }) {\n    const horizontal = props.horizontal;\n\n    const onScroll = (offset: number) => {\n      emit(\"scroll\", offset);\n    };\n    const onScrollEnd = () => {\n      emit(\"scrollEnd\");\n    };\n\n    const handle = ref<InstanceType<typeof Virtualizer>>();\n\n    expose({\n      get scrollOffset() {\n        return handle.value!.scrollOffset;\n      },\n      get scrollSize() {\n        return handle.value!.scrollSize;\n      },\n      get viewportSize() {\n        return handle.value!.viewportSize;\n      },\n      findStartIndex: (...args) => handle.value!.findStartIndex(...args),\n      findEndIndex: (...args) => handle.value!.findEndIndex(...args),\n      getItemOffset: (...args) => handle.value!.getItemOffset(...args),\n      getItemSize: (...args) => handle.value!.getItemSize(...args),\n      scrollToIndex: (...args) => handle.value!.scrollToIndex(...args),\n      scrollTo: (...args) => handle.value!.scrollTo(...args),\n      scrollBy: (...args) => handle.value!.scrollBy(...args),\n    } satisfies VListHandle);\n\n    return () => {\n      return (\n        <div\n          style={{\n            display: horizontal ? \"inline-block\" : \"block\",\n            [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\",\n            contain: \"strict\",\n            width: \"100%\",\n            height: \"100%\",\n          }}\n        >\n          <Virtualizer\n            ref={handle}\n            data={props.data}\n            overscan={props.overscan}\n            itemSize={props.itemSize}\n            itemProps={props.itemProps}\n            shift={props.shift}\n            ssrCount={props.ssrCount}\n            horizontal={horizontal}\n            keepMounted={props.keepMounted}\n            onScroll={onScroll}\n            onScrollEnd={onScrollEnd}\n          >\n            {slots}\n          </Virtualizer>\n        </div>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  VListHandle,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked whenever scroll offset changes.\n     * @param offset Current scrollTop, or scrollLeft if horizontal: true.\n     */\n    scroll: (offset: number) => void;\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\n>);\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  onMounted,\n  defineComponent,\n  onUnmounted,\n  VNode,\n  watch,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  PropType,\n  NativeElements,\n  computed,\n} from \"vue\";\nimport {\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  UPDATE_SCROLL_EVENT,\n  createWindowResizer,\n  createWindowScroller,\n  ItemsRange,\n  ScrollToIndexOpts,\n} from \"../core\";\nimport { ListItem } from \"./ListItem\";\nimport { getKey, isSameRange } from \"./utils\";\n\nexport interface WindowVirtualizerHandle {\n  /**\n   * Find the start index of visible range of items.\n   */\n  findStartIndex: () => number;\n  /**\n   * Find the end index of visible range of items.\n   */\n  findEndIndex: () => number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param opts options\n   */\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\n}\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: Number,\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * Component or element type for container element.\n   * @defaultValue \"div\"\n   */\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n  /**\n   * Component or element type for item element.\n   * @defaultValue \"div\"\n   */\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n} satisfies ComponentObjectPropsOptions;\n\nexport const WindowVirtualizer = /*#__PURE__*/ defineComponent({\n  props,\n  emits: [\"scroll\", \"scrollEnd\"],\n  setup(props, { emit, slots, expose }) {\n    const isHorizontal = props.horizontal;\n    const containerRef = ref<HTMLDivElement>();\n    const store = createVirtualStore(\n      props.data.length,\n      props.itemSize,\n      props.overscan,\n      undefined,\n      undefined,\n      !props.itemSize\n    );\n    const resizer = createWindowResizer(store, isHorizontal);\n    const scroller = createWindowScroller(store, isHorizontal);\n\n    const stateVersion = ref(store.$getStateVersion());\n    const unsubscribeStore = store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\n      stateVersion.value = store.$getStateVersion();\n    });\n\n    const unsubscribeOnScroll = store.$subscribe(UPDATE_SCROLL_EVENT, () => {\n      // https://github.com/inokawa/virtua/discussions/580\n      emit(\"scroll\");\n    });\n    const unsubscribeOnScrollEnd = store.$subscribe(\n      UPDATE_SCROLL_END_EVENT,\n      () => {\n        emit(\"scrollEnd\");\n      }\n    );\n\n    const range = computed<ItemsRange>((prev) => {\n      stateVersion.value;\n      const next = store.$getRange();\n      if (prev && isSameRange(prev, next)) {\n        return prev;\n      }\n      return next;\n    });\n    const isScrolling = computed(\n      () => stateVersion.value && store.$isScrolling()\n    );\n    const totalSize = computed(\n      () => stateVersion.value && store.$getTotalSize()\n    );\n\n    onMounted(() => {\n      const el = containerRef.value;\n      if (!el) return;\n      resizer.$observeRoot(el);\n      scroller.$observe(el);\n    });\n    onUnmounted(() => {\n      unsubscribeStore();\n      unsubscribeOnScroll();\n      unsubscribeOnScrollEnd();\n      resizer.$dispose();\n      scroller.$dispose();\n    });\n\n    watch(\n      () => props.data.length,\n      (count) => {\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    );\n\n    watch(\n      [stateVersion],\n      () => {\n        scroller.$fixScrollJump();\n      },\n      { flush: \"post\" }\n    );\n\n    expose({\n      findStartIndex: store.$findStartIndex,\n      findEndIndex: store.$findEndIndex,\n      scrollToIndex: scroller.$scrollToIndex,\n    } satisfies WindowVirtualizerHandle);\n\n    return () => {\n      const Element = props.as;\n      const ItemElement = props.item;\n\n      const [startIndex, endIndex] = range.value;\n      const total = totalSize.value;\n\n      const items: VNode[] = [];\n      for (let i = startIndex, j = endIndex; i <= j; i++) {\n        const e = slots.default({ item: props.data![i]!, index: i })[0]!;\n        items.push(\n          <ListItem\n            key={getKey(e, i)}\n            _stateVersion={stateVersion}\n            _store={store}\n            _resizer={resizer.$observeItem}\n            _index={i}\n            _children={e}\n            _isHorizontal={isHorizontal}\n            _as={ItemElement}\n          />\n        );\n      }\n\n      return (\n        <Element\n          ref={containerRef}\n          style={{\n            // contain: \"content\",\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n            flex: \"none\", // flex style can break layout\n            position: \"relative\",\n            visibility: \"hidden\", // TODO replace with other optimization methods\n            width: isHorizontal ? total + \"px\" : \"100%\",\n            height: isHorizontal ? \"100%\" : total + \"px\",\n            pointerEvents: isScrolling.value ? \"none\" : undefined,\n          }}\n        >\n          {items}\n        </Element>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  void,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked whenever scroll offset changes.\n     */\n    scroll: () => void;\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\n>);\n"],"names":["NULL","min","max","abs","floor","Math","clamp","value","minValue","maxValue","sort","arr","a","b","microtask","queueMicrotask","fn","Promise","resolve","then","once","cache","undefined","UNCACHED","fill","array","length","prepend","key","i","getItemSize","index","size","_sizes","_defaultItemSize","setItemSize","isInitialMeasurement","_computedOffsetIndex","computeOffset","_length","_offsets","top","findIndex","offset","low","high","mid","itemOffset","updateCacheLength","isShift","diff","splice","reduce","acc","removed","isBrowser","window","getDocumentElement","document","documentElement","getCurrentDocument","node","ownerDocument","getCurrentWindow","doc","defaultView","isRTLDocument","getComputedStyle","direction","isIOSWebKit","test","navigator","userAgent","isSmoothScrollSupported","style","isInitialMeasurementDone","store","$getViewportSize","createVirtualStore","elementsCount","itemSize","overscan","ssrCount","cacheSnapshot","shouldAutoEstimateItemSize","isSSR","stateVersion","viewportSize","startSpacerSize","scrollOffset","jump","pendingJump","_flushedJump","_scrollDirection","_scrollMode","_frozenRange","_prevRange","_totalMeasuredSize","initCache","subscribers","Set","getRelativeScrollOffset","getVisibleOffset","getRange","computeRange","prevStartIndex","end","start","getTotalSize","computeTotalSize","getItemOffset","computeStartOffset","_getItemSize","applyJump","j","$getStateVersion","$getCacheSnapshot","slice","takeCacheSnapshot","$getRange","startIndex","endIndex","$findStartIndex","$findEndIndex","$isUnmeasuredItem","_hasUnmeasuredItemsInFrozenRange","includes","$getItemOffset","$getItemSize","$getItemsLength","$getScrollOffset","$isScrolling","$getStartSpacerSize","$getTotalSize","_flushJump","$subscribe","target","cb","sub","add","delete","$update","type","payload","shouldFlushPendingJump","shouldSync","mutated","flushedJump","delta","distance","relativeOffset","updated","filter","prevSize","estimateDefaultItemSize","measuredCountBeforeStart","measuredSizes","forEach","s","push","sorted","len","median","prevDefaultItemSize","UPDATE_VIRTUAL_STATE","timeout","setTimeout","normalizeOffset","isHorizontal","createScrollObserver","viewport","getScrollOffset","updateScrollOffset","getStartOffset","now","Date","lastScrollTime","wheeling","touching","justTouchEnded","stillMomentumScrolling","onScrollEnd","debounce","id","cancel","clearTimeout","debouncedFn","_cancel","onScroll","onWheel","e","ctrlKey","timeDelta","deltaX","deltaY","onTouchStart","onTouchEnd","addEventListener","passive","_dispose","removeEventListener","_fixScrollJump","shift","createResizeObserver","ro","_observe","observe","_unobserve","unobserve","disconnect","ListItem","defineComponent","props","_stateVersion","Object","required","_store","_children","_resizer","Function","_index","Number","_isHorizontal","Boolean","_isSSR","_as","String","_itemProps","setup","elementRef","ref","computed","hide","watch","_","__","onCleanup","flush","children","Element","isHide","styleProp","rest","_a","position","visibility","display","_createVNode","createVNode","_mergeProps","_isVNode","prototype","toString","call","default","getKey","isSameRange","prev","next","data","Array","horizontal","startMargin","scrollRef","as","item","itemProps","keepMounted","Virtualizer","emits","emit","expose","slots","containerRef","resizer","createResizer","viewportElement","sizeKey","mountedIndexes","WeakMap","resizeObserver","entries","resizes","contentRect","offsetParent","get","$observeRoot","$observeItem","el","set","$dispose","scroller","createScroller","scrollObserver","cancelScroll","scrollOffsetKey","overflowKey","scheduleImperativeScroll","async","getTargetOffset","smooth","waitForMeasurement","queue","reject","promise","unsubscribe","scrollTo","behavior","$observe","isMomentumScrolling","$scrollTo","$scrollBy","$scrollToIndex","align","$fixScrollJump","unsubscribeStore","unsubscribeOnScroll","unsubscribeOnScrollEnd","range","isScrolling","totalSize","onMounted","assignScrollableElement","parentElement","onUnmounted","count","immediate","scrollSize","getScrollSize","findStartIndex","findEndIndex","scrollToIndex","scrollBy","ItemElement","total","items","getListItem","W","X","U","D","Y","G","K","Z","ee","startItems","endItems","unshift","overflowAnchor","flex","width","height","pointerEvents","VList","handle","args","contain","WindowVirtualizer","createWindowResizer","windowSizeKey","cleanupOnWindowResize","container","onWindowResize","createWindowScroller","containerElement","calcOffsetToViewport","offsetKey","offsetSum","innerWidth","offsetWidth","parent","scroll","documentBody","body","html","getScrollbarSize","clientWidth","clientHeight"],"mappings":"qBACO,MAAMA,EAAO,MAGPC,IAAEA,EAAGC,IAAEA,EAAGC,IAAEA,EAAGC,MAAEA,GAAUC,KAK3BC,EAAQA,CACnBC,EACAC,EACAC,IACWR,EAAIQ,EAAUP,EAAIM,EAAUD,IAK5BG,EAA0BC,GAC9B,IAAIA,GAAKD,MAAK,CAACE,EAAGC,IAAMD,EAAIC,IAMxBC,EACe,mBAAnBC,eACHA,eACCC,IACCC,QAAQC,UAAUC,KAAKH,EAAG,EAMrBI,EAAWJ,IACtB,IAAIK,EAEJ,MAAO,KACDL,IACFK,EAAQL,IACRA,OAAKM,GAEAD,EACR,ECpCUE,GAAY,EAenBC,EAAOA,CAACC,EAAiBC,EAAgBC,KAC7C,MAAMC,EAAMD,EAAU,UAAY,OAClC,IAAK,IAAIE,EAAI,EAAGA,EAAIH,EAAQG,IAC1BJ,EAAMG,GAAKL,GAEb,OAAOE,CAAK,EAMDK,EAAcA,CAACT,EAAcU,KACxC,MAAMC,EAAOX,EAAMY,EAAOF,GAC1B,OAAOC,IAAST,EAAWF,EAAMa,EAAmBF,CAAI,EAM7CG,EAAcA,CACzBd,EACAU,EACAC,KAEA,MAAMI,EAAuBf,EAAMY,EAAOF,KAAWR,EAIrD,OAHAF,EAAMY,EAAOF,GAASC,EAEtBX,EAAMgB,EAAuBpC,EAAI8B,EAAOV,EAAMgB,GACvCD,CAAoB,EAMhBE,EAAgBA,CAC3BjB,EACAU,KAEA,IAAKV,EAAMkB,EAAS,OAAO,EAC3B,GAAIlB,EAAMgB,GAAwBN,EAChC,OAAOV,EAAMmB,EAAST,GAGpBV,EAAMgB,EAAuB,IAG/BhB,EAAMmB,EAAS,GAAK,EACpBnB,EAAMgB,EAAuB,GAE/B,IAAIR,EAAIR,EAAMgB,EACVI,EAAMpB,EAAMmB,EAASX,GACzB,KAAOA,EAAIE,GACTU,GAAOX,EAAYT,EAAOQ,GAC1BR,EAAMmB,IAAWX,GAAKY,EAIxB,OADApB,EAAMgB,EAAuBN,EACtBU,CAAG,EAmBCC,EAAYA,CACvBrB,EACAsB,EACAC,EAAc,EACdC,EAAexB,EAAMkB,EAAU,KAG/B,KAAOK,GAAOC,GAAM,CAClB,MAAMC,EAAM1C,GAAOwC,EAAMC,GAAQ,GAC3BE,EAAaT,EAAcjB,EAAOyB,GACxC,GAAIC,GAAcJ,EAAQ,CACxB,GAAII,EAAajB,EAAYT,EAAOyB,GAAOH,EACzC,OAAOG,EAETF,EAAME,EAAM,CACd,MACED,EAAOC,EAAM,CAEjB,CACA,OAAOxC,EAAMsC,EAAK,EAAGvB,EAAMkB,EAAU,EAAE,EAoG5BS,EAAoBA,CAC/B3B,EACAK,EACAuB,KAEA,MAAMC,EAAOxB,EAASL,EAAMkB,EAQ5B,OANAlB,EAAMgB,EAAuBY,GAExB,EACDhD,EAAIyB,EAAS,EAAGL,EAAMgB,GAC1BhB,EAAMkB,EAAUb,EAEZwB,EAAO,GAET1B,EAAKH,EAAMmB,EAAUU,GACrB1B,EAAKH,EAAMY,EAAQiB,EAAMD,GAClB5B,EAAMa,EAAmBgB,IAGhC7B,EAAMmB,EAASW,OAAOD,IAEpBD,EAAU5B,EAAMY,EAAOkB,OAAO,GAAID,GAAQ7B,EAAMY,EAAOkB,OAAOD,IAC9DE,QACA,CAACC,EAAKC,IACJD,GAAOC,IAAY/B,EAAWF,EAAMa,EAAmBoB,IACzD,GAEJ,ECjPWC,EAA8B,oBAAXC,OAE1BC,EAAqBA,IAAMC,SAASC,gBAK7BC,EAAsBC,GACjCA,EAAKC,cAKMC,EAAoBC,GAAkBA,EAAIC,YAK1CC,eAA8B9C,GAAK,MAEvCmC,GACkD,QAArDY,iBAAiBV,KAAsBW,YAQhCC,eAA4BjD,GAAK,IACrC,iBAAiBkD,KAAKC,UAAUC,aAM5BC,eAAwCrD,GAAK,IACjD,mBAAoBqC,IAAqBiB,QC+CrCC,EAA4BC,KAC9BA,EAAMC,IAoCJC,EAAqBA,CAChCC,EACAC,EAAmB,GACnBC,EAAmB,EACnBC,EAAmB,EACnBC,EACAC,GAAsC,KAEtC,IAAIC,IAAUH,EACVI,EAA6B,EAC7BC,EAAe,EACfC,EAAkB,EAClBC,EAAe,EACfC,EAAO,EACPC,EAAc,EACdC,EAAe,EACfC,EAtHc,EAuHdC,EA/GmB,EAgHnBC,EAAkCV,EAClC,CAAC,EAAGnF,EAAIgF,EAAW,EAAG,IACtBlF,EACAgG,EAAyB,CAAC,EAAG,GAC7BC,EAAqB,EAEzB,MAAM5E,EFqCiB6E,EACvBxE,EACAsD,KAGO,CACL9C,EAA2C8C,EAC3C/C,EAOMT,EAAK,GAAIE,GACfa,EAASb,EACTW,GAAuB,EACvBG,EAAUhB,EAAK,GAAIE,KEtDPwE,CACZnB,EACAC,GAGImB,EAAc,IAAIC,IAClBC,EAA0BA,IAAMZ,EAAeD,EAC/Cc,EAAmBA,IAAMD,IAA4BV,EAAcD,EACnEa,EAAY5D,GFlCQ6D,EAC1BnF,EACAoE,EACAF,EACAkB,KAKA,GAFAA,EAAiBxG,EAAIwG,EAAgBpF,EAAMkB,EAAU,GAEjDD,EAAcjB,EAAOoF,IAAmBhB,EAAc,CAGxD,MAAMiB,EAAMhE,EAAUrB,EAAOoE,EAAeF,EAAckB,GAC1D,MAAO,CAAC/D,EAAUrB,EAAOoE,EAAcgB,EAAgBC,GAAMA,EAC/D,CAAO,CAGL,MAAMC,EAAQjE,EAAUrB,EAAOoE,OAAcnE,EAAWmF,GACxD,MAAO,CAACE,EAAOjE,EAAUrB,EAAOoE,EAAeF,EAAcoB,GAC/D,GEgBSH,CAAanF,EAAOsB,EAAQ4C,EAAcS,EAAW,IAExDY,EAAeA,IF3EUvF,IAC1BA,EAAMkB,EAETD,EAAcjB,EAAOA,EAAMkB,EAAU,GACrCT,EAAYT,EAAOA,EAAMkB,EAAU,GAHV,EE0EQsE,CAAiBxF,GAC9CyF,EAAiB/E,GACdgF,EAAmB1F,EAAOU,GAAS4D,EAEtC7D,EAAeC,GACZiF,EAAa3F,EAAOU,GAGvBkF,EAAaC,IACbA,IAEE7C,KApJU,IAoJOwB,EACnBF,GAAeuB,EAEfxB,GAAQwB,EAEZ,EAGF,MAAO,CACLC,EAAkBA,IAAM7B,EACxB8B,EAAmBA,IF6BW/F,IACzB,CAACA,EAAMY,EAAOoF,QAAShG,EAAMa,GE7BzBoF,CAAkBjG,GAE3BkG,EAAWA,KACT,IAAIC,EACAC,EAqBJ,OApBI7B,GAGD4B,EAAYC,GAAYzB,IAExBwB,EAAYC,GAAYzB,EAAaO,EACpCrG,EAAI,EAAGoG,MAELP,IACFyB,EAAavH,EAAIuH,EAAYzB,EAAa,IAC1C0B,EAAWvH,EAAIuH,EAAU1B,EAAa,MA7K5B,IAiLVF,IACF2B,GAActH,EAAI,EAAG+E,IAjLX,IAmLRY,IACF4B,GAAYvH,EAAI,EAAG+E,IAEd,CAAC/E,EAAIsH,EAAY,GAAIvH,EAAIwH,EAAUpG,EAAMkB,EAAU,GAAG,EAE/DmF,EAAiBA,IAAMhF,EAAUrB,EAAOiF,KACxCqB,EAAeA,IAAMjF,EAAUrB,EAAOiF,IAAqBf,GAC3DqC,EAAoB7F,GAAUV,EAAMY,EAAOF,KAAWR,EACtDsG,EAAkCA,MAC3B9B,GACE1E,EAAMY,EACVoF,MACCnH,EAAI,EAAG6F,EAAa,GAAK,GACzB9F,EAAIoB,EAAMkB,EAAU,EAAGwD,EAAa,GAAK,GAAK,GAE/C+B,SAASvG,GAEdwG,EAAgBjB,EAChBkB,EAAclG,EACdmG,EAAiBA,IAAM5G,EAAMkB,EAC7B2F,EAAkBA,IAAMzC,EACxB0C,EAAcA,IA1ME,IA0MItC,EACpBhB,EAAkBA,IAAMU,EACxB6C,EAAqBA,IAAM5C,EAC3B6C,EAAezB,EACf0B,EAAYA,KACV1C,EAAeF,EACfA,EAAO,EACA,CACLE,EAxMgB,IA0MhBE,GAEEO,IAA4Bd,GAAgBqB,MAGlD2B,EAAYA,CAACC,EAAQC,KACnB,MAAMC,EAA4B,CAACF,EAAQC,GAE3C,OADAtC,EAAYwC,IAAID,GACT,KACLvC,EAAYyC,OAAOF,EAAI,CACxB,EAEHG,EAASA,CAACC,EAAMC,KACd,IAAIC,EACAC,EACAC,EAAU,EAEd,OAAQJ,GACN,KArNqB,EAqND,CAClB,MAAMK,EAAcvD,EACpBA,EAAe,EAEf,MAAMwD,EAAQL,EAAUtD,EAClB4D,EAAWlJ,EAAIiJ,GAKAD,GAAeE,EAAWlJ,EAAIgJ,GAAe,GAxOnD,IA8ObrD,IAEAD,EAAmBuD,EAAQ,EAtPrB,EADE,GAsQN/D,IACFU,EAAe/F,EACfqF,GAAQ,GAGVI,EAAesD,EACfG,EA1NyB,EA8NzB,MAAMI,EAAiBjD,IAErBiD,IAAmB/D,GACnB+D,GAAkB1C,MAElBsC,GAvOwB,EA0OxBD,EAAaI,EAAW9D,GAE1B,KACF,CACA,KA1QyB,EA2QvB2D,EAzO6B,EArDnB,IA+RNrD,IACFmD,GAAyB,EACzBE,GAlPwB,GAoP1BrD,EAnSU,EAoSVC,EA5Re,EA6RfC,EAAe/F,EACf,MAEF,KAnR0B,EAmRD,CACvB,MAAMuJ,EAAUR,EAAQS,QACtB,EAAEzH,EAAOC,KAAUX,EAAMY,EAAOF,KAAWC,IAI7C,IAAKuH,EAAQ7H,OACX,MAIFuF,EACEsC,EAAQnG,QAAO,CAACC,GAAMtB,EAAOC,OA1SjB,IA6SR8D,IACCC,GAGIV,GAAStD,EAAQgE,EAAa,GAE/Be,EAAc/E,IA7Td,IA+TG8D,GAvTE,IAwTHC,EACIhE,EAAYC,GACZ,GACNsE,QAEJhD,GAAOrB,EAAOF,EAAYC,IAErBsB,IACN,IAIL,IAAK,MAAOtB,EAAOC,KAASuH,EAAS,CACnC,MAAME,EAAW3H,EAAYC,GACvBK,EAAuBD,EAAYd,EAAOU,EAAOC,GAEnDoD,IACFa,GAAsB7D,EAClBJ,EACAA,EAAOyH,EAEf,CAIErE,GACAG,GAEAU,EAAqBV,IAErB0B,EFjO2ByC,EACrCrI,EACAmG,KAEA,IAAImC,EAA2B,EAE/B,MAAMC,EAA0B,GAChCvI,EAAMY,EAAO4H,SAAQ,CAACC,EAAGjI,KACnBiI,IAAMvI,IACRqI,EAAcG,KAAKD,GACfjI,EAAI2F,GACNmC,IAEJ,IAIFtI,EAAMgB,GAAwB,EAG9B,MAAM2H,EAAStJ,EAAKkJ,GACdK,EAAMD,EAAOtI,OACboB,EAAOmH,EAAM,EAAK,EAClBC,EACJD,EAAM,GAAM,GAAKD,EAAOlH,EAAM,GAAMkH,EAAOlH,IAAS,EAAIkH,EAAOlH,GAE3DqH,EAAsB9I,EAAMa,EAGlC,QACIb,EAAMa,EAAmBgI,GAAUC,GACrCjK,EAAIsH,EAAamC,EAA0B,EAAE,EEmMnCD,CACErI,EACAqB,EAAUrB,EAAOiF,OAGrBlB,GAA6B,GAG/B8D,EAAUkB,EAQVnB,GAAa,EACb,KACF,CACA,KA3V8B,EA4VxB1D,IAAiBwD,IACnBxD,EAAewD,EACfG,EAAUkB,GAEZ,MAEF,KAhWkC,EAiW5BrB,EAAQ,IACV9B,EAAUjE,EAAkB3B,EAAO0H,EAAQ,IAAI,IAC/CjD,EAlXY,EAmXZoD,EA9UwB,IAgVxBlG,EAAkB3B,EAAO0H,EAAQ,IAGjCG,EAnVwB,GAqV1B,MAEF,KA3WkC,EA4WhC1D,EAAkBuD,EAClB,MAEF,KA7W4B,EA8W1BjD,EAlYsB,EAmYtB,MAEF,KA/W0C,EAgXxCC,EAAeQ,EAASwC,GACxBG,EAjW0B,EAsW1BA,IACF5D,EAA6C,GAxZlC,WAwZKA,GAEZ0D,GAA0BrD,IAC5BD,GAAQC,EACRA,EAAc,GAGhBQ,EAAY0D,SAAQ,EAAErB,EAAQC,MAEtBS,EAAUV,GAKhBC,EAAGQ,EAAW,IAElB,EAEH,EC5aGoB,EAAUC,WA6BVC,EAAkBA,CAAC5H,EAAgB6H,IACnCA,GAAgBtG,KACVvB,EAEDA,EAIL8H,EAAuBA,CAC3B7F,EACA8F,EACAF,EACAG,EACAC,EAKAC,KAEA,MAAMC,EAAMC,KAAKD,IAEjB,IAAIE,EAAiB,EACjBC,GAAW,EACXC,GAAW,EACXC,GAAiB,EACjBC,GAAyB,EAE7B,MAAMC,EAvDSC,MACf,IAAIC,EAEJ,MAAMC,EAASA,KACTD,GAAMvL,GACRyL,aAAaF,EACf,EAEIG,EAAcA,KAClBF,IACAD,EAAKlB,GAAQ,KACXkB,EAAKvL,EA4CoB,MAC3B,GAAIiL,GAAYC,EAKd,OAJAD,GAAW,OAGXI,IAIFF,GAAiB,EAEjBvG,EAAMiE,ED7CuB,EC6CG,EAtD9B7H,EAAI,GAuDL,IAtDK,EAGR,OADA0K,EAAYC,EAAUH,EACfE,CAAW,EAuCEJ,GAcdM,EAAWA,KACfZ,EAAiBF,IAEbK,IACFC,GAAyB,GAGvBP,GACFjG,EAAMiE,EDhD8B,ECgDMgC,KAE5CjG,EAAMiE,ED5DmB,EC4DI8B,KAE7BU,GAAa,EAKTQ,EAAYC,IAChB,GACEb,IAECrG,EAAMuD,KAEP2D,EAAEC,QAEF,OAGF,MAAMC,EAAYlB,IAAQE,EAGxB,IAAMgB,GACN,GAAKA,IAIJxB,EAAesB,EAAEG,OAASH,EAAEI,UAE7BjB,GAAW,EACb,EAGIkB,EAAeA,KACnBjB,GAAW,EACXC,EAAiBC,GAAyB,CAAK,EAE3CgB,EAAaA,KACjBlB,GAAW,EACP7G,MACF8G,GAAiB,EACnB,EAQF,OALAT,EAAS2B,iBAAiB,SAAUT,GACpClB,EAAS2B,iBAAiB,QAASR,EAAS,CAAES,SAAS,IACvD5B,EAAS2B,iBAAiB,aAAcF,EAAc,CAAEG,SAAS,IACjE5B,EAAS2B,iBAAiB,WAAYD,EAAY,CAAEE,SAAS,IAEtD,CACLC,EAAUA,KACR7B,EAAS8B,oBAAoB,SAAUZ,GACvClB,EAAS8B,oBAAoB,QAASX,GACtCnB,EAAS8B,oBAAoB,aAAcL,GAC3CzB,EAAS8B,oBAAoB,WAAYJ,GACzCf,EAAYM,GAAS,EAEvBc,EAAgBA,KACd,MAAO/G,EAAMgH,GAAS9H,EAAM0D,IACvB5C,IACLkF,EACEL,EAAgB7E,EAAM8E,GACtBkC,EACAtB,GAEFA,GAAyB,EAErBsB,GAAS9H,EAAMC,IAAqBD,EAAMyD,KAG5CzD,EAAMiE,EDjIe,ECiIQ8B,KAC/B,EAEH,ECpKGgC,EAAwBlE,IAC5B,IAAImE,EAEJ,MAAO,CACLC,CAAAA,CAASf,IAILc,IAECA,EAAK,IAAK7I,EAAiBH,EAAmBkI,IAAkB,gBAAErD,KACnEqE,QAAQhB,EACX,EACDiB,CAAAA,CAAWjB,GACTc,EAAII,UAAUlB,EACf,EACDS,CAAAA,GACEK,GAAMA,EAAGK,YACX,EACD,ECLUC,eAAyBC,EAAAA,gBAAgB,CACpDC,MAAO,CACLC,EAAe,CACbvE,KAAMwE,OACNC,UAAU,GAEZC,EAAQ,CAAE1E,KAAMwE,OAAkCC,UAAU,GAC5DE,EAAW,CAAE3E,KAAMwE,OAA2BC,UAAU,GACxDG,EAAU,CACR5E,KAAM6E,SACNJ,UAAU,GAEZK,EAAQ,CAAE9E,KAAM+E,OAAQN,UAAU,GAClCO,EAAe,CAAEhF,KAAMiF,SACvBC,EAAQ,CAAElF,KAAMiF,SAChBE,EAAK,CAAEnF,KAAMoF,OAA0CX,UAAU,GACjEY,GAAYb,QAEdc,KAAAA,CAAMhB,GACJ,MAAMiB,EAAaC,EAAAA,MAEb3L,EAAS4L,EAAAA,UACb,IACEnB,EAAMC,EAAc9M,OAAS6M,EAAMI,EAAOzF,EAAeqF,EAAMQ,KAE7DY,EAAOD,EAAAA,UACX,IACEnB,EAAMC,EAAc9M,OACpB6M,EAAMI,EAAO5F,EAAkBwF,EAAMQ,KAczC,OAVAa,SACE,IAAMJ,EAAW9N,OAAS6M,EAAMQ,IAChC,CAACc,EAAGC,EAAIC,KACNA,EAAUxB,EAAMM,EAASW,EAAW9N,MAAQ6M,EAAMQ,GAAQ,GAE5D,CACEiB,MAAO,SAIJ,WACL,MACEpB,EAAWqB,EACXhB,EAAetD,EACfwD,EAAQ3I,EACR4I,EAAKc,GACH3B,EACE4B,EAASR,EAAKjO,OAEZmE,MAAOuK,KAAcC,GAAyB,UAAhB9B,EAAMe,UAAU,IAAAgB,EAAAA,EAAI,CAAE,EAEtDzK,EAAoB,CACxB0K,SAAUJ,GAAU3J,OAAQ/D,EAAY,WACxC,CAACkJ,EAAe,SAAW,SAAU,OACrC,CAACA,EAAe,MAAQ,QAAS,MACjC,CAACA,EAAgBtG,IAAkB,QAAU,OAAU,OACrDvB,EAAOpC,MAAQ,KACjB8O,YAAaL,GAAU3J,EAAQ,UAAY,YACxC4J,GAML,OAJIzE,IACF9F,EAAM4K,QAAU,QAGlBC,EAAAC,YAAAT,EAAAU,aAAA,CAAAnB,IACgBD,EAAU3J,MAASA,GAAWwK,GAtEpD,mBAAApF,EAuEWgF,IAvEXY,oBAAApC,OAAAqC,UAAAC,SAAAC,KAAA/F,KAAA4F,EAAAA,QAAA5F,GAuEWgF,EAAQ,CAAAgB,QAAAA,IAAA,CAARhB,GAAQJ,EAAA,GAAA,GAAA,CAAA,UAvEnB,IAAA5E,CAuEmB,CAIjB,ICzFWiG,EAASA,CAACjE,EAAUjK,KAC/B,MAAMD,EAAMkK,EAAElK,IACd,OAAc,MAAPA,EAAcA,EAAM,IAAMC,CAAC,EAMvBmO,EAAcA,CAACC,EAAkBC,IACrCD,EAAK,KAAOC,EAAK,IAAMD,EAAK,KAAOC,EAAK,GCoE3C9C,EAAQ,CAIZ+C,KAAM,CAAErH,KAAMsH,MAAO7C,UAAU,GAK/BtI,SAAU4I,OAOV7I,SAAU6I,OAIVnB,MAAOqB,QAIPsC,WAAYtC,QAIZuC,YAAa,CAAExH,KAAM+E,OAAQiC,QAAS,GAItC5K,SAAU2I,OAIV0C,UAAWjD,OAKXkD,GAAI,CAAE1H,KAAMoF,OAA0C4B,QAAS,OAK/DW,KAAM,CAAE3H,KAAMoF,OAA0C4B,QAAS,OAMjEY,UAAW/C,SAIXgD,YAAaP,OAGFQ,eAA4BzD,EAAAA,gBAAgB,CACvDC,MAAOA,EACPyD,MAAO,CAAC,SAAU,aAClBzC,KAAAA,CAAMhB,GAAO0D,KAAEA,EAAIC,OAAEA,EAAMC,MAAEA,IAC3B,IAAI3L,IAAU+H,EAAMlI,SAEpB,MAAMsF,EAAe4C,EAAMiD,WACrBY,EAAe3C,EAAAA,MACf1J,EAAQE,EACZsI,EAAM+C,KAAKzO,OACX0L,EAAMpI,SACNoI,EAAMnI,SACNmI,EAAMlI,SACN5D,GACC8L,EAAMpI,UAEHkM,EHjHmBC,EAC3BvM,EACA4F,KAEA,IAAI4G,EACJ,MAAMC,EAAU7G,EAAe,QAAU,SACnC8G,EAAiB,IAAIC,QAErBC,EAAiB7E,GAAsB8E,IAC3C,MAAMC,EAAwB,GAC9B,IAAK,MAAMlJ,OAAEA,EAAMmJ,YAAEA,KAAiBF,EAEpC,GAAMjJ,EAAuBoJ,aAE7B,GAAIpJ,IAAW4I,EACbxM,EAAMiE,EFbwB,EEaQ8I,EAAYN,QAC7C,CACL,MAAMtP,EAAQuP,EAAeO,IAAIrJ,GAC7BzG,GAAS/B,GACX0R,EAAQ3H,KAAK,CAAChI,EAAO4P,EAAYN,IAErC,CAGEK,EAAQhQ,QACVkD,EAAMiE,EFzBsB,EEyBM6I,EACpC,IAGF,MAAO,CACLI,EAAAA,CAAapH,GACX8G,EAAe3E,EAAUuE,EAAkB1G,EAC5C,EACDqH,GAAcA,CAACC,EAAiBnQ,KAC9ByP,EAAeW,IAAID,EAAInQ,GACvB2P,EAAe3E,EAASmF,GACjB,KACLV,EAAe1I,OAAOoJ,GACtBR,EAAezE,EAAWiF,EAAG,GAGjCE,GAAUV,EAAejF,EAC1B,EGuEiB4E,CAAcvM,EAAO4F,GAC/B2H,EJkCoBC,EAC5BxN,EACA4F,KAEA,IAAI4G,EACAiB,EACAC,EACJ,MAAMC,EAAkB/H,EAAe,aAAe,YAChDgI,EAAchI,EAAe,YAAc,YAI3CiI,EAA2BC,MAC/BC,EACAC,KAEA,IAAKxB,EAGH,YADAtQ,GAAU,IAAM2R,EAAyBE,EAAiBC,KAIxDN,GAEFA,IAGF,MAAMO,EAAqBA,KAGzB,IAAIC,EACJ,MAAO,CACL,IAAI7R,SAAc,CAACC,EAAS6R,KAC1BD,EAAQ5R,EACRoR,EAAeS,EAKXpO,EAAyBC,IAE3ByF,EAAQ0I,EAAQ,IAClB,IAEFnO,EAAM2D,EDpKmB,GCoKW,KAClCuK,GAASA,GAAO,IAEnB,EAGH,GAAIF,GAAUnO,IAA2B,CACvC,KACEG,EAAMiE,ED9LoC,EC8LQ8J,KAE7C/N,EAAMiD,KAHA,CAOX,MAAOmL,EAASC,GAAeJ,IAE/B,UACQG,CACP,CAAC,MAAOlH,GAEP,MACF,CAAU,QACRmH,GACF,CACF,CAEA7B,EAAgB8B,SAAS,CACvB,CAAC1I,EAAe,OAAS,OAAQD,EAC/BoI,IACAnI,GAEF2I,SAAU,UAEd,MACE,OAAa,CACX,MAAOH,EAASC,GAAeJ,IAE/B,IACEzB,EAAgBmB,GAAmBhI,EACjCoI,IACAnI,GAEF5F,EAAMiE,EDlOoB,SCoOpBmK,CACP,CAAC,MAAOlH,GAEP,MACF,CAAU,QACRmH,GACF,CACF,CACF,EAGF,MAAO,CACLG,EAAAA,CAAS1I,GACP0G,EAAkB1G,EAElB2H,EAAiB5H,EACf7F,EACA8F,EACAF,GACA,IAAMD,EAAgBG,EAAS6H,GAAkB/H,KACjD,CAAC9E,EAAMgH,EAAO2G,KAKZ,GAAIA,EAAqB,CACvB,MAAM3O,EAAQgG,EAAShG,MACjBuL,EAAOvL,EAAM8N,GACnB9N,EAAM8N,GAAe,SACrBnI,GAAQ,KACN3F,EAAM8N,GAAevC,CAAI,GAE7B,CAEIvD,GACFhC,EAAS6H,GAAmB3N,EAAMsD,IAAqBxC,EAEvD4M,GAAgBA,KAEhB5H,EAAS6H,IAAoB7M,CAC/B,GAGL,EACDwM,EAAAA,GACEG,GAAkBA,EAAe9F,GAClC,EACD+G,EAAAA,CAAU3Q,GACR8P,GAAyB,IAAM9P,GAChC,EACD4Q,EAAAA,CAAU5Q,GACRA,GAAUiC,EAAMsD,IAChBuK,GAAyB,IAAM9P,GAChC,EACD6Q,EAAAA,CAAezR,GAAO0R,MAAEA,EAAKb,OAAEA,EAAMjQ,OAAEA,EAAS,GAAM,IAGpD,GAFAZ,EAAQzB,EAAMyB,EAAO,EAAG6C,EAAMqD,IAAoB,GAEpC,YAAVwL,EAAqB,CACvB,MAAM1Q,EAAa6B,EAAMmD,EAAehG,GAClC0D,EAAeb,EAAMsD,IAE3B,GAAInF,EAAa0C,EACfgO,EAAQ,YACH,MACL1Q,EAAa6B,EAAMoD,EAAajG,GAChC0D,EAAeb,EAAMC,KAKrB,OAHA4O,EAAQ,KAIV,CACF,CAEAhB,GAAyB,IAErB9P,EACAiC,EAAMwD,IACNxD,EAAMmD,EAAehG,IACV,QAAV0R,EACG7O,EAAMoD,EAAajG,GAAS6C,EAAMC,IACxB,WAAV4O,GACG7O,EAAMoD,EAAajG,GAAS6C,EAAMC,KAAsB,EACzD,IAEP+N,EACJ,EACDc,GAAgBA,KACdrB,GAAkBA,EAAe5F,GAAgB,EAEpD,EIpNkB2F,CAAexN,EAAO4F,GAEjClF,EAAegJ,EAAAA,IAAI1J,EAAMuC,KACzBwM,EAAmB/O,EAAM2D,EL3FC,GK2FgC,KAC9DjD,EAAa/E,MAAQqE,EAAMuC,GAAkB,IAGzCyM,EAAsBhP,EAAM2D,EL3FH,GK2FmC,KAChEuI,EAAK,SAAUlM,EAAMsD,IAAmB,IAEpC2L,EAAyBjP,EAAM2D,EL5FF,GK8FjC,KACEuI,EAAK,YAAY,IAIfgD,EAAQvF,EAAQA,UAAc0B,IAClC3K,EAAa/E,MACb,MAAM2P,EAAOtL,EAAM2C,IACnB,OAAI0I,GAAQD,EAAYC,EAAMC,GACrBD,EAEFC,CAAI,IAEP6D,EAAcxF,EAAAA,UAClB,IAAMjJ,EAAa/E,OAASqE,EAAMuD,MAE9B6L,EAAYzF,EAAAA,UAChB,IAAMjJ,EAAa/E,OAASqE,EAAMyD,MAoEpC,OAjEA4L,EAAAA,WAAU,KACR5O,GAAQ,EAERvE,GAAU,KACR,MAAMoT,EAA2BpI,IAC/BoF,EAAQY,GAAahG,GACrBqG,EAASiB,GAAStH,EAAE,EAElBsB,EAAMmD,UAER2D,EAAwB9G,EAAMmD,WAE9B2D,EAAwBjD,EAAa1Q,MAAO4T,cAC9C,GACA,IAEJC,EAAAA,aAAY,KACVT,IACAC,IACAC,IACA3C,EAAQgB,KACRC,EAASD,IAAU,IAGrBzD,EAAAA,OACE,IAAMrB,EAAM+C,KAAKzO,SAChB2S,IACCzP,EAAMiE,ELzK4B,EKyKQ,CAACwL,EAAOjH,EAAMV,OAAO,IAGnE+B,EAAAA,OACE,IAAMrB,EAAMkD,cACX/P,IACCqE,EAAMiE,EL7K4B,EK6KQtI,EAAM,GAElD,CAAE+T,WAAW,IAGf7F,QACE,CAACnJ,IACD,KACE6M,EAASuB,IAAgB,GAE3B,CAAE7E,MAAO,SAGXkC,EAAO,CACL,gBAAItL,GACF,OAAOb,EAAMsD,GACd,EACD,cAAIqM,GACF,MLhKsB3P,IACrB1E,EAAI0E,EAAMyD,IAAiBzD,EAAMC,KK+J3B2P,CAAc5P,EACtB,EACD,gBAAIW,GACF,OAAOX,EAAMC,GACd,EACD4P,eAAgB7P,EAAM8C,EACtBgN,aAAc9P,EAAM+C,EACpBb,cAAelC,EAAMmD,EACrBjG,YAAa8C,EAAMoD,EACnB2M,cAAexC,EAASqB,GACxBN,SAAUf,EAASmB,GACnBsB,SAAUzC,EAASoB,KAGd,KACL,MAAMxE,EAAU3B,EAAMoD,GAChBqE,EAAczH,EAAMqD,MAEnBjJ,EAAYC,GAAYqM,EAAMvT,MAC/BuU,EAAQd,EAAUzT,MAElBwU,EAAiB,GAEvB,SAASC,EAAYnT,SACnB,MAAMiK,EAAIkF,EAAMlB,QAAQ,CAAEW,KAAMrD,EAAM+C,KAAMtO,GAAKE,MAAOF,IAAK,GAC7D,OAAA0N,EAAAA,YAAArC,EAAA,CAAAtL,IAESmO,EAAOjE,EAAGjK,GAAEoT,EACF3P,EAAY4P,EACnBtQ,EAAKuQ,EACHjE,EAAQa,GAAYqD,EACtBvT,EAACwT,EACEvJ,EAACwJ,EACG9K,EAAY+K,EACnBlQ,EAAKmQ,EACRX,EAAWY,WACJtG,EAAA/B,EAAMsD,uCAAY,CAAED,KAAMrD,EAAM+C,KAAMtO,GAAKE,MAAOF,KAAI,KAAA,EAAA,CAAA,gBAAA,SAAA,WAAA,SAAA,YAAA,gBAAA,SAAA,MAAA,cAGxE,CACA,IAAK,IAAIA,EAAI2F,EAAYN,EAAIO,EAAU5F,GAAKqF,EAAGrF,IAC7CkT,EAAMhL,KAAKiL,EAAYnT,IAGzB,GAAIuL,EAAMuD,YAAa,CACrB,MAAM+E,EAAsB,GACtBC,EAAoB,GAC1BjV,EAAK0M,EAAMuD,aAAa9G,SAAS9H,IAC3BA,EAAQyF,GACVkO,EAAW3L,KAAKiL,EAAYjT,IAE1BA,EAAQ0F,GACVkO,EAAS5L,KAAKiL,EAAYjT,GAC5B,IAGFgT,EAAMa,WAAWF,GACjBX,EAAMhL,QAAQ4L,EAChB,CAEA,OAAApG,EAAAA,YAAAR,EAAA,CAAAT,IAES2C,EAAYvM,MACV,CAELmR,eAAgB,OAChBC,KAAM,OACN1G,SAAU,WACVC,WAAY,SACZ0G,MAAOvL,EAAesK,EAAQ,KAAO,OACrCkB,OAAQxL,EAAe,OAASsK,EAAQ,KACxCmB,cAAelC,EAAYxT,MAAQ,YAASe,IAzRC,mBAAAwI,EA4R9CiL,IA5R8CrF,oBAAApC,OAAAqC,UAAAC,SAAAC,KAAA/F,KAAA4F,EAAAA,QAAA5F,GA4R9CiL,EAAK,CAAAjF,QAAAA,IAAA,CAALiF,GAAKrG,EAAA,GAAA,EAAA,CAAA,UA5RyC,IAAA5E,CA4RzC,CAId,IChTIsD,EAAQ,CAIZ+C,KAAM,CAAErH,KAAMsH,MAAO7C,UAAU,GAK/BtI,SAAU4I,OAOV7I,SAAU6I,OAIVnB,MAAOqB,QAIPsC,WAAYtC,QAIZ7I,SAAU2I,OAMV6C,UAAW/C,SAIXgD,YAAaP,OAGF8F,eAAsB/I,EAAAA,gBAAgB,CACjDC,MAAOA,EACPyD,MAAO,CAAC,SAAU,aAClBzC,KAAAA,CAAMhB,GAAO0D,KAAEA,EAAIC,OAAEA,EAAMC,MAAEA,IAC3B,MAAMX,EAAajD,EAAMiD,WAEnBzE,EAAYjJ,IAChBmO,EAAK,SAAUnO,EAAO,EAElB0I,EAAcA,KAClByF,EAAK,YAAY,EAGbqF,EAAS7H,EAAAA,MAqBf,OAnBAyC,EAAO,CACL,gBAAItL,GACF,OAAO0Q,EAAO5V,MAAOkF,YACtB,EACD,cAAI8O,GACF,OAAO4B,EAAO5V,MAAOgU,UACtB,EACD,gBAAIhP,GACF,OAAO4Q,EAAO5V,MAAOgF,YACtB,EACDkP,eAAgBA,IAAI2B,IAASD,EAAO5V,MAAOkU,kBAAkB2B,GAC7D1B,aAAcA,IAAI0B,IAASD,EAAO5V,MAAOmU,gBAAgB0B,GACzDtP,cAAeA,IAAIsP,IAASD,EAAO5V,MAAOuG,iBAAiBsP,GAC3DtU,YAAaA,IAAIsU,IAASD,EAAO5V,MAAOuB,eAAesU,GACvDzB,cAAeA,IAAIyB,IAASD,EAAO5V,MAAOoU,iBAAiByB,GAC3DlD,SAAUA,IAAIkD,IAASD,EAAO5V,MAAO2S,YAAYkD,GACjDxB,SAAUA,IAAIwB,IAASD,EAAO5V,MAAOqU,YAAYwB,KAG5C,KACL,OAAA7G,EAAAA,YAAA,MAAA,CAAA7K,MAEW,CACL4K,QAASe,EAAa,eAAiB,QACvC,CAACA,EAAa,YAAc,aAAc,OAC1CgG,QAAS,SACTN,MAAO,OACPC,OAAQ,SACTzG,CAAAA,EAAAC,YAAAoB,EAAA,CAAAtC,IAGM6H,EAAMhG,KACL/C,EAAM+C,KAAIlL,SACNmI,EAAMnI,SAAQD,SACdoI,EAAMpI,SAAQ0L,UACbtD,EAAMsD,UAAShE,MACnBU,EAAMV,MAAKxH,SACRkI,EAAMlI,SAAQmL,WACZA,EAAUM,YACTvD,EAAMuD,YAAW/E,SACpBA,EAAQP,YACLA,IAtGsCvB,EAwGlDkH,EAxGkD,mBAAAlH,GAAA4F,oBAAApC,OAAAqC,UAAAC,SAAAC,KAAA/F,KAAA4F,EAAAA,QAAA5F,GAwGlDkH,EAAK,CAAAlB,QAAAA,IAAA,CAALkB,GAAKtC,EAAA,IAAA,EAAA,CAAA,OAAA,WAAA,WAAA,YAAA,QAAA,WAAA,aAAA,cAAA,WAAA,iBAAA,GAxG6C,IAAA5E,CAwG7C,CAKhB,ICzEIsD,EAAQ,CAIZ+C,KAAM,CAAErH,KAAMsH,MAAO7C,UAAU,GAK/BtI,SAAU4I,OAOV7I,SAAU6I,OAIVnB,MAAOqB,QAIPsC,WAAYtC,QAKZyC,GAAI,CAAE1H,KAAMoF,OAA0C4B,QAAS,OAK/DW,KAAM,CAAE3H,KAAMoF,OAA0C4B,QAAS,QAGtDwG,eAAkCnJ,EAAAA,gBAAgB,CAC7DC,QACAyD,MAAO,CAAC,SAAU,aAClBzC,KAAAA,CAAMhB,GAAO0D,KAAEA,EAAIE,MAAEA,EAAKD,OAAEA,IAC1B,MAAMvG,EAAe4C,EAAMiD,WACrBY,EAAe3C,EAAAA,MACf1J,EAAQE,EACZsI,EAAM+C,KAAKzO,OACX0L,EAAMpI,SACNoI,EAAMnI,cACN3D,EACAA,GACC8L,EAAMpI,UAEHkM,ELCyBqF,EACjC3R,EACA4F,KAEA,MAAM6G,EAAU7G,EAAe,QAAU,SACnCgM,EAAgBhM,EAAe,aAAe,cAC9C8G,EAAiB,IAAIC,QAErBC,EAAiB7E,GAAsB8E,IAC3C,MAAMC,EAAwB,GAC9B,IAAK,MAAMlJ,OAAEA,EAAMmJ,YAAEA,KAAiBF,EAAS,CAE7C,IAAMjJ,EAAuBoJ,aAAc,SAE3C,MAAM7P,EAAQuP,EAAeO,IAAIrJ,GAC7BzG,GAAS/B,GACX0R,EAAQ3H,KAAK,CAAChI,EAAO4P,EAAYN,IAErC,CAEIK,EAAQhQ,QACVkD,EAAMiE,EF3EsB,EE2EM6I,EACpC,IAGF,IAAI+E,EAEJ,MAAO,CACL3E,EAAAA,CAAa4E,GACX,MAAMlT,EAASO,EAAiBH,EAAmB8S,IAC7CC,EAAiBA,KACrB/R,EAAMiE,EFnFwB,EEmFQrF,EAAOgT,GAAe,EAE9DhT,EAAO6I,iBAAiB,SAAUsK,GAClCA,IAEAF,EAAwBA,KACtBjT,EAAOgJ,oBAAoB,SAAUmK,EAAe,CAEvD,EACD5E,GAAcA,CAACC,EAAiBnQ,KAC9ByP,EAAeW,IAAID,EAAInQ,GACvB2P,EAAe3E,EAASmF,GACjB,KACLV,EAAe1I,OAAOoJ,GACtBR,EAAezE,EAAWiF,EAAG,GAGjCE,EAAAA,GACEuE,GAAyBA,IACzBjF,EAAejF,GACjB,EACD,EKrDiBgK,CAAoB3R,EAAO4F,GACrC2H,ENgS0ByE,EAClChS,EACA4F,KAEA,IAAIqM,EACAxE,EACAC,EAEJ,MAAMwE,EAAuBA,CAC3BjT,EACA6G,EACAlH,EACAgH,EACA7H,EAAiB,KAGjB,MAAMoU,EAAYvM,EAAe,aAAe,YAC1CwM,EACJrU,GACC6H,GAAgBtG,IACbV,EAAOyT,WAAapT,EAAKkT,GAAalT,EAAKqT,YAC3CrT,EAAKkT,IAELI,EAAStT,EAAK+N,aACpB,OAAI/N,IAAS6G,GAAayM,EAInBL,EACLK,EACAzM,EACAlH,EACAgH,EACAwM,GAROA,CASR,EAGGvE,EAA2BC,MAC/BC,EACAC,KAEA,IAAKiE,EAGH,YADA/V,GAAU,IAAM2R,EAAyBE,EAAiBC,KAIxDN,GACFA,IAGF,MAAMO,EAAqBA,KACzB,IAAIC,EACJ,MAAO,CACL,IAAI7R,SAAc,CAACC,EAAS6R,KAC1BD,EAAQ5R,EACRoR,EAAeS,EAEXpO,EAAyBC,IAC3ByF,EAAQ0I,EAAQ,IAClB,IAEFnO,EAAM2D,EDxXmB,GCwXW,KAClCuK,GAASA,GAAO,IAEnB,EAGGtP,EAASO,EAAiBH,EAAmBiT,IAEnD,GAAIjE,GAAUnO,IAA2B,CACvC,KACEG,EAAMiE,EDpZoC,ECoZQ8J,KAE7C/N,EAAMiD,KAHA,CAOX,MAAOmL,EAASC,GAAeJ,IAE/B,UACQG,CACP,CAAC,MAAOlH,GACP,MACF,CAAU,QACRmH,GACF,CACF,CAEAzP,EAAO4T,OAAO,CACZ,CAAC5M,EAAe,OAAS,OAAQD,EAC/BoI,IACAnI,GAEF2I,SAAU,UAEd,MACE,OAAa,CACX,MAAOH,EAASC,GAAeJ,IAE/B,IACErP,EAAO4T,OAAO,CACZ,CAAC5M,EAAe,OAAS,OAAQD,EAC/BoI,IACAnI,KAGJ5F,EAAMiE,EDzboB,SC2bpBmK,CACP,CAAC,MAAOlH,GACP,MACF,CAAU,QACRmH,GACF,CACF,CACF,EAGF,MAAO,CACLG,EAAAA,CAASsD,GACPG,EAAmBH,EACnB,MAAMnE,EAAkB/H,EAAe,UAAY,UAE7C9G,EAAWE,EAAmB8S,GAC9BlT,EAASO,EAAiBL,GAC1B2T,EAAe3T,EAAS4T,KAE9BjF,EAAiB5H,EACf7F,EACApB,EACAgH,GACA,IAAMD,EAAgB/G,EAAO+O,GAAkB/H,KAC/C,CAAC9E,EAAMgH,KAEDA,EACFlJ,EAAO4T,OAAO,CACZ,CAAC5M,EAAe,OAAS,OAAQ5F,EAAMsD,IAAqBxC,IAG9DlC,EAAOoR,SAASpK,EAAe9E,EAAO,EAAG8E,EAAe,EAAI9E,EAC9D,IAEF,IACEoR,EAAqBJ,EAAWW,EAAc7T,EAAQgH,IAE3D,EACD0H,EAAAA,GACEG,GAAkBA,EAAe9F,IACjCsK,OAAmBvV,CACpB,EACDoS,GAAgBA,KACdrB,GAAkBA,EAAe5F,GAAgB,EAEnD+G,EAAAA,CAAezR,GAAO0R,MAAEA,EAAKb,OAAEA,EAAMjQ,OAAEA,EAAS,GAAM,IACpD,IAAKkU,EAAkB,OAIvB,GAFA9U,EAAQzB,EAAMyB,EAAO,EAAG6C,EAAMqD,IAAoB,GAEpC,YAAVwL,EAAqB,CACvB,MAAM1Q,EAAa6B,EAAMmD,EAAehG,GAClC0D,EAAeb,EAAMsD,IAE3B,GAAInF,EAAa0C,EACfgO,EAAQ,YACH,MACL1Q,EAAa6B,EAAMoD,EAAajG,GAChC0D,EAAeb,EAAMC,KAIrB,OAFA4O,EAAQ,KAGV,CACF,CAEA,MAAM/P,EAAWE,EAAmBiT,GAC9BrT,EAASO,EAAiBL,GAC1B6T,EAAO7T,EAASC,gBAChB6T,EAAmBA,IACvB5S,EAAMC,KACL2F,EAAe+M,EAAKE,YAAcF,EAAKG,cAE1CjF,GAAyB,IAErB9P,EAEAmU,EACED,EACAnT,EAAS4T,KACT9T,EACAgH,GAGF5F,EAAMmD,EAAehG,IACV,QAAV0R,EACG7O,EAAMoD,EAAajG,IAClB6C,EAAMC,IAAqB2S,KAClB,WAAV/D,GACG7O,EAAMoD,EAAajG,IACjB6C,EAAMC,IAAqB2S,MAC9B,EACA,IAEP5E,EACL,EACD,EM7ekBgE,CAAqBhS,EAAO4F,GAEvClF,EAAegJ,EAAAA,IAAI1J,EAAMuC,KACzBwM,EAAmB/O,EAAM2D,EP/BC,GO+BgC,KAC9DjD,EAAa/E,MAAQqE,EAAMuC,GAAkB,IAGzCyM,EAAsBhP,EAAM2D,EP/BH,GO+BmC,KAEhEuI,EAAK,SAAS,IAEV+C,EAAyBjP,EAAM2D,EPjCF,GOmCjC,KACEuI,EAAK,YAAY,IAIfgD,EAAQvF,EAAQA,UAAc0B,IAClC3K,EAAa/E,MACb,MAAM2P,EAAOtL,EAAM2C,IACnB,OAAI0I,GAAQD,EAAYC,EAAMC,GACrBD,EAEFC,CAAI,IAEP6D,EAAcxF,EAAAA,UAClB,IAAMjJ,EAAa/E,OAASqE,EAAMuD,MAE9B6L,EAAYzF,EAAAA,UAChB,IAAMjJ,EAAa/E,OAASqE,EAAMyD,MAsCpC,OAnCA4L,EAAAA,WAAU,KACR,MAAMjC,EAAKf,EAAa1Q,MACnByR,IACLd,EAAQY,GAAaE,GACrBG,EAASiB,GAASpB,GAAG,IAEvBoC,EAAAA,aAAY,KACVT,IACAC,IACAC,IACA3C,EAAQgB,KACRC,EAASD,IAAU,IAGrBzD,EAAAA,OACE,IAAMrB,EAAM+C,KAAKzO,SAChB2S,IACCzP,EAAMiE,EPpG4B,EOoGQ,CAACwL,EAAOjH,EAAMV,OAAO,IAInE+B,QACE,CAACnJ,IACD,KACE6M,EAASuB,IAAgB,GAE3B,CAAE7E,MAAO,SAGXkC,EAAO,CACL0D,eAAgB7P,EAAM8C,EACtBgN,aAAc9P,EAAM+C,EACpBgN,cAAexC,EAASqB,KAGnB,KACL,MAAMzE,EAAU3B,EAAMoD,GAChBqE,EAAczH,EAAMqD,MAEnBjJ,EAAYC,GAAYqM,EAAMvT,MAC/BuU,EAAQd,EAAUzT,MAElBwU,EAAiB,GACvB,IAAK,IAAIlT,EAAI2F,EAAYN,EAAIO,EAAU5F,GAAKqF,EAAGrF,IAAK,CAClD,MAAMiK,EAAIkF,EAAMlB,QAAQ,CAAEW,KAAMrD,EAAM+C,KAAMtO,GAAKE,MAAOF,IAAK,GAC7DkT,EAAMhL,KAAIwF,EAAAC,YAAAtC,EAAA,CAAAtL,IAEDmO,EAAOjE,EAAGjK,GAAEoT,EACF3P,EAAY4P,EACnBtQ,EAAKuQ,EACHjE,EAAQa,GAAYqD,EACtBvT,EAACwT,EACEvJ,EAACwJ,EACG9K,EAAYgL,EACtBX,GAAW,KAAA,EAAA,CAAA,gBAAA,SAAA,WAAA,SAAA,YAAA,gBAAA,QAGtB,CAEA,OAAAtF,EAAAA,YAAAR,EAAA,CAAAT,IAES2C,EAAYvM,MACV,CAELmR,eAAgB,OAChBC,KAAM,OACN1G,SAAU,WACVC,WAAY,SACZ0G,MAAOvL,EAAesK,EAAQ,KAAO,OACrCkB,OAAQxL,EAAe,OAASsK,EAAQ,KACxCmB,cAAelC,EAAYxT,MAAQ,YAASe,IA9KV,mBAAAwI,EAiLnCiL,IAjLmCrF,oBAAApC,OAAAqC,UAAAC,SAAAC,KAAA/F,KAAA4F,EAAAA,QAAA5F,GAiLnCiL,EAAK,CAAAjF,QAAAA,IAAA,CAALiF,GAAKrG,EAAA,GAAA,EAAA,CAAA,UAjL8B,IAAA5E,CAiL9B,CAId"}