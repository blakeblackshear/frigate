{"version":3,"sources":["../src/index.ts","../src/use-chat.ts","../src/chat.react.ts","../src/throttle.ts","../src/use-completion.ts","../src/use-object.ts"],"sourcesContent":["export * from './use-chat';\nexport { Chat } from './chat.react';\nexport * from './use-completion';\nexport * from './use-object';\n","import {\n  AbstractChat,\n  ChatInit,\n  type CreateUIMessage,\n  type UIMessage,\n} from 'ai';\nimport { useCallback, useEffect, useRef, useSyncExternalStore } from 'react';\nimport { Chat } from './chat.react';\n\nexport type { CreateUIMessage, UIMessage };\n\nexport type UseChatHelpers<UI_MESSAGE extends UIMessage> = {\n  /**\n   * The id of the chat.\n   */\n  readonly id: string;\n\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (\n    messages: UI_MESSAGE[] | ((messages: UI_MESSAGE[]) => UI_MESSAGE[]),\n  ) => void;\n\n  error: Error | undefined;\n} & Pick<\n  AbstractChat<UI_MESSAGE>,\n  | 'sendMessage'\n  | 'regenerate'\n  | 'stop'\n  | 'resumeStream'\n  | 'addToolResult'\n  | 'status'\n  | 'messages'\n  | 'clearError'\n>;\n\nexport type UseChatOptions<UI_MESSAGE extends UIMessage> = (\n  | { chat: Chat<UI_MESSAGE> }\n  | ChatInit<UI_MESSAGE>\n) & {\n  /**\nCustom throttle wait in ms for the chat messages and data updates.\nDefault is undefined, which disables throttling.\n   */\n  experimental_throttle?: number;\n\n  /**\n   * Whether to resume an ongoing chat generation stream.\n   */\n  resume?: boolean;\n};\n\nexport function useChat<UI_MESSAGE extends UIMessage = UIMessage>({\n  experimental_throttle: throttleWaitMs,\n  resume = false,\n  ...options\n}: UseChatOptions<UI_MESSAGE> = {}): UseChatHelpers<UI_MESSAGE> {\n  const chatRef = useRef<Chat<UI_MESSAGE>>(\n    'chat' in options ? options.chat : new Chat(options),\n  );\n\n  const shouldRecreateChat =\n    ('chat' in options && options.chat !== chatRef.current) ||\n    ('id' in options && chatRef.current.id !== options.id);\n\n  if (shouldRecreateChat) {\n    chatRef.current = 'chat' in options ? options.chat : new Chat(options);\n  }\n\n  const optionsId = 'id' in options ? options.id : null;\n\n  const subscribeToMessages = useCallback(\n    (update: () => void) =>\n      chatRef.current['~registerMessagesCallback'](update, throttleWaitMs),\n    // optionsId is required to trigger re-subscription when the chat ID changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [throttleWaitMs, optionsId],\n  );\n\n  const messages = useSyncExternalStore(\n    subscribeToMessages,\n    () => chatRef.current.messages,\n    () => chatRef.current.messages,\n  );\n\n  const status = useSyncExternalStore(\n    chatRef.current['~registerStatusCallback'],\n    () => chatRef.current.status,\n    () => chatRef.current.status,\n  );\n\n  const error = useSyncExternalStore(\n    chatRef.current['~registerErrorCallback'],\n    () => chatRef.current.error,\n    () => chatRef.current.error,\n  );\n\n  const setMessages = useCallback(\n    (\n      messagesParam: UI_MESSAGE[] | ((messages: UI_MESSAGE[]) => UI_MESSAGE[]),\n    ) => {\n      if (typeof messagesParam === 'function') {\n        messagesParam = messagesParam(chatRef.current.messages);\n      }\n      chatRef.current.messages = messagesParam;\n    },\n    [chatRef],\n  );\n\n  useEffect(() => {\n    if (resume) {\n      chatRef.current.resumeStream();\n    }\n  }, [resume, chatRef]);\n\n  return {\n    id: chatRef.current.id,\n    messages,\n    setMessages,\n    sendMessage: chatRef.current.sendMessage,\n    regenerate: chatRef.current.regenerate,\n    clearError: chatRef.current.clearError,\n    stop: chatRef.current.stop,\n    error,\n    resumeStream: chatRef.current.resumeStream,\n    status,\n    addToolResult: chatRef.current.addToolResult,\n  };\n}\n","import { AbstractChat, ChatInit, ChatState, ChatStatus, UIMessage } from 'ai';\nimport { throttle } from './throttle';\n\nclass ReactChatState<UI_MESSAGE extends UIMessage>\n  implements ChatState<UI_MESSAGE>\n{\n  #messages: UI_MESSAGE[];\n  #status: ChatStatus = 'ready';\n  #error: Error | undefined = undefined;\n\n  #messagesCallbacks = new Set<() => void>();\n  #statusCallbacks = new Set<() => void>();\n  #errorCallbacks = new Set<() => void>();\n\n  constructor(initialMessages: UI_MESSAGE[] = []) {\n    this.#messages = initialMessages;\n  }\n\n  get status(): ChatStatus {\n    return this.#status;\n  }\n\n  set status(newStatus: ChatStatus) {\n    this.#status = newStatus;\n    this.#callStatusCallbacks();\n  }\n\n  get error(): Error | undefined {\n    return this.#error;\n  }\n\n  set error(newError: Error | undefined) {\n    this.#error = newError;\n    this.#callErrorCallbacks();\n  }\n\n  get messages(): UI_MESSAGE[] {\n    return this.#messages;\n  }\n\n  set messages(newMessages: UI_MESSAGE[]) {\n    this.#messages = [...newMessages];\n    this.#callMessagesCallbacks();\n  }\n\n  pushMessage = (message: UI_MESSAGE) => {\n    this.#messages = this.#messages.concat(message);\n    this.#callMessagesCallbacks();\n  };\n\n  popMessage = () => {\n    this.#messages = this.#messages.slice(0, -1);\n    this.#callMessagesCallbacks();\n  };\n\n  replaceMessage = (index: number, message: UI_MESSAGE) => {\n    this.#messages = [\n      ...this.#messages.slice(0, index),\n      // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:\n      this.snapshot(message),\n      ...this.#messages.slice(index + 1),\n    ];\n    this.#callMessagesCallbacks();\n  };\n\n  snapshot = <T>(value: T): T => structuredClone(value);\n\n  '~registerMessagesCallback' = (\n    onChange: () => void,\n    throttleWaitMs?: number,\n  ): (() => void) => {\n    const callback = throttleWaitMs\n      ? throttle(onChange, throttleWaitMs)\n      : onChange;\n    this.#messagesCallbacks.add(callback);\n    return () => {\n      this.#messagesCallbacks.delete(callback);\n    };\n  };\n\n  '~registerStatusCallback' = (onChange: () => void): (() => void) => {\n    this.#statusCallbacks.add(onChange);\n    return () => {\n      this.#statusCallbacks.delete(onChange);\n    };\n  };\n\n  '~registerErrorCallback' = (onChange: () => void): (() => void) => {\n    this.#errorCallbacks.add(onChange);\n    return () => {\n      this.#errorCallbacks.delete(onChange);\n    };\n  };\n\n  #callMessagesCallbacks = () => {\n    this.#messagesCallbacks.forEach(callback => callback());\n  };\n\n  #callStatusCallbacks = () => {\n    this.#statusCallbacks.forEach(callback => callback());\n  };\n\n  #callErrorCallbacks = () => {\n    this.#errorCallbacks.forEach(callback => callback());\n  };\n}\n\nexport class Chat<\n  UI_MESSAGE extends UIMessage,\n> extends AbstractChat<UI_MESSAGE> {\n  #state: ReactChatState<UI_MESSAGE>;\n\n  constructor({ messages, ...init }: ChatInit<UI_MESSAGE>) {\n    const state = new ReactChatState(messages);\n    super({ ...init, state });\n    this.#state = state;\n  }\n\n  '~registerMessagesCallback' = (\n    onChange: () => void,\n    throttleWaitMs?: number,\n  ): (() => void) =>\n    this.#state['~registerMessagesCallback'](onChange, throttleWaitMs);\n\n  '~registerStatusCallback' = (onChange: () => void): (() => void) =>\n    this.#state['~registerStatusCallback'](onChange);\n\n  '~registerErrorCallback' = (onChange: () => void): (() => void) =>\n    this.#state['~registerErrorCallback'](onChange);\n}\n","import throttleFunction from 'throttleit';\n\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  waitMs: number | undefined,\n): T {\n  return waitMs != null ? throttleFunction(fn, waitMs) : fn;\n}\n","import {\n  CompletionRequestOptions,\n  UseCompletionOptions,\n  callCompletionApi,\n} from 'ai';\nimport { useCallback, useEffect, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport { throttle } from './throttle';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: string;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: CompletionRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /** The error object of the API request */\n  error: undefined | Error;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /**\n   * An input/textarea-ready onChange handler to control the value of the input\n   * @example\n   * ```jsx\n   * <input onChange={handleInputChange} value={input} />\n   * ```\n   */\n  handleInputChange: (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input onChange={handleInputChange} value={input} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n\n  /** Whether the API request is in progress */\n  isLoading: boolean;\n};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  fetch,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs,\n}: UseCompletionOptions & {\n  /**\n   * Custom throttle wait in ms for the completion and data updates.\n   * Default is undefined, which disables throttling.\n   */\n  experimental_throttle?: number;\n} = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const hookId = useId();\n  const completionId = id || hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<string>([api, completionId], null, {\n    fallbackData: initialCompletion,\n  });\n\n  const { data: isLoading = false, mutate: mutateLoading } = useSWR<boolean>(\n    [completionId, 'loading'],\n    null,\n  );\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const completion = data!;\n\n  // Abort controller to cancel the current API call.\n  const [abortController, setAbortController] =\n    useState<AbortController | null>(null);\n\n  const extraMetadataRef = useRef({\n    credentials,\n    headers,\n    body,\n  });\n\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body,\n    };\n  }, [credentials, headers, body]);\n\n  const triggerRequest = useCallback(\n    async (prompt: string, options?: CompletionRequestOptions) =>\n      callCompletionApi({\n        api,\n        prompt,\n        credentials: extraMetadataRef.current.credentials,\n        headers: { ...extraMetadataRef.current.headers, ...options?.headers },\n        body: {\n          ...extraMetadataRef.current.body,\n          ...options?.body,\n        },\n        streamProtocol,\n        fetch,\n        // throttle streamed ui updates:\n        setCompletion: throttle(\n          (completion: string) => mutate(completion, false),\n          throttleWaitMs,\n        ),\n        setLoading: mutateLoading,\n        setError,\n        setAbortController,\n        onFinish,\n        onError,\n      }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onFinish,\n      onError,\n      setError,\n      streamProtocol,\n      fetch,\n      throttleWaitMs,\n    ],\n  );\n\n  const stop = useCallback(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n\n  const setCompletion = useCallback(\n    (completion: string) => {\n      mutate(completion, false);\n    },\n    [mutate],\n  );\n\n  const complete = useCallback<UseCompletionHelpers['complete']>(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest],\n  );\n\n  const [input, setInput] = useState(initialInput);\n\n  const handleSubmit = useCallback(\n    (event?: { preventDefault?: () => void }) => {\n      event?.preventDefault?.();\n      return input ? complete(input) : undefined;\n    },\n    [input, complete],\n  );\n\n  const handleInputChange = useCallback(\n    (e: any) => {\n      setInput(e.target.value);\n    },\n    [setInput],\n  );\n\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n  };\n}\n","import {\n  FetchFunction,\n  InferSchema,\n  isAbortError,\n  safeValidateTypes,\n} from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  isDeepEqualData,\n  parsePartialJson,\n  Schema,\n} from 'ai';\nimport { useCallback, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport type Experimental_UseObjectOptions<\n  SCHEMA extends z4.core.$ZodType | z3.Schema | Schema,\n  RESULT,\n> = {\n  /**\n   * The API endpoint. It should stream JSON that matches the schema as chunked text.\n   */\n  api: string;\n\n  /**\n   * A Zod schema that defines the shape of the complete object.\n   */\n  schema: SCHEMA;\n\n  /**\n   * An unique identifier. If not provided, a random one will be\n   * generated. When provided, the `useObject` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * An optional value for the initial object.\n   */\n  initialValue?: DeepPartial<RESULT>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nCallback that is called when the stream has finished.\n     */\n  onFinish?: (event: {\n    /**\nThe generated object (typed according to the schema).\nCan be undefined if the final object does not match the schema.\n   */\n    object: RESULT | undefined;\n\n    /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n */\n    error: Error | undefined;\n  }) => Promise<void> | void;\n\n  /**\n   * Callback function to be called when an error is encountered.\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Additional HTTP headers to be included in the request.\n   */\n  headers?: Record<string, string> | Headers;\n\n  /**\n   * The credentials mode to be used for the fetch request.\n   * Possible values are: 'omit', 'same-origin', 'include'.\n   * Defaults to 'same-origin'.\n   */\n  credentials?: RequestCredentials;\n};\n\nexport type Experimental_UseObjectHelpers<RESULT, INPUT> = {\n  /**\n   * Calls the API with the provided input as JSON body.\n   */\n  submit: (input: INPUT) => void;\n\n  /**\n   * The current value for the generated object. Updated as the API streams JSON chunks.\n   */\n  object: DeepPartial<RESULT> | undefined;\n\n  /**\n   * The error object of the API request if any.\n   */\n  error: Error | undefined;\n\n  /**\n   * Flag that indicates whether an API request is in progress.\n   */\n  isLoading: boolean;\n\n  /**\n   * Abort the current request immediately, keep the current partial object if any.\n   */\n  stop: () => void;\n\n  /**\n   * Clear the object state.\n   */\n  clear: () => void;\n};\n\nfunction useObject<\n  SCHEMA extends z4.core.$ZodType | z3.Schema | Schema,\n  RESULT = InferSchema<SCHEMA>,\n  INPUT = any,\n>({\n  api,\n  id,\n  schema, // required, in the future we will use it for validation\n  initialValue,\n  fetch,\n  onError,\n  onFinish,\n  headers,\n  credentials,\n}: Experimental_UseObjectOptions<\n  SCHEMA,\n  RESULT\n>): Experimental_UseObjectHelpers<RESULT, INPUT> {\n  // Generate an unique id if not provided.\n  const hookId = useId();\n  const completionId = id ?? hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<DeepPartial<RESULT>>(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue },\n  );\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const stop = useCallback(() => {\n    try {\n      abortControllerRef.current?.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const submit = async (input: INPUT) => {\n    try {\n      clearObject();\n\n      setIsLoading(true);\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        credentials,\n        signal: abortController.signal,\n        body: JSON.stringify(input),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      let accumulatedText = '';\n      let latestObject: DeepPartial<RESULT> | undefined = undefined;\n\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream<string>({\n          async write(chunk) {\n            accumulatedText += chunk;\n\n            const { value } = await parsePartialJson(accumulatedText);\n            const currentObject = value as DeepPartial<RESULT>;\n\n            if (!isDeepEqualData(latestObject, currentObject)) {\n              latestObject = currentObject;\n\n              mutate(currentObject);\n            }\n          },\n\n          async close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n\n            if (onFinish != null) {\n              const validationResult = await safeValidateTypes({\n                value: latestObject,\n                schema: asSchema(schema),\n              });\n\n              onFinish(\n                validationResult.success\n                  ? { object: validationResult.value, error: undefined }\n                  : { object: undefined, error: validationResult.error },\n              );\n            }\n          },\n        }),\n      );\n    } catch (error) {\n      if (isAbortError(error)) {\n        return;\n      }\n\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n\n      setIsLoading(false);\n      setError(error instanceof Error ? error : new Error(String(error)));\n    }\n  };\n\n  const clear = () => {\n    stop();\n    clearObject();\n  };\n\n  const clearObject = () => {\n    setError(undefined);\n    setIsLoading(false);\n    mutate(undefined);\n  };\n\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n    clear,\n  };\n}\n\nexport const experimental_useObject = useObject;\n"],"mappings":"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","names":["throttleFunction","import_ai","import_react","fetch","useSWR","completion","import_ai","import_react","import_swr","fetch","useSWR","error"]}