{"version":3,"file":"use-editable.es.js","sources":["../src/useEditable.ts"],"sourcesContent":["import { useState, useLayoutEffect, useMemo } from 'react';\n\nexport interface Position {\n  position: number;\n  extent: number;\n  content: string;\n  line: number;\n}\n\ntype History = [Position, string];\n\nconst observerSettings = {\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst getCurrentRange = () => window.getSelection()!.getRangeAt(0)!;\n\nconst setCurrentRange = (range: Range) => {\n  const selection = window.getSelection()!;\n  selection.empty();\n  selection.addRange(range);\n};\n\nconst isUndoRedoKey = (event: KeyboardEvent): boolean =>\n  (event.metaKey || event.ctrlKey) && !event.altKey && event.code === 'KeyZ';\n\nconst toString = (element: HTMLElement): string => {\n  const queue: Node[] = [element.firstChild!];\n\n  let content = '';\n  let node: Node;\n  while ((node = queue.pop()!)) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      content += node.textContent;\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === 'BR') {\n      content += '\\n';\n    }\n\n    if (node.nextSibling) queue.push(node.nextSibling);\n    if (node.firstChild) queue.push(node.firstChild);\n  }\n\n  // contenteditable Quirk: Without plaintext-only a pre/pre-wrap element must always\n  // end with at least one newline character\n  if (content[content.length - 1] !== '\\n') content += '\\n';\n\n  return content;\n};\n\nconst setStart = (range: Range, node: Node, offset: number) => {\n  if (offset < node.textContent!.length) {\n    range.setStart(node, offset);\n  } else {\n    range.setStartAfter(node);\n  }\n};\n\nconst setEnd = (range: Range, node: Node, offset: number) => {\n  if (offset < node.textContent!.length) {\n    range.setEnd(node, offset);\n  } else {\n    range.setEndAfter(node);\n  }\n};\n\nconst getPosition = (element: HTMLElement): Position => {\n  // Firefox Quirk: Since plaintext-only is unsupported the position\n  // of the text here is retrieved via a range, rather than traversal\n  // as seen in makeRange()\n  const range = getCurrentRange();\n  const extent = !range.collapsed ? range.toString().length : 0;\n  const untilRange = document.createRange();\n  untilRange.setStart(element, 0);\n  untilRange.setEnd(range.startContainer, range.startOffset);\n  let content = untilRange.toString();\n  const position = content.length;\n  const lines = content.split('\\n');\n  const line = lines.length - 1;\n  content = lines[line];\n  return { position, extent, content, line };\n};\n\nconst makeRange = (\n  element: HTMLElement,\n  start: number,\n  end?: number\n): Range => {\n  if (start <= 0) start = 0;\n  if (!end || end < 0) end = start;\n\n  const range = document.createRange();\n  const queue: Node[] = [element.firstChild!];\n  let current = 0;\n\n  let node: Node;\n  let position = start;\n  while ((node = queue[queue.length - 1])) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const length = node.textContent!.length;\n      if (current + length >= position) {\n        const offset = position - current;\n        if (position === start) {\n          setStart(range, node, offset);\n          if (end !== start) {\n            position = end;\n            continue;\n          } else {\n            break;\n          }\n        } else {\n          setEnd(range, node, offset);\n          break;\n        }\n      }\n\n      current += node.textContent!.length;\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === 'BR') {\n      if (current + 1 >= position) {\n        if (position === start) {\n          setStart(range, node, 0);\n          if (end !== start) {\n            position = end;\n            continue;\n          } else {\n            break;\n          }\n        } else {\n          setEnd(range, node, 0);\n          break;\n        }\n      }\n\n      current++;\n    }\n\n    queue.pop();\n    if (node.nextSibling) queue.push(node.nextSibling);\n    if (node.firstChild) queue.push(node.firstChild);\n  }\n\n  return range;\n};\n\ninterface State {\n  observer: MutationObserver;\n  disconnected: boolean;\n  onChange(text: string, position: Position): void;\n  queue: MutationRecord[];\n  history: History[];\n  historyAt: number;\n  position: Position | null;\n}\n\nexport interface Options {\n  disabled?: boolean;\n  indentation?: number;\n}\n\nexport interface Edit {\n  /** Replaces the entire content of the editable while adjusting the caret position. */\n  update(content: string): void;\n  /** Inserts new text at the caret position while deleting text in range of the offset (which accepts negative offsets). */\n  insert(append: string, offset?: number): void;\n  /** Positions the caret where specified */\n  move(pos: number | { row: number; column: number }): void;\n  /** Returns the current editor state, as usually received in onChange */\n  getState(): { text: string; position: Position };\n}\n\nexport const useEditable = (\n  elementRef: { current: HTMLElement | undefined | null },\n  onChange: (text: string, position: Position) => void,\n  opts?: Options\n): Edit => {\n  if (!opts) opts = {};\n\n  const unblock = useState([])[1];\n  const state: State = useState(() => {\n    const state: State = {\n      observer: null as any,\n      disconnected: false,\n      onChange,\n      queue: [],\n      history: [],\n      historyAt: -1,\n      position: null,\n    };\n\n    if (typeof MutationObserver !== 'undefined') {\n      state.observer = new MutationObserver(batch => {\n        state.queue.push(...batch);\n      });\n    }\n\n    return state;\n  })[0];\n\n  const edit = useMemo<Edit>(\n    () => ({\n      update(content: string) {\n        const { current: element } = elementRef;\n        if (element) {\n          const position = getPosition(element);\n          const prevContent = toString(element);\n          position.position += content.length - prevContent.length;\n          state.position = position;\n          state.onChange(content, position);\n        }\n      },\n      insert(append: string, deleteOffset?: number) {\n        const { current: element } = elementRef;\n        if (element) {\n          let range = getCurrentRange();\n          range.deleteContents();\n          range.collapse();\n          const position = getPosition(element);\n          const offset = deleteOffset || 0;\n          const start = position.position + (offset < 0 ? offset : 0);\n          const end = position.position + (offset > 0 ? offset : 0);\n          range = makeRange(element, start, end);\n          range.deleteContents();\n          if (append) range.insertNode(document.createTextNode(append));\n          setCurrentRange(makeRange(element, start + append.length));\n        }\n      },\n      move(pos: number | { row: number; column: number }) {\n        const { current: element } = elementRef;\n        if (element) {\n          element.focus();\n          let position = 0;\n          if (typeof pos === 'number') {\n            position = pos;\n          } else {\n            const lines = toString(element).split('\\n').slice(0, pos.row);\n            if (pos.row) position += lines.join('\\n').length + 1;\n            position += pos.column;\n          }\n\n          setCurrentRange(makeRange(element, position));\n        }\n      },\n      getState() {\n        const { current: element } = elementRef;\n        const text = toString(element!);\n        const position = getPosition(element!);\n        return { text, position };\n      },\n    }),\n    []\n  );\n\n  // Only for SSR / server-side logic\n  if (typeof navigator !== 'object') return edit;\n\n  useLayoutEffect(() => {\n    state.onChange = onChange;\n\n    if (!elementRef.current || opts!.disabled) return;\n\n    state.disconnected = false;\n    state.observer.observe(elementRef.current, observerSettings);\n    if (state.position) {\n      const { position, extent } = state.position;\n      setCurrentRange(\n        makeRange(elementRef.current, position, position + extent)\n      );\n    }\n\n    return () => {\n      state.observer.disconnect();\n    };\n  });\n\n  useLayoutEffect(() => {\n    if (!elementRef.current || opts!.disabled) {\n      state.history.length = 0;\n      state.historyAt = -1;\n      return;\n    }\n\n    const element = elementRef.current!;\n    if (state.position) {\n      element.focus();\n      const { position, extent } = state.position;\n      setCurrentRange(makeRange(element, position, position + extent));\n    }\n\n    const prevWhiteSpace = element.style.whiteSpace;\n    const prevContentEditable = element.contentEditable;\n    let hasPlaintextSupport = true;\n    try {\n      // Firefox and IE11 do not support plaintext-only mode\n      element.contentEditable = 'plaintext-only';\n    } catch (_error) {\n      element.contentEditable = 'true';\n      hasPlaintextSupport = false;\n    }\n\n    if (prevWhiteSpace !== 'pre') element.style.whiteSpace = 'pre-wrap';\n\n    if (opts!.indentation) {\n      element.style.tabSize = (element.style as any).MozTabSize =\n        '' + opts!.indentation;\n    }\n\n    const indentPattern = `${' '.repeat(opts!.indentation || 0)}`;\n    const indentRe = new RegExp(`^(?:${indentPattern})`);\n    const blanklineRe = new RegExp(`^(?:${indentPattern})*(${indentPattern})$`);\n\n    let _trackStateTimestamp: number;\n    const trackState = (ignoreTimestamp?: boolean) => {\n      if (!elementRef.current || !state.position) return;\n\n      const content = toString(element);\n      const position = getPosition(element);\n      const timestamp = new Date().valueOf();\n\n      // Prevent recording new state in list if last one has been new enough\n      const lastEntry = state.history[state.historyAt];\n      if (\n        (!ignoreTimestamp && timestamp - _trackStateTimestamp < 500) ||\n        (lastEntry && lastEntry[1] === content)\n      ) {\n        _trackStateTimestamp = timestamp;\n        return;\n      }\n\n      const at = ++state.historyAt;\n      state.history[at] = [position, content];\n      state.history.splice(at + 1);\n      if (at > 500) {\n        state.historyAt--;\n        state.history.shift();\n      }\n    };\n\n    const disconnect = () => {\n      state.observer.disconnect();\n      state.disconnected = true;\n    };\n\n    const flushChanges = () => {\n      state.queue.push(...state.observer.takeRecords());\n      const position = getPosition(element);\n      if (state.queue.length) {\n        disconnect();\n        const content = toString(element);\n        state.position = position;\n        let mutation: MutationRecord | void;\n        let i = 0;\n        while ((mutation = state.queue.pop())) {\n          if (mutation.oldValue !== null)\n            mutation.target.textContent = mutation.oldValue;\n          for (i = mutation.removedNodes.length - 1; i >= 0; i--)\n            mutation.target.insertBefore(\n              mutation.removedNodes[i],\n              mutation.nextSibling\n            );\n          for (i = mutation.addedNodes.length - 1; i >= 0; i--)\n            if (mutation.addedNodes[i].parentNode)\n              mutation.target.removeChild(mutation.addedNodes[i]);\n        }\n\n        state.onChange(content, position);\n      }\n    };\n\n    const onKeyDown = (event: HTMLElementEventMap['keydown']) => {\n      if (event.defaultPrevented || event.target !== element) {\n        return;\n      } else if (state.disconnected) {\n        // React Quirk: It's expected that we may lose events while disconnected, which is why\n        // we'd like to block some inputs if they're unusually fast. However, this always\n        // coincides with React not executing the update immediately and then getting stuck,\n        // which can be prevented by issuing a dummy state change.\n        event.preventDefault();\n        return unblock([]);\n      }\n\n      if (isUndoRedoKey(event)) {\n        event.preventDefault();\n\n        let history: History;\n        if (!event.shiftKey) {\n          const at = --state.historyAt;\n          history = state.history[at];\n          if (!history) state.historyAt = 0;\n        } else {\n          const at = ++state.historyAt;\n          history = state.history[at];\n          if (!history) state.historyAt = state.history.length - 1;\n        }\n\n        if (history) {\n          disconnect();\n          state.position = history[0];\n          state.onChange(history[1], history[0]);\n        }\n        return;\n      } else {\n        trackState();\n      }\n\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        // Firefox Quirk: Since plaintext-only is unsupported we must\n        // ensure that only newline characters are inserted\n        const position = getPosition(element);\n        // We also get the current line and preserve indentation for the next\n        // line that's created\n        const match = /\\S/g.exec(position.content);\n        const index = match ? match.index : position.content.length;\n        const text = '\\n' + position.content.slice(0, index);\n        edit.insert(text);\n      } else if (\n        (!hasPlaintextSupport || opts!.indentation) &&\n        event.key === 'Backspace'\n      ) {\n        // Firefox Quirk: Since plaintext-only is unsupported we must\n        // ensure that only a single character is deleted\n        event.preventDefault();\n        const range = getCurrentRange();\n        if (!range.collapsed) {\n          edit.insert('', 0);\n        } else {\n          const position = getPosition(element);\n          const match = blanklineRe.exec(position.content);\n          edit.insert('', match ? -match[1].length : -1);\n        }\n      } else if (opts!.indentation && event.key === 'Tab') {\n        event.preventDefault();\n        const position = getPosition(element);\n        const start = position.position - position.content.length;\n        const content = toString(element);\n        const newContent = event.shiftKey\n          ? content.slice(0, start) +\n            position.content.replace(indentRe, '') +\n            content.slice(start + position.content.length)\n          : content.slice(0, start) +\n            (opts!.indentation ? ' '.repeat(opts!.indentation) : '\\t') +\n            content.slice(start);\n        edit.update(newContent);\n      }\n\n      // Flush changes as a key is held so the app can catch up\n      if (event.repeat) flushChanges();\n    };\n\n    const onKeyUp = (event: HTMLElementEventMap['keyup']) => {\n      if (event.defaultPrevented || event.isComposing) return;\n      if (!isUndoRedoKey(event)) trackState();\n      flushChanges();\n      // Chrome Quirk: The contenteditable may lose focus after the first edit or so\n      element.focus();\n    };\n\n    const onSelect = (event: Event) => {\n      // Chrome Quirk: The contenteditable may lose its selection immediately on first focus\n      state.position =\n        window.getSelection()!.rangeCount && event.target === element\n          ? getPosition(element)\n          : null;\n    };\n\n    const onPaste = (event: HTMLElementEventMap['paste']) => {\n      event.preventDefault();\n      trackState(true);\n      edit.insert(event.clipboardData!.getData('text/plain'));\n      trackState(true);\n      flushChanges();\n    };\n\n    document.addEventListener('selectstart', onSelect);\n    window.addEventListener('keydown', onKeyDown);\n    element.addEventListener('paste', onPaste);\n    element.addEventListener('keyup', onKeyUp);\n\n    return () => {\n      document.removeEventListener('selectstart', onSelect);\n      window.removeEventListener('keydown', onKeyDown);\n      element.removeEventListener('paste', onPaste);\n      element.removeEventListener('keyup', onKeyUp);\n      element.style.whiteSpace = prevWhiteSpace;\n      element.contentEditable = prevContentEditable;\n    };\n  }, [elementRef.current!, opts!.disabled, opts!.indentation]);\n\n  return edit;\n};\n"],"names":["const","observerSettings","characterData","characterDataOldValue","childList","subtree","range","selection","window","event","element","node","content","queue","Node","extent","untilRange","document","lines","line","start","end","current","position","offset","getPosition","toString","prevContent","append","deleteOffset","makeRange","pos","opts","unblock","useState","state","observer","disconnected","onChange","history","historyAt","MutationObserver","batch","edit","useMemo","update","insert","move","getState","elementRef","prevWhiteSpace","prevContentEditable","hasPlaintextSupport","_error","_trackStateTimestamp","indentRe","RegExp","indentPattern","blanklineRe","trackState","ignoreTimestamp","timestamp","valueOf","Date","lastEntry","at","flushChanges","mutation","i","onKeyDown","isUndoRedoKey","match","text","newContent","onKeyUp","onSelect","onPaste"],"mappings":"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"}