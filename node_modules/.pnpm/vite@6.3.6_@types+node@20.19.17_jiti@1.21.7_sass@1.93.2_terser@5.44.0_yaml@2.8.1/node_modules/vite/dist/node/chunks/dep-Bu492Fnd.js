import * as fs$8 from 'node:fs';
import fs__default, { promises as promises$1, existsSync as existsSync$1, readFileSync as readFileSync$1 } from 'node:fs';
import path$b, { posix as posix$1, isAbsolute as isAbsolute$1, join as join$1, resolve as resolve$4, sep as sep$1, normalize, dirname as dirname$2, relative as relative$2, basename as basename$2, extname as extname$1 } from 'node:path';
import fsp, { constants as constants$3 } from 'node:fs/promises';
import require$$1$1, { fileURLToPath as fileURLToPath$1, URL as URL$3, pathToFileURL as pathToFileURL$1 } from 'node:url';
import { promisify as promisify$4, format as format$2, inspect, stripVTControlCharacters } from 'node:util';
import { performance as performance$1 } from 'node:perf_hooks';
import require$$0$6, { createRequire as createRequire$1, builtinModules } from 'node:module';
import crypto$2 from 'node:crypto';
import picomatch$2 from 'picomatch';
import esbuild, { transform as transform$1, formatMessages, build as build$3 } from 'esbuild';
import { CLIENT_ENTRY, wildcardHosts, loopbackHosts, OPTIMIZABLE_ENTRY_RE, FS_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH, DEFAULT_ASSETS_INLINE_LIMIT, SPECIAL_QUERY_RE, KNOWN_ASSET_TYPES, JS_TYPES_RE, CSS_LANGS_RE, METADATA_FILENAME, ESBUILD_MODULES_TARGET, ENV_ENTRY, DEP_VERSION_RE, DEV_PROD_CONDITION, ERR_OPTIMIZE_DEPS_PROCESSING_ERROR, ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR, VITE_PACKAGE_DIR, defaultAllowedOrigins, DEFAULT_DEV_PORT, CLIENT_DIR, VERSION, ROLLUP_HOOKS, DEFAULT_PREVIEW_PORT, DEFAULT_ASSETS_RE, DEFAULT_CONFIG_FILES, DEFAULT_CLIENT_CONDITIONS, DEFAULT_SERVER_CONDITIONS, DEFAULT_CLIENT_MAIN_FIELDS, DEFAULT_SERVER_MAIN_FIELDS } from '../constants.js';
import require$$0$2, { posix, isAbsolute, resolve as resolve$3, win32, relative as relative$1, join, dirname as dirname$1, extname, basename as basename$1, sep } from 'path';
import require$$0$4, { statSync, existsSync, readFileSync, readdirSync } from 'fs';
import { fdir } from 'fdir';
import childProcess$2, { exec, execFile, execSync } from 'node:child_process';
import { createServer as createServer$3, STATUS_CODES, get as get$2 } from 'node:http';
import { createServer as createServer$2, get as get$1 } from 'node:https';
import require$$0$3 from 'tty';
import require$$1 from 'util';
import require$$4$1 from 'net';
import require$$0$7 from 'events';
import require$$0$5 from 'url';
import require$$1$2 from 'http';
import require$$0$8 from 'stream';
import require$$2 from 'os';
import require$$2$1 from 'child_process';
import os$3 from 'node:os';
import net$1 from 'node:net';
import { promises } from 'node:dns';
import { ModuleRunner, ESModulesEvaluator } from 'vite/module-runner';
import { parseAstAsync, parseAst } from 'rollup/parseAst';
import { Buffer as Buffer$1 } from 'node:buffer';
import { createRequire as createRequire$2 } from 'module';
import readline from 'node:readline';
import process$1 from 'node:process';
import { EventEmitter as EventEmitter$4 } from 'node:events';
import { glob, escapePath, isDynamicPattern, globSync } from 'tinyglobby';
import require$$3 from 'crypto';
import assert$1 from 'node:assert';
import v8 from 'node:v8';
import { Worker as Worker$1, MessageChannel } from 'node:worker_threads';
import require$$1$3 from 'https';
import require$$4$2 from 'tls';
import zlib$1 from 'zlib';
import require$$0$9 from 'buffer';
import require$$4$3 from 'assert';
import * as qs from 'node:querystring';
import { gzip } from 'node:zlib';

import { createRequire as __cjs_createRequire } from 'node:module';

const __require = __cjs_createRequire(import.meta.url);
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

let p = process || {}, argv = p.argv || [], env$1 = p.env || {};
let isColorSupported =
	!(!!env$1.NO_COLOR || argv.includes("--no-color")) &&
	(!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env$1.TERM !== "dumb") || !!env$1.CI);

let formatter = (open, close, replace = open) =>
	input => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
	};

let replaceClose = (string, close, replace, index) => {
	let result = "", cursor = 0;
	do {
		result += string.substring(cursor, index) + replace;
		cursor = index + close.length;
		index = string.indexOf(close, cursor);
	} while (~index)
	return result + string.substring(cursor)
};

let createColors = (enabled = isColorSupported) => {
	let f = enabled ? formatter : () => String;
	return {
		isColorSupported: enabled,
		reset: f("\x1b[0m", "\x1b[0m"),
		bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
		dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
		italic: f("\x1b[3m", "\x1b[23m"),
		underline: f("\x1b[4m", "\x1b[24m"),
		inverse: f("\x1b[7m", "\x1b[27m"),
		hidden: f("\x1b[8m", "\x1b[28m"),
		strikethrough: f("\x1b[9m", "\x1b[29m"),

		black: f("\x1b[30m", "\x1b[39m"),
		red: f("\x1b[31m", "\x1b[39m"),
		green: f("\x1b[32m", "\x1b[39m"),
		yellow: f("\x1b[33m", "\x1b[39m"),
		blue: f("\x1b[34m", "\x1b[39m"),
		magenta: f("\x1b[35m", "\x1b[39m"),
		cyan: f("\x1b[36m", "\x1b[39m"),
		white: f("\x1b[37m", "\x1b[39m"),
		gray: f("\x1b[90m", "\x1b[39m"),

		bgBlack: f("\x1b[40m", "\x1b[49m"),
		bgRed: f("\x1b[41m", "\x1b[49m"),
		bgGreen: f("\x1b[42m", "\x1b[49m"),
		bgYellow: f("\x1b[43m", "\x1b[49m"),
		bgBlue: f("\x1b[44m", "\x1b[49m"),
		bgMagenta: f("\x1b[45m", "\x1b[49m"),
		bgCyan: f("\x1b[46m", "\x1b[49m"),
		bgWhite: f("\x1b[47m", "\x1b[49m"),

		blackBright: f("\x1b[90m", "\x1b[39m"),
		redBright: f("\x1b[91m", "\x1b[39m"),
		greenBright: f("\x1b[92m", "\x1b[39m"),
		yellowBright: f("\x1b[93m", "\x1b[39m"),
		blueBright: f("\x1b[94m", "\x1b[39m"),
		magentaBright: f("\x1b[95m", "\x1b[39m"),
		cyanBright: f("\x1b[96m", "\x1b[39m"),
		whiteBright: f("\x1b[97m", "\x1b[39m"),

		bgBlackBright: f("\x1b[100m", "\x1b[49m"),
		bgRedBright: f("\x1b[101m", "\x1b[49m"),
		bgGreenBright: f("\x1b[102m", "\x1b[49m"),
		bgYellowBright: f("\x1b[103m", "\x1b[49m"),
		bgBlueBright: f("\x1b[104m", "\x1b[49m"),
		bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
		bgCyanBright: f("\x1b[106m", "\x1b[49m"),
		bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
	}
};

picocolors.exports = createColors();
picocolors.exports.createColors = createColors;

var picocolorsExports = picocolors.exports;
var colors$1 = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const VALID_ID_PREFIX = `/@id/`;
const NULL_BYTE_PLACEHOLDER = `__x00__`;
let SOURCEMAPPING_URL = "sourceMa";
SOURCEMAPPING_URL += "ppingURL";
const MODULE_RUNNER_SOURCEMAPPING_SOURCE = "//# sourceMappingSource=vite-generated";
const ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";

const isWindows$3 = typeof process !== "undefined" && process.platform === "win32";
function wrapId$1(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
function unwrapId$1(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
const windowsSlashRE = /\\/g;
function slash$1(p) {
  return p.replace(windowsSlashRE, "/");
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}
function splitFileAndPostfix(path) {
  const file = cleanUrl(path);
  return { file, postfix: path.slice(file.length) };
}
function withTrailingSlash(path) {
  if (path[path.length - 1] !== "/") {
    return `${path}/`;
  }
  return path;
}
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, resolve, reject };
}

// @ts-check
/** @typedef { import('estree').BaseNode} BaseNode */

/** @typedef {{
	skip: () => void;
	remove: () => void;
	replace: (node: BaseNode) => void;
}} WalkerContext */

let WalkerBase$1 = class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {BaseNode | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 * @param {BaseNode} node
	 */
	replace(parent, prop, index, node) {
		if (parent) {
			if (index !== null) {
				parent[prop][index] = node;
			} else {
				parent[prop] = node;
			}
		}
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 */
	remove(parent, prop, index) {
		if (parent) {
			if (index !== null) {
				parent[prop].splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
};

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./walker.js').WalkerContext} WalkerContext */

/** @typedef {(
 *    this: WalkerContext,
 *    node: BaseNode,
 *    parent: BaseNode,
 *    key: string,
 *    index: number
 * ) => void} SyncHandler */

let SyncWalker$1 = class SyncWalker extends WalkerBase$1 {
	/**
	 *
	 * @param {SyncHandler} enter
	 * @param {SyncHandler} leave
	 */
	constructor(enter, leave) {
		super();

		/** @type {SyncHandler} */
		this.enter = enter;

		/** @type {SyncHandler} */
		this.leave = leave;
	}

	/**
	 *
	 * @param {BaseNode} node
	 * @param {BaseNode} parent
	 * @param {string} [prop]
	 * @param {number} [index]
	 * @returns {BaseNode}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			for (const key in node) {
				const value = node[key];

				if (typeof value !== "object") {
					continue;
				} else if (Array.isArray(value)) {
					for (let i = 0; i < value.length; i += 1) {
						if (value[i] !== null && typeof value[i].type === 'string') {
							if (!this.visit(value[i], node, key, i)) {
								// removed
								i--;
							}
						}
					}
				} else if (value !== null && typeof value.type === "string") {
					this.visit(value, node, key, null);
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
};

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */

/**
 *
 * @param {BaseNode} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {BaseNode}
 */
function walk$2(ast, { enter, leave }) {
	const instance = new SyncWalker$1(enter, leave);
	return instance.visit(ast, null);
}

const extractors = {
    ArrayPattern(names, param) {
        for (const element of param.elements) {
            if (element)
                extractors[element.type](names, element);
        }
    },
    AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
    },
    Identifier(names, param) {
        names.push(param.name);
    },
    MemberExpression() { },
    ObjectPattern(names, param) {
        for (const prop of param.properties) {
            // @ts-ignore Typescript reports that this is not a valid type
            if (prop.type === 'RestElement') {
                extractors.RestElement(names, prop);
            }
            else {
                extractors[prop.value.type](names, prop.value);
            }
        }
    },
    RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
    }
};
const extractAssignedNames = function extractAssignedNames(param) {
    const names = [];
    extractors[param.type](names, param);
    return names;
};

const blockDeclarations = {
    const: true,
    let: true
};
class Scope {
    constructor(options = {}) {
        this.parent = options.parent;
        this.isBlockScope = !!options.block;
        this.declarations = Object.create(null);
        if (options.params) {
            options.params.forEach((param) => {
                extractAssignedNames(param).forEach((name) => {
                    this.declarations[name] = true;
                });
            });
        }
    }
    addDeclaration(node, isBlockDeclaration, isVar) {
        if (!isBlockDeclaration && this.isBlockScope) {
            // it's a `var` or function node, and this
            // is a block scope, so we need to go up
            this.parent.addDeclaration(node, isBlockDeclaration, isVar);
        }
        else if (node.id) {
            extractAssignedNames(node.id).forEach((name) => {
                this.declarations[name] = true;
            });
        }
    }
    contains(name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
    }
}
const attachScopes = function attachScopes(ast, propertyName = 'scope') {
    let scope = new Scope();
    walk$2(ast, {
        enter(n, parent) {
            const node = n;
            // function foo () {...}
            // class Foo {...}
            if (/(?:Function|Class)Declaration/.test(node.type)) {
                scope.addDeclaration(node, false, false);
            }
            // var foo = 1
            if (node.type === 'VariableDeclaration') {
                const { kind } = node;
                const isBlockDeclaration = blockDeclarations[kind];
                node.declarations.forEach((declaration) => {
                    scope.addDeclaration(declaration, isBlockDeclaration, true);
                });
            }
            let newScope;
            // create new function scope
            if (node.type.includes('Function')) {
                const func = node;
                newScope = new Scope({
                    parent: scope,
                    block: false,
                    params: func.params
                });
                // named function expressions - the name is considered
                // part of the function's scope
                if (func.type === 'FunctionExpression' && func.id) {
                    newScope.addDeclaration(func, false, false);
                }
            }
            // create new for scope
            if (/For(?:In|Of)?Statement/.test(node.type)) {
                newScope = new Scope({
                    parent: scope,
                    block: true
                });
            }
            // create new block scope
            if (node.type === 'BlockStatement' && !parent.type.includes('Function')) {
                newScope = new Scope({
                    parent: scope,
                    block: true
                });
            }
            // catch clause has its own block scope
            if (node.type === 'CatchClause') {
                newScope = new Scope({
                    parent: scope,
                    params: node.param ? [node.param] : [],
                    block: true
                });
            }
            if (newScope) {
                Object.defineProperty(node, propertyName, {
                    value: newScope,
                    configurable: true
                });
                scope = newScope;
            }
        },
        leave(n) {
            const node = n;
            if (node[propertyName])
                scope = scope.parent;
        }
    });
    return scope;
};

// Helper since Typescript can't detect readonly arrays with Array.isArray
function isArray(arg) {
    return Array.isArray(arg);
}
function ensureArray(thing) {
    if (isArray(thing))
        return thing;
    if (thing == null)
        return [];
    return [thing];
}

const normalizePathRegExp = new RegExp(`\\${win32.sep}`, 'g');
const normalizePath$5 = function normalizePath(filename) {
    return filename.replace(normalizePathRegExp, posix.sep);
};

function getMatcherString$1(id, resolutionBase) {
    if (resolutionBase === false || isAbsolute(id) || id.startsWith('**')) {
        return normalizePath$5(id);
    }
    // resolve('') is valid and will default to process.cwd()
    const basePath = normalizePath$5(resolve$3(resolutionBase || ''))
        // escape all possible (posix + win) path characters that might interfere with regex
        .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
    // Note that we use posix.join because:
    // 1. the basePath has been normalized to use /
    // 2. the incoming glob (id) matcher, also uses /
    // otherwise Node will force backslash (\) on windows
    return posix.join(basePath, normalizePath$5(id));
}
const createFilter$2 = function createFilter(include, exclude, options) {
    const resolutionBase = options && options.resolve;
    const getMatcher = (id) => id instanceof RegExp
        ? id
        : {
            test: (what) => {
                // this refactor is a tad overly verbose but makes for easy debugging
                const pattern = getMatcherString$1(id, resolutionBase);
                const fn = picomatch$2(pattern, { dot: true });
                const result = fn(what);
                return result;
            }
        };
    const includeMatchers = ensureArray(include).map(getMatcher);
    const excludeMatchers = ensureArray(exclude).map(getMatcher);
    if (!includeMatchers.length && !excludeMatchers.length)
        return (id) => typeof id === 'string' && !id.includes('\0');
    return function result(id) {
        if (typeof id !== 'string')
            return false;
        if (id.includes('\0'))
            return false;
        const pathId = normalizePath$5(id);
        for (let i = 0; i < excludeMatchers.length; ++i) {
            const matcher = excludeMatchers[i];
            if (matcher instanceof RegExp) {
                matcher.lastIndex = 0;
            }
            if (matcher.test(pathId))
                return false;
        }
        for (let i = 0; i < includeMatchers.length; ++i) {
            const matcher = includeMatchers[i];
            if (matcher instanceof RegExp) {
                matcher.lastIndex = 0;
            }
            if (matcher.test(pathId))
                return true;
        }
        return !includeMatchers.length;
    };
};

const reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
const forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));
forbiddenIdentifiers.add('');
const makeLegalIdentifier = function makeLegalIdentifier(str) {
    let identifier = str
        .replace(/-(\w)/g, (_, letter) => letter.toUpperCase())
        .replace(/[^$_a-zA-Z0-9]/g, '_');
    if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
        identifier = `_${identifier}`;
    }
    return identifier || '_';
};

function stringify$5(obj) {
    return (JSON.stringify(obj) || 'undefined').replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
    let output = '[';
    const separator = indent ? `\n${baseIndent}${indent}` : '';
    for (let i = 0; i < arr.length; i++) {
        const key = arr[i];
        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;
    }
    return `${output}${indent ? `\n${baseIndent}` : ''}]`;
}
function serializeObject(obj, indent, baseIndent) {
    let output = '{';
    const separator = indent ? `\n${baseIndent}${indent}` : '';
    const entries = Object.entries(obj);
    for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        const stringKey = makeLegalIdentifier(key) === key ? key : stringify$5(key);
        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;
    }
    return `${output}${indent ? `\n${baseIndent}` : ''}}`;
}
function serialize(obj, indent, baseIndent) {
    if (typeof obj === 'object' && obj !== null) {
        if (Array.isArray(obj))
            return serializeArray(obj, indent, baseIndent);
        if (obj instanceof Date)
            return `new Date(${obj.getTime()})`;
        if (obj instanceof RegExp)
            return obj.toString();
        return serializeObject(obj, indent, baseIndent);
    }
    if (typeof obj === 'number') {
        if (obj === Infinity)
            return 'Infinity';
        if (obj === -Infinity)
            return '-Infinity';
        if (obj === 0)
            return 1 / obj === Infinity ? '0' : '-0';
        if (obj !== obj)
            return 'NaN'; // eslint-disable-line no-self-compare
    }
    if (typeof obj === 'symbol') {
        const key = Symbol.keyFor(obj);
        // eslint-disable-next-line no-undefined
        if (key !== undefined)
            return `Symbol.for(${stringify$5(key)})`;
    }
    if (typeof obj === 'bigint')
        return `${obj}n`;
    return stringify$5(obj);
}
// isWellFormed exists from Node.js 20
const hasStringIsWellFormed = 'isWellFormed' in String.prototype;
function isWellFormedString(input) {
    // @ts-expect-error String::isWellFormed exists from ES2024. tsconfig lib is set to ES6
    if (hasStringIsWellFormed)
        return input.isWellFormed();
    // https://github.com/tc39/proposal-is-usv-string/blob/main/README.md#algorithm
    return !/\p{Surrogate}/u.test(input);
}
const dataToEsm = function dataToEsm(data, options = {}) {
    var _a, _b;
    const t = options.compact ? '' : 'indent' in options ? options.indent : '\t';
    const _ = options.compact ? '' : ' ';
    const n = options.compact ? '' : '\n';
    const declarationType = options.preferConst ? 'const' : 'var';
    if (options.namedExports === false ||
        typeof data !== 'object' ||
        Array.isArray(data) ||
        data instanceof Date ||
        data instanceof RegExp ||
        data === null) {
        const code = serialize(data, options.compact ? null : t, '');
        const magic = _ || (/^[{[\-\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape
        return `export default${magic}${code};`;
    }
    let maxUnderbarPrefixLength = 0;
    for (const key of Object.keys(data)) {
        const underbarPrefixLength = (_b = (_a = /^(_+)/.exec(key)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;
        if (underbarPrefixLength > maxUnderbarPrefixLength) {
            maxUnderbarPrefixLength = underbarPrefixLength;
        }
    }
    const arbitraryNamePrefix = `${'_'.repeat(maxUnderbarPrefixLength + 1)}arbitrary`;
    let namedExportCode = '';
    const defaultExportRows = [];
    const arbitraryNameExportRows = [];
    for (const [key, value] of Object.entries(data)) {
        if (key === makeLegalIdentifier(key)) {
            if (options.objectShorthand)
                defaultExportRows.push(key);
            else
                defaultExportRows.push(`${key}:${_}${key}`);
            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;
        }
        else {
            defaultExportRows.push(`${stringify$5(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);
            if (options.includeArbitraryNames && isWellFormedString(key)) {
                const variableName = `${arbitraryNamePrefix}${arbitraryNameExportRows.length}`;
                namedExportCode += `${declarationType} ${variableName}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;
                arbitraryNameExportRows.push(`${variableName} as ${JSON.stringify(key)}`);
            }
        }
    }
    const arbitraryExportCode = arbitraryNameExportRows.length > 0
        ? `export${_}{${n}${t}${arbitraryNameExportRows.join(`,${n}${t}`)}${n}};${n}`
        : '';
    const defaultExportCode = `export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;
    return `${namedExportCode}${arbitraryExportCode}${defaultExportCode}`;
};

var path$a = require$$0$2;

var commondir = function (basedir, relfiles) {
    if (relfiles) {
        var files = relfiles.map(function (r) {
            return path$a.resolve(basedir, r);
        });
    }
    else {
        var files = basedir;
    }
    
    var res = files.slice(1).reduce(function (ps, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
            throw new Error('relative path without a basedir');
        }
        
        var xs = file.split(/\/+|\\+/);
        for (
            var i = 0;
            ps[i] === xs[i] && i < Math.min(ps.length, xs.length);
            i++
        );
        return ps.slice(0, i);
    }, files[0].split(/\/+|\\+/));
    
    // Windows correctly handles paths with forward-slashes
    return res.length > 1 ? res.join('/') : '/'
};

var getCommonDir = /*@__PURE__*/getDefaultExportFromCjs(commondir);

const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars$1.length; i++) {
    const c = chars$1.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    } while (integer & 32);
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
        value = -2147483648 | -value;
    }
    return relative + value;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;
    do {
        let clamped = delta & 0b011111;
        delta >>>= 5;
        if (delta > 0)
            clamped |= 0b100000;
        builder.write(intToChar[clamped]);
    } while (delta > 0);
    return num;
}
function hasMoreVlq(reader, max) {
    if (reader.pos >= max)
        return false;
    return reader.peek() !== comma;
}

const bufLength = 1024 * 16;
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
        ? {
            decode(buf) {
                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                return out.toString();
            },
        }
        : {
            decode(buf) {
                let out = '';
                for (let i = 0; i < buf.length; i++) {
                    out += String.fromCharCode(buf[i]);
                }
                return out;
            },
        };
class StringWriter {
    constructor() {
        this.pos = 0;
        this.out = '';
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
}
class StringReader {
    constructor(buffer) {
        this.pos = 0;
        this.buffer = buffer;
    }
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return idx === -1 ? buffer.length : idx;
    }
}

function decode(mappings) {
    const { length } = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(';');
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
                sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
                }
                else {
                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
                }
            }
            else {
                seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
        }
        if (!sorted)
            sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    } while (reader.pos <= length);
    return decoded;
}
function sort(line) {
    line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
    return a[0] - b[0];
}
function encode$1(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0)
            writer.write(semicolon);
        if (line.length === 0)
            continue;
        let genColumn = 0;
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
                writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
                continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
                continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   ✔️ edit    -> '' + 'test'
			//   ✖️ edit    -> 'test' + ''
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa$1 = /*#__PURE__*/ getBtoa();

let SourceMap$1 = class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode$1(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
		if (typeof properties.debugId !== 'undefined') {
			this.debugId = properties.debugId;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa$1(this.toString());
	}
};

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString$1 = Object.prototype.toString;

function isObject$2(thing) {
	return toString$1.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

					if (this.hires === 'boundary') {
						// in hires "boundary", group segments per word boundary than per char
						if (wordRegex.test(original[originalCharIndex])) {
							// for first char in the boundary found, start the boundary by pushing a segment
							if (!charInHiresBoundary) {
								this.rawSegments.push(segment);
								charInHiresBoundary = true;
							}
						} else {
							// for non-word char, end the boundary by pushing a segment
							this.rawSegments.push(segment);
							charInHiresBoundary = false;
						}
					} else {
						this.rawSegments.push(segment);
					}
				}

				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n$1 = '\n';

const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
			offset: { writable: true, value: options.offset || 0 },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap$1(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject$2(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			);
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			);
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;

		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;

		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				);
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n$1);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n$1);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(match.index, match.index + match[0].length, replacement);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(match.index, match.index + match[0].length, replacement);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			this.overwrite(index, index + string.length, replacement);
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
}

function isReference(node, parent) {
    if (node.type === 'MemberExpression') {
        return !node.computed && isReference(node.object, node);
    }
    if (node.type === 'Identifier') {
        if (!parent)
            return true;
        switch (parent.type) {
            // disregard `bar` in `foo.bar`
            case 'MemberExpression': return parent.computed || node === parent.object;
            // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
            case 'MethodDefinition': return parent.computed;
            // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
            case 'FieldDefinition': return parent.computed || node === parent.value;
            // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
            case 'Property': return parent.computed || node === parent.value;
            // disregard the `bar` in `export { foo as bar }` or
            // the foo in `import { foo as bar }`
            case 'ExportSpecifier':
            case 'ImportSpecifier': return node === parent.local;
            // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
            case 'LabeledStatement':
            case 'BreakStatement':
            case 'ContinueStatement': return false;
            default: return true;
        }
    }
    return false;
}

var version$2 = "28.0.3";
var peerDependencies = {
	rollup: "^2.68.0||^3.0.0||^4.0.0"
};

function tryParse(parse, code, id) {
  try {
    return parse(code, { allowReturnOutsideFunction: true });
  } catch (err) {
    err.message += ` in ${id}`;
    throw err;
  }
}

const firstpassGlobal = /\b(?:require|module|exports|global)\b/;

const firstpassNoGlobal = /\b(?:require|module|exports)\b/;

function hasCjsKeywords(code, ignoreGlobal) {
  const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
  return firstpass.test(code);
}

/* eslint-disable no-underscore-dangle */


function analyzeTopLevelStatements(parse, code, id) {
  const ast = tryParse(parse, code, id);

  let isEsModule = false;
  let hasDefaultExport = false;
  let hasNamedExports = false;

  for (const node of ast.body) {
    switch (node.type) {
      case 'ExportDefaultDeclaration':
        isEsModule = true;
        hasDefaultExport = true;
        break;
      case 'ExportNamedDeclaration':
        isEsModule = true;
        if (node.declaration) {
          hasNamedExports = true;
        } else {
          for (const specifier of node.specifiers) {
            if (specifier.exported.name === 'default') {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
          }
        }
        break;
      case 'ExportAllDeclaration':
        isEsModule = true;
        if (node.exported && node.exported.name === 'default') {
          hasDefaultExport = true;
        } else {
          hasNamedExports = true;
        }
        break;
      case 'ImportDeclaration':
        isEsModule = true;
        break;
    }
  }

  return { isEsModule, hasDefaultExport, hasNamedExports, ast };
}

/* eslint-disable import/prefer-default-export */


function deconflict(scopes, globals, identifier) {
  let i = 1;
  let deconflicted = makeLegalIdentifier(identifier);
  const hasConflicts = () =>
    scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);

  while (hasConflicts()) {
    deconflicted = makeLegalIdentifier(`${identifier}_${i}`);
    i += 1;
  }

  for (const scope of scopes) {
    scope.declarations[deconflicted] = true;
  }

  return deconflicted;
}

function getName(id) {
  const name = makeLegalIdentifier(basename$1(id, extname(id)));
  if (name !== 'index') {
    return name;
  }
  return makeLegalIdentifier(basename$1(dirname$1(id)));
}

function normalizePathSlashes(path) {
  return path.replace(/\\/g, '/');
}

const getVirtualPathForDynamicRequirePath = (path, commonDir) =>
  `/${normalizePathSlashes(relative$1(commonDir, path))}`;

function capitalize(name) {
  return name[0].toUpperCase() + name.slice(1);
}

function getStrictRequiresFilter({ strictRequires }) {
  switch (strictRequires) {
    // eslint-disable-next-line no-undefined
    case undefined:
    case true:
      return { strictRequiresFilter: () => true, detectCyclesAndConditional: false };
    case 'auto':
    case 'debug':
    case null:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: true };
    case false:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: false };
    default:
      if (typeof strictRequires === 'string' || Array.isArray(strictRequires)) {
        return {
          strictRequiresFilter: createFilter$2(strictRequires),
          detectCyclesAndConditional: false
        };
      }
      throw new Error('Unexpected value for "strictRequires" option.');
  }
}

function getPackageEntryPoint(dirPath) {
  let entryPoint = 'index.js';

  try {
    if (existsSync(join(dirPath, 'package.json'))) {
      entryPoint =
        JSON.parse(readFileSync(join(dirPath, 'package.json'), { encoding: 'utf8' })).main ||
        entryPoint;
    }
  } catch (ignored) {
    // ignored
  }

  return entryPoint;
}

function isDirectory$1(path) {
  try {
    if (statSync(path).isDirectory()) return true;
  } catch (ignored) {
    // Nothing to do here
  }
  return false;
}

function getDynamicRequireModules(patterns, dynamicRequireRoot) {
  const dynamicRequireModules = new Map();
  const dirNames = new Set();
  for (const pattern of !patterns || Array.isArray(patterns) ? patterns || [] : [patterns]) {
    const isNegated = pattern.startsWith('!');
    const modifyMap = (targetPath, resolvedPath) =>
      isNegated
        ? dynamicRequireModules.delete(targetPath)
        : dynamicRequireModules.set(targetPath, resolvedPath);
    // eslint-disable-next-line new-cap
    for (const path of new fdir()
      .withBasePath()
      .withDirs()
      .glob(isNegated ? pattern.substr(1) : pattern)
      .crawl()
      .sync()
      .sort((a, b) => a.localeCompare(b, 'en'))) {
      const resolvedPath = resolve$3(path);
      const requirePath = normalizePathSlashes(resolvedPath);
      if (isDirectory$1(resolvedPath)) {
        dirNames.add(resolvedPath);
        const modulePath = resolve$3(join(resolvedPath, getPackageEntryPoint(path)));
        modifyMap(requirePath, modulePath);
        modifyMap(normalizePathSlashes(modulePath), modulePath);
      } else {
        dirNames.add(dirname$1(resolvedPath));
        modifyMap(requirePath, resolvedPath);
      }
    }
  }
  return {
    commonDir: dirNames.size ? getCommonDir([...dirNames, dynamicRequireRoot]) : null,
    dynamicRequireModules
  };
}

const FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;

const COMMONJS_REQUIRE_EXPORT = 'commonjsRequire';
const CREATE_COMMONJS_REQUIRE_EXPORT = 'createCommonjsRequire';

function getDynamicModuleRegistry(
  isDynamicRequireModulesEnabled,
  dynamicRequireModules,
  commonDir,
  ignoreDynamicRequires
) {
  if (!isDynamicRequireModulesEnabled) {
    return `export function ${COMMONJS_REQUIRE_EXPORT}(path) {
	${FAILED_REQUIRE_ERROR}
}`;
  }
  const dynamicModuleImports = [...dynamicRequireModules.values()]
    .map(
      (id, index) =>
        `import ${
          id.endsWith('.json') ? `json${index}` : `{ __require as require${index} }`
        } from ${JSON.stringify(id)};`
    )
    .join('\n');
  const dynamicModuleProps = [...dynamicRequireModules.keys()]
    .map(
      (id, index) =>
        `\t\t${JSON.stringify(getVirtualPathForDynamicRequirePath(id, commonDir))}: ${
          id.endsWith('.json') ? `function () { return json${index}; }` : `require${index}`
        }`
    )
    .join(',\n');
  return `${dynamicModuleImports}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
${dynamicModuleProps}
	});
}

export function ${CREATE_COMMONJS_REQUIRE_EXPORT}(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		${ignoreDynamicRequires ? 'return require(path);' : FAILED_REQUIRE_ERROR}
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}`;
}

const isWrappedId = (id, suffix) => id.endsWith(suffix);
const wrapId = (id, suffix) => `\0${id}${suffix}`;
const unwrapId = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);

// A proxy module when a module is required from non-wrapped CommonJS. Is different for ESM and CommonJS requires.
const PROXY_SUFFIX = '?commonjs-proxy';
// Indicates that a required module is wrapped commonjs and needs special handling.
const WRAPPED_SUFFIX = '?commonjs-wrapped';
// Indicates that a required module is external
const EXTERNAL_SUFFIX = '?commonjs-external';
// A helper module that contains the exports object of a module
const EXPORTS_SUFFIX = '?commonjs-exports';
// A helper module that contains the module object of a module, e.g. when module.exports is reassigned
const MODULE_SUFFIX = '?commonjs-module';
// A special proxy for CommonJS entry points
const ENTRY_SUFFIX = '?commonjs-entry';
// A proxy when wrapped ESM is required from CommonJS
const ES_IMPORT_SUFFIX = '?commonjs-es-import';

const DYNAMIC_MODULES_ID = '\0commonjs-dynamic-modules';
const HELPERS_ID = '\0commonjsHelpers.js';

const IS_WRAPPED_COMMONJS = 'withRequireFunction';

// `x['default']` is used instead of `x.default` for backward compatibility with ES3 browsers.
// Minifiers like uglify will usually transpile it back if compatibility with ES3 is not enabled.
// This could be improved by inspecting Rollup's "generatedCode" option

const HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;

function getHelpersModule() {
  return HELPERS;
}

function getUnknownRequireProxy(id, requireReturnsDefault) {
  if (requireReturnsDefault === true || id.endsWith('.json')) {
    return `export { default } from ${JSON.stringify(id)};`;
  }
  const name = getName(id);
  const exported =
    requireReturnsDefault === 'auto'
      ? `import { getDefaultExportFromNamespaceIfNotNamed } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});`
      : requireReturnsDefault === 'preferred'
      ? `import { getDefaultExportFromNamespaceIfPresent } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});`
      : !requireReturnsDefault
      ? `import { getAugmentedNamespace } from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});`
      : `export default ${name};`;
  return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
}

async function getStaticRequireProxy(id, requireReturnsDefault, loadModule) {
  const name = getName(id);
  const {
    meta: { commonjs: commonjsMeta }
  } = await loadModule({ id });
  if (!commonjsMeta) {
    return getUnknownRequireProxy(id, requireReturnsDefault);
  }
  if (commonjsMeta.isCommonJS) {
    return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
  }
  if (!requireReturnsDefault) {
    return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(
      id
    )}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
  }
  if (
    requireReturnsDefault !== true &&
    (requireReturnsDefault === 'namespace' ||
      !commonjsMeta.hasDefaultExport ||
      (requireReturnsDefault === 'auto' && commonjsMeta.hasNamedExports))
  ) {
    return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
  }
  return `export { default } from ${JSON.stringify(id)};`;
}

function getEntryProxy(id, defaultIsModuleExports, getModuleInfo, shebang) {
  const {
    meta: { commonjs: commonjsMeta },
    hasDefaultExport
  } = getModuleInfo(id);
  if (!commonjsMeta || commonjsMeta.isCommonJS !== IS_WRAPPED_COMMONJS) {
    const stringifiedId = JSON.stringify(id);
    let code = `export * from ${stringifiedId};`;
    if (hasDefaultExport) {
      code += `export { default } from ${stringifiedId};`;
    }
    return shebang + code;
  }
  const result = getEsImportProxy(id, defaultIsModuleExports, true);
  return {
    ...result,
    code: shebang + result.code
  };
}

function getEsImportProxy(id, defaultIsModuleExports, moduleSideEffects) {
  const name = getName(id);
  const exportsName = `${name}Exports`;
  const requireModule = `require${capitalize(name)}`;
  let code =
    `import { getDefaultExportFromCjs } from "${HELPERS_ID}";\n` +
    `import { __require as ${requireModule} } from ${JSON.stringify(id)};\n` +
    `var ${exportsName} = ${moduleSideEffects ? '' : '/*@__PURE__*/ '}${requireModule}();\n` +
    `export { ${exportsName} as __moduleExports };`;
  if (defaultIsModuleExports === true) {
    code += `\nexport { ${exportsName} as default };`;
  } else if (defaultIsModuleExports === false) {
    code += `\nexport default ${exportsName}.default;`;
  } else {
    code += `\nexport default /*@__PURE__*/getDefaultExportFromCjs(${exportsName});`;
  }
  return {
    code,
    syntheticNamedExports: '__moduleExports'
  };
}

/* eslint-disable no-param-reassign, no-undefined */


function getCandidatesForExtension(resolved, extension) {
  return [resolved + extension, `${resolved}${sep}index${extension}`];
}

function getCandidates(resolved, extensions) {
  return extensions.reduce(
    (paths, extension) => paths.concat(getCandidatesForExtension(resolved, extension)),
    [resolved]
  );
}

function resolveExtensions(importee, importer, extensions) {
  // not our problem
  if (importee[0] !== '.' || !importer) return undefined;

  const resolved = resolve$3(dirname$1(importer), importee);
  const candidates = getCandidates(resolved, extensions);

  for (let i = 0; i < candidates.length; i += 1) {
    try {
      const stats = statSync(candidates[i]);
      if (stats.isFile()) return { id: candidates[i] };
    } catch (err) {
      /* noop */
    }
  }

  return undefined;
}

function getResolveId(extensions, isPossibleCjsId) {
  const currentlyResolving = new Map();

  return {
    /**
     * This is a Maps of importers to Sets of require sources being resolved at
     * the moment by resolveRequireSourcesAndUpdateMeta
     */
    currentlyResolving,
    async resolveId(importee, importer, resolveOptions) {
      const customOptions = resolveOptions.custom;
      // All logic below is specific to ES imports.
      // Also, if we do not skip this logic for requires that are resolved while
      // transforming a commonjs file, it can easily lead to deadlocks.
      if (customOptions?.['node-resolve']?.isRequire) {
        return null;
      }
      const currentlyResolvingForParent = currentlyResolving.get(importer);
      if (currentlyResolvingForParent && currentlyResolvingForParent.has(importee)) {
        this.warn({
          code: 'THIS_RESOLVE_WITHOUT_OPTIONS',
          message:
            'It appears a plugin has implemented a "resolveId" hook that uses "this.resolve" without forwarding the third "options" parameter of "resolveId". This is problematic as it can lead to wrong module resolutions especially for the node-resolve plugin and in certain cases cause early exit errors for the commonjs plugin.\nIn rare cases, this warning can appear if the same file is both imported and required from the same mixed ES/CommonJS module, in which case it can be ignored.',
          url: 'https://rollupjs.org/guide/en/#resolveid'
        });
        return null;
      }

      if (isWrappedId(importee, WRAPPED_SUFFIX)) {
        return unwrapId(importee, WRAPPED_SUFFIX);
      }

      if (
        importee.endsWith(ENTRY_SUFFIX) ||
        isWrappedId(importee, MODULE_SUFFIX) ||
        isWrappedId(importee, EXPORTS_SUFFIX) ||
        isWrappedId(importee, PROXY_SUFFIX) ||
        isWrappedId(importee, ES_IMPORT_SUFFIX) ||
        isWrappedId(importee, EXTERNAL_SUFFIX) ||
        importee.startsWith(HELPERS_ID) ||
        importee === DYNAMIC_MODULES_ID
      ) {
        return importee;
      }

      if (importer) {
        if (
          importer === DYNAMIC_MODULES_ID ||
          // Proxies are only importing resolved ids, no need to resolve again
          isWrappedId(importer, PROXY_SUFFIX) ||
          isWrappedId(importer, ES_IMPORT_SUFFIX) ||
          importer.endsWith(ENTRY_SUFFIX)
        ) {
          return importee;
        }
        if (isWrappedId(importer, EXTERNAL_SUFFIX)) {
          // We need to return null for unresolved imports so that the proper warning is shown
          if (
            !(await this.resolve(
              importee,
              importer,
              Object.assign({ skipSelf: true }, resolveOptions)
            ))
          ) {
            return null;
          }
          // For other external imports, we need to make sure they are handled as external
          return { id: importee, external: true };
        }
      }

      if (importee.startsWith('\0')) {
        return null;
      }

      // If this is an entry point or ESM import, we need to figure out if the importee is wrapped and
      // if that is the case, we need to add a proxy.
      const resolved =
        (await this.resolve(
          importee,
          importer,
          Object.assign({ skipSelf: true }, resolveOptions)
        )) || resolveExtensions(importee, importer, extensions);
      // Make sure that even if other plugins resolve again, we ignore our own proxies
      if (
        !resolved ||
        resolved.external ||
        resolved.id.endsWith(ENTRY_SUFFIX) ||
        isWrappedId(resolved.id, ES_IMPORT_SUFFIX) ||
        !isPossibleCjsId(resolved.id)
      ) {
        return resolved;
      }
      const moduleInfo = await this.load(resolved);
      const {
        meta: { commonjs: commonjsMeta }
      } = moduleInfo;
      if (commonjsMeta) {
        const { isCommonJS } = commonjsMeta;
        if (isCommonJS) {
          if (resolveOptions.isEntry) {
            moduleInfo.moduleSideEffects = true;
            // We must not precede entry proxies with a `\0` as that will mess up relative external resolution
            return resolved.id + ENTRY_SUFFIX;
          }
          if (isCommonJS === IS_WRAPPED_COMMONJS) {
            return { id: wrapId(resolved.id, ES_IMPORT_SUFFIX), meta: { commonjs: { resolved } } };
          }
        }
      }
      return resolved;
    }
  };
}

function getRequireResolver(extensions, detectCyclesAndConditional, currentlyResolving) {
  const knownCjsModuleTypes = Object.create(null);
  const requiredIds = Object.create(null);
  const unconditionallyRequiredIds = Object.create(null);
  const dependencies = Object.create(null);
  const getDependencies = (id) => dependencies[id] || (dependencies[id] = new Set());

  const isCyclic = (id) => {
    const dependenciesToCheck = new Set(getDependencies(id));
    for (const dependency of dependenciesToCheck) {
      if (dependency === id) {
        return true;
      }
      for (const childDependency of getDependencies(dependency)) {
        dependenciesToCheck.add(childDependency);
      }
    }
    return false;
  };

  // Once a module is listed here, its type (wrapped or not) is fixed and may
  // not change for the rest of the current build, to not break already
  // transformed modules.
  const fullyAnalyzedModules = Object.create(null);

  const getTypeForFullyAnalyzedModule = (id) => {
    const knownType = knownCjsModuleTypes[id];
    if (knownType !== true || !detectCyclesAndConditional || fullyAnalyzedModules[id]) {
      return knownType;
    }
    if (isCyclic(id)) {
      return (knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS);
    }
    return knownType;
  };

  const setInitialParentType = (id, initialCommonJSType) => {
    // Fully analyzed modules may never change type
    if (fullyAnalyzedModules[id]) {
      return;
    }
    knownCjsModuleTypes[id] = initialCommonJSType;
    if (
      detectCyclesAndConditional &&
      knownCjsModuleTypes[id] === true &&
      requiredIds[id] &&
      !unconditionallyRequiredIds[id]
    ) {
      knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
    }
  };

  const analyzeRequiredModule = async (parentId, resolved, isConditional, loadModule) => {
    const childId = resolved.id;
    requiredIds[childId] = true;
    if (!(isConditional || knownCjsModuleTypes[parentId] === IS_WRAPPED_COMMONJS)) {
      unconditionallyRequiredIds[childId] = true;
    }

    getDependencies(parentId).add(childId);
    if (!isCyclic(childId)) {
      // This makes sure the current transform handler waits for all direct
      // dependencies to be loaded and transformed and therefore for all
      // transitive CommonJS dependencies to be loaded as well so that all
      // cycles have been found and knownCjsModuleTypes is reliable.
      await loadModule(resolved);
    }
  };

  const getTypeForImportedModule = async (resolved, loadModule) => {
    if (resolved.id in knownCjsModuleTypes) {
      // This handles cyclic ES dependencies
      return knownCjsModuleTypes[resolved.id];
    }
    const {
      meta: { commonjs }
    } = await loadModule(resolved);
    return (commonjs && commonjs.isCommonJS) || false;
  };

  return {
    getWrappedIds: () =>
      Object.keys(knownCjsModuleTypes).filter(
        (id) => knownCjsModuleTypes[id] === IS_WRAPPED_COMMONJS
      ),
    isRequiredId: (id) => requiredIds[id],
    async shouldTransformCachedModule({
      id: parentId,
      resolvedSources,
      meta: { commonjs: parentMeta }
    }) {
      // We explicitly track ES modules to handle circular imports
      if (!(parentMeta && parentMeta.isCommonJS)) knownCjsModuleTypes[parentId] = false;
      if (isWrappedId(parentId, ES_IMPORT_SUFFIX)) return false;
      const parentRequires = parentMeta && parentMeta.requires;
      if (parentRequires) {
        setInitialParentType(parentId, parentMeta.initialCommonJSType);
        await Promise.all(
          parentRequires.map(({ resolved, isConditional }) =>
            analyzeRequiredModule(parentId, resolved, isConditional, this.load)
          )
        );
        if (getTypeForFullyAnalyzedModule(parentId) !== parentMeta.isCommonJS) {
          return true;
        }
        for (const {
          resolved: { id }
        } of parentRequires) {
          if (getTypeForFullyAnalyzedModule(id) !== parentMeta.isRequiredCommonJS[id]) {
            return true;
          }
        }
        // Now that we decided to go with the cached copy, neither the parent
        // module nor any of its children may change types anymore
        fullyAnalyzedModules[parentId] = true;
        for (const {
          resolved: { id }
        } of parentRequires) {
          fullyAnalyzedModules[id] = true;
        }
      }
      const parentRequireSet = new Set((parentRequires || []).map(({ resolved: { id } }) => id));
      return (
        await Promise.all(
          Object.keys(resolvedSources)
            .map((source) => resolvedSources[source])
            .filter(({ id, external }) => !(external || parentRequireSet.has(id)))
            .map(async (resolved) => {
              if (isWrappedId(resolved.id, ES_IMPORT_SUFFIX)) {
                return (
                  (await getTypeForImportedModule(
                    (
                      await this.load({ id: resolved.id })
                    ).meta.commonjs.resolved,
                    this.load
                  )) !== IS_WRAPPED_COMMONJS
                );
              }
              return (await getTypeForImportedModule(resolved, this.load)) === IS_WRAPPED_COMMONJS;
            })
        )
      ).some((shouldTransform) => shouldTransform);
    },
    /* eslint-disable no-param-reassign */
    resolveRequireSourcesAndUpdateMeta:
      (rollupContext) => async (parentId, isParentCommonJS, parentMeta, sources) => {
        parentMeta.initialCommonJSType = isParentCommonJS;
        parentMeta.requires = [];
        parentMeta.isRequiredCommonJS = Object.create(null);
        setInitialParentType(parentId, isParentCommonJS);
        const currentlyResolvingForParent = currentlyResolving.get(parentId) || new Set();
        currentlyResolving.set(parentId, currentlyResolvingForParent);
        const requireTargets = await Promise.all(
          sources.map(async ({ source, isConditional }) => {
            // Never analyze or proxy internal modules
            if (source.startsWith('\0')) {
              return { id: source, allowProxy: false };
            }
            currentlyResolvingForParent.add(source);
            const resolved =
              (await rollupContext.resolve(source, parentId, {
                skipSelf: false,
                custom: { 'node-resolve': { isRequire: true } }
              })) || resolveExtensions(source, parentId, extensions);
            currentlyResolvingForParent.delete(source);
            if (!resolved) {
              return { id: wrapId(source, EXTERNAL_SUFFIX), allowProxy: false };
            }
            const childId = resolved.id;
            if (resolved.external) {
              return { id: wrapId(childId, EXTERNAL_SUFFIX), allowProxy: false };
            }
            parentMeta.requires.push({ resolved, isConditional });
            await analyzeRequiredModule(parentId, resolved, isConditional, rollupContext.load);
            return { id: childId, allowProxy: true };
          })
        );
        parentMeta.isCommonJS = getTypeForFullyAnalyzedModule(parentId);
        fullyAnalyzedModules[parentId] = true;
        return requireTargets.map(({ id: dependencyId, allowProxy }, index) => {
          // eslint-disable-next-line no-multi-assign
          const isCommonJS = (parentMeta.isRequiredCommonJS[dependencyId] =
            getTypeForFullyAnalyzedModule(dependencyId));
          const isWrappedCommonJS = isCommonJS === IS_WRAPPED_COMMONJS;
          fullyAnalyzedModules[dependencyId] = true;
          return {
            wrappedModuleSideEffects:
              isWrappedCommonJS && rollupContext.getModuleInfo(dependencyId).moduleSideEffects,
            source: sources[index].source,
            id: allowProxy
              ? wrapId(dependencyId, isWrappedCommonJS ? WRAPPED_SUFFIX : PROXY_SUFFIX)
              : dependencyId,
            isCommonJS
          };
        });
      },
    isCurrentlyResolving(source, parentId) {
      const currentlyResolvingForParent = currentlyResolving.get(parentId);
      return currentlyResolvingForParent && currentlyResolvingForParent.has(source);
    }
  };
}

function validateVersion(actualVersion, peerDependencyVersion, name) {
  const versionRegexp = /\^(\d+\.\d+\.\d+)/g;
  let minMajor = Infinity;
  let minMinor = Infinity;
  let minPatch = Infinity;
  let foundVersion;
  // eslint-disable-next-line no-cond-assign
  while ((foundVersion = versionRegexp.exec(peerDependencyVersion))) {
    const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split('.').map(Number);
    if (foundMajor < minMajor) {
      minMajor = foundMajor;
      minMinor = foundMinor;
      minPatch = foundPatch;
    }
  }
  if (!actualVersion) {
    throw new Error(
      `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch}.`
    );
  }
  const [major, minor, patch] = actualVersion.split('.').map(Number);
  if (
    major < minMajor ||
    (major === minMajor && (minor < minMinor || (minor === minMinor && patch < minPatch)))
  ) {
    throw new Error(
      `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch} but found ${name}@${actualVersion}.`
    );
  }
}

const operators = {
  '==': (x) => equals(x.left, x.right, false),

  '!=': (x) => not(operators['=='](x)),

  '===': (x) => equals(x.left, x.right, true),

  '!==': (x) => not(operators['==='](x)),

  '!': (x) => isFalsy(x.argument),

  '&&': (x) => isTruthy(x.left) && isTruthy(x.right),

  '||': (x) => isTruthy(x.left) || isTruthy(x.right)
};

function not(value) {
  return value === null ? value : !value;
}

function equals(a, b, strict) {
  if (a.type !== b.type) return null;
  // eslint-disable-next-line eqeqeq
  if (a.type === 'Literal') return strict ? a.value === b.value : a.value == b.value;
  return null;
}

function isTruthy(node) {
  if (!node) return false;
  if (node.type === 'Literal') return !!node.value;
  if (node.type === 'ParenthesizedExpression') return isTruthy(node.expression);
  if (node.operator in operators) return operators[node.operator](node);
  return null;
}

function isFalsy(node) {
  return not(isTruthy(node));
}

function getKeypath(node) {
  const parts = [];

  while (node.type === 'MemberExpression') {
    if (node.computed) return null;

    parts.unshift(node.property.name);
    // eslint-disable-next-line no-param-reassign
    node = node.object;
  }

  if (node.type !== 'Identifier') return null;

  const { name } = node;
  parts.unshift(name);

  return { name, keypath: parts.join('.') };
}

const KEY_COMPILED_ESM = '__esModule';

function getDefineCompiledEsmType(node) {
  const definedPropertyWithExports = getDefinePropertyCallName(node, 'exports');
  const definedProperty =
    definedPropertyWithExports || getDefinePropertyCallName(node, 'module.exports');
  if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
    return isTruthy(definedProperty.value)
      ? definedPropertyWithExports
        ? 'exports'
        : 'module'
      : false;
  }
  return false;
}

function getDefinePropertyCallName(node, targetName) {
  const {
    callee: { object, property }
  } = node;
  if (!object || object.type !== 'Identifier' || object.name !== 'Object') return;
  if (!property || property.type !== 'Identifier' || property.name !== 'defineProperty') return;
  if (node.arguments.length !== 3) return;

  const targetNames = targetName.split('.');
  const [target, key, value] = node.arguments;
  if (targetNames.length === 1) {
    if (target.type !== 'Identifier' || target.name !== targetNames[0]) {
      return;
    }
  }

  if (targetNames.length === 2) {
    if (
      target.type !== 'MemberExpression' ||
      target.object.name !== targetNames[0] ||
      target.property.name !== targetNames[1]
    ) {
      return;
    }
  }

  if (value.type !== 'ObjectExpression' || !value.properties) return;

  const valueProperty = value.properties.find((p) => p.key && p.key.name === 'value');
  if (!valueProperty || !valueProperty.value) return;

  // eslint-disable-next-line consistent-return
  return { key: key.value, value: valueProperty.value };
}

function isShorthandProperty(parent) {
  return parent && parent.type === 'Property' && parent.shorthand;
}

function wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges) {
  const args = [];
  const passedArgs = [];
  if (uses.module) {
    args.push('module');
    passedArgs.push(moduleName);
  }
  if (uses.exports) {
    args.push('exports');
    passedArgs.push(uses.module ? `${moduleName}.exports` : exportsName);
  }
  magicString
    .trim()
    .indent('\t', { exclude: indentExclusionRanges })
    .prepend(`(function (${args.join(', ')}) {\n`)
    // For some reason, this line is only indented correctly when using a
    // require-wrapper if we have this leading space
    .append(` \n} (${passedArgs.join(', ')}));`);
}

function rewriteExportsAndGetExportsBlock(
  magicString,
  moduleName,
  exportsName,
  exportedExportsName,
  wrapped,
  moduleExportsAssignments,
  firstTopLevelModuleExportsAssignment,
  exportsAssignmentsByName,
  topLevelAssignments,
  defineCompiledEsmExpressions,
  deconflictedExportNames,
  code,
  HELPERS_NAME,
  exportMode,
  defaultIsModuleExports,
  usesRequireWrapper,
  requireName
) {
  const exports = [];
  const exportDeclarations = [];

  if (usesRequireWrapper) {
    getExportsWhenUsingRequireWrapper(
      magicString,
      wrapped,
      exportMode,
      exports,
      moduleExportsAssignments,
      exportsAssignmentsByName,
      moduleName,
      exportsName,
      requireName,
      defineCompiledEsmExpressions
    );
  } else if (exportMode === 'replace') {
    getExportsForReplacedModuleExports(
      magicString,
      exports,
      exportDeclarations,
      moduleExportsAssignments,
      firstTopLevelModuleExportsAssignment,
      exportsName,
      defaultIsModuleExports,
      HELPERS_NAME
    );
  } else {
    if (exportMode === 'module') {
      exportDeclarations.push(`var ${exportedExportsName} = ${moduleName}.exports`);
      exports.push(`${exportedExportsName} as __moduleExports`);
    } else {
      exports.push(`${exportsName} as __moduleExports`);
    }
    if (wrapped) {
      exportDeclarations.push(
        getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME)
      );
    } else {
      getExports(
        magicString,
        exports,
        exportDeclarations,
        moduleExportsAssignments,
        exportsAssignmentsByName,
        deconflictedExportNames,
        topLevelAssignments,
        moduleName,
        exportsName,
        exportedExportsName,
        defineCompiledEsmExpressions,
        HELPERS_NAME,
        defaultIsModuleExports,
        exportMode
      );
    }
  }
  if (exports.length) {
    exportDeclarations.push(`export { ${exports.join(', ')} }`);
  }

  return `\n\n${exportDeclarations.join(';\n')};`;
}

function getExportsWhenUsingRequireWrapper(
  magicString,
  wrapped,
  exportMode,
  exports,
  moduleExportsAssignments,
  exportsAssignmentsByName,
  moduleName,
  exportsName,
  requireName,
  defineCompiledEsmExpressions
) {
  exports.push(`${requireName} as __require`);
  if (wrapped) return;
  if (exportMode === 'replace') {
    rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName);
  } else {
    rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, `${moduleName}.exports`);
    // Collect and rewrite named exports
    for (const [exportName, { nodes }] of exportsAssignmentsByName) {
      for (const { node, type } of nodes) {
        magicString.overwrite(
          node.start,
          node.left.end,
          `${
            exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
          }.${exportName}`
        );
      }
    }
    replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
      defineCompiledEsmExpressions,
      magicString,
      exportMode,
      moduleName,
      exportsName
    );
  }
}

function getExportsForReplacedModuleExports(
  magicString,
  exports,
  exportDeclarations,
  moduleExportsAssignments,
  firstTopLevelModuleExportsAssignment,
  exportsName,
  defaultIsModuleExports,
  HELPERS_NAME
) {
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, exportsName);
  }
  magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, 'var ');
  exports.push(`${exportsName} as __moduleExports`);
  exportDeclarations.push(
    getDefaultExportDeclaration(exportsName, defaultIsModuleExports, HELPERS_NAME)
  );
}

function getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME) {
  return `export default ${
    defaultIsModuleExports === true
      ? exportedExportsName
      : defaultIsModuleExports === false
      ? `${exportedExportsName}.default`
      : `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportedExportsName})`
  }`;
}

function getExports(
  magicString,
  exports,
  exportDeclarations,
  moduleExportsAssignments,
  exportsAssignmentsByName,
  deconflictedExportNames,
  topLevelAssignments,
  moduleName,
  exportsName,
  exportedExportsName,
  defineCompiledEsmExpressions,
  HELPERS_NAME,
  defaultIsModuleExports,
  exportMode
) {
  let deconflictedDefaultExportName;
  // Collect and rewrite module.exports assignments
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
  }

  // Collect and rewrite named exports
  for (const [exportName, { nodes }] of exportsAssignmentsByName) {
    const deconflicted = deconflictedExportNames[exportName];
    let needsDeclaration = true;
    for (const { node, type } of nodes) {
      let replacement = `${deconflicted} = ${
        exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
      }.${exportName}`;
      if (needsDeclaration && topLevelAssignments.has(node)) {
        replacement = `var ${replacement}`;
        needsDeclaration = false;
      }
      magicString.overwrite(node.start, node.left.end, replacement);
    }
    if (needsDeclaration) {
      magicString.prepend(`var ${deconflicted};\n`);
    }

    if (exportName === 'default') {
      deconflictedDefaultExportName = deconflicted;
    } else {
      exports.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
    }
  }

  const isRestorableCompiledEsm = replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
    defineCompiledEsmExpressions,
    magicString,
    exportMode,
    moduleName,
    exportsName
  );

  if (
    defaultIsModuleExports === false ||
    (defaultIsModuleExports === 'auto' &&
      isRestorableCompiledEsm &&
      moduleExportsAssignments.length === 0)
  ) {
    // If there is no deconflictedDefaultExportName, then we use the namespace as
    // fallback because there can be no "default" property on the namespace
    exports.push(`${deconflictedDefaultExportName || exportedExportsName} as default`);
  } else if (
    defaultIsModuleExports === true ||
    (!isRestorableCompiledEsm && moduleExportsAssignments.length === 0)
  ) {
    exports.push(`${exportedExportsName} as default`);
  } else {
    exportDeclarations.push(
      getDefaultExportDeclaration(exportedExportsName, defaultIsModuleExports, HELPERS_NAME)
    );
  }
}

function rewriteModuleExportsAssignments(magicString, moduleExportsAssignments, exportsName) {
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, exportsName);
  }
}

function replaceDefineCompiledEsmExpressionsAndGetIfRestorable(
  defineCompiledEsmExpressions,
  magicString,
  exportMode,
  moduleName,
  exportsName
) {
  let isRestorableCompiledEsm = false;
  for (const { node, type } of defineCompiledEsmExpressions) {
    isRestorableCompiledEsm = true;
    const moduleExportsExpression =
      node.type === 'CallExpression' ? node.arguments[0] : node.left.object;
    magicString.overwrite(
      moduleExportsExpression.start,
      moduleExportsExpression.end,
      exportMode === 'module' && type === 'module' ? `${moduleName}.exports` : exportsName
    );
  }
  return isRestorableCompiledEsm;
}

function isRequireExpression(node, scope) {
  if (!node) return false;
  if (node.type !== 'CallExpression') return false;

  // Weird case of `require()` or `module.require()` without arguments
  if (node.arguments.length === 0) return false;

  return isRequire(node.callee, scope);
}

function isRequire(node, scope) {
  return (
    (node.type === 'Identifier' && node.name === 'require' && !scope.contains('require')) ||
    (node.type === 'MemberExpression' && isModuleRequire(node, scope))
  );
}

function isModuleRequire({ object, property }, scope) {
  return (
    object.type === 'Identifier' &&
    object.name === 'module' &&
    property.type === 'Identifier' &&
    property.name === 'require' &&
    !scope.contains('module')
  );
}

function hasDynamicArguments(node) {
  return (
    node.arguments.length > 1 ||
    (node.arguments[0].type !== 'Literal' &&
      (node.arguments[0].type !== 'TemplateLiteral' || node.arguments[0].expressions.length > 0))
  );
}

const reservedMethod = { resolve: true, cache: true, main: true };

function isNodeRequirePropertyAccess(parent) {
  return parent && parent.property && reservedMethod[parent.property.name];
}

function getRequireStringArg(node) {
  return node.arguments[0].type === 'Literal'
    ? node.arguments[0].value
    : node.arguments[0].quasis[0].value.cooked;
}

function getRequireHandlers() {
  const requireExpressions = [];

  function addRequireExpression(
    sourceId,
    node,
    scope,
    usesReturnValue,
    isInsideTryBlock,
    isInsideConditional,
    toBeRemoved
  ) {
    requireExpressions.push({
      sourceId,
      node,
      scope,
      usesReturnValue,
      isInsideTryBlock,
      isInsideConditional,
      toBeRemoved
    });
  }

  async function rewriteRequireExpressionsAndGetImportBlock(
    magicString,
    topLevelDeclarations,
    reassignedNames,
    helpersName,
    dynamicRequireName,
    moduleName,
    exportsName,
    id,
    exportMode,
    resolveRequireSourcesAndUpdateMeta,
    needsRequireWrapper,
    isEsModule,
    isDynamicRequireModulesEnabled,
    getIgnoreTryCatchRequireStatementMode,
    commonjsMeta
  ) {
    const imports = [];
    imports.push(`import * as ${helpersName} from "${HELPERS_ID}"`);
    if (dynamicRequireName) {
      imports.push(
        `import { ${
          isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
        } as ${dynamicRequireName} } from "${DYNAMIC_MODULES_ID}"`
      );
    }
    if (exportMode === 'module') {
      imports.push(
        `import { __module as ${moduleName} } from ${JSON.stringify(wrapId(id, MODULE_SUFFIX))}`,
        `var ${exportsName} = ${moduleName}.exports`
      );
    } else if (exportMode === 'exports') {
      imports.push(
        `import { __exports as ${exportsName} } from ${JSON.stringify(wrapId(id, EXPORTS_SUFFIX))}`
      );
    }
    const requiresBySource = collectSources(requireExpressions);
    const requireTargets = await resolveRequireSourcesAndUpdateMeta(
      id,
      needsRequireWrapper ? IS_WRAPPED_COMMONJS : !isEsModule,
      commonjsMeta,
      Object.keys(requiresBySource).map((source) => {
        return {
          source,
          isConditional: requiresBySource[source].every((require) => require.isInsideConditional)
        };
      })
    );
    processRequireExpressions(
      imports,
      requireTargets,
      requiresBySource,
      getIgnoreTryCatchRequireStatementMode,
      magicString
    );
    return imports.length ? `${imports.join(';\n')};\n\n` : '';
  }

  return {
    addRequireExpression,
    rewriteRequireExpressionsAndGetImportBlock
  };
}

function collectSources(requireExpressions) {
  const requiresBySource = Object.create(null);
  for (const requireExpression of requireExpressions) {
    const { sourceId } = requireExpression;
    if (!requiresBySource[sourceId]) {
      requiresBySource[sourceId] = [];
    }
    const requires = requiresBySource[sourceId];
    requires.push(requireExpression);
  }
  return requiresBySource;
}

function processRequireExpressions(
  imports,
  requireTargets,
  requiresBySource,
  getIgnoreTryCatchRequireStatementMode,
  magicString
) {
  const generateRequireName = getGenerateRequireName();
  for (const { source, id: resolvedId, isCommonJS, wrappedModuleSideEffects } of requireTargets) {
    const requires = requiresBySource[source];
    const name = generateRequireName(requires);
    let usesRequired = false;
    let needsImport = false;
    for (const { node, usesReturnValue, toBeRemoved, isInsideTryBlock } of requires) {
      const { canConvertRequire, shouldRemoveRequire } =
        isInsideTryBlock && isWrappedId(resolvedId, EXTERNAL_SUFFIX)
          ? getIgnoreTryCatchRequireStatementMode(source)
          : { canConvertRequire: true, shouldRemoveRequire: false };
      if (shouldRemoveRequire) {
        if (usesReturnValue) {
          magicString.overwrite(node.start, node.end, 'undefined');
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      } else if (canConvertRequire) {
        needsImport = true;
        if (isCommonJS === IS_WRAPPED_COMMONJS) {
          magicString.overwrite(
            node.start,
            node.end,
            `${wrappedModuleSideEffects ? '' : '/*@__PURE__*/ '}${name}()`
          );
        } else if (usesReturnValue) {
          usesRequired = true;
          magicString.overwrite(node.start, node.end, name);
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      }
    }
    if (needsImport) {
      if (isCommonJS === IS_WRAPPED_COMMONJS) {
        imports.push(`import { __require as ${name} } from ${JSON.stringify(resolvedId)}`);
      } else {
        imports.push(`import ${usesRequired ? `${name} from ` : ''}${JSON.stringify(resolvedId)}`);
      }
    }
  }
}

function getGenerateRequireName() {
  let uid = 0;
  return (requires) => {
    let name;
    const hasNameConflict = ({ scope }) => scope.contains(name);
    do {
      name = `require$$${uid}`;
      uid += 1;
    } while (requires.some(hasNameConflict));
    return name;
  };
}

/* eslint-disable no-param-reassign, no-shadow, no-underscore-dangle, no-continue */


const exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;

const functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;

// There are three different types of CommonJS modules, described by their
// "exportMode":
// - exports: Only assignments to (module.)exports properties
// - replace: A single assignment to module.exports itself
// - module: Anything else
// Special cases:
// - usesRequireWrapper
// - isWrapped
async function transformCommonjs(
  parse,
  code,
  id,
  isEsModule,
  ignoreGlobal,
  ignoreRequire,
  ignoreDynamicRequires,
  getIgnoreTryCatchRequireStatementMode,
  sourceMap,
  isDynamicRequireModulesEnabled,
  dynamicRequireModules,
  commonDir,
  astCache,
  defaultIsModuleExports,
  needsRequireWrapper,
  resolveRequireSourcesAndUpdateMeta,
  isRequired,
  checkDynamicRequire,
  commonjsMeta
) {
  const ast = astCache || tryParse(parse, code, id);
  const magicString = new MagicString(code);
  const uses = {
    module: false,
    exports: false,
    global: false,
    require: false
  };
  const virtualDynamicRequirePath =
    isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(dirname$1(id), commonDir);
  let scope = attachScopes(ast, 'scope');
  let lexicalDepth = 0;
  let programDepth = 0;
  let classBodyDepth = 0;
  let currentTryBlockEnd = null;
  let shouldWrap = false;

  const globals = new Set();
  // A conditionalNode is a node for which execution is not guaranteed. If such a node is a require
  // or contains nested requires, those should be handled as function calls unless there is an
  // unconditional require elsewhere.
  let currentConditionalNodeEnd = null;
  const conditionalNodes = new Set();
  const { addRequireExpression, rewriteRequireExpressionsAndGetImportBlock } = getRequireHandlers();

  // See which names are assigned to. This is necessary to prevent
  // illegally replacing `var foo = require('foo')` with `import foo from 'foo'`,
  // where `foo` is later reassigned. (This happens in the wild. CommonJS, sigh)
  const reassignedNames = new Set();
  const topLevelDeclarations = [];
  const skippedNodes = new Set();
  const moduleAccessScopes = new Set([scope]);
  const exportsAccessScopes = new Set([scope]);
  const moduleExportsAssignments = [];
  let firstTopLevelModuleExportsAssignment = null;
  const exportsAssignmentsByName = new Map();
  const topLevelAssignments = new Set();
  const topLevelDefineCompiledEsmExpressions = [];
  const replacedGlobal = [];
  const replacedThis = [];
  const replacedDynamicRequires = [];
  const importedVariables = new Set();
  const indentExclusionRanges = [];

  walk$2(ast, {
    enter(node, parent) {
      if (skippedNodes.has(node)) {
        this.skip();
        return;
      }

      if (currentTryBlockEnd !== null && node.start > currentTryBlockEnd) {
        currentTryBlockEnd = null;
      }
      if (currentConditionalNodeEnd !== null && node.start > currentConditionalNodeEnd) {
        currentConditionalNodeEnd = null;
      }
      if (currentConditionalNodeEnd === null && conditionalNodes.has(node)) {
        currentConditionalNodeEnd = node.end;
      }

      programDepth += 1;
      if (node.scope) ({ scope } = node);
      if (functionType.test(node.type)) lexicalDepth += 1;
      if (sourceMap) {
        magicString.addSourcemapLocation(node.start);
        magicString.addSourcemapLocation(node.end);
      }

      // eslint-disable-next-line default-case
      switch (node.type) {
        case 'AssignmentExpression':
          if (node.left.type === 'MemberExpression') {
            const flattened = getKeypath(node.left);
            if (!flattened || scope.contains(flattened.name)) return;

            const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
            if (!exportsPatternMatch || flattened.keypath === 'exports') return;

            const [, exportName] = exportsPatternMatch;
            uses[flattened.name] = true;

            // we're dealing with `module.exports = ...` or `[module.]exports.foo = ...` –
            if (flattened.keypath === 'module.exports') {
              moduleExportsAssignments.push(node);
              if (programDepth > 3) {
                moduleAccessScopes.add(scope);
              } else if (!firstTopLevelModuleExportsAssignment) {
                firstTopLevelModuleExportsAssignment = node;
              }
            } else if (exportName === KEY_COMPILED_ESM) {
              if (programDepth > 3) {
                shouldWrap = true;
              } else {
                // The "type" is either "module" or "exports" to discern
                // assignments to module.exports vs exports if needed
                topLevelDefineCompiledEsmExpressions.push({ node, type: flattened.name });
              }
            } else {
              const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                nodes: [],
                scopes: new Set()
              };
              exportsAssignments.nodes.push({ node, type: flattened.name });
              exportsAssignments.scopes.add(scope);
              exportsAccessScopes.add(scope);
              exportsAssignmentsByName.set(exportName, exportsAssignments);
              if (programDepth <= 3) {
                topLevelAssignments.add(node);
              }
            }

            skippedNodes.add(node.left);
          } else {
            for (const name of extractAssignedNames(node.left)) {
              reassignedNames.add(name);
            }
          }
          return;
        case 'CallExpression': {
          const defineCompiledEsmType = getDefineCompiledEsmType(node);
          if (defineCompiledEsmType) {
            if (programDepth === 3 && parent.type === 'ExpressionStatement') {
              // skip special handling for [module.]exports until we know we render this
              skippedNodes.add(node.arguments[0]);
              topLevelDefineCompiledEsmExpressions.push({ node, type: defineCompiledEsmType });
            } else {
              shouldWrap = true;
            }
            return;
          }

          // Transform require.resolve
          if (
            isDynamicRequireModulesEnabled &&
            node.callee.object &&
            isRequire(node.callee.object, scope) &&
            node.callee.property.name === 'resolve'
          ) {
            checkDynamicRequire(node.start);
            uses.require = true;
            const requireNode = node.callee.object;
            replacedDynamicRequires.push(requireNode);
            skippedNodes.add(node.callee);
            return;
          }

          if (!isRequireExpression(node, scope)) {
            const keypath = getKeypath(node.callee);
            if (keypath && importedVariables.has(keypath.name)) {
              // Heuristic to deoptimize requires after a required function has been called
              currentConditionalNodeEnd = Infinity;
            }
            return;
          }

          skippedNodes.add(node.callee);
          uses.require = true;

          if (hasDynamicArguments(node)) {
            if (isDynamicRequireModulesEnabled) {
              checkDynamicRequire(node.start);
            }
            if (!ignoreDynamicRequires) {
              replacedDynamicRequires.push(node.callee);
            }
            return;
          }

          const requireStringArg = getRequireStringArg(node);
          if (!ignoreRequire(requireStringArg)) {
            const usesReturnValue = parent.type !== 'ExpressionStatement';
            const toBeRemoved =
              parent.type === 'ExpressionStatement' &&
              (!currentConditionalNodeEnd ||
                // We should completely remove requires directly in a try-catch
                // so that Rollup can remove up the try-catch
                (currentTryBlockEnd !== null && currentTryBlockEnd < currentConditionalNodeEnd))
                ? parent
                : node;
            addRequireExpression(
              requireStringArg,
              node,
              scope,
              usesReturnValue,
              currentTryBlockEnd !== null,
              currentConditionalNodeEnd !== null,
              toBeRemoved
            );
            if (parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') {
              for (const name of extractAssignedNames(parent.id)) {
                importedVariables.add(name);
              }
            }
          }
          return;
        }
        case 'ClassBody':
          classBodyDepth += 1;
          return;
        case 'ConditionalExpression':
        case 'IfStatement':
          // skip dead branches
          if (isFalsy(node.test)) {
            skippedNodes.add(node.consequent);
          } else if (isTruthy(node.test)) {
            if (node.alternate) {
              skippedNodes.add(node.alternate);
            }
          } else {
            conditionalNodes.add(node.consequent);
            if (node.alternate) {
              conditionalNodes.add(node.alternate);
            }
          }
          return;
        case 'ArrowFunctionExpression':
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          // requires in functions should be conditional unless it is an IIFE
          if (
            currentConditionalNodeEnd === null &&
            !(parent.type === 'CallExpression' && parent.callee === node)
          ) {
            currentConditionalNodeEnd = node.end;
          }
          return;
        case 'Identifier': {
          const { name } = node;
          if (
            !isReference(node, parent) ||
            scope.contains(name) ||
            (parent.type === 'PropertyDefinition' && parent.key === node)
          )
            return;
          switch (name) {
            case 'require':
              uses.require = true;
              if (isNodeRequirePropertyAccess(parent)) {
                return;
              }
              if (!ignoreDynamicRequires) {
                if (isShorthandProperty(parent)) {
                  // as key and value are the same object, isReference regards
                  // both as references, so we need to skip now
                  skippedNodes.add(parent.value);
                  magicString.prependRight(node.start, 'require: ');
                }
                replacedDynamicRequires.push(node);
              }
              return;
            case 'module':
            case 'exports':
              shouldWrap = true;
              uses[name] = true;
              return;
            case 'global':
              uses.global = true;
              if (!ignoreGlobal) {
                replacedGlobal.push(node);
              }
              return;
            case 'define':
              magicString.overwrite(node.start, node.end, 'undefined', {
                storeName: true
              });
              return;
            default:
              globals.add(name);
              return;
          }
        }
        case 'LogicalExpression':
          // skip dead branches
          if (node.operator === '&&') {
            if (isFalsy(node.left)) {
              skippedNodes.add(node.right);
            } else if (!isTruthy(node.left)) {
              conditionalNodes.add(node.right);
            }
          } else if (node.operator === '||') {
            if (isTruthy(node.left)) {
              skippedNodes.add(node.right);
            } else if (!isFalsy(node.left)) {
              conditionalNodes.add(node.right);
            }
          }
          return;
        case 'MemberExpression':
          if (!isDynamicRequireModulesEnabled && isModuleRequire(node, scope)) {
            uses.require = true;
            replacedDynamicRequires.push(node);
            skippedNodes.add(node.object);
            skippedNodes.add(node.property);
          }
          return;
        case 'ReturnStatement':
          // if top-level return, we need to wrap it
          if (lexicalDepth === 0) {
            shouldWrap = true;
          }
          return;
        case 'ThisExpression':
          // rewrite top-level `this` as `commonjsHelpers.commonjsGlobal`
          if (lexicalDepth === 0 && !classBodyDepth) {
            uses.global = true;
            if (!ignoreGlobal) {
              replacedThis.push(node);
            }
          }
          return;
        case 'TryStatement':
          if (currentTryBlockEnd === null) {
            currentTryBlockEnd = node.block.end;
          }
          if (currentConditionalNodeEnd === null) {
            currentConditionalNodeEnd = node.end;
          }
          return;
        case 'UnaryExpression':
          // rewrite `typeof module`, `typeof module.exports` and `typeof exports` (https://github.com/rollup/rollup-plugin-commonjs/issues/151)
          if (node.operator === 'typeof') {
            const flattened = getKeypath(node.argument);
            if (!flattened) return;

            if (scope.contains(flattened.name)) return;

            if (
              !isEsModule &&
              (flattened.keypath === 'module.exports' ||
                flattened.keypath === 'module' ||
                flattened.keypath === 'exports')
            ) {
              magicString.overwrite(node.start, node.end, `'object'`, {
                storeName: false
              });
            }
          }
          return;
        case 'VariableDeclaration':
          if (!scope.parent) {
            topLevelDeclarations.push(node);
          }
          return;
        case 'TemplateElement':
          if (node.value.raw.includes('\n')) {
            indentExclusionRanges.push([node.start, node.end]);
          }
      }
    },

    leave(node) {
      programDepth -= 1;
      if (node.scope) scope = scope.parent;
      if (functionType.test(node.type)) lexicalDepth -= 1;
      if (node.type === 'ClassBody') classBodyDepth -= 1;
    }
  });

  const nameBase = getName(id);
  const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
  const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
  const requireName = deconflict([scope], globals, `require${capitalize(nameBase)}`);
  const isRequiredName = deconflict([scope], globals, `hasRequired${capitalize(nameBase)}`);
  const helpersName = deconflict([scope], globals, 'commonjsHelpers');
  const dynamicRequireName =
    replacedDynamicRequires.length > 0 &&
    deconflict(
      [scope],
      globals,
      isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
    );
  const deconflictedExportNames = Object.create(null);
  for (const [exportName, { scopes }] of exportsAssignmentsByName) {
    deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
  }

  for (const node of replacedGlobal) {
    magicString.overwrite(node.start, node.end, `${helpersName}.commonjsGlobal`, {
      storeName: true
    });
  }
  for (const node of replacedThis) {
    magicString.overwrite(node.start, node.end, exportsName, {
      storeName: true
    });
  }
  for (const node of replacedDynamicRequires) {
    magicString.overwrite(
      node.start,
      node.end,
      isDynamicRequireModulesEnabled
        ? `${dynamicRequireName}(${JSON.stringify(virtualDynamicRequirePath)})`
        : dynamicRequireName,
      {
        contentOnly: true,
        storeName: true
      }
    );
  }

  // We cannot wrap ES/mixed modules
  shouldWrap = !isEsModule && (shouldWrap || (uses.exports && moduleExportsAssignments.length > 0));

  if (
    !(
      shouldWrap ||
      isRequired ||
      needsRequireWrapper ||
      uses.module ||
      uses.exports ||
      uses.require ||
      topLevelDefineCompiledEsmExpressions.length > 0
    ) &&
    (ignoreGlobal || !uses.global)
  ) {
    return { meta: { commonjs: { isCommonJS: false } } };
  }

  let leadingComment = '';
  if (code.startsWith('/*')) {
    const commentEnd = code.indexOf('*/', 2) + 2;
    leadingComment = `${code.slice(0, commentEnd)}\n`;
    magicString.remove(0, commentEnd).trim();
  }

  let shebang = '';
  if (code.startsWith('#!')) {
    const shebangEndPosition = code.indexOf('\n') + 1;
    shebang = code.slice(0, shebangEndPosition);
    magicString.remove(0, shebangEndPosition).trim();
  }

  const exportMode = isEsModule
    ? 'none'
    : shouldWrap
    ? uses.module
      ? 'module'
      : 'exports'
    : firstTopLevelModuleExportsAssignment
    ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0
      ? 'replace'
      : 'module'
    : moduleExportsAssignments.length === 0
    ? 'exports'
    : 'module';

  const exportedExportsName =
    exportMode === 'module' ? deconflict([], globals, `${nameBase}Exports`) : exportsName;

  const importBlock = await rewriteRequireExpressionsAndGetImportBlock(
    magicString,
    topLevelDeclarations,
    reassignedNames,
    helpersName,
    dynamicRequireName,
    moduleName,
    exportsName,
    id,
    exportMode,
    resolveRequireSourcesAndUpdateMeta,
    needsRequireWrapper,
    isEsModule,
    isDynamicRequireModulesEnabled,
    getIgnoreTryCatchRequireStatementMode,
    commonjsMeta
  );
  const usesRequireWrapper = commonjsMeta.isCommonJS === IS_WRAPPED_COMMONJS;
  const exportBlock = isEsModule
    ? ''
    : rewriteExportsAndGetExportsBlock(
        magicString,
        moduleName,
        exportsName,
        exportedExportsName,
        shouldWrap,
        moduleExportsAssignments,
        firstTopLevelModuleExportsAssignment,
        exportsAssignmentsByName,
        topLevelAssignments,
        topLevelDefineCompiledEsmExpressions,
        deconflictedExportNames,
        code,
        helpersName,
        exportMode,
        defaultIsModuleExports,
        usesRequireWrapper,
        requireName
      );

  if (shouldWrap) {
    wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges);
  }

  if (usesRequireWrapper) {
    magicString.trim().indent('\t', {
      exclude: indentExclusionRanges
    });
    const exported = exportMode === 'module' ? `${moduleName}.exports` : exportsName;
    magicString.prepend(
      `var ${isRequiredName};

function ${requireName} () {
\tif (${isRequiredName}) return ${exported};
\t${isRequiredName} = 1;
`
    ).append(`
\treturn ${exported};
}`);
    if (exportMode === 'replace') {
      magicString.prepend(`var ${exportsName};\n`);
    }
  }

  magicString
    .trim()
    .prepend(shebang + leadingComment + importBlock)
    .append(exportBlock);

  return {
    code: magicString.toString(),
    map: sourceMap ? magicString.generateMap() : null,
    syntheticNamedExports: isEsModule || usesRequireWrapper ? false : '__moduleExports',
    meta: { commonjs: { ...commonjsMeta, shebang } }
  };
}

const PLUGIN_NAME = 'commonjs';

function commonjs(options = {}) {
  const {
    ignoreGlobal,
    ignoreDynamicRequires,
    requireReturnsDefault: requireReturnsDefaultOption,
    defaultIsModuleExports: defaultIsModuleExportsOption,
    esmExternals
  } = options;
  const extensions = options.extensions || ['.js'];
  const filter = createFilter$2(options.include, options.exclude);
  const isPossibleCjsId = (id) => {
    const extName = extname(id);
    return extName === '.cjs' || (extensions.includes(extName) && filter(id));
  };

  const { strictRequiresFilter, detectCyclesAndConditional } = getStrictRequiresFilter(options);

  const getRequireReturnsDefault =
    typeof requireReturnsDefaultOption === 'function'
      ? requireReturnsDefaultOption
      : () => requireReturnsDefaultOption;

  let esmExternalIds;
  const isEsmExternal =
    typeof esmExternals === 'function'
      ? esmExternals
      : Array.isArray(esmExternals)
      ? ((esmExternalIds = new Set(esmExternals)), (id) => esmExternalIds.has(id))
      : () => esmExternals;

  const getDefaultIsModuleExports =
    typeof defaultIsModuleExportsOption === 'function'
      ? defaultIsModuleExportsOption
      : () =>
          typeof defaultIsModuleExportsOption === 'boolean' ? defaultIsModuleExportsOption : 'auto';

  const dynamicRequireRoot =
    typeof options.dynamicRequireRoot === 'string'
      ? resolve$3(options.dynamicRequireRoot)
      : process.cwd();
  const { commonDir, dynamicRequireModules } = getDynamicRequireModules(
    options.dynamicRequireTargets,
    dynamicRequireRoot
  );
  const isDynamicRequireModulesEnabled = dynamicRequireModules.size > 0;

  const ignoreRequire =
    typeof options.ignore === 'function'
      ? options.ignore
      : Array.isArray(options.ignore)
      ? (id) => options.ignore.includes(id)
      : () => false;

  const getIgnoreTryCatchRequireStatementMode = (id) => {
    const mode =
      typeof options.ignoreTryCatch === 'function'
        ? options.ignoreTryCatch(id)
        : Array.isArray(options.ignoreTryCatch)
        ? options.ignoreTryCatch.includes(id)
        : typeof options.ignoreTryCatch !== 'undefined'
        ? options.ignoreTryCatch
        : true;

    return {
      canConvertRequire: mode !== 'remove' && mode !== true,
      shouldRemoveRequire: mode === 'remove'
    };
  };

  const { currentlyResolving, resolveId } = getResolveId(extensions, isPossibleCjsId);

  const sourceMap = options.sourceMap !== false;

  // Initialized in buildStart
  let requireResolver;

  function transformAndCheckExports(code, id) {
    const normalizedId = normalizePathSlashes(id);
    const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(
      this.parse,
      code,
      id
    );

    const commonjsMeta = this.getModuleInfo(id).meta.commonjs || {};
    if (hasDefaultExport) {
      commonjsMeta.hasDefaultExport = true;
    }
    if (hasNamedExports) {
      commonjsMeta.hasNamedExports = true;
    }

    if (
      !dynamicRequireModules.has(normalizedId) &&
      (!(hasCjsKeywords(code, ignoreGlobal) || requireResolver.isRequiredId(id)) ||
        (isEsModule && !options.transformMixedEsModules))
    ) {
      commonjsMeta.isCommonJS = false;
      return { meta: { commonjs: commonjsMeta } };
    }

    const needsRequireWrapper =
      !isEsModule && (dynamicRequireModules.has(normalizedId) || strictRequiresFilter(id));

    const checkDynamicRequire = (position) => {
      const normalizedDynamicRequireRoot = normalizePathSlashes(dynamicRequireRoot);

      if (normalizedId.indexOf(normalizedDynamicRequireRoot) !== 0) {
        this.error(
          {
            code: 'DYNAMIC_REQUIRE_OUTSIDE_ROOT',
            normalizedId,
            normalizedDynamicRequireRoot,
            message: `"${normalizedId}" contains dynamic require statements but it is not within the current dynamicRequireRoot "${normalizedDynamicRequireRoot}". You should set dynamicRequireRoot to "${dirname$1(
              normalizedId
            )}" or one of its parent directories.`
          },
          position
        );
      }
    };

    return transformCommonjs(
      this.parse,
      code,
      id,
      isEsModule,
      ignoreGlobal || isEsModule,
      ignoreRequire,
      ignoreDynamicRequires && !isDynamicRequireModulesEnabled,
      getIgnoreTryCatchRequireStatementMode,
      sourceMap,
      isDynamicRequireModulesEnabled,
      dynamicRequireModules,
      commonDir,
      ast,
      getDefaultIsModuleExports(id),
      needsRequireWrapper,
      requireResolver.resolveRequireSourcesAndUpdateMeta(this),
      requireResolver.isRequiredId(id),
      checkDynamicRequire,
      commonjsMeta
    );
  }

  return {
    name: PLUGIN_NAME,

    version: version$2,

    options(rawOptions) {
      // We inject the resolver in the beginning so that "catch-all-resolver" like node-resolver
      // do not prevent our plugin from resolving entry points ot proxies.
      const plugins = Array.isArray(rawOptions.plugins)
        ? [...rawOptions.plugins]
        : rawOptions.plugins
        ? [rawOptions.plugins]
        : [];
      plugins.unshift({
        name: 'commonjs--resolver',
        resolveId
      });
      return { ...rawOptions, plugins };
    },

    buildStart({ plugins }) {
      validateVersion(this.meta.rollupVersion, peerDependencies.rollup, 'rollup');
      const nodeResolve = plugins.find(({ name }) => name === 'node-resolve');
      if (nodeResolve) {
        validateVersion(nodeResolve.version, '^13.0.6', '@rollup/plugin-node-resolve');
      }
      if (options.namedExports != null) {
        this.warn(
          'The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.'
        );
      }
      requireResolver = getRequireResolver(
        extensions,
        detectCyclesAndConditional,
        currentlyResolving
      );
    },

    buildEnd() {
      if (options.strictRequires === 'debug') {
        const wrappedIds = requireResolver.getWrappedIds();
        if (wrappedIds.length) {
          this.warn({
            code: 'WRAPPED_IDS',
            ids: wrappedIds,
            message: `The commonjs plugin automatically wrapped the following files:\n[\n${wrappedIds
              .map((id) => `\t${JSON.stringify(relative$1(process.cwd(), id))}`)
              .join(',\n')}\n]`
          });
        } else {
          this.warn({
            code: 'WRAPPED_IDS',
            ids: wrappedIds,
            message: 'The commonjs plugin did not wrap any files.'
          });
        }
      }
    },

    async load(id) {
      if (id === HELPERS_ID) {
        return getHelpersModule();
      }

      if (isWrappedId(id, MODULE_SUFFIX)) {
        const name = getName(unwrapId(id, MODULE_SUFFIX));
        return {
          code: `var ${name} = {exports: {}}; export {${name} as __module}`,
          meta: { commonjs: { isCommonJS: false } }
        };
      }

      if (isWrappedId(id, EXPORTS_SUFFIX)) {
        const name = getName(unwrapId(id, EXPORTS_SUFFIX));
        return {
          code: `var ${name} = {}; export {${name} as __exports}`,
          meta: { commonjs: { isCommonJS: false } }
        };
      }

      if (isWrappedId(id, EXTERNAL_SUFFIX)) {
        const actualId = unwrapId(id, EXTERNAL_SUFFIX);
        return getUnknownRequireProxy(
          actualId,
          isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true
        );
      }

      // entry suffix is just appended to not mess up relative external resolution
      if (id.endsWith(ENTRY_SUFFIX)) {
        const acutalId = id.slice(0, -ENTRY_SUFFIX.length);
        const {
          meta: { commonjs: commonjsMeta }
        } = this.getModuleInfo(acutalId);
        const shebang = commonjsMeta?.shebang ?? '';
        return getEntryProxy(
          acutalId,
          getDefaultIsModuleExports(acutalId),
          this.getModuleInfo,
          shebang
        );
      }

      if (isWrappedId(id, ES_IMPORT_SUFFIX)) {
        const actualId = unwrapId(id, ES_IMPORT_SUFFIX);
        return getEsImportProxy(
          actualId,
          getDefaultIsModuleExports(actualId),
          (await this.load({ id: actualId })).moduleSideEffects
        );
      }

      if (id === DYNAMIC_MODULES_ID) {
        return getDynamicModuleRegistry(
          isDynamicRequireModulesEnabled,
          dynamicRequireModules,
          commonDir,
          ignoreDynamicRequires
        );
      }

      if (isWrappedId(id, PROXY_SUFFIX)) {
        const actualId = unwrapId(id, PROXY_SUFFIX);
        return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), this.load);
      }

      return null;
    },

    shouldTransformCachedModule(...args) {
      return requireResolver.shouldTransformCachedModule.call(this, ...args);
    },

    transform(code, id) {
      if (!isPossibleCjsId(id)) return null;

      try {
        return transformAndCheckExports.call(this, code, id);
      } catch (err) {
        return this.error(err, err.pos);
      }
    }
  };
}

function perEnvironmentState(initial) {
  const stateMap = /* @__PURE__ */ new WeakMap();
  return function(context) {
    const { environment } = context;
    let state = stateMap.get(environment);
    if (!state) {
      state = initial(environment);
      stateMap.set(environment, state);
    }
    return state;
  };
}

// Matches the scheme of a URL, eg "http://"
const schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7 /* Absolute */,
    };
}
function parseUrl$3(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = 6 /* SchemeRelative */;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = 5 /* AbsolutePath */;
        return url;
    }
    if (isFileUrl(input))
        return parseFileUrl(input);
    if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input
        ? input.startsWith('?')
            ? 3 /* Query */
            : input.startsWith('#')
                ? 2 /* Hash */
                : 4 /* RelativePath */
        : 1 /* Empty */;
    return url;
}
function stripPathFilename(path) {
    // If a path ends with a parent directory "..", then it's a relative path with excess parent
    // paths. It's not a file, so we can't strip it.
    if (path.endsWith('/..'))
        return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath$4(base, base.type);
    // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    // path).
    if (url.path === '/') {
        url.path = base.path;
    }
    else {
        // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */
function normalizePath$4(url, type) {
    const rel = type <= 4 /* RelativePath */;
    const pieces = url.path.split('/');
    // We need to preserve the first piece always, so that we output a leading slash. The item at
    // pieces[0] is an empty string.
    let pointer = 1;
    // Positive is the number of real directories we've output, used for popping a parent directory.
    // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.')
            continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            }
            else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */
function resolve$2(input, base) {
    if (!input && !base)
        return '';
    const url = parseUrl$3(input);
    let inputType = url.type;
    if (base && inputType !== 7 /* Absolute */) {
        const baseUrl = parseUrl$3(base);
        const baseType = baseUrl.type;
        switch (inputType) {
            case 1 /* Empty */:
                url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */:
                url.query = baseUrl.query;
            // fall through
            case 3 /* Query */:
            case 4 /* RelativePath */:
                mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */:
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */:
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
            inputType = baseType;
    }
    normalizePath$4(url, inputType);
    const queryHash = url.query + url.hash;
    switch (inputType) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2 /* Hash */:
        case 3 /* Query */:
            return queryHash;
        case 4 /* RelativePath */: {
            // The first char is always a "/", and we need it to be relative.
            const path = url.path.slice(1);
            if (!path)
                return queryHash || '.';
            if (isRelative(base || input) && !isRelative(path)) {
                // If base started with a leading ".", or there is no base and input started with a ".",
                // then we need to ensure that the relative path starts with a ".". We don't know if
                // relative starts with a "..", though, so check before prepending.
                return './' + path + queryHash;
            }
            return path + queryHash;
        }
        case 5 /* AbsolutePath */:
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

function resolve$1(input, base) {
    // The base is always treated as a directory, if it's not empty.
    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
    if (base && !base.endsWith('/'))
        base += '/';
    return resolve$2(input, base);
}

/**
 * Removes everything after the last "/", but leaves the slash.
 */
function stripFilename(path) {
    if (!path)
        return '';
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}

const COLUMN$1 = 0;
const SOURCES_INDEX$1 = 1;
const SOURCE_LINE$1 = 2;
const SOURCE_COLUMN$1 = 3;
const NAMES_INDEX$1 = 4;

function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length)
        return mappings;
    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
    // not, we do not want to modify the consumer's input array.
    if (!owned)
        mappings = mappings.slice();
    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
            return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {
            return false;
        }
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned)
        line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN$1] - b[COLUMN$1];
}

let found = false;
/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * ```js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * ```
 */
function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
        const mid = low + ((high - low) >> 1);
        const cmp = haystack[mid][COLUMN$1] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for (let i = index + 1; i < haystack.length; index = i++) {
        if (haystack[i][COLUMN$1] !== needle)
            break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for (let i = index - 1; i >= 0; index = i--) {
        if (haystack[i][COLUMN$1] !== needle)
            break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
    };
}
/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) {
            // lastIndex may be -1 if the previous needle was not found.
            low = lastIndex === -1 ? 0 : lastIndex;
        }
        else {
            high = lastIndex;
        }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return (state.lastIndex = binarySearch(haystack, needle, low, high));
}

const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
const LEAST_UPPER_BOUND = -1;
const GREATEST_LOWER_BOUND = 1;
class TraceMap {
    constructor(map, mapUrl) {
        const isString = typeof map === 'string';
        if (!isString && map._decodedMemo)
            return map;
        const parsed = (isString ? JSON.parse(map) : map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
        const from = resolve$1(sourceRoot || '', stripFilename(mapUrl));
        this.resolvedSources = sources.map((s) => resolve$1(s || '', from));
        const { mappings } = parsed;
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = undefined;
        }
        else {
            this._encoded = undefined;
            this._decoded = maybeSort(mappings, isString);
        }
        this._decodedMemo = memoizedState();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
    }
}
/**
 * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
 * with public access modifiers.
 */
function cast$2(map) {
    return map;
}
/**
 * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
 */
function encodedMappings(map) {
    var _a;
    var _b;
    return ((_a = (_b = cast$2(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = encode$1(cast$2(map)._decoded)));
}
/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */
function decodedMappings(map) {
    var _a;
    return ((_a = cast$2(map))._decoded || (_a._decoded = decode(cast$2(map)._encoded)));
}
/**
 * A low-level API to find the segment associated with a generated line/column (think, from a
 * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
 */
function traceSegment(map, line, column) {
    const decoded = decodedMappings(map);
    // It's common for parent source maps to have pointers to lines that have no
    // mapping (like a "//# sourceMappingURL=") at the end of the child file.
    if (line >= decoded.length)
        return null;
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast$2(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
}
/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * `source-map` library.
 */
function originalPositionFor$1(map, needle) {
    let { line, column, bias } = needle;
    line--;
    if (line < 0)
        throw new Error(LINE_GTR_ZERO);
    if (column < 0)
        throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map);
    // It's common for parent source maps to have pointers to lines that have no
    // mapping (like a "//# sourceMappingURL=") at the end of the child file.
    if (line >= decoded.length)
        return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast$2(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index === -1)
        return OMapping(null, null, null, null);
    const segment = segments[index];
    if (segment.length === 1)
        return OMapping(null, null, null, null);
    const { names, resolvedSources } = map;
    return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);
}
/**
 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
function decodedMap(map) {
    return clone(map, decodedMappings(map));
}
/**
 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
function encodedMap(map) {
    return clone(map, encodedMappings(map));
}
function clone(map, mappings) {
    return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings,
        ignoreList: map.ignoreList || map.x_google_ignoreList,
    };
}
function OMapping(source, line, column, name) {
    return { source, line, column, name };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = memoizedBinarySearch(segments, column, memo, line);
    if (found) {
        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    }
    else if (bias === LEAST_UPPER_BOUND)
        index++;
    if (index === -1 || index === segments.length)
        return -1;
    return index;
}

/**
 * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
 * index of the `key` in the backing array.
 *
 * This is designed to allow synchronizing a second array with the contents of the backing array,
 * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
 * and there are never duplicates.
 */
class SetArray {
    constructor() {
        this._indexes = { __proto__: null };
        this.array = [];
    }
}
/**
 * Typescript doesn't allow friend access to private fields, so this just casts the set into a type
 * with public access modifiers.
 */
function cast$1(set) {
    return set;
}
/**
 * Gets the index associated with `key` in the backing array, if it is already present.
 */
function get(setarr, key) {
    return cast$1(setarr)._indexes[key];
}
/**
 * Puts `key` into the backing array, if it is not already present. Returns
 * the index of the `key` in the backing array.
 */
function put(setarr, key) {
    // The key may or may not be present. If it is present, it's a number.
    const index = get(setarr, key);
    if (index !== undefined)
        return index;
    const { array, _indexes: indexes } = cast$1(setarr);
    const length = array.push(key);
    return (indexes[key] = length - 1);
}
/**
 * Removes the key, if it exists in the set.
 */
function remove(setarr, key) {
    const index = get(setarr, key);
    if (index === undefined)
        return;
    const { array, _indexes: indexes } = cast$1(setarr);
    for (let i = index + 1; i < array.length; i++) {
        const k = array[i];
        array[i - 1] = k;
        indexes[k]--;
    }
    indexes[key] = undefined;
    array.pop();
}

const COLUMN = 0;
const SOURCES_INDEX = 1;
const SOURCE_LINE = 2;
const SOURCE_COLUMN = 3;
const NAMES_INDEX = 4;

const NO_NAME = -1;
/**
 * Provides the state to generate a sourcemap.
 */
class GenMapping {
    constructor({ file, sourceRoot } = {}) {
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
}
/**
 * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
 * with public access modifiers.
 */
function cast(map) {
    return map;
}
/**
 * Same as `addSegment`, but will only add the segment if it generates useful information in the
 * resulting map. This only works correctly if segments are added **in order**, meaning you should
 * not add a segment with a lower generated line/column than one that came before.
 */
const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name);
};
/**
 * Adds/removes the content of the source file to the source map.
 */
function setSourceContent(map, source, content) {
    const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
    const index = put(sources, source);
    sourcesContent[index] = content;
}
function setIgnore(map, source, ignore = true) {
    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
    const index = put(sources, source);
    if (index === sourcesContent.length)
        sourcesContent[index] = null;
    if (ignore)
        put(ignoreList, index);
    else
        remove(ignoreList, index);
}
/**
 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
function toDecodedMap(map) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || undefined,
        names: names.array,
        sourceRoot: map.sourceRoot || undefined,
        sources: sources.array,
        sourcesContent,
        mappings,
        ignoreList: ignoreList.array,
    };
}
/**
 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */
function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    return Object.assign(Object.assign({}, decoded), { mappings: encode$1(decoded.mappings) });
}
// This split declaration is only so that terser can elminiate the static initialization block.
function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);
    const line = getLine(mappings, genLine);
    const index = getColumnIndex(line, genColumn);
    if (!source) {
        if (skipSourceless(line, index))
            return;
        return insert(line, index, [genColumn]);
    }
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length)
        sourcesContent[sourcesIndex] = null;
    if (skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
    }
    return insert(line, index, name
        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
        : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
}
function getLine(mappings, index) {
    for (let i = mappings.length; i <= index; i++) {
        mappings[i] = [];
    }
    return mappings[index];
}
function getColumnIndex(line, genColumn) {
    let index = line.length;
    for (let i = index - 1; i >= 0; index = i--) {
        const current = line[i];
        if (genColumn >= current[COLUMN])
            break;
    }
    return index;
}
function insert(array, index, value) {
    for (let i = array.length; i > index; i--) {
        array[i] = array[i - 1];
    }
    array[index] = value;
}
function removeEmptyFinalLines(mappings) {
    const { length } = mappings;
    let len = length;
    for (let i = len - 1; i >= 0; len = i, i--) {
        if (mappings[i].length > 0)
            break;
    }
    if (len < length)
        mappings.length = len;
}
function skipSourceless(line, index) {
    // The start of a line is already sourceless, so adding a sourceless segment to the beginning
    // doesn't generate any useful information.
    if (index === 0)
        return true;
    const prev = line[index - 1];
    // If the previous segment is also sourceless, then adding another sourceless segment doesn't
    // genrate any new information. Else, this segment will end the source/named segment and point to
    // a sourceless position, which is useful.
    return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    // A source/named segment at the start of a line gives position at that genColumn
    if (index === 0)
        return false;
    const prev = line[index - 1];
    // If the previous segment is sourceless, then we're transitioning to a source.
    if (prev.length === 1)
        return false;
    // If the previous segment maps to the exact same source position, then this segment doesn't
    // provide any new position information.
    return (sourcesIndex === prev[SOURCES_INDEX] &&
        sourceLine === prev[SOURCE_LINE] &&
        sourceColumn === prev[SOURCE_COLUMN] &&
        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));
}

const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null, false);
const EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
    return { source, line, column, name, content, ignore };
}
function Source(map, sources, source, content, ignore) {
    return {
        map,
        sources,
        source,
        content,
        ignore,
    };
}
/**
 * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
 * (which may themselves be SourceMapTrees).
 */
function MapSource(map, sources) {
    return Source(map, sources, '', null, false);
}
/**
 * A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
 * segment tracing ends at the `OriginalSource`.
 */
function OriginalSource(source, content, ignore) {
    return Source(null, EMPTY_SOURCES, source, content, ignore);
}
/**
 * traceMappings is only called on the root level SourceMapTree, and begins the process of
 * resolving each mapping in terms of the original source files.
 */
function traceMappings(tree) {
    // TODO: Eventually support sourceRoot, which has to be removed because the sources are already
    // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.
    const gen = new GenMapping({ file: tree.map.file });
    const { sources: rootSources, map } = tree;
    const rootNames = map.names;
    const rootMappings = decodedMappings(map);
    for (let i = 0; i < rootMappings.length; i++) {
        const segments = rootMappings[i];
        for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            // 1-length segments only move the current generated column, there's no source information
            // to gather from it.
            if (segment.length !== 1) {
                const source = rootSources[segment[1]];
                traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');
                // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a
                // respective segment into an original source.
                if (traced == null)
                    continue;
            }
            const { column, line, name, content, source, ignore } = traced;
            maybeAddSegment(gen, i, genCol, source, line, column, name);
            if (source && content != null)
                setSourceContent(gen, source, content);
            if (ignore)
                setIgnore(gen, source, true);
        }
    }
    return gen;
}
/**
 * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
 * child SourceMapTrees, until we find the original source map.
 */
function originalPositionFor(source, line, column, name) {
    if (!source.map) {
        return SegmentObject(source.source, line, column, name, source.content, source.ignore);
    }
    const segment = traceSegment(source.map, line, column);
    // If we couldn't find a segment, then this doesn't exist in the sourcemap.
    if (segment == null)
        return null;
    // 1-length segments only move the current generated column, there's no source information
    // to gather from it.
    if (segment.length === 1)
        return SOURCELESS_MAPPING;
    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}

function asArray(value) {
    if (Array.isArray(value))
        return value;
    return [value];
}
/**
 * Recursively builds a tree structure out of sourcemap files, with each node
 * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
 * `OriginalSource`s and `SourceMapTree`s.
 *
 * Every sourcemap is composed of a collection of source files and mappings
 * into locations of those source files. When we generate a `SourceMapTree` for
 * the sourcemap, we attempt to load each source file's own sourcemap. If it
 * does not have an associated sourcemap, it is considered an original,
 * unmodified source file.
 */
function buildSourceMapTree(input, loader) {
    const maps = asArray(input).map((m) => new TraceMap(m, ''));
    const map = maps.pop();
    for (let i = 0; i < maps.length; i++) {
        if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.\n` +
                'Did you specify these with the most recent transformation maps first?');
        }
    }
    let tree = build$2(map, loader, '', 0);
    for (let i = maps.length - 1; i >= 0; i--) {
        tree = MapSource(maps[i], [tree]);
    }
    return tree;
}
function build$2(map, loader, importer, importerDepth) {
    const { resolvedSources, sourcesContent, ignoreList } = map;
    const depth = importerDepth + 1;
    const children = resolvedSources.map((sourceFile, i) => {
        // The loading context gives the loader more information about why this file is being loaded
        // (eg, from which importer). It also allows the loader to override the location of the loaded
        // sourcemap/original source, or to override the content in the sourcesContent field if it's
        // an unmodified source file.
        const ctx = {
            importer,
            depth,
            source: sourceFile || '',
            content: undefined,
            ignore: undefined,
        };
        // Use the provided loader callback to retrieve the file's sourcemap.
        // TODO: We should eventually support async loading of sourcemap files.
        const sourceMap = loader(ctx.source, ctx);
        const { source} = ctx;
        // If there is a sourcemap, then we need to recurse into it to load its source files.
        if (sourceMap)
            return build$2(new TraceMap(sourceMap, source), loader, source, depth);
        // Else, it's an unmodified source file.
        // The contents of this unmodified source file can be overridden via the loader context,
        // allowing it to be explicitly null or a string. If it remains undefined, we fall back to
        // the importing sourcemap's `sourcesContent` field.
        const sourceContent = sourcesContent ? sourcesContent[i] : null;
        const ignored = ignoreList ? ignoreList.includes(i) : false;
        return OriginalSource(source, sourceContent, ignored);
    });
    return MapSource(map, children);
}

/**
 * A SourceMap v3 compatible sourcemap, which only includes fields that were
 * provided to it.
 */
class SourceMap {
    constructor(map, options) {
        const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);
        this.version = out.version; // SourceMap spec says this should be first.
        this.file = out.file;
        this.mappings = out.mappings;
        this.names = out.names;
        this.ignoreList = out.ignoreList;
        this.sourceRoot = out.sourceRoot;
        this.sources = out.sources;
        if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
}

/**
 * Traces through all the mappings in the root sourcemap, through the sources
 * (and their sourcemaps), all the way back to the original source location.
 *
 * `loader` will be called every time we encounter a source file. If it returns
 * a sourcemap, we will recurse into that sourcemap to continue the trace. If
 * it returns a falsey value, that source file is treated as an original,
 * unmodified source file.
 *
 * Pass `excludeContent` to exclude any self-containing source file content
 * from the output sourcemap.
 *
 * Pass `decodedMappings` to receive a SourceMap with decoded (instead of
 * VLQ encoded) mappings.
 */
function remapping(input, loader, options) {
    const opts = { excludeContent: false, decodedMappings: false };
    const tree = buildSourceMapTree(input, loader);
    return new SourceMap(traceMappings(tree), opts);
}

var node$1 = {exports: {}};

/**
 * Helpers.
 */

var ms$1;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms$1;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms$1 = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms$1;
}

var common$4;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common$4;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(' ', ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common$4 = setup;
	return common$4;
}

/**
 * Module dependencies.
 */

(function (module, exports) {
	const tty = require$$0$3;
	const util = require$$1;

	/**
	 * This is the Node.js implementation of `debug()`.
	 */

	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util.deprecate(
		() => {},
		'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
	);

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	try {
		// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
		// eslint-disable-next-line import/no-extraneous-dependencies
		const supportsColor = require('supports-color');

		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
			exports.colors = [
				20,
				21,
				26,
				27,
				32,
				33,
				38,
				39,
				40,
				41,
				42,
				43,
				44,
				45,
				56,
				57,
				62,
				63,
				68,
				69,
				74,
				75,
				76,
				77,
				78,
				79,
				80,
				81,
				92,
				93,
				98,
				99,
				112,
				113,
				128,
				129,
				134,
				135,
				148,
				149,
				160,
				161,
				162,
				163,
				164,
				165,
				166,
				167,
				168,
				169,
				170,
				171,
				172,
				173,
				178,
				179,
				184,
				185,
				196,
				197,
				198,
				199,
				200,
				201,
				202,
				203,
				204,
				205,
				206,
				207,
				208,
				209,
				214,
				215,
				220,
				221
			];
		}
	} catch (error) {
		// Swallow - we only care if `supports-color` is available; it doesn't have to be.
	}

	/**
	 * Build up the default `inspectOpts` object from the environment variables.
	 *
	 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	 */

	exports.inspectOpts = Object.keys(process.env).filter(key => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		// Camel-case
		const prop = key
			.substring(6)
			.toLowerCase()
			.replace(/_([a-z])/g, (_, k) => {
				return k.toUpperCase();
			});

		// Coerce string value into JS value
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) {
			val = true;
		} else if (/^(no|off|false|disabled)$/i.test(val)) {
			val = false;
		} else if (val === 'null') {
			val = null;
		} else {
			val = Number(val);
		}

		obj[prop] = val;
		return obj;
	}, {});

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
		return 'colors' in exports.inspectOpts ?
			Boolean(exports.inspectOpts.colors) :
			tty.isatty(process.stderr.fd);
	}

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
		const {namespace: name, useColors} = this;

		if (useColors) {
			const c = this.color;
			const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;

			args[0] = prefix + args[0].split('\n').join('\n' + prefix);
			args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
		} else {
			args[0] = getDate() + name + ' ' + args[0];
		}
	}

	function getDate() {
		if (exports.inspectOpts.hideDate) {
			return '';
		}
		return new Date().toISOString() + ' ';
	}

	/**
	 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	 */

	function log(...args) {
		return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	function save(namespaces) {
		if (namespaces) {
			process.env.DEBUG = namespaces;
		} else {
			// If you set a process.env field to null or undefined, it gets cast to the
			// string 'null' or 'undefined'. Just delete instead.
			delete process.env.DEBUG;
		}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
		return process.env.DEBUG;
	}

	/**
	 * Init logic for `debug` instances.
	 *
	 * Create a new `inspectOpts` object in case `useColors` is set
	 * differently for a particular `debug` instance.
	 */

	function init(debug) {
		debug.inspectOpts = {};

		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) {
			debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
		}
	}

	module.exports = requireCommon()(exports);

	const {formatters} = module.exports;

	/**
	 * Map %o to `util.inspect()`, all on a single line.
	 */

	formatters.o = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts)
			.split('\n')
			.map(str => str.trim())
			.join(' ');
	};

	/**
	 * Map %O to `util.inspect()`, allowing multiple lines if needed.
	 */

	formatters.O = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts);
	}; 
} (node$1, node$1.exports));

var nodeExports$1 = node$1.exports;
var debug$j = /*@__PURE__*/getDefaultExportFromCjs(nodeExports$1);

let pnp;
if (process.versions.pnp) {
  try {
    pnp = createRequire$1(import.meta.url)("pnpapi");
  } catch {
  }
}
function invalidatePackageData(packageCache, pkgPath) {
  const pkgDir = normalizePath$3(path$b.dirname(pkgPath));
  packageCache.forEach((pkg, cacheKey) => {
    if (pkg.dir === pkgDir) {
      packageCache.delete(cacheKey);
    }
  });
}
function resolvePackageData(pkgName, basedir, preserveSymlinks = false, packageCache) {
  if (pnp) {
    const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
    if (packageCache?.has(cacheKey)) return packageCache.get(cacheKey);
    try {
      const pkg = pnp.resolveToUnqualified(pkgName, basedir, {
        considerBuiltins: false
      });
      if (!pkg) return null;
      const pkgData = loadPackageData(path$b.join(pkg, "package.json"));
      packageCache?.set(cacheKey, pkgData);
      return pkgData;
    } catch {
      return null;
    }
  }
  const originalBasedir = basedir;
  while (basedir) {
    if (packageCache) {
      const cached = getRpdCache(
        packageCache,
        pkgName,
        basedir,
        originalBasedir,
        preserveSymlinks
      );
      if (cached) return cached;
    }
    const pkg = path$b.join(basedir, "node_modules", pkgName, "package.json");
    try {
      if (fs__default.existsSync(pkg)) {
        const pkgPath = preserveSymlinks ? pkg : safeRealpathSync(pkg);
        const pkgData = loadPackageData(pkgPath);
        if (packageCache) {
          setRpdCache(
            packageCache,
            pkgData,
            pkgName,
            basedir,
            originalBasedir,
            preserveSymlinks
          );
        }
        return pkgData;
      }
    } catch {
    }
    const nextBasedir = path$b.dirname(basedir);
    if (nextBasedir === basedir) break;
    basedir = nextBasedir;
  }
  return null;
}
function findNearestPackageData(basedir, packageCache) {
  const originalBasedir = basedir;
  while (basedir) {
    if (packageCache) {
      const cached = getFnpdCache(packageCache, basedir, originalBasedir);
      if (cached) return cached;
    }
    const pkgPath = path$b.join(basedir, "package.json");
    if (tryStatSync(pkgPath)?.isFile()) {
      try {
        const pkgData = loadPackageData(pkgPath);
        if (packageCache) {
          setFnpdCache(packageCache, pkgData, basedir, originalBasedir);
        }
        return pkgData;
      } catch {
      }
    }
    const nextBasedir = path$b.dirname(basedir);
    if (nextBasedir === basedir) break;
    basedir = nextBasedir;
  }
  return null;
}
function findNearestMainPackageData(basedir, packageCache) {
  const nearestPackage = findNearestPackageData(basedir, packageCache);
  return nearestPackage && (nearestPackage.data.name ? nearestPackage : findNearestMainPackageData(
    path$b.dirname(nearestPackage.dir),
    packageCache
  ));
}
function loadPackageData(pkgPath) {
  const data = JSON.parse(stripBomTag(fs__default.readFileSync(pkgPath, "utf-8")));
  const pkgDir = normalizePath$3(path$b.dirname(pkgPath));
  const { sideEffects } = data;
  let hasSideEffects;
  if (typeof sideEffects === "boolean") {
    hasSideEffects = () => sideEffects;
  } else if (Array.isArray(sideEffects)) {
    if (sideEffects.length <= 0) {
      hasSideEffects = () => false;
    } else {
      const finalPackageSideEffects = sideEffects.map((sideEffect) => {
        if (sideEffect.includes("/")) {
          return sideEffect;
        }
        return `**/${sideEffect}`;
      });
      hasSideEffects = createFilter$1(finalPackageSideEffects, null, {
        resolve: pkgDir
      });
    }
  } else {
    hasSideEffects = () => null;
  }
  const resolvedCache = {};
  const pkg = {
    dir: pkgDir,
    data,
    hasSideEffects,
    setResolvedCache(key, entry, options) {
      resolvedCache[getResolveCacheKey(key, options)] = entry;
    },
    getResolvedCache(key, options) {
      return resolvedCache[getResolveCacheKey(key, options)];
    }
  };
  return pkg;
}
function getResolveCacheKey(key, options) {
  return [
    key,
    options.isRequire ? "1" : "0",
    options.conditions.join("_"),
    options.extensions.join("_"),
    options.mainFields.join("_")
  ].join("|");
}
function findNearestNodeModules(basedir) {
  while (basedir) {
    const pkgPath = path$b.join(basedir, "node_modules");
    if (tryStatSync(pkgPath)?.isDirectory()) {
      return pkgPath;
    }
    const nextBasedir = path$b.dirname(basedir);
    if (nextBasedir === basedir) break;
    basedir = nextBasedir;
  }
  return null;
}
function watchPackageDataPlugin(packageCache) {
  const watchQueue = /* @__PURE__ */ new Set();
  const watchedDirs = /* @__PURE__ */ new Set();
  const watchFileStub = (id) => {
    watchQueue.add(id);
  };
  let watchFile = watchFileStub;
  const setPackageData = packageCache.set.bind(packageCache);
  packageCache.set = (id, pkg) => {
    if (!isInNodeModules$1(pkg.dir) && !watchedDirs.has(pkg.dir)) {
      watchedDirs.add(pkg.dir);
      watchFile(path$b.join(pkg.dir, "package.json"));
    }
    return setPackageData(id, pkg);
  };
  return {
    name: "vite:watch-package-data",
    buildStart() {
      watchFile = this.addWatchFile.bind(this);
      watchQueue.forEach(watchFile);
      watchQueue.clear();
    },
    buildEnd() {
      watchFile = watchFileStub;
    },
    watchChange(id) {
      if (id.endsWith("/package.json")) {
        invalidatePackageData(packageCache, path$b.normalize(id));
      }
    }
  };
}
function getRpdCache(packageCache, pkgName, basedir, originalBasedir, preserveSymlinks) {
  const cacheKey = getRpdCacheKey(pkgName, basedir, preserveSymlinks);
  const pkgData = packageCache.get(cacheKey);
  if (pkgData) {
    traverseBetweenDirs(originalBasedir, basedir, (dir) => {
      packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
    });
    return pkgData;
  }
}
function setRpdCache(packageCache, pkgData, pkgName, basedir, originalBasedir, preserveSymlinks) {
  packageCache.set(getRpdCacheKey(pkgName, basedir, preserveSymlinks), pkgData);
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    packageCache.set(getRpdCacheKey(pkgName, dir, preserveSymlinks), pkgData);
  });
}
function getRpdCacheKey(pkgName, basedir, preserveSymlinks) {
  return `rpd_${pkgName}_${basedir}_${preserveSymlinks}`;
}
function getFnpdCache(packageCache, basedir, originalBasedir) {
  const cacheKey = getFnpdCacheKey(basedir);
  const pkgData = packageCache.get(cacheKey);
  if (pkgData) {
    traverseBetweenDirs(originalBasedir, basedir, (dir) => {
      packageCache.set(getFnpdCacheKey(dir), pkgData);
    });
    return pkgData;
  }
}
function setFnpdCache(packageCache, pkgData, basedir, originalBasedir) {
  packageCache.set(getFnpdCacheKey(basedir), pkgData);
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    packageCache.set(getFnpdCacheKey(dir), pkgData);
  });
}
function getFnpdCacheKey(basedir) {
  return `fnpd_${basedir}`;
}
function traverseBetweenDirs(longerDir, shorterDir, cb) {
  while (longerDir !== shorterDir) {
    cb(longerDir);
    longerDir = path$b.dirname(longerDir);
  }
}

const createFilter$1 = createFilter$2;
const replaceSlashOrColonRE = /[/:]/g;
const replaceDotRE = /\./g;
const replaceNestedIdRE = /\s*>\s*/g;
const replaceHashRE = /#/g;
const flattenId = (id) => {
  const flatId = limitFlattenIdLength(
    id.replace(replaceSlashOrColonRE, "_").replace(replaceDotRE, "__").replace(replaceNestedIdRE, "___").replace(replaceHashRE, "____")
  );
  return flatId;
};
const FLATTEN_ID_HASH_LENGTH = 8;
const FLATTEN_ID_MAX_FILE_LENGTH = 170;
const limitFlattenIdLength = (id, limit = FLATTEN_ID_MAX_FILE_LENGTH) => {
  if (id.length <= limit) {
    return id;
  }
  return id.slice(0, limit - (FLATTEN_ID_HASH_LENGTH + 1)) + "_" + getHash(id);
};
const normalizeId = (id) => id.replace(replaceNestedIdRE, " > ");
const NODE_BUILTIN_NAMESPACE = "node:";
const NPM_BUILTIN_NAMESPACE = "npm:";
const BUN_BUILTIN_NAMESPACE = "bun:";
const nodeBuiltins = builtinModules.filter((id) => !id.includes(":"));
const isBuiltinCache = /* @__PURE__ */ new WeakMap();
function isBuiltin(builtins, id) {
  let isBuiltin2 = isBuiltinCache.get(builtins);
  if (!isBuiltin2) {
    isBuiltin2 = createIsBuiltin(builtins);
    isBuiltinCache.set(builtins, isBuiltin2);
  }
  return isBuiltin2(id);
}
function createIsBuiltin(builtins) {
  const plainBuiltinsSet = new Set(
    builtins.filter((builtin) => typeof builtin === "string")
  );
  const regexBuiltins = builtins.filter(
    (builtin) => typeof builtin !== "string"
  );
  return (id) => plainBuiltinsSet.has(id) || regexBuiltins.some((regexp) => regexp.test(id));
}
const nodeLikeBuiltins = [
  ...nodeBuiltins,
  new RegExp(`^${NODE_BUILTIN_NAMESPACE}`),
  new RegExp(`^${NPM_BUILTIN_NAMESPACE}`),
  new RegExp(`^${BUN_BUILTIN_NAMESPACE}`)
];
function isNodeLikeBuiltin(id) {
  return isBuiltin(nodeLikeBuiltins, id);
}
function isNodeBuiltin(id) {
  if (id.startsWith(NODE_BUILTIN_NAMESPACE)) return true;
  return nodeBuiltins.includes(id);
}
function isInNodeModules$1(id) {
  return id.includes("node_modules");
}
function moduleListContains(moduleList, id) {
  return moduleList?.some(
    (m) => m === id || id.startsWith(withTrailingSlash(m))
  );
}
function isOptimizable(id, optimizeDeps) {
  const { extensions } = optimizeDeps;
  return OPTIMIZABLE_ENTRY_RE.test(id) || (extensions?.some((ext) => id.endsWith(ext)) ?? false);
}
const bareImportRE = /^(?![a-zA-Z]:)[\w@](?!.*:\/\/)/;
const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
const _require$1 = createRequire$1(import.meta.url);
const _dirname = path$b.dirname(fileURLToPath$1(import.meta.url));
const rollupVersion = resolvePackageData("rollup", _dirname, true)?.data.version ?? "";
const filter = process.env.VITE_DEBUG_FILTER;
const DEBUG = process.env.DEBUG;
function createDebugger(namespace, options = {}) {
  const log = debug$j(namespace);
  const { onlyWhenFocused, depth } = options;
  if (depth && log.inspectOpts && log.inspectOpts.depth == null) {
    log.inspectOpts.depth = options.depth;
  }
  let enabled = log.enabled;
  if (enabled && onlyWhenFocused) {
    const ns = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
    enabled = !!DEBUG?.includes(ns);
  }
  if (enabled) {
    return (...args) => {
      if (!filter || args.some((a) => a?.includes?.(filter))) {
        log(...args);
      }
    };
  }
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(
      `cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`
    );
  }
  if (!fs__default.existsSync(CLIENT_ENTRY)) {
    throw new Error(
      "cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY
    );
  }
  return fs__default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
const urlCanParse = (
  // eslint-disable-next-line n/no-unsupported-features/node-builtins
  URL$3.canParse ?? // URL.canParse is supported from Node.js 18.17.0+, 20.0.0+
  ((path2, base) => {
    try {
      new URL$3(path2, base);
      return true;
    } catch {
      return false;
    }
  })
);
const isCaseInsensitiveFS = testCaseInsensitiveFS();
const VOLUME_RE = /^[A-Z]:/i;
function normalizePath$3(id) {
  return path$b.posix.normalize(isWindows$3 ? slash$1(id) : id);
}
function fsPathFromId(id) {
  const fsPath = normalizePath$3(
    id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id
  );
  return fsPath[0] === "/" || VOLUME_RE.test(fsPath) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url) {
  return fsPathFromId(cleanUrl(url));
}
function isParentDirectory(dir, file) {
  dir = withTrailingSlash(dir);
  return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
}
function isSameFileUri(file1, file2) {
  return file1 === file2 || isCaseInsensitiveFS && file1.toLowerCase() === file2.toLowerCase();
}
const externalRE = /^([a-z]+:)?\/\//;
const isExternalUrl = (url) => externalRE.test(url);
const dataUrlRE = /^\s*data:/i;
const isDataUrl = (url) => dataUrlRE.test(url);
const virtualModuleRE = /^virtual-module:.*/;
const virtualModulePrefix = "virtual-module:";
const knownJsSrcRE = /\.(?:[jt]sx?|m[jt]s|vue|marko|svelte|astro|imba|mdx)(?:$|\?)/;
const isJSRequest = (url) => {
  url = cleanUrl(url);
  if (knownJsSrcRE.test(url)) {
    return true;
  }
  if (!path$b.extname(url) && url[url.length - 1] !== "/") {
    return true;
  }
  return false;
};
const importQueryRE = /(\?|&)import=?(?:&|$)/;
const directRequestRE$1 = /(\?|&)direct=?(?:&|$)/;
const internalPrefixes = [
  FS_PREFIX,
  VALID_ID_PREFIX,
  CLIENT_PUBLIC_PATH,
  ENV_PUBLIC_PATH
];
const InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
const trailingSeparatorRE = /[?&]$/;
const isImportRequest = (url) => importQueryRE.test(url);
const isInternalRequest = (url) => InternalPrefixRE.test(url);
function removeImportQuery(url) {
  return url.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
}
function removeDirectQuery(url) {
  return url.replace(directRequestRE$1, "$1").replace(trailingSeparatorRE, "");
}
const urlRE$1 = /(\?|&)url(?:&|$)/;
const rawRE$1 = /(\?|&)raw(?:&|$)/;
function removeUrlQuery(url) {
  return url.replace(urlRE$1, "$1").replace(trailingSeparatorRE, "");
}
function injectQuery(url, queryToInject) {
  const { file, postfix } = splitFileAndPostfix(url);
  const normalizedFile = isWindows$3 ? slash$1(file) : file;
  return `${normalizedFile}?${queryToInject}${postfix[0] === "?" ? `&${postfix.slice(1)}` : (
    /* hash only */
    postfix
  )}`;
}
const timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url) {
  return url.replace(timestampRE, "").replace(trailingSeparatorRE, "");
}
async function asyncReplace(input, re, replacer) {
  let match;
  let remaining = input;
  let rewritten = "";
  while (match = re.exec(remaining)) {
    rewritten += remaining.slice(0, match.index);
    rewritten += await replacer(match);
    remaining = remaining.slice(match.index + match[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function timeFrom(start, subtract = 0) {
  const time = performance$1.now() - start - subtract;
  const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
  if (time < 10) {
    return colors$1.green(timeString);
  } else if (time < 50) {
    return colors$1.yellow(timeString);
  } else {
    return colors$1.red(timeString);
  }
}
function prettifyUrl(url, root) {
  url = removeTimestampQuery(url);
  const isAbsoluteFile = url.startsWith(root);
  if (isAbsoluteFile || url.startsWith(FS_PREFIX)) {
    const file = path$b.posix.relative(
      root,
      isAbsoluteFile ? url : fsPathFromId(url)
    );
    return colors$1.dim(file);
  } else {
    return colors$1.dim(url);
  }
}
function isObject$1(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function isDefined(value) {
  return value != null;
}
function tryStatSync(file) {
  try {
    return fs__default.statSync(file, { throwIfNoEntry: false });
  } catch {
  }
}
function lookupFile(dir, fileNames) {
  while (dir) {
    for (const fileName of fileNames) {
      const fullPath = path$b.join(dir, fileName);
      if (tryStatSync(fullPath)?.isFile()) return fullPath;
    }
    const parentDir = path$b.dirname(dir);
    if (parentDir === dir) return;
    dir = parentDir;
  }
}
function isFilePathESM(filePath, packageCache) {
  if (/\.m[jt]s$/.test(filePath)) {
    return true;
  } else if (/\.c[jt]s$/.test(filePath)) {
    return false;
  } else {
    try {
      const pkg = findNearestPackageData(path$b.dirname(filePath), packageCache);
      return pkg?.data.type === "module";
    } catch {
      return false;
    }
  }
}
const splitRE = /\r?\n/g;
const range = 2;
function pad$1(source, n = 2) {
  const lines = source.split(splitRE);
  return lines.map((l) => ` `.repeat(n) + l).join(`
`);
}
function posToNumber(source, pos) {
  if (typeof pos === "number") return pos;
  const lines = source.split(splitRE);
  const { line, column } = pos;
  let start = 0;
  for (let i = 0; i < line - 1 && i < lines.length; i++) {
    start += lines[i].length + 1;
  }
  return start + column;
}
function numberToPos(source, offset) {
  if (typeof offset !== "number") return offset;
  if (offset > source.length) {
    throw new Error(
      `offset is longer than source length! offset ${offset} > length ${source.length}`
    );
  }
  const lines = source.split(splitRE);
  let counted = 0;
  let line = 0;
  let column = 0;
  for (; line < lines.length; line++) {
    const lineLength = lines[line].length + 1;
    if (counted + lineLength >= offset) {
      column = offset - counted + 1;
      break;
    }
    counted += lineLength;
  }
  return { line: line + 1, column };
}
function generateCodeFrame(source, start = 0, end) {
  start = Math.max(posToNumber(source, start), 0);
  end = Math.min(
    end !== void 0 ? posToNumber(source, end) : start,
    source.length
  );
  const lines = source.split(splitRE);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length;
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        if (j === i) {
          const pad2 = Math.max(start - (count - lineLength), 0);
          const length = Math.max(
            1,
            end > count ? lineLength - pad2 : end - start
          );
          res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
    count++;
  }
  return res.join("\n");
}
function isFileReadable(filename) {
  if (!tryStatSync(filename)) {
    return false;
  }
  try {
    fs__default.accessSync(filename, fs__default.constants.R_OK);
    return true;
  } catch {
    return false;
  }
}
const splitFirstDirRE = /(.+?)[\\/](.+)/;
function emptyDir(dir, skip) {
  const skipInDir = [];
  let nested = null;
  if (skip?.length) {
    for (const file of skip) {
      if (path$b.dirname(file) !== ".") {
        const matched = splitFirstDirRE.exec(file);
        if (matched) {
          nested ??= /* @__PURE__ */ new Map();
          const [, nestedDir, skipPath] = matched;
          let nestedSkip = nested.get(nestedDir);
          if (!nestedSkip) {
            nestedSkip = [];
            nested.set(nestedDir, nestedSkip);
          }
          if (!nestedSkip.includes(skipPath)) {
            nestedSkip.push(skipPath);
          }
        }
      } else {
        skipInDir.push(file);
      }
    }
  }
  for (const file of fs__default.readdirSync(dir)) {
    if (skipInDir.includes(file)) {
      continue;
    }
    if (nested?.has(file)) {
      emptyDir(path$b.resolve(dir, file), nested.get(file));
    } else {
      fs__default.rmSync(path$b.resolve(dir, file), { recursive: true, force: true });
    }
  }
}
function copyDir(srcDir, destDir) {
  fs__default.mkdirSync(destDir, { recursive: true });
  for (const file of fs__default.readdirSync(srcDir)) {
    const srcFile = path$b.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = path$b.resolve(destDir, file);
    const stat = fs__default.statSync(srcFile);
    if (stat.isDirectory()) {
      copyDir(srcFile, destFile);
    } else {
      fs__default.copyFileSync(srcFile, destFile);
    }
  }
}
const ERR_SYMLINK_IN_RECURSIVE_READDIR = "ERR_SYMLINK_IN_RECURSIVE_READDIR";
async function recursiveReaddir(dir) {
  if (!fs__default.existsSync(dir)) {
    return [];
  }
  let dirents;
  try {
    dirents = await fsp.readdir(dir, { withFileTypes: true });
  } catch (e) {
    if (e.code === "EACCES") {
      return [];
    }
    throw e;
  }
  if (dirents.some((dirent) => dirent.isSymbolicLink())) {
    const err = new Error(
      "Symbolic links are not supported in recursiveReaddir"
    );
    err.code = ERR_SYMLINK_IN_RECURSIVE_READDIR;
    throw err;
  }
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path$b.resolve(dir, dirent.name);
      return dirent.isDirectory() ? recursiveReaddir(res) : normalizePath$3(res);
    })
  );
  return files.flat(1);
}
let safeRealpathSync = isWindows$3 ? windowsSafeRealPathSync : fs__default.realpathSync.native;
const windowsNetworkMap = /* @__PURE__ */ new Map();
function windowsMappedRealpathSync(path2) {
  const realPath = fs__default.realpathSync.native(path2);
  if (realPath.startsWith("\\\\")) {
    for (const [network, volume] of windowsNetworkMap) {
      if (realPath.startsWith(network)) return realPath.replace(network, volume);
    }
  }
  return realPath;
}
const parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
let firstSafeRealPathSyncRun = false;
function windowsSafeRealPathSync(path2) {
  if (!firstSafeRealPathSyncRun) {
    optimizeSafeRealPathSync();
    firstSafeRealPathSyncRun = true;
  }
  return fs__default.realpathSync(path2);
}
function optimizeSafeRealPathSync() {
  const nodeVersion = process.versions.node.split(".").map(Number);
  if (nodeVersion[0] < 18 || nodeVersion[0] === 18 && nodeVersion[1] < 10) {
    safeRealpathSync = fs__default.realpathSync;
    return;
  }
  try {
    fs__default.realpathSync.native(path$b.resolve("./"));
  } catch (error) {
    if (error.message.includes("EISDIR: illegal operation on a directory")) {
      safeRealpathSync = fs__default.realpathSync;
      return;
    }
  }
  exec("net use", (error, stdout) => {
    if (error) return;
    const lines = stdout.split("\n");
    for (const line of lines) {
      const m = parseNetUseRE.exec(line);
      if (m) windowsNetworkMap.set(m[2], m[1]);
    }
    if (windowsNetworkMap.size === 0) {
      safeRealpathSync = fs__default.realpathSync.native;
    } else {
      safeRealpathSync = windowsMappedRealpathSync;
    }
  });
}
function ensureWatchedFile(watcher, file, root) {
  if (file && // only need to watch if out of root
  !file.startsWith(withTrailingSlash(root)) && // some rollup plugins use null bytes for private resolved Ids
  !file.includes("\0") && fs__default.existsSync(file)) {
    watcher.add(path$b.resolve(file));
  }
}
function joinSrcset(ret) {
  return ret.map(({ url, descriptor }) => url + (descriptor ? ` ${descriptor}` : "")).join(", ");
}
const imageCandidateRegex = /(?:^|\s|(?<=,))(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g;
const escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g;
function parseSrcset(string) {
  const matches = string.trim().replace(escapedSpaceCharacters, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(imageCandidateRegex);
  return Array.from(matches, ({ groups }) => ({
    url: groups?.url?.trim() ?? "",
    descriptor: groups?.descriptor?.trim() ?? ""
  })).filter(({ url }) => !!url);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(
    parseSrcset(srcs).map(async ({ url, descriptor }) => ({
      url: await replacer({ url, descriptor }),
      descriptor
    }))
  ).then(joinSrcset);
}
function processSrcSetSync(srcs, replacer) {
  return joinSrcset(
    parseSrcset(srcs).map(({ url, descriptor }) => ({
      url: replacer({ url, descriptor }),
      descriptor
    }))
  );
}
const windowsDriveRE = /^[A-Z]:/;
const replaceWindowsDriveRE = /^([A-Z]):\//;
const linuxAbsolutePathRE = /^\/[^/]/;
function escapeToLinuxLikePath(path2) {
  if (windowsDriveRE.test(path2)) {
    return path2.replace(replaceWindowsDriveRE, "/windows/$1/");
  }
  if (linuxAbsolutePathRE.test(path2)) {
    return `/linux${path2}`;
  }
  return path2;
}
const revertWindowsDriveRE = /^\/windows\/([A-Z])\//;
function unescapeToLinuxLikePath(path2) {
  if (path2.startsWith("/linux/")) {
    return path2.slice("/linux".length);
  }
  if (path2.startsWith("/windows/")) {
    return path2.replace(revertWindowsDriveRE, "$1:/");
  }
  return path2;
}
const nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList) {
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0)) {
    return { ...nullSourceMap };
  }
  sourcemapList = sourcemapList.map((sourcemap) => {
    const newSourcemaps = { ...sourcemap };
    newSourcemaps.sources = sourcemap.sources.map(
      (source) => source ? escapeToLinuxLikePath(source) : null
    );
    if (sourcemap.sourceRoot) {
      newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
    }
    return newSourcemaps;
  });
  const escapedFilename = escapeToLinuxLikePath(filename);
  let map;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map = remapping(sourcemapList, () => null);
  } else {
    map = remapping(sourcemapList[0], function loader(sourcefile) {
      if (sourcefile === escapedFilename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++];
      } else {
        return null;
      }
    });
  }
  if (!map.file) {
    delete map.file;
  }
  map.sources = map.sources.map(
    (source) => source ? unescapeToLinuxLikePath(source) : source
  );
  map.file = filename;
  return map;
}
function unique(arr) {
  return Array.from(new Set(arr));
}
async function getLocalhostAddressIfDiffersFromDNS() {
  const [nodeResult, dnsResult] = await Promise.all([
    promises.lookup("localhost"),
    promises.lookup("localhost", { verbatim: true })
  ]);
  const isSame = nodeResult.family === dnsResult.family && nodeResult.address === dnsResult.address;
  return isSame ? void 0 : nodeResult.address;
}
function diffDnsOrderChange(oldUrls, newUrls) {
  return !(oldUrls === newUrls || oldUrls && newUrls && arrayEqual(oldUrls.local, newUrls.local) && arrayEqual(oldUrls.network, newUrls.network));
}
async function resolveHostname(optionsHost) {
  let host;
  if (optionsHost === void 0 || optionsHost === false) {
    host = "localhost";
  } else if (optionsHost === true) {
    host = void 0;
  } else {
    host = optionsHost;
  }
  let name = host === void 0 || wildcardHosts.has(host) ? "localhost" : host;
  if (host === "localhost") {
    const localhostAddr = await getLocalhostAddressIfDiffersFromDNS();
    if (localhostAddr) {
      name = localhostAddr;
    }
  }
  return { host, name };
}
async function resolveServerUrls(server, options, httpsOptions, config) {
  const address = server.address();
  const isAddressInfo = (x) => x?.address;
  if (!isAddressInfo(address)) {
    return { local: [], network: [] };
  }
  const local = [];
  const network = [];
  const hostname = await resolveHostname(options.host);
  const protocol = options.https ? "https" : "http";
  const port = address.port;
  const base = config.rawBase === "./" || config.rawBase === "" ? "/" : config.rawBase;
  if (hostname.host !== void 0 && !wildcardHosts.has(hostname.host)) {
    let hostnameName = hostname.name;
    if (hostnameName.includes(":")) {
      hostnameName = `[${hostnameName}]`;
    }
    const address2 = `${protocol}://${hostnameName}:${port}${base}`;
    if (loopbackHosts.has(hostname.host)) {
      local.push(address2);
    } else {
      network.push(address2);
    }
  } else {
    Object.values(os$3.networkInterfaces()).flatMap((nInterface) => nInterface ?? []).filter(
      (detail) => detail.address && (detail.family === "IPv4" || // @ts-expect-error Node 18.0 - 18.3 returns number
      detail.family === 4)
    ).forEach((detail) => {
      let host = detail.address.replace("127.0.0.1", hostname.name);
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      const url = `${protocol}://${host}:${port}${base}`;
      if (detail.address.includes("127.0.0.1")) {
        local.push(url);
      } else {
        network.push(url);
      }
    });
  }
  const cert = httpsOptions?.cert && !Array.isArray(httpsOptions.cert) ? new crypto$2.X509Certificate(httpsOptions.cert) : void 0;
  const hostnameFromCert = cert?.subjectAltName ? extractHostnamesFromSubjectAltName(cert.subjectAltName) : [];
  if (hostnameFromCert.length > 0) {
    const existings = /* @__PURE__ */ new Set([...local, ...network]);
    local.push(
      ...hostnameFromCert.map((hostname2) => `https://${hostname2}:${port}${base}`).filter((url) => !existings.has(url))
    );
  }
  return { local, network };
}
function extractHostnamesFromSubjectAltName(subjectAltName) {
  const hostnames = [];
  let remaining = subjectAltName;
  while (remaining) {
    const nameEndIndex = remaining.indexOf(":");
    const name = remaining.slice(0, nameEndIndex);
    remaining = remaining.slice(nameEndIndex + 1);
    if (!remaining) break;
    const isQuoted = remaining[0] === '"';
    let value;
    if (isQuoted) {
      const endQuoteIndex = remaining.indexOf('"', 1);
      value = JSON.parse(remaining.slice(0, endQuoteIndex + 1));
      remaining = remaining.slice(endQuoteIndex + 1);
    } else {
      const maybeEndIndex = remaining.indexOf(",");
      const endIndex = maybeEndIndex === -1 ? remaining.length : maybeEndIndex;
      value = remaining.slice(0, endIndex);
      remaining = remaining.slice(endIndex);
    }
    remaining = remaining.slice(
      /* for , */
      1
    ).trimStart();
    if (name === "DNS" && // [::1] might be included but skip it as it's already included as a local address
    value !== "[::1]" && // skip *.IPv4 addresses, which is invalid
    !(value.startsWith("*.") && net$1.isIPv4(value.slice(2)))) {
      hostnames.push(value.replace("*", "vite"));
    }
  }
  return hostnames;
}
function arraify(target) {
  return Array.isArray(target) ? target : [target];
}
const multilineCommentsRE = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g;
const singlelineCommentsRE = /\/\/.*/g;
const requestQuerySplitRE = /\?(?!.*[/|}])/;
const requestQueryMaybeEscapedSplitRE = /\\?\?(?!.*[/|}])/;
const blankReplacer = (match) => " ".repeat(match.length);
const hash$1 = (
  // eslint-disable-next-line n/no-unsupported-features/node-builtins -- crypto.hash is supported in Node 21.7.0+, 20.12.0+
  crypto$2.hash ?? ((algorithm, data, outputEncoding) => crypto$2.createHash(algorithm).update(data).digest(outputEncoding))
);
function getHash(text, length = 8) {
  const h = hash$1("sha256", text, "hex").substring(0, length);
  if (length <= 64) return h;
  return h.padEnd(length, "_");
}
const requireResolveFromRootWithFallback = (root, id) => {
  const found = resolvePackageData(id, root) || resolvePackageData(id, _dirname);
  if (!found) {
    const error = new Error(`${JSON.stringify(id)} not found.`);
    error.code = "MODULE_NOT_FOUND";
    throw error;
  }
  return _require$1.resolve(id, { paths: [root, _dirname] });
};
function emptyCssComments(raw) {
  return raw.replace(multilineCommentsRE, blankReplacer);
}
function backwardCompatibleWorkerPlugins(plugins) {
  if (Array.isArray(plugins)) {
    return plugins;
  }
  if (typeof plugins === "function") {
    return plugins();
  }
  return [];
}
function deepClone(value) {
  if (Array.isArray(value)) {
    return value.map((v) => deepClone(v));
  }
  if (isObject$1(value)) {
    const cloned = {};
    for (const key in value) {
      cloned[key] = deepClone(value[key]);
    }
    return cloned;
  }
  if (typeof value === "function") {
    return value;
  }
  if (value instanceof RegExp) {
    return new RegExp(value);
  }
  if (typeof value === "object" && value != null) {
    throw new Error("Cannot deep clone non-plain object");
  }
  return value;
}
function mergeWithDefaultsRecursively(defaults, values) {
  const merged = defaults;
  for (const key in values) {
    const value = values[key];
    if (value === void 0) continue;
    const existing = merged[key];
    if (existing === void 0) {
      merged[key] = value;
      continue;
    }
    if (isObject$1(existing) && isObject$1(value)) {
      merged[key] = mergeWithDefaultsRecursively(existing, value);
      continue;
    }
    merged[key] = value;
  }
  return merged;
}
function mergeWithDefaults(defaults, values) {
  const clonedDefaults = deepClone(defaults);
  return mergeWithDefaultsRecursively(clonedDefaults, values);
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
  const merged = { ...defaults };
  for (const key in overrides) {
    const value = overrides[key];
    if (value == null) {
      continue;
    }
    const existing = merged[key];
    if (existing == null) {
      merged[key] = value;
      continue;
    }
    if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
      merged[key] = mergeAlias(existing, value);
      continue;
    } else if (key === "assetsInclude" && rootPath === "") {
      merged[key] = [].concat(existing, value);
      continue;
    } else if (key === "noExternal" && (rootPath === "ssr" || rootPath === "resolve") && (existing === true || value === true)) {
      merged[key] = true;
      continue;
    } else if (key === "plugins" && rootPath === "worker") {
      merged[key] = () => [
        ...backwardCompatibleWorkerPlugins(existing),
        ...backwardCompatibleWorkerPlugins(value)
      ];
      continue;
    } else if (key === "server" && rootPath === "server.hmr") {
      merged[key] = value;
      continue;
    }
    if (Array.isArray(existing) || Array.isArray(value)) {
      merged[key] = [...arraify(existing), ...arraify(value)];
      continue;
    }
    if (isObject$1(existing) && isObject$1(value)) {
      merged[key] = mergeConfigRecursively(
        existing,
        value,
        rootPath ? `${rootPath}.${key}` : key
      );
      continue;
    }
    merged[key] = value;
  }
  return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
  if (typeof defaults === "function" || typeof overrides === "function") {
    throw new Error(`Cannot merge config in form of callback`);
  }
  return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
function mergeAlias(a, b) {
  if (!a) return b;
  if (!b) return a;
  if (isObject$1(a) && isObject$1(b)) {
    return { ...a, ...b };
  }
  return [...normalizeAlias(b), ...normalizeAlias(a)];
}
function normalizeAlias(o = []) {
  return Array.isArray(o) ? o.map(normalizeSingleAlias) : Object.keys(o).map(
    (find) => normalizeSingleAlias({
      find,
      replacement: o[find]
    })
  );
}
function normalizeSingleAlias({
  find,
  replacement,
  customResolver
}) {
  if (typeof find === "string" && find.endsWith("/") && replacement.endsWith("/")) {
    find = find.slice(0, find.length - 1);
    replacement = replacement.slice(0, replacement.length - 1);
  }
  const alias = {
    find,
    replacement
  };
  if (customResolver) {
    alias.customResolver = customResolver;
  }
  return alias;
}
function transformStableResult(s, id, config) {
  return {
    code: s.toString(),
    map: config.command === "build" && config.build.sourcemap ? s.generateMap({ hires: "boundary", source: id }) : null
  };
}
async function asyncFlatten(arr) {
  do {
    arr = (await Promise.all(arr)).flat(Infinity);
  } while (arr.some((v) => v?.then));
  return arr;
}
function stripBomTag(content) {
  if (content.charCodeAt(0) === 65279) {
    return content.slice(1);
  }
  return content;
}
const windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/;
const isNonDriveRelativeAbsolutePath = (p) => {
  if (!isWindows$3) return p[0] === "/";
  return windowsDrivePathPrefixRE.test(p);
};
function shouldServeFile(filePath, root) {
  if (!isCaseInsensitiveFS) return true;
  return hasCorrectCase(filePath, root);
}
function hasCorrectCase(file, assets) {
  if (file === assets) return true;
  const parent = path$b.dirname(file);
  if (fs__default.readdirSync(parent).includes(path$b.basename(file))) {
    return hasCorrectCase(parent, assets);
  }
  return false;
}
function joinUrlSegments(a, b) {
  if (!a || !b) {
    return a || b || "";
  }
  if (a.endsWith("/")) {
    a = a.substring(0, a.length - 1);
  }
  if (b[0] !== "/") {
    b = "/" + b;
  }
  return a + b;
}
function removeLeadingSlash(str) {
  return str[0] === "/" ? str.slice(1) : str;
}
function stripBase(path2, base) {
  if (path2 === base) {
    return "/";
  }
  const devBase = withTrailingSlash(base);
  return path2.startsWith(devBase) ? path2.slice(devBase.length - 1) : path2;
}
function arrayEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function evalValue(rawValue) {
  const fn = new Function(`
    var console, exports, global, module, process, require
    return (
${rawValue}
)
  `);
  return fn();
}
function getNpmPackageName(importPath) {
  const parts = importPath.split("/");
  if (parts[0][0] === "@") {
    if (!parts[1]) return null;
    return `${parts[0]}/${parts[1]}`;
  } else {
    return parts[0];
  }
}
function getPkgName(name) {
  return name[0] === "@" ? name.split("/")[1] : name;
}
const escapeRegexRE = /[-/\\^$*+?.()|[\]{}]/g;
function escapeRegex(str) {
  return str.replace(escapeRegexRE, "\\$&");
}
function getPackageManagerCommand(type = "install") {
  const packageManager = process.env.npm_config_user_agent?.split(" ")[0].split("/")[0] || "npm";
  switch (type) {
    case "install":
      return packageManager === "npm" ? "npm install" : `${packageManager} add`;
    case "uninstall":
      return packageManager === "npm" ? "npm uninstall" : `${packageManager} remove`;
    case "update":
      return packageManager === "yarn" ? "yarn upgrade" : `${packageManager} update`;
    default:
      throw new TypeError(`Unknown command type: ${type}`);
  }
}
function isDevServer(server) {
  return "pluginContainer" in server;
}
function createSerialPromiseQueue() {
  let previousTask;
  return {
    async run(f) {
      const thisTask = f();
      const depTasks = Promise.all([previousTask, thisTask]);
      previousTask = depTasks;
      const [, result] = await depTasks;
      if (previousTask === depTasks) {
        previousTask = void 0;
      }
      return result;
    }
  };
}
function sortObjectKeys(obj) {
  const sorted = {};
  for (const key of Object.keys(obj).sort()) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function displayTime(time) {
  if (time < 1e3) {
    return `${time}ms`;
  }
  time = time / 1e3;
  if (time < 60) {
    return `${time.toFixed(2)}s`;
  }
  const mins = Math.floor(time / 60);
  const seconds = Math.round(time % 60);
  if (seconds === 60) {
    return `${mins + 1}m`;
  }
  return `${mins}m${seconds < 1 ? "" : ` ${seconds}s`}`;
}
function encodeURIPath(uri) {
  if (uri.startsWith("data:")) return uri;
  const filePath = cleanUrl(uri);
  const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
  return encodeURI(filePath) + postfix;
}
function partialEncodeURIPath(uri) {
  if (uri.startsWith("data:")) return uri;
  const filePath = cleanUrl(uri);
  const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
  return filePath.replaceAll("%", "%25") + postfix;
}
const sigtermCallbacks = /* @__PURE__ */ new Set();
const parentSigtermCallback = async (signal, exitCode) => {
  await Promise.all([...sigtermCallbacks].map((cb) => cb(signal, exitCode)));
};
const setupSIGTERMListener = (callback) => {
  if (sigtermCallbacks.size === 0) {
    process.once("SIGTERM", parentSigtermCallback);
    if (process.env.CI !== "true") {
      process.stdin.on("end", parentSigtermCallback);
    }
  }
  sigtermCallbacks.add(callback);
};
const teardownSIGTERMListener = (callback) => {
  sigtermCallbacks.delete(callback);
  if (sigtermCallbacks.size === 0) {
    process.off("SIGTERM", parentSigtermCallback);
    if (process.env.CI !== "true") {
      process.stdin.off("end", parentSigtermCallback);
    }
  }
};
function getServerUrlByHost(resolvedUrls, host) {
  if (typeof host === "string") {
    const matchedUrl = [
      ...resolvedUrls?.local ?? [],
      ...resolvedUrls?.network ?? []
    ].find((url) => url.includes(host));
    if (matchedUrl) {
      return matchedUrl;
    }
  }
  return resolvedUrls?.local[0] ?? resolvedUrls?.network[0];
}

const LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
let lastType;
let lastMsg;
let sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  readline.cursorTo(process.stdout, 0, 0);
  readline.clearScreenDown(process.stdout);
}
let timeFormatter;
function getTimeFormatter() {
  timeFormatter ??= new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  });
  return timeFormatter;
}
function createLogger(level = "info", options = {}) {
  if (options.customLogger) {
    return options.customLogger;
  }
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const {
    prefix = "[vite]",
    allowClearScreen = true,
    console: console2 = globalThis.console
  } = options;
  const thresh = LogLevels[level];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function format(type, msg, options2 = {}) {
    if (options2.timestamp) {
      let tag = "";
      if (type === "info") {
        tag = colors$1.cyan(colors$1.bold(prefix));
      } else if (type === "warn") {
        tag = colors$1.yellow(colors$1.bold(prefix));
      } else {
        tag = colors$1.red(colors$1.bold(prefix));
      }
      const environment = options2.environment ? options2.environment + " " : "";
      return `${colors$1.dim(getTimeFormatter().format(/* @__PURE__ */ new Date()))} ${tag} ${environment}${msg}`;
    } else {
      return msg;
    }
  }
  function output(type, msg, options2 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      if (options2.error) {
        loggedErrors.add(options2.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console2[method](
            format(type, msg, options2),
            colors$1.yellow(`(x${sameCount + 1})`)
          );
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options2.clear) {
            clear();
          }
          console2[method](format(type, msg, options2));
        }
      } else {
        console2[method](format(type, msg, options2));
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg)) return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error);
    }
  };
  return logger;
}
function printServerUrls(urls, optionsHost, info) {
  const colorUrl = (url) => colors$1.cyan(url.replace(/:(\d+)\//, (_, port) => `:${colors$1.bold(port)}/`));
  for (const url of urls.local) {
    info(`  ${colors$1.green("\u279C")}  ${colors$1.bold("Local")}:   ${colorUrl(url)}`);
  }
  for (const url of urls.network) {
    info(`  ${colors$1.green("\u279C")}  ${colors$1.bold("Network")}: ${colorUrl(url)}`);
  }
  if (urls.network.length === 0 && optionsHost === void 0) {
    info(
      colors$1.dim(`  ${colors$1.green("\u279C")}  ${colors$1.bold("Network")}: use `) + colors$1.bold("--host") + colors$1.dim(" to expose")
    );
  }
}

const groups = [
  { name: "Assets", color: colors$1.green },
  { name: "CSS", color: colors$1.magenta },
  { name: "JS", color: colors$1.cyan }
];
const COMPRESSIBLE_ASSETS_RE = /\.(?:html|json|svg|txt|xml|xhtml|wasm)$/;
function buildReporterPlugin(config) {
  const compress = promisify$4(gzip);
  const numberFormatter = new Intl.NumberFormat("en", {
    maximumFractionDigits: 2,
    minimumFractionDigits: 2
  });
  const displaySize = (bytes) => {
    return `${numberFormatter.format(bytes / 1e3)} kB`;
  };
  const tty = process.stdout.isTTY && !process.env.CI;
  const shouldLogInfo = LogLevels[config.logLevel || "info"] >= LogLevels.info;
  const modulesReporter = shouldLogInfo ? perEnvironmentState((environment) => {
    let hasTransformed = false;
    let transformedCount = 0;
    const logTransform = throttle((id) => {
      writeLine(
        `transforming (${transformedCount}) ${colors$1.dim(
          path$b.relative(config.root, id)
        )}`
      );
    });
    return {
      reset() {
        transformedCount = 0;
      },
      register(id) {
        transformedCount++;
        if (!tty) {
          if (!hasTransformed) {
            config.logger.info(`transforming...`);
          }
        } else {
          if (id.includes(`?`)) return;
          logTransform(id);
        }
        hasTransformed = true;
      },
      log() {
        if (tty) {
          clearLine$1();
        }
        environment.logger.info(
          `${colors$1.green(`\u2713`)} ${transformedCount} modules transformed.`
        );
      }
    };
  }) : void 0;
  const chunksReporter = perEnvironmentState((environment) => {
    let hasRenderedChunk = false;
    let hasCompressChunk = false;
    let chunkCount = 0;
    let compressedCount = 0;
    async function getCompressedSize(code) {
      if (environment.config.consumer !== "client" || !environment.config.build.reportCompressedSize) {
        return null;
      }
      if (shouldLogInfo && !hasCompressChunk) {
        if (!tty) {
          config.logger.info("computing gzip size...");
        } else {
          writeLine("computing gzip size (0)...");
        }
        hasCompressChunk = true;
      }
      const compressed = await compress(
        typeof code === "string" ? code : Buffer.from(code)
      );
      compressedCount++;
      if (shouldLogInfo && tty) {
        writeLine(`computing gzip size (${compressedCount})...`);
      }
      return compressed.length;
    }
    return {
      reset() {
        chunkCount = 0;
        compressedCount = 0;
      },
      register() {
        chunkCount++;
        if (shouldLogInfo) {
          if (!tty) {
            if (!hasRenderedChunk) {
              environment.logger.info("rendering chunks...");
            }
          } else {
            writeLine(`rendering chunks (${chunkCount})...`);
          }
          hasRenderedChunk = true;
        }
      },
      async log(output, outDir) {
        const chunkLimit = environment.config.build.chunkSizeWarningLimit;
        let hasLargeChunks = false;
        if (shouldLogInfo) {
          const entries = (await Promise.all(
            Object.values(output).map(
              async (chunk) => {
                if (chunk.type === "chunk") {
                  return {
                    name: chunk.fileName,
                    group: "JS",
                    size: Buffer.byteLength(chunk.code),
                    compressedSize: await getCompressedSize(chunk.code),
                    mapSize: chunk.map ? Buffer.byteLength(chunk.map.toString()) : null
                  };
                } else {
                  if (chunk.fileName.endsWith(".map")) return null;
                  const isCSS = chunk.fileName.endsWith(".css");
                  const isCompressible = isCSS || COMPRESSIBLE_ASSETS_RE.test(chunk.fileName);
                  return {
                    name: chunk.fileName,
                    group: isCSS ? "CSS" : "Assets",
                    size: Buffer.byteLength(chunk.source),
                    mapSize: null,
                    // Rollup doesn't support CSS maps?
                    compressedSize: isCompressible ? await getCompressedSize(chunk.source) : null
                  };
                }
              }
            )
          )).filter(isDefined);
          if (tty) clearLine$1();
          let longest = 0;
          let biggestSize = 0;
          let biggestMap = 0;
          let biggestCompressSize = 0;
          for (const entry of entries) {
            if (entry.name.length > longest) longest = entry.name.length;
            if (entry.size > biggestSize) biggestSize = entry.size;
            if (entry.mapSize && entry.mapSize > biggestMap) {
              biggestMap = entry.mapSize;
            }
            if (entry.compressedSize && entry.compressedSize > biggestCompressSize) {
              biggestCompressSize = entry.compressedSize;
            }
          }
          const sizePad = displaySize(biggestSize).length;
          const mapPad = displaySize(biggestMap).length;
          const compressPad = displaySize(biggestCompressSize).length;
          const relativeOutDir = normalizePath$3(
            path$b.relative(
              config.root,
              path$b.resolve(
                config.root,
                outDir ?? environment.config.build.outDir
              )
            )
          );
          const assetsDir = path$b.join(environment.config.build.assetsDir, "/");
          for (const group of groups) {
            const filtered = entries.filter((e) => e.group === group.name);
            if (!filtered.length) continue;
            for (const entry of filtered.sort((a, z) => a.size - z.size)) {
              const isLarge = group.name === "JS" && entry.size / 1e3 > chunkLimit;
              if (isLarge) hasLargeChunks = true;
              const sizeColor = isLarge ? colors$1.yellow : colors$1.dim;
              let log = colors$1.dim(withTrailingSlash(relativeOutDir));
              log += !config.build.lib && entry.name.startsWith(withTrailingSlash(assetsDir)) ? colors$1.dim(assetsDir) + group.color(
                entry.name.slice(assetsDir.length).padEnd(longest + 2 - assetsDir.length)
              ) : group.color(entry.name.padEnd(longest + 2));
              log += colors$1.bold(
                sizeColor(displaySize(entry.size).padStart(sizePad))
              );
              if (entry.compressedSize) {
                log += colors$1.dim(
                  ` \u2502 gzip: ${displaySize(entry.compressedSize).padStart(
                    compressPad
                  )}`
                );
              }
              if (entry.mapSize) {
                log += colors$1.dim(
                  ` \u2502 map: ${displaySize(entry.mapSize).padStart(mapPad)}`
                );
              }
              config.logger.info(log);
            }
          }
        } else {
          hasLargeChunks = Object.values(output).some((chunk) => {
            return chunk.type === "chunk" && chunk.code.length / 1e3 > chunkLimit;
          });
        }
        if (hasLargeChunks && environment.config.build.minify && !config.build.lib && environment.config.consumer === "client") {
          environment.logger.warn(
            colors$1.yellow(
              `
(!) Some chunks are larger than ${chunkLimit} kB after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`
            )
          );
        }
      }
    };
  });
  return {
    name: "vite:reporter",
    sharedDuringBuild: true,
    perEnvironmentStartEndDuringDev: true,
    ...modulesReporter ? {
      transform(_, id) {
        modulesReporter(this).register(id);
      },
      buildStart() {
        modulesReporter(this).reset();
      },
      buildEnd() {
        modulesReporter(this).log();
      }
    } : {},
    renderStart() {
      chunksReporter(this).reset();
    },
    renderChunk(_, chunk, options) {
      if (!options.inlineDynamicImports) {
        for (const id of chunk.moduleIds) {
          const module = this.getModuleInfo(id);
          if (!module) continue;
          if (module.importers.length && module.dynamicImporters.length) {
            const detectedIneffectiveDynamicImport = module.dynamicImporters.some(
              (id2) => !isInNodeModules$1(id2) && chunk.moduleIds.includes(id2)
            );
            if (detectedIneffectiveDynamicImport) {
              this.warn(
                `
(!) ${module.id} is dynamically imported by ${module.dynamicImporters.join(
                  ", "
                )} but also statically imported by ${module.importers.join(
                  ", "
                )}, dynamic import will not move module into another chunk.
`
              );
            }
          }
        }
      }
      chunksReporter(this).register();
    },
    generateBundle() {
      if (shouldLogInfo && tty) clearLine$1();
    },
    async writeBundle({ dir }, output) {
      await chunksReporter(this).log(output, dir);
    }
  };
}
function writeLine(output) {
  clearLine$1();
  if (output.length < process.stdout.columns) {
    process.stdout.write(output);
  } else {
    process.stdout.write(output.substring(0, process.stdout.columns - 1));
  }
}
function clearLine$1() {
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
}
function throttle(fn) {
  let timerHandle = null;
  return (...args) => {
    if (timerHandle) return;
    fn(...args);
    timerHandle = setTimeout(() => {
      timerHandle = null;
    }, 100);
  };
}

const POSIX_SEP_RE = new RegExp('\\' + path$b.posix.sep, 'g');
const NATIVE_SEP_RE = new RegExp('\\' + path$b.sep, 'g');
/** @type {Map<string,RegExp>}*/
const PATTERN_REGEX_CACHE = new Map();
const GLOB_ALL_PATTERN = `**/*`;
const TS_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];
const JS_EXTENSIONS = ['.js', '.jsx', '.mjs', '.cjs'];
const TSJS_EXTENSIONS = TS_EXTENSIONS.concat(JS_EXTENSIONS);
const TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext) => ext.substring(1)).join('|')})`;
const TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext) => ext.substring(1)).join(
	'|'
)})`;
const IS_POSIX = path$b.posix.sep === path$b.sep;

/**
 * @template T
 * @returns {{resolve:(result:T)=>void, reject:(error:any)=>void, promise: Promise<T>}}
 */
function makePromise() {
	let resolve, reject;
	const promise = new Promise((res, rej) => {
		resolve = res;
		reject = rej;
	});
	return { promise, resolve, reject };
}

/**
 * @param {string} filename
 * @param {import('./cache.js').TSConfckCache} [cache]
 * @returns {Promise<string|void>}
 */
async function resolveTSConfigJson(filename, cache) {
	if (path$b.extname(filename) !== '.json') {
		return; // ignore files that are not json
	}
	const tsconfig = path$b.resolve(filename);
	if (cache && (cache.hasParseResult(tsconfig) || cache.hasParseResult(filename))) {
		return tsconfig;
	}
	return promises$1.stat(tsconfig).then((stat) => {
		if (stat.isFile() || stat.isFIFO()) {
			return tsconfig;
		} else {
			throw new Error(`${filename} exists but is not a regular file.`);
		}
	});
}

/**
 *
 * @param {string} dir an absolute directory path
 * @returns {boolean}  if dir path includes a node_modules segment
 */
const isInNodeModules = IS_POSIX
	? (dir) => dir.includes('/node_modules/')
	: (dir) => dir.match(/[/\\]node_modules[/\\]/);

/**
 * convert posix separator to native separator
 *
 * eg.
 * windows: C:/foo/bar -> c:\foo\bar
 * linux: /foo/bar -> /foo/bar
 *
 * @param {string} filename with posix separators
 * @returns {string} filename with native separators
 */
const posix2native = IS_POSIX
	? (filename) => filename
	: (filename) => filename.replace(POSIX_SEP_RE, path$b.sep);

/**
 * convert native separator to posix separator
 *
 * eg.
 * windows: C:\foo\bar -> c:/foo/bar
 * linux: /foo/bar -> /foo/bar
 *
 * @param {string} filename - filename with native separators
 * @returns {string} filename with posix separators
 */
const native2posix = IS_POSIX
	? (filename) => filename
	: (filename) => filename.replace(NATIVE_SEP_RE, path$b.posix.sep);

/**
 * converts params to native separator, resolves path and converts native back to posix
 *
 * needed on windows to handle posix paths in tsconfig
 *
 * @param dir {string|null} directory to resolve from
 * @param filename {string} filename or pattern to resolve
 * @returns string
 */
const resolve2posix = IS_POSIX
	? (dir, filename) => (dir ? path$b.resolve(dir, filename) : path$b.resolve(filename))
	: (dir, filename) =>
			native2posix(
				dir
					? path$b.resolve(posix2native(dir), posix2native(filename))
					: path$b.resolve(posix2native(filename))
			);

/**
 *
 * @param {import('./public.d.ts').TSConfckParseResult} result
 * @param {import('./public.d.ts').TSConfckParseOptions} [options]
 * @returns {string[]}
 */
function resolveReferencedTSConfigFiles(result, options) {
	const dir = path$b.dirname(result.tsconfigFile);
	return result.tsconfig.references.map((ref) => {
		const refPath = ref.path.endsWith('.json')
			? ref.path
			: path$b.join(ref.path, options?.configName ?? 'tsconfig.json');
		return resolve2posix(dir, refPath);
	});
}

/**
 * @param {string} filename
 * @param {import('./public.d.ts').TSConfckParseResult} result
 * @returns {import('./public.d.ts').TSConfckParseResult}
 */
function resolveSolutionTSConfig(filename, result) {
	const allowJs = result.tsconfig.compilerOptions?.allowJs;
	const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
	if (
		result.referenced &&
		extensions.some((ext) => filename.endsWith(ext)) &&
		!isIncluded(filename, result)
	) {
		const solutionTSConfig = result.referenced.find((referenced) =>
			isIncluded(filename, referenced)
		);
		if (solutionTSConfig) {
			return solutionTSConfig;
		}
	}
	return result;
}

/**
 *
 * @param {string} filename
 * @param {import('./public.d.ts').TSConfckParseResult} result
 * @returns {boolean}
 */
function isIncluded(filename, result) {
	const dir = native2posix(path$b.dirname(result.tsconfigFile));
	const files = (result.tsconfig.files || []).map((file) => resolve2posix(dir, file));
	const absoluteFilename = resolve2posix(null, filename);
	if (files.includes(filename)) {
		return true;
	}
	const allowJs = result.tsconfig.compilerOptions?.allowJs;
	const isIncluded = isGlobMatch(
		absoluteFilename,
		dir,
		result.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN]),
		allowJs
	);
	if (isIncluded) {
		const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || [], allowJs);
		return !isExcluded;
	}
	return false;
}

/**
 * test filenames agains glob patterns in tsconfig
 *
 * @param filename {string} posix style abolute path to filename to test
 * @param dir {string} posix style absolute path to directory of tsconfig containing patterns
 * @param patterns {string[]} glob patterns to match against
 * @param allowJs {boolean} allowJs setting in tsconfig to include js extensions in checks
 * @returns {boolean} true when at least one pattern matches filename
 */
function isGlobMatch(filename, dir, patterns, allowJs) {
	const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
	return patterns.some((pattern) => {
		// filename must end with part of pattern that comes after last wildcard
		let lastWildcardIndex = pattern.length;
		let hasWildcard = false;
		let hasExtension = false;
		let hasSlash = false;
		let lastSlashIndex = -1;
		for (let i = pattern.length - 1; i > -1; i--) {
			const c = pattern[i];
			if (!hasWildcard) {
				if (c === '*' || c === '?') {
					lastWildcardIndex = i;
					hasWildcard = true;
				}
			}
			if (!hasSlash) {
				if (c === '.') {
					hasExtension = true;
				} else if (c === '/') {
					lastSlashIndex = i;
					hasSlash = true;
				}
			}
			if (hasWildcard && hasSlash) {
				break;
			}
		}
		if (!hasExtension && (!hasWildcard || lastWildcardIndex < lastSlashIndex)) {
			// add implicit glob
			pattern += `${pattern.endsWith('/') ? '' : '/'}${GLOB_ALL_PATTERN}`;
			lastWildcardIndex = pattern.length - 1;
			hasWildcard = true;
		}

		// if pattern does not end with wildcard, filename must end with pattern after last wildcard
		if (
			lastWildcardIndex < pattern.length - 1 &&
			!filename.endsWith(pattern.slice(lastWildcardIndex + 1))
		) {
			return false;
		}

		// if pattern ends with *, filename must end with a default extension
		if (pattern.endsWith('*') && !extensions.some((ext) => filename.endsWith(ext))) {
			return false;
		}

		// for **/* , filename must start with the dir
		if (pattern === GLOB_ALL_PATTERN) {
			return filename.startsWith(`${dir}/`);
		}

		const resolvedPattern = resolve2posix(dir, pattern);

		// filename must start with part of pattern that comes before first wildcard
		let firstWildcardIndex = -1;
		for (let i = 0; i < resolvedPattern.length; i++) {
			if (resolvedPattern[i] === '*' || resolvedPattern[i] === '?') {
				firstWildcardIndex = i;
				hasWildcard = true;
				break;
			}
		}
		if (
			firstWildcardIndex > 1 &&
			!filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))
		) {
			return false;
		}

		if (!hasWildcard) {
			//  no wildcard in pattern, filename must be equal to resolved pattern
			return filename === resolvedPattern;
		} else if (
			firstWildcardIndex + GLOB_ALL_PATTERN.length ===
				resolvedPattern.length - (pattern.length - 1 - lastWildcardIndex) &&
			resolvedPattern.slice(firstWildcardIndex, firstWildcardIndex + GLOB_ALL_PATTERN.length) ===
				GLOB_ALL_PATTERN
		) {
			// singular glob-all pattern and we already validated prefix and suffix matches
			return true;
		}
		// complex pattern, use regex to check it
		if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
			return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
		}
		const regex = pattern2regex(resolvedPattern, allowJs);
		PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
		return regex.test(filename);
	});
}

/**
 * @param {string} resolvedPattern
 * @param {boolean} allowJs
 * @returns {RegExp}
 */
function pattern2regex(resolvedPattern, allowJs) {
	let regexStr = '^';
	for (let i = 0; i < resolvedPattern.length; i++) {
		const char = resolvedPattern[i];
		if (char === '?') {
			regexStr += '[^\\/]';
			continue;
		}
		if (char === '*') {
			if (resolvedPattern[i + 1] === '*' && resolvedPattern[i + 2] === '/') {
				i += 2;
				regexStr += '(?:[^\\/]*\\/)*'; // zero or more path segments
				continue;
			}
			regexStr += '[^\\/]*';
			continue;
		}
		if ('/.+^${}()|[]\\'.includes(char)) {
			regexStr += `\\`;
		}
		regexStr += char;
	}

	// add known file endings if pattern ends on *
	if (resolvedPattern.endsWith('*')) {
		regexStr += allowJs ? TSJS_EXTENSIONS_RE_GROUP : TS_EXTENSIONS_RE_GROUP;
	}
	regexStr += '$';

	return new RegExp(regexStr);
}

/**
 * replace tokens like ${configDir}
 * @param {import('./public.d.ts').TSConfckParseResult} result
 */
function replaceTokens(result) {
	if (result.tsconfig) {
		result.tsconfig = JSON.parse(
			JSON.stringify(result.tsconfig)
				// replace ${configDir}
				.replaceAll(/"\${configDir}/g, `"${native2posix(path$b.dirname(result.tsconfigFile))}`)
		);
	}
}

/**
 * find the closest tsconfig.json file
 *
 * @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)
 * @param {import('./public.d.ts').TSConfckFindOptions} [options] - options
 * @returns {Promise<string|null>} absolute path to closest tsconfig.json or null if not found
 */
async function find(filename, options) {
	let dir = path$b.dirname(path$b.resolve(filename));
	if (isInNodeModules(dir)) {
		return null;
	}
	const cache = options?.cache;
	const configName = options?.configName ?? 'tsconfig.json';
	if (cache?.hasConfigPath(dir, configName)) {
		return cache.getConfigPath(dir, configName);
	}
	const { /** @type {Promise<string|null>} */ promise, resolve, reject } = makePromise();
	if (options?.root && !path$b.isAbsolute(options.root)) {
		options.root = path$b.resolve(options.root);
	}
	findUp(dir, { promise, resolve, reject }, options);
	return promise;
}

/**
 *
 * @param {string} dir
 * @param {{promise:Promise<string|null>,resolve:(result:string|null)=>void,reject:(err:any)=>void}} madePromise
 * @param {import('./public.d.ts').TSConfckFindOptions} [options] - options
 */
function findUp(dir, { resolve, reject, promise }, options) {
	const { cache, root, configName } = options ?? {};
	if (cache) {
		if (cache.hasConfigPath(dir, configName)) {
			let cached;
			try {
				cached = cache.getConfigPath(dir, configName);
			} catch (e) {
				reject(e);
				return;
			}
			if (cached?.then) {
				cached.then(resolve).catch(reject);
			} else {
				resolve(cached);
			}
		} else {
			cache.setConfigPath(dir, promise, configName);
		}
	}
	const tsconfig = path$b.join(dir, options?.configName ?? 'tsconfig.json');
	fs__default.stat(tsconfig, (err, stats) => {
		if (stats && (stats.isFile() || stats.isFIFO())) {
			resolve(tsconfig);
		} else if (err?.code !== 'ENOENT') {
			reject(err);
		} else {
			let parent;
			if (root === dir || (parent = path$b.dirname(dir)) === dir) {
				resolve(null);
			} else {
				findUp(parent, { promise, resolve, reject }, options);
			}
		}
	});
}

/*
 this file contains code from strip-bom and strip-json-comments by Sindre Sorhus
 https://github.com/sindresorhus/strip-json-comments/blob/v4.0.0/index.js
 https://github.com/sindresorhus/strip-bom/blob/v5.0.0/index.js
 licensed under MIT, see ../LICENSE
*/

/**
 * convert content of tsconfig.json to regular json
 *
 * @param {string} tsconfigJson - content of tsconfig.json
 * @returns {string} content as regular json, comments and dangling commas have been replaced with whitespace
 */
function toJson(tsconfigJson) {
	const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
	if (stripped.trim() === '') {
		// only whitespace left after stripping, return empty object so that JSON.parse still works
		return '{}';
	} else {
		return stripped;
	}
}

/**
 * replace dangling commas from pseudo-json string with single space
 * implementation heavily inspired by strip-json-comments
 *
 * @param {string} pseudoJson
 * @returns {string}
 */
function stripDanglingComma(pseudoJson) {
	let insideString = false;
	let offset = 0;
	let result = '';
	let danglingCommaPos = null;
	for (let i = 0; i < pseudoJson.length; i++) {
		const currentCharacter = pseudoJson[i];
		if (currentCharacter === '"') {
			const escaped = isEscaped(pseudoJson, i);
			if (!escaped) {
				insideString = !insideString;
			}
		}
		if (insideString) {
			danglingCommaPos = null;
			continue;
		}
		if (currentCharacter === ',') {
			danglingCommaPos = i;
			continue;
		}
		if (danglingCommaPos) {
			if (currentCharacter === '}' || currentCharacter === ']') {
				result += pseudoJson.slice(offset, danglingCommaPos) + ' ';
				offset = danglingCommaPos + 1;
				danglingCommaPos = null;
			} else if (!currentCharacter.match(/\s/)) {
				danglingCommaPos = null;
			}
		}
	}
	return result + pseudoJson.substring(offset);
}

// start strip-json-comments
/**
 *
 * @param {string} jsonString
 * @param {number} quotePosition
 * @returns {boolean}
 */
function isEscaped(jsonString, quotePosition) {
	let index = quotePosition - 1;
	let backslashCount = 0;

	while (jsonString[index] === '\\') {
		index -= 1;
		backslashCount += 1;
	}

	return Boolean(backslashCount % 2);
}

/**
 *
 * @param {string} string
 * @param {number?} start
 * @param {number?} end
 */
function strip(string, start, end) {
	return string.slice(start, end).replace(/\S/g, ' ');
}

const singleComment = Symbol('singleComment');
const multiComment = Symbol('multiComment');

/**
 * @param {string} jsonString
 * @returns {string}
 */
function stripJsonComments(jsonString) {
	let isInsideString = false;
	/** @type {false | symbol} */
	let isInsideComment = false;
	let offset = 0;
	let result = '';

	for (let index = 0; index < jsonString.length; index++) {
		const currentCharacter = jsonString[index];
		const nextCharacter = jsonString[index + 1];

		if (!isInsideComment && currentCharacter === '"') {
			const escaped = isEscaped(jsonString, index);
			if (!escaped) {
				isInsideString = !isInsideString;
			}
		}

		if (isInsideString) {
			continue;
		}

		if (!isInsideComment && currentCharacter + nextCharacter === '//') {
			result += jsonString.slice(offset, index);
			offset = index;
			isInsideComment = singleComment;
			index++;
		} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\r\n') {
			index++;
			isInsideComment = false;
			result += strip(jsonString, offset, index);
			offset = index;
		} else if (isInsideComment === singleComment && currentCharacter === '\n') {
			isInsideComment = false;
			result += strip(jsonString, offset, index);
			offset = index;
		} else if (!isInsideComment && currentCharacter + nextCharacter === '/*') {
			result += jsonString.slice(offset, index);
			offset = index;
			isInsideComment = multiComment;
			index++;
		} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {
			index++;
			isInsideComment = false;
			result += strip(jsonString, offset, index + 1);
			offset = index + 1;
		}
	}

	return result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
// end strip-json-comments

// start strip-bom
/**
 * @param {string} string
 * @returns {string}
 */
function stripBom(string) {
	// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
	// conversion translates it to FEFF (UTF-16 BOM).
	if (string.charCodeAt(0) === 0xfeff) {
		return string.slice(1);
	}
	return string;
}
// end strip-bom

const not_found_result = {
	tsconfigFile: null,
	tsconfig: {}
};

/**
 * parse the closest tsconfig.json file
 *
 * @param {string} filename - path to a tsconfig .json or a source file or directory (absolute or relative to cwd)
 * @param {import('./public.d.ts').TSConfckParseOptions} [options] - options
 * @returns {Promise<import('./public.d.ts').TSConfckParseResult>}
 * @throws {TSConfckParseError}
 */
async function parse$e(filename, options) {
	/** @type {import('./cache.js').TSConfckCache} */
	const cache = options?.cache;
	if (cache?.hasParseResult(filename)) {
		return getParsedDeep(filename, cache, options);
	}
	const {
		resolve,
		reject,
		/** @type {Promise<import('./public.d.ts').TSConfckParseResult>}*/
		promise
	} = makePromise();
	cache?.setParseResult(filename, promise, true);
	try {
		let tsconfigFile =
			(await resolveTSConfigJson(filename, cache)) || (await find(filename, options));
		if (!tsconfigFile) {
			resolve(not_found_result);
			return promise;
		}
		let result;
		if (filename !== tsconfigFile && cache?.hasParseResult(tsconfigFile)) {
			result = await getParsedDeep(tsconfigFile, cache, options);
		} else {
			result = await parseFile$1(tsconfigFile, cache, filename === tsconfigFile);
			await Promise.all([parseExtends(result, cache), parseReferences(result, options)]);
		}
		replaceTokens(result);
		resolve(resolveSolutionTSConfig(filename, result));
	} catch (e) {
		reject(e);
	}
	return promise;
}

/**
 * ensure extends and references are parsed
 *
 * @param {string} filename - cached file
 * @param {import('./cache.js').TSConfckCache} cache - cache
 * @param {import('./public.d.ts').TSConfckParseOptions} options - options
 */
async function getParsedDeep(filename, cache, options) {
	const result = await cache.getParseResult(filename);
	if (
		(result.tsconfig.extends && !result.extended) ||
		(result.tsconfig.references && !result.referenced)
	) {
		const promise = Promise.all([
			parseExtends(result, cache),
			parseReferences(result, options)
		]).then(() => result);
		cache.setParseResult(filename, promise, true);
		return promise;
	}
	return result;
}

/**
 *
 * @param {string} tsconfigFile - path to tsconfig file
 * @param {import('./cache.js').TSConfckCache} [cache] - cache
 * @param {boolean} [skipCache] - skip cache
 * @returns {Promise<import('./public.d.ts').TSConfckParseResult>}
 */
async function parseFile$1(tsconfigFile, cache, skipCache) {
	if (
		!skipCache &&
		cache?.hasParseResult(tsconfigFile) &&
		!cache.getParseResult(tsconfigFile)._isRootFile_
	) {
		return cache.getParseResult(tsconfigFile);
	}
	const promise = promises$1
		.readFile(tsconfigFile, 'utf-8')
		.then(toJson)
		.then((json) => {
			const parsed = JSON.parse(json);
			applyDefaults(parsed, tsconfigFile);
			return {
				tsconfigFile,
				tsconfig: normalizeTSConfig(parsed, path$b.dirname(tsconfigFile))
			};
		})
		.catch((e) => {
			throw new TSConfckParseError(
				`parsing ${tsconfigFile} failed: ${e}`,
				'PARSE_FILE',
				tsconfigFile,
				e
			);
		});
	if (
		!skipCache &&
		(!cache?.hasParseResult(tsconfigFile) || !cache.getParseResult(tsconfigFile)._isRootFile_)
	) {
		cache?.setParseResult(tsconfigFile, promise);
	}
	return promise;
}

/**
 * normalize to match the output of ts.parseJsonConfigFileContent
 *
 * @param {any} tsconfig - typescript tsconfig output
 * @param {string} dir - directory
 */
function normalizeTSConfig(tsconfig, dir) {
	// set baseUrl to absolute path
	const baseUrl = tsconfig.compilerOptions?.baseUrl;
	if (baseUrl && !baseUrl.startsWith('${') && !path$b.isAbsolute(baseUrl)) {
		tsconfig.compilerOptions.baseUrl = resolve2posix(dir, baseUrl);
	}
	return tsconfig;
}

/**
 *
 * @param {import('./public.d.ts').TSConfckParseResult} result
 * @param {import('./public.d.ts').TSConfckParseOptions} [options]
 * @returns {Promise<void>}
 */
async function parseReferences(result, options) {
	if (!result.tsconfig.references) {
		return;
	}
	const referencedFiles = resolveReferencedTSConfigFiles(result, options);
	const referenced = await Promise.all(
		referencedFiles.map((file) => parseFile$1(file, options?.cache))
	);
	await Promise.all(referenced.map((ref) => parseExtends(ref, options?.cache)));
	referenced.forEach((ref) => {
		ref.solution = result;
		replaceTokens(ref);
	});
	result.referenced = referenced;
}

/**
 * @param {import('./public.d.ts').TSConfckParseResult} result
 * @param {import('./cache.js').TSConfckCache}[cache]
 * @returns {Promise<void>}
 */
async function parseExtends(result, cache) {
	if (!result.tsconfig.extends) {
		return;
	}
	// use result as first element in extended
	// but dereference tsconfig so that mergeExtended can modify the original without affecting extended[0]
	/** @type {import('./public.d.ts').TSConfckParseResult[]} */
	const extended = [
		{ tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }
	];

	// flatten extends graph into extended
	let pos = 0;
	/** @type {string[]} */
	const extendsPath = [];
	let currentBranchDepth = 0;
	while (pos < extended.length) {
		const extending = extended[pos];
		extendsPath.push(extending.tsconfigFile);
		if (extending.tsconfig.extends) {
			// keep following this branch
			currentBranchDepth += 1;
			/** @type {string[]} */
			let resolvedExtends;
			if (!Array.isArray(extending.tsconfig.extends)) {
				resolvedExtends = [resolveExtends(extending.tsconfig.extends, extending.tsconfigFile)];
			} else {
				// reverse because typescript 5.0 treats ['a','b','c'] as c extends b extends a
				resolvedExtends = extending.tsconfig.extends
					.reverse()
					.map((ex) => resolveExtends(ex, extending.tsconfigFile));
			}

			const circularExtends = resolvedExtends.find((tsconfigFile) =>
				extendsPath.includes(tsconfigFile)
			);
			if (circularExtends) {
				const circle = extendsPath.concat([circularExtends]).join(' -> ');
				throw new TSConfckParseError(
					`Circular dependency in "extends": ${circle}`,
					'EXTENDS_CIRCULAR',
					result.tsconfigFile
				);
			}
			// add new extends to the list directly after current
			extended.splice(
				pos + 1,
				0,
				...(await Promise.all(resolvedExtends.map((file) => parseFile$1(file, cache))))
			);
		} else {
			// reached a leaf, backtrack to the last branching point and continue
			extendsPath.splice(-currentBranchDepth);
			currentBranchDepth = 0;
		}
		pos = pos + 1;
	}
	result.extended = extended;
	// skip first as it is the original config
	for (const ext of result.extended.slice(1)) {
		extendTSConfig(result, ext);
	}
}

/**
 *
 * @param {string} extended
 * @param {string} from
 * @returns {string}
 */
function resolveExtends(extended, from) {
	if (extended === '..') {
		// see #149
		extended = '../tsconfig.json';
	}
	const req = createRequire$2(from);
	let error;
	try {
		return req.resolve(extended);
	} catch (e) {
		error = e;
	}
	if (extended[0] !== '.' && !path$b.isAbsolute(extended)) {
		try {
			return req.resolve(`${extended}/tsconfig.json`);
		} catch (e) {
			error = e;
		}
	}

	throw new TSConfckParseError(
		`failed to resolve "extends":"${extended}" in ${from}`,
		'EXTENDS_RESOLVE',
		from,
		error
	);
}

// references, extends and custom keys are not carried over
const EXTENDABLE_KEYS = [
	'compilerOptions',
	'files',
	'include',
	'exclude',
	'watchOptions',
	'compileOnSave',
	'typeAcquisition',
	'buildOptions'
];

/**
 *
 * @param {import('./public.d.ts').TSConfckParseResult} extending
 * @param {import('./public.d.ts').TSConfckParseResult} extended
 * @returns void
 */
function extendTSConfig(extending, extended) {
	const extendingConfig = extending.tsconfig;
	const extendedConfig = extended.tsconfig;
	const relativePath = native2posix(
		path$b.relative(path$b.dirname(extending.tsconfigFile), path$b.dirname(extended.tsconfigFile))
	);
	for (const key of Object.keys(extendedConfig).filter((key) => EXTENDABLE_KEYS.includes(key))) {
		if (key === 'compilerOptions') {
			if (!extendingConfig.compilerOptions) {
				extendingConfig.compilerOptions = {};
			}
			for (const option of Object.keys(extendedConfig.compilerOptions)) {
				if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
					continue; // already set
				}
				extendingConfig.compilerOptions[option] = rebaseRelative(
					option,
					extendedConfig.compilerOptions[option],
					relativePath
				);
			}
		} else if (extendingConfig[key] === undefined) {
			if (key === 'watchOptions') {
				extendingConfig.watchOptions = {};
				for (const option of Object.keys(extendedConfig.watchOptions)) {
					extendingConfig.watchOptions[option] = rebaseRelative(
						option,
						extendedConfig.watchOptions[option],
						relativePath
					);
				}
			} else {
				extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
			}
		}
	}
}

const REBASE_KEYS = [
	// root
	'files',
	'include',
	'exclude',
	// compilerOptions
	'baseUrl',
	'rootDir',
	'rootDirs',
	'typeRoots',
	'outDir',
	'outFile',
	'declarationDir',
	// watchOptions
	'excludeDirectories',
	'excludeFiles'
];

/** @typedef {string | string[]} PathValue */

/**
 *
 * @param {string} key
 * @param {PathValue} value
 * @param {string} prependPath
 * @returns {PathValue}
 */
function rebaseRelative(key, value, prependPath) {
	if (!REBASE_KEYS.includes(key)) {
		return value;
	}
	if (Array.isArray(value)) {
		return value.map((x) => rebasePath(x, prependPath));
	} else {
		return rebasePath(value, prependPath);
	}
}

/**
 *
 * @param {string} value
 * @param {string} prependPath
 * @returns {string}
 */
function rebasePath(value, prependPath) {
	if (path$b.isAbsolute(value) || value.startsWith('${configDir}')) {
		return value;
	} else {
		// relative paths use posix syntax in tsconfig
		return path$b.posix.normalize(path$b.posix.join(prependPath, value));
	}
}

class TSConfckParseError extends Error {
	/**
	 * error code
	 * @type {string}
	 */
	code;
	/**
	 * error cause
	 * @type { Error | undefined}
	 */
	cause;

	/**
	 * absolute path of tsconfig file where the error happened
	 * @type {string}
	 */
	tsconfigFile;
	/**
	 *
	 * @param {string} message - error message
	 * @param {string} code - error code
	 * @param {string} tsconfigFile - path to tsconfig file
	 * @param {Error?} cause - cause of this error
	 */
	constructor(message, code, tsconfigFile, cause) {
		super(message);
		// Set the prototype explicitly.
		Object.setPrototypeOf(this, TSConfckParseError.prototype);
		this.name = TSConfckParseError.name;
		this.code = code;
		this.cause = cause;
		this.tsconfigFile = tsconfigFile;
	}
}

/**
 *
 * @param {any} tsconfig
 * @param {string} tsconfigFile
 */
function applyDefaults(tsconfig, tsconfigFile) {
	if (isJSConfig(tsconfigFile)) {
		tsconfig.compilerOptions = {
			...DEFAULT_JSCONFIG_COMPILER_OPTIONS,
			...tsconfig.compilerOptions
		};
	}
}

const DEFAULT_JSCONFIG_COMPILER_OPTIONS = {
	allowJs: true,
	maxNodeModuleJsDepth: 2,
	allowSyntheticDefaultImports: true,
	skipLibCheck: true,
	noEmit: true
};

/**
 * @param {string} configFileName
 */
function isJSConfig(configFileName) {
	return path$b.basename(configFileName) === 'jsconfig.json';
}

/** @template T */
class TSConfckCache {
	/**
	 * clear cache, use this if you have a long running process and tsconfig files have been added,changed or deleted
	 */
	clear() {
		this.#configPaths.clear();
		this.#parsed.clear();
	}

	/**
	 * has cached closest config for files in dir
	 * @param {string} dir
	 * @param {string} [configName=tsconfig.json]
	 * @returns {boolean}
	 */
	hasConfigPath(dir, configName = 'tsconfig.json') {
		return this.#configPaths.has(`${dir}/${configName}`);
	}

	/**
	 * get cached closest tsconfig for files in dir
	 * @param {string} dir
	 * @param {string} [configName=tsconfig.json]
	 * @returns {Promise<string|null>|string|null}
	 * @throws {unknown} if cached value is an error
	 */
	getConfigPath(dir, configName = 'tsconfig.json') {
		const key = `${dir}/${configName}`;
		const value = this.#configPaths.get(key);
		if (value == null || value.length || value.then) {
			return value;
		} else {
			throw value;
		}
	}

	/**
	 * has parsed tsconfig for file
	 * @param {string} file
	 * @returns {boolean}
	 */
	hasParseResult(file) {
		return this.#parsed.has(file);
	}

	/**
	 * get parsed tsconfig for file
	 * @param {string} file
	 * @returns {Promise<T>|T}
	 * @throws {unknown} if cached value is an error
	 */
	getParseResult(file) {
		const value = this.#parsed.get(file);
		if (value.then || value.tsconfig) {
			return value;
		} else {
			throw value; // cached error, rethrow
		}
	}

	/**
	 * @internal
	 * @private
	 * @param file
	 * @param {boolean} isRootFile a flag to check if current file which involking the parse() api, used to distinguish the normal cache which only parsed by parseFile()
	 * @param {Promise<T>} result
	 */
	setParseResult(file, result, isRootFile = false) {
		// _isRootFile_ is a temporary property for Promise result, used to prevent deadlock with cache
		Object.defineProperty(result, '_isRootFile_', {
			value: isRootFile,
			writable: false,
			enumerable: false,
			configurable: false
		});
		this.#parsed.set(file, result);
		result
			.then((parsed) => {
				if (this.#parsed.get(file) === result) {
					this.#parsed.set(file, parsed);
				}
			})
			.catch((e) => {
				if (this.#parsed.get(file) === result) {
					this.#parsed.set(file, e);
				}
			});
	}

	/**
	 * @internal
	 * @private
	 * @param {string} dir
	 * @param {Promise<string|null>} configPath
	 * @param {string} [configName=tsconfig.json]
	 */
	setConfigPath(dir, configPath, configName = 'tsconfig.json') {
		const key = `${dir}/${configName}`;
		this.#configPaths.set(key, configPath);
		configPath
			.then((path) => {
				if (this.#configPaths.get(key) === configPath) {
					this.#configPaths.set(key, path);
				}
			})
			.catch((e) => {
				if (this.#configPaths.get(key) === configPath) {
					this.#configPaths.set(key, e);
				}
			});
	}

	/**
	 * map directories to their closest tsconfig.json
	 * @internal
	 * @private
	 * @type{Map<string,(Promise<string|null>|string|null)>}
	 */
	#configPaths = new Map();

	/**
	 * map files to their parsed tsconfig result
	 * @internal
	 * @private
	 * @type {Map<string,(Promise<T>|T)> }
	 */
	#parsed = new Map();
}

const debug$i = createDebugger("vite:esbuild");
const IIFE_BEGIN_RE = /(?:const|var)\s+\S+\s*=\s*function\([^()]*\)\s*\{\s*"use strict";/;
const validExtensionRE = /\.\w+$/;
const jsxExtensionsRE = /\.(?:j|t)sx\b/;
const defaultEsbuildSupported = {
  "dynamic-import": true,
  "import-meta": true
};
async function transformWithEsbuild(code, filename, options, inMap, config, watcher) {
  let loader = options?.loader;
  if (!loader) {
    const ext = path$b.extname(validExtensionRE.test(filename) ? filename : cleanUrl(filename)).slice(1);
    if (ext === "cjs" || ext === "mjs") {
      loader = "js";
    } else if (ext === "cts" || ext === "mts") {
      loader = "ts";
    } else {
      loader = ext;
    }
  }
  let tsconfigRaw = options?.tsconfigRaw;
  if (typeof tsconfigRaw !== "string") {
    const meaningfulFields = [
      "alwaysStrict",
      "experimentalDecorators",
      "importsNotUsedAsValues",
      "jsx",
      "jsxFactory",
      "jsxFragmentFactory",
      "jsxImportSource",
      "preserveValueImports",
      "target",
      "useDefineForClassFields",
      "verbatimModuleSyntax"
    ];
    const compilerOptionsForFile = {};
    if (loader === "ts" || loader === "tsx") {
      try {
        const { tsconfig: loadedTsconfig, tsconfigFile } = await loadTsconfigJsonForFile(filename, config);
        if (watcher && tsconfigFile && config) {
          ensureWatchedFile(watcher, tsconfigFile, config.root);
        }
        const loadedCompilerOptions = loadedTsconfig.compilerOptions ?? {};
        for (const field of meaningfulFields) {
          if (field in loadedCompilerOptions) {
            compilerOptionsForFile[field] = loadedCompilerOptions[field];
          }
        }
      } catch (e) {
        if (e instanceof TSConfckParseError) {
          if (watcher && e.tsconfigFile && config) {
            ensureWatchedFile(watcher, e.tsconfigFile, config.root);
          }
        }
        throw e;
      }
    }
    const compilerOptions = {
      ...compilerOptionsForFile,
      ...tsconfigRaw?.compilerOptions
    };
    if (compilerOptions.useDefineForClassFields === void 0 && compilerOptions.target === void 0) {
      compilerOptions.useDefineForClassFields = false;
    }
    if (options) {
      if (options.jsx) compilerOptions.jsx = void 0;
      if (options.jsxFactory) compilerOptions.jsxFactory = void 0;
      if (options.jsxFragment) compilerOptions.jsxFragmentFactory = void 0;
      if (options.jsxImportSource) compilerOptions.jsxImportSource = void 0;
    }
    tsconfigRaw = {
      ...tsconfigRaw,
      compilerOptions
    };
  }
  const resolvedOptions = {
    sourcemap: true,
    // ensure source file name contains full query
    sourcefile: filename,
    ...options,
    loader,
    tsconfigRaw
  };
  delete resolvedOptions.include;
  delete resolvedOptions.exclude;
  delete resolvedOptions.jsxInject;
  try {
    const result = await transform$1(code, resolvedOptions);
    let map;
    if (inMap && resolvedOptions.sourcemap) {
      const nextMap = JSON.parse(result.map);
      nextMap.sourcesContent = [];
      map = combineSourcemaps(filename, [
        nextMap,
        inMap
      ]);
    } else {
      map = resolvedOptions.sourcemap && resolvedOptions.sourcemap !== "inline" ? JSON.parse(result.map) : { mappings: "" };
    }
    return {
      ...result,
      map
    };
  } catch (e) {
    debug$i?.(`esbuild error with options used: `, resolvedOptions);
    if (e.errors) {
      e.frame = "";
      e.errors.forEach((m) => {
        if (m.text === "Experimental decorators are not currently enabled" || m.text === "Parameter decorators only work when experimental decorators are enabled") {
          m.text += '. Vite 5 now uses esbuild 0.18 and you need to enable them by adding "experimentalDecorators": true in your "tsconfig.json" file.';
        }
        e.frame += `
` + prettifyMessage(m, code);
      });
      e.loc = e.errors[0].location;
    }
    throw e;
  }
}
function esbuildPlugin(config) {
  const options = config.esbuild;
  const { jsxInject, include, exclude, ...esbuildTransformOptions } = options;
  const filter = createFilter$1(include || /\.(m?ts|[jt]sx)$/, exclude || /\.js$/);
  const transformOptions = {
    target: "esnext",
    charset: "utf8",
    ...esbuildTransformOptions,
    minify: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    treeShaking: false,
    // keepNames is not needed when minify is disabled.
    // Also transforming multiple times with keepNames enabled breaks
    // tree-shaking. (#9164)
    keepNames: false,
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildTransformOptions.supported
    }
  };
  let server;
  return {
    name: "vite:esbuild",
    configureServer(_server) {
      server = _server;
    },
    async transform(code, id) {
      if (filter(id) || filter(cleanUrl(id))) {
        const result = await transformWithEsbuild(
          code,
          id,
          transformOptions,
          void 0,
          config,
          server?.watcher
        );
        if (result.warnings.length) {
          result.warnings.forEach((m) => {
            this.warn(prettifyMessage(m, code));
          });
        }
        if (jsxInject && jsxExtensionsRE.test(id)) {
          result.code = jsxInject + ";" + result.code;
        }
        return {
          code: result.code,
          map: result.map
        };
      }
    }
  };
}
const rollupToEsbuildFormatMap = {
  es: "esm",
  cjs: "cjs",
  // passing `var Lib = (() => {})()` to esbuild with format = "iife"
  // will turn it to `(() => { var Lib = (() => {})() })()`,
  // so we remove the format config to tell esbuild not doing this
  //
  // although esbuild doesn't change format, there is still possibility
  // that `{ treeShaking: true }` removes a top-level no-side-effect variable
  // like: `var Lib = 1`, which becomes `` after esbuild transforming,
  // but thankfully rollup does not do this optimization now
  iife: void 0
};
const buildEsbuildPlugin = () => {
  return {
    name: "vite:esbuild-transpile",
    applyToEnvironment(environment) {
      return environment.config.esbuild !== false;
    },
    async renderChunk(code, chunk, opts) {
      if (opts.__vite_skip_esbuild__) {
        return null;
      }
      const config = this.environment.config;
      const options = resolveEsbuildTranspileOptions(config, opts.format);
      if (!options) {
        return null;
      }
      const res = await transformWithEsbuild(
        code,
        chunk.fileName,
        options,
        void 0,
        config
      );
      if (config.build.lib) {
        const esbuildCode = res.code;
        const contentIndex = opts.format === "iife" ? Math.max(esbuildCode.search(IIFE_BEGIN_RE), 0) : opts.format === "umd" ? esbuildCode.indexOf(`(function(`) : 0;
        if (contentIndex > 0) {
          const esbuildHelpers = esbuildCode.slice(0, contentIndex);
          res.code = esbuildCode.slice(contentIndex).replace(`"use strict";`, `"use strict";` + esbuildHelpers);
        }
      }
      return res;
    }
  };
};
function resolveEsbuildTranspileOptions(config, format) {
  const target = config.build.target;
  const minify = config.build.minify === "esbuild";
  if ((!target || target === "esnext") && !minify) {
    return null;
  }
  const isEsLibBuild = config.build.lib && format === "es";
  const esbuildOptions = config.esbuild || {};
  const options = {
    charset: "utf8",
    ...esbuildOptions,
    loader: "js",
    target: target || void 0,
    format: rollupToEsbuildFormatMap[format],
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildOptions.supported
    }
  };
  if (!minify) {
    return {
      ...options,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: false,
      minifyWhitespace: false,
      treeShaking: false
    };
  }
  if (options.minifyIdentifiers != null || options.minifySyntax != null || options.minifyWhitespace != null) {
    if (isEsLibBuild) {
      return {
        ...options,
        minify: false,
        minifyIdentifiers: options.minifyIdentifiers ?? true,
        minifySyntax: options.minifySyntax ?? true,
        minifyWhitespace: false,
        treeShaking: true
      };
    } else {
      return {
        ...options,
        minify: false,
        minifyIdentifiers: options.minifyIdentifiers ?? true,
        minifySyntax: options.minifySyntax ?? true,
        minifyWhitespace: options.minifyWhitespace ?? true,
        treeShaking: true
      };
    }
  }
  if (isEsLibBuild) {
    return {
      ...options,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true
    };
  } else {
    return {
      ...options,
      minify: true,
      treeShaking: true
    };
  }
}
function prettifyMessage(m, code) {
  let res = colors$1.yellow(m.text);
  if (m.location) {
    res += `
` + generateCodeFrame(code, m.location);
  }
  return res + `
`;
}
let globalTSConfckCache;
const tsconfckCacheMap = /* @__PURE__ */ new WeakMap();
function getTSConfckCache(config) {
  if (!config) {
    return globalTSConfckCache ??= new TSConfckCache();
  }
  let cache = tsconfckCacheMap.get(config);
  if (!cache) {
    cache = new TSConfckCache();
    tsconfckCacheMap.set(config, cache);
  }
  return cache;
}
async function loadTsconfigJsonForFile(filename, config) {
  const { tsconfig, tsconfigFile } = await parse$e(filename, {
    cache: getTSConfckCache(config)});
  return { tsconfigFile, tsconfig };
}
async function reloadOnTsconfigChange(server, changedFile) {
  if (changedFile.endsWith(".json")) {
    const cache = getTSConfckCache(server.config);
    if (changedFile.endsWith("/tsconfig.json") || cache.hasParseResult(changedFile)) {
      server.config.logger.info(
        `changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure TypeScript is compiled with updated config values.`,
        { clear: server.config.clearScreen, timestamp: true }
      );
      for (const environment of Object.values(server.environments)) {
        environment.moduleGraph.invalidateAll();
      }
      cache.clear();
      for (const environment of Object.values(server.environments)) {
        environment.hot.send({
          type: "full-reload",
          path: "*"
        });
      }
    }
  }
}

// src/realWorker.ts

// src/utils.ts
var AsyncFunction = async function() {
}.constructor;
var codeToDataUrl = (code) => `data:application/javascript,${encodeURIComponent(code + "\n//# sourceURL=[worker-eval(artichokie)]")}`;
var viteSsrDynamicImport = "__vite_ssr_dynamic_import__";

// src/realWorker.ts
var Worker = class {
  /** @internal */
  _isModule;
  /** @internal */
  _code;
  /** @internal */
  _parentFunctions;
  /** @internal */
  _max;
  /** @internal */
  _pool;
  /** @internal */
  _idlePool;
  /** @internal */
  _queue;
  constructor(fn, options = {}) {
    this._isModule = options.type === "module";
    this._code = genWorkerCode(
      fn,
      this._isModule,
      options.parentFunctions ?? {}
    );
    this._parentFunctions = options.parentFunctions ?? {};
    const defaultMax = Math.max(
      1,
      // os.availableParallelism is available from Node.js 18.14.0
      (os$3.availableParallelism?.() ?? os$3.cpus().length) - 1
    );
    this._max = options.max || defaultMax;
    this._pool = [];
    this._idlePool = [];
    this._queue = [];
  }
  async run(...args) {
    const worker = await this._getAvailableWorker();
    return new Promise((resolve, reject) => {
      worker.currentResolve = resolve;
      worker.currentReject = reject;
      worker.postMessage({ args });
    });
  }
  stop() {
    this._pool.forEach((w) => w.unref());
    this._queue.forEach(
      ([, reject]) => reject(
        new Error("Main worker pool stopped before a worker was available.")
      )
    );
    this._pool = [];
    this._idlePool = [];
    this._queue = [];
  }
  /** @internal */
  _createWorker(parentFunctionSyncMessagePort, parentFunctionAsyncMessagePort, lockState) {
    const options = {
      workerData: [
        parentFunctionSyncMessagePort,
        parentFunctionAsyncMessagePort,
        lockState
      ],
      transferList: [
        parentFunctionSyncMessagePort,
        parentFunctionAsyncMessagePort
      ]
    };
    if (this._isModule) {
      return new Worker$1(
        new URL(codeToDataUrl(this._code)),
        options
      );
    }
    return new Worker$1(this._code, {
      ...options,
      eval: true
    });
  }
  /** @internal */
  async _getAvailableWorker() {
    if (this._idlePool.length) {
      return this._idlePool.shift();
    }
    if (this._pool.length < this._max) {
      const parentFunctionResponder = createParentFunctionResponder(
        this._parentFunctions
      );
      const worker = this._createWorker(
        parentFunctionResponder.workerPorts.sync,
        parentFunctionResponder.workerPorts.async,
        parentFunctionResponder.lockState
      );
      worker.on("message", async (args) => {
        if ("result" in args) {
          worker.currentResolve?.(args.result);
          worker.currentResolve = null;
        } else {
          if (args.error instanceof ReferenceError) {
            args.error.message += ". Maybe you forgot to pass the function to parentFunction?";
          }
          worker.currentReject?.(args.error);
          worker.currentReject = null;
        }
        this._assignDoneWorker(worker);
      });
      worker.on("error", (err) => {
        worker.currentReject?.(err);
        worker.currentReject = null;
        parentFunctionResponder.close();
      });
      worker.on("exit", (code) => {
        const i = this._pool.indexOf(worker);
        if (i > -1) this._pool.splice(i, 1);
        if (code !== 0 && worker.currentReject) {
          worker.currentReject(
            new Error(`Worker stopped with non-0 exit code ${code}`)
          );
          worker.currentReject = null;
          parentFunctionResponder.close();
        }
      });
      this._pool.push(worker);
      return worker;
    }
    let resolve;
    let reject;
    const onWorkerAvailablePromise = new Promise((r, rj) => {
      resolve = r;
      reject = rj;
    });
    this._queue.push([resolve, reject]);
    return onWorkerAvailablePromise;
  }
  /** @internal */
  _assignDoneWorker(worker) {
    if (this._queue.length) {
      const [resolve] = this._queue.shift();
      resolve(worker);
      return;
    }
    this._idlePool.push(worker);
  }
};
function createParentFunctionResponder(parentFunctions) {
  const lockState = new Int32Array(new SharedArrayBuffer(4));
  const unlock = () => {
    Atomics.store(lockState, 0, 0);
    Atomics.notify(lockState, 0);
  };
  const parentFunctionSyncMessageChannel = new MessageChannel();
  const parentFunctionAsyncMessageChannel = new MessageChannel();
  const parentFunctionSyncMessagePort = parentFunctionSyncMessageChannel.port1;
  const parentFunctionAsyncMessagePort = parentFunctionAsyncMessageChannel.port1;
  const syncResponse = (data) => {
    parentFunctionSyncMessagePort.postMessage(data);
    unlock();
  };
  parentFunctionSyncMessagePort.on("message", async (args) => {
    let syncResult;
    try {
      syncResult = parentFunctions[args.name](...args.args);
    } catch (error) {
      syncResponse({ id: args.id, error });
      return;
    }
    if (!(typeof syncResult === "object" && syncResult !== null && "then" in syncResult && typeof syncResult.then === "function")) {
      syncResponse({
        id: args.id,
        result: syncResult
      });
      return;
    }
    syncResponse({
      id: args.id,
      isAsync: true
    });
    try {
      const result = await syncResult;
      parentFunctionAsyncMessagePort.postMessage({ id: args.id, result });
    } catch (error) {
      parentFunctionAsyncMessagePort.postMessage({ id: args.id, error });
    }
  });
  parentFunctionSyncMessagePort.unref();
  return {
    close: () => {
      parentFunctionSyncMessagePort.close();
      parentFunctionAsyncMessagePort.close();
    },
    lockState,
    workerPorts: {
      sync: parentFunctionSyncMessageChannel.port2,
      async: parentFunctionAsyncMessageChannel.port2
    }
  };
}
function genWorkerCode(fn, isModule, parentFunctions) {
  const createLock = (lockState) => {
    return {
      lock: () => {
        Atomics.store(lockState, 0, 1);
      },
      waitUnlock: () => {
        const status = Atomics.wait(lockState, 0, 1, 10 * 1e3);
        if (status === "timed-out") {
          throw new Error(status);
        }
      }
    };
  };
  const createParentFunctionRequester = (syncPort, asyncPort, receive, lock) => {
    let id = 0;
    const resolvers = /* @__PURE__ */ new Map();
    const call = (key) => (...args) => {
      id++;
      lock.lock();
      syncPort.postMessage({ id, name: key, args });
      lock.waitUnlock();
      const resArgs = receive(syncPort).message;
      if (resArgs.isAsync) {
        let resolve, reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        resolvers.set(id, { resolve, reject });
        return promise;
      }
      if ("error" in resArgs) {
        throw resArgs.error;
      } else {
        return resArgs.result;
      }
    };
    asyncPort.on("message", (args) => {
      const id2 = args.id;
      if (resolvers.has(id2)) {
        const { resolve, reject } = resolvers.get(id2);
        resolvers.delete(id2);
        if ("result" in args) {
          resolve(args.result);
        } else {
          reject(args.error);
        }
      }
    });
    return { call };
  };
  const fnString = fn.toString().replaceAll(viteSsrDynamicImport, "import");
  return `
${isModule ? "import { parentPort, receiveMessageOnPort, workerData } from 'worker_threads'" : "const { parentPort, receiveMessageOnPort, workerData } = require('worker_threads')"}
const [parentFunctionSyncMessagePort, parentFunctionAsyncMessagePort, lockState] = workerData
const createLock = ${createLock.toString()}
const parentFunctionRequester = (${createParentFunctionRequester.toString()})(
  parentFunctionSyncMessagePort,
  parentFunctionAsyncMessagePort,
  receiveMessageOnPort,
  createLock(lockState)
)

const doWorkPromise = (async () => {
  ${Object.keys(parentFunctions).map(
    (key) => `const ${key} = parentFunctionRequester.call(${JSON.stringify(key)});`
  ).join("\n")}
  return await (${fnString})()
})()
let doWork

parentPort.on('message', async (args) => {
  doWork ||= await doWorkPromise

  try {
    const res = await doWork(...args.args)
    parentPort.postMessage({ result: res })
  } catch (e) {
    parentPort.postMessage({ error: e })
  }
})
  `;
}
var importRe = /\bimport\s*\(/;
var internalImportName = "__artichokie_local_import__";
var FakeWorker = class {
  /** @internal */
  _fn;
  constructor(fn, options = {}) {
    const declareRequire = options.type !== "module";
    const argsAndCode = genFakeWorkerArgsAndCode(
      fn,
      declareRequire,
      options.parentFunctions ?? {}
    );
    const localImport = (specifier) => import(specifier);
    const args = [
      ...declareRequire ? [createRequire$1(import.meta.url)] : [],
      localImport,
      options.parentFunctions
    ];
    this._fn = new AsyncFunction(...argsAndCode)(...args);
  }
  async run(...args) {
    try {
      return await (await this._fn)(...args);
    } catch (err) {
      if (err instanceof ReferenceError) {
        err.message += ". Maybe you forgot to pass the function to parentFunction?";
      }
      throw err;
    }
  }
  stop() {
  }
};
function genFakeWorkerArgsAndCode(fn, declareRequire, parentFunctions) {
  const fnString = fn.toString().replace(importRe, `${internalImportName}(`).replaceAll(viteSsrDynamicImport, internalImportName);
  return [
    ...declareRequire ? ["require"] : [],
    internalImportName,
    "parentFunctions",
    `
${Object.keys(parentFunctions).map((key) => `const ${key} = parentFunctions[${JSON.stringify(key)}];`).join("\n")}
return await (${fnString})()
  `
  ];
}

// src/workerWithFallback.ts
var WorkerWithFallback = class {
  /** @internal */
  _disableReal;
  /** @internal */
  _realWorker;
  /** @internal */
  _fakeWorker;
  /** @internal */
  _shouldUseFake;
  constructor(fn, options) {
    this._disableReal = options.max !== void 0 && options.max <= 0;
    this._realWorker = new Worker(fn, options);
    this._fakeWorker = new FakeWorker(fn, options);
    this._shouldUseFake = options.shouldUseFake;
  }
  async run(...args) {
    const useFake = this._disableReal || this._shouldUseFake(...args);
    return this[useFake ? "_fakeWorker" : "_realWorker"].run(...args);
  }
  stop() {
    this._realWorker.stop();
    this._fakeWorker.stop();
  }
};

let terserPath;
const loadTerserPath = (root) => {
  if (terserPath) return terserPath;
  try {
    terserPath = requireResolveFromRootWithFallback(root, "terser");
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      throw new Error(
        "terser not found. Since Vite v3, terser has become an optional dependency. You need to install it."
      );
    } else {
      const message = new Error(`terser failed to load:
${e.message}`);
      message.stack = e.stack + "\n" + message.stack;
      throw message;
    }
  }
  return terserPath;
};
function terserPlugin(config) {
  const { maxWorkers, ...terserOptions } = config.build.terserOptions;
  const makeWorker = () => new WorkerWithFallback(
    () => async (terserPath2, code, options) => {
      const terser = require(terserPath2);
      return terser.minify(code, options);
    },
    {
      shouldUseFake(_terserPath, _code, options) {
        return !!(typeof options.mangle === "object" && (options.mangle.nth_identifier?.get || typeof options.mangle.properties === "object" && options.mangle.properties.nth_identifier?.get) || typeof options.format?.comments === "function" || typeof options.output?.comments === "function");
      },
      max: maxWorkers
    }
  );
  let worker;
  return {
    name: "vite:terser",
    applyToEnvironment(environment) {
      return !!environment.config.build.minify;
    },
    async renderChunk(code, _chunk, outputOptions) {
      if (config.build.minify !== "terser" && // @ts-expect-error injected by @vitejs/plugin-legacy
      !outputOptions.__vite_force_terser__) {
        return null;
      }
      if (config.build.lib && outputOptions.format === "es") {
        return null;
      }
      worker ||= makeWorker();
      const terserPath2 = loadTerserPath(config.root);
      const res = await worker.run(terserPath2, code, {
        safari10: true,
        ...terserOptions,
        sourceMap: !!outputOptions.sourcemap,
        module: outputOptions.format.startsWith("es"),
        toplevel: outputOptions.format === "cjs"
      });
      return {
        code: res.code,
        map: res.map
      };
    },
    closeBundle() {
      worker?.stop();
    }
  };
}

async function resolveEnvironmentPlugins(environment) {
  const environmentPlugins = [];
  for (const plugin of environment.getTopLevelConfig().plugins) {
    if (plugin.applyToEnvironment) {
      const applied = await plugin.applyToEnvironment(environment);
      if (!applied) {
        continue;
      }
      if (applied !== true) {
        environmentPlugins.push(
          ...(await asyncFlatten(arraify(applied))).filter(
            Boolean
          )
        );
        continue;
      }
    }
    environmentPlugins.push(plugin);
  }
  return environmentPlugins;
}
function perEnvironmentPlugin(name, applyToEnvironment) {
  return {
    name,
    applyToEnvironment
  };
}

const mimes = {
  "3g2": "video/3gpp2",
  "3gp": "video/3gpp",
  "3gpp": "video/3gpp",
  "3mf": "model/3mf",
  "aac": "audio/aac",
  "ac": "application/pkix-attr-cert",
  "adp": "audio/adpcm",
  "adts": "audio/aac",
  "ai": "application/postscript",
  "aml": "application/automationml-aml+xml",
  "amlx": "application/automationml-amlx+zip",
  "amr": "audio/amr",
  "apng": "image/apng",
  "appcache": "text/cache-manifest",
  "appinstaller": "application/appinstaller",
  "appx": "application/appx",
  "appxbundle": "application/appxbundle",
  "asc": "application/pgp-keys",
  "atom": "application/atom+xml",
  "atomcat": "application/atomcat+xml",
  "atomdeleted": "application/atomdeleted+xml",
  "atomsvc": "application/atomsvc+xml",
  "au": "audio/basic",
  "avci": "image/avci",
  "avcs": "image/avcs",
  "avif": "image/avif",
  "aw": "application/applixware",
  "bdoc": "application/bdoc",
  "bin": "application/octet-stream",
  "bmp": "image/bmp",
  "bpk": "application/octet-stream",
  "btf": "image/prs.btif",
  "btif": "image/prs.btif",
  "buffer": "application/octet-stream",
  "ccxml": "application/ccxml+xml",
  "cdfx": "application/cdfx+xml",
  "cdmia": "application/cdmi-capability",
  "cdmic": "application/cdmi-container",
  "cdmid": "application/cdmi-domain",
  "cdmio": "application/cdmi-object",
  "cdmiq": "application/cdmi-queue",
  "cer": "application/pkix-cert",
  "cgm": "image/cgm",
  "cjs": "application/node",
  "class": "application/java-vm",
  "coffee": "text/coffeescript",
  "conf": "text/plain",
  "cpl": "application/cpl+xml",
  "cpt": "application/mac-compactpro",
  "crl": "application/pkix-crl",
  "css": "text/css",
  "csv": "text/csv",
  "cu": "application/cu-seeme",
  "cwl": "application/cwl",
  "cww": "application/prs.cww",
  "davmount": "application/davmount+xml",
  "dbk": "application/docbook+xml",
  "deb": "application/octet-stream",
  "def": "text/plain",
  "deploy": "application/octet-stream",
  "dib": "image/bmp",
  "disposition-notification": "message/disposition-notification",
  "dist": "application/octet-stream",
  "distz": "application/octet-stream",
  "dll": "application/octet-stream",
  "dmg": "application/octet-stream",
  "dms": "application/octet-stream",
  "doc": "application/msword",
  "dot": "application/msword",
  "dpx": "image/dpx",
  "drle": "image/dicom-rle",
  "dsc": "text/prs.lines.tag",
  "dssc": "application/dssc+der",
  "dtd": "application/xml-dtd",
  "dump": "application/octet-stream",
  "dwd": "application/atsc-dwd+xml",
  "ear": "application/java-archive",
  "ecma": "application/ecmascript",
  "elc": "application/octet-stream",
  "emf": "image/emf",
  "eml": "message/rfc822",
  "emma": "application/emma+xml",
  "emotionml": "application/emotionml+xml",
  "eps": "application/postscript",
  "epub": "application/epub+zip",
  "exe": "application/octet-stream",
  "exi": "application/exi",
  "exp": "application/express",
  "exr": "image/aces",
  "ez": "application/andrew-inset",
  "fdf": "application/fdf",
  "fdt": "application/fdt+xml",
  "fits": "image/fits",
  "g3": "image/g3fax",
  "gbr": "application/rpki-ghostbusters",
  "geojson": "application/geo+json",
  "gif": "image/gif",
  "glb": "model/gltf-binary",
  "gltf": "model/gltf+json",
  "gml": "application/gml+xml",
  "gpx": "application/gpx+xml",
  "gram": "application/srgs",
  "grxml": "application/srgs+xml",
  "gxf": "application/gxf",
  "gz": "application/gzip",
  "h261": "video/h261",
  "h263": "video/h263",
  "h264": "video/h264",
  "heic": "image/heic",
  "heics": "image/heic-sequence",
  "heif": "image/heif",
  "heifs": "image/heif-sequence",
  "hej2": "image/hej2k",
  "held": "application/atsc-held+xml",
  "hjson": "application/hjson",
  "hlp": "application/winhlp",
  "hqx": "application/mac-binhex40",
  "hsj2": "image/hsj2",
  "htm": "text/html",
  "html": "text/html",
  "ics": "text/calendar",
  "ief": "image/ief",
  "ifb": "text/calendar",
  "iges": "model/iges",
  "igs": "model/iges",
  "img": "application/octet-stream",
  "in": "text/plain",
  "ini": "text/plain",
  "ink": "application/inkml+xml",
  "inkml": "application/inkml+xml",
  "ipfix": "application/ipfix",
  "iso": "application/octet-stream",
  "its": "application/its+xml",
  "jade": "text/jade",
  "jar": "application/java-archive",
  "jhc": "image/jphc",
  "jls": "image/jls",
  "jp2": "image/jp2",
  "jpe": "image/jpeg",
  "jpeg": "image/jpeg",
  "jpf": "image/jpx",
  "jpg": "image/jpeg",
  "jpg2": "image/jp2",
  "jpgm": "image/jpm",
  "jpgv": "video/jpeg",
  "jph": "image/jph",
  "jpm": "image/jpm",
  "jpx": "image/jpx",
  "js": "text/javascript",
  "json": "application/json",
  "json5": "application/json5",
  "jsonld": "application/ld+json",
  "jsonml": "application/jsonml+json",
  "jsx": "text/jsx",
  "jt": "model/jt",
  "jxl": "image/jxl",
  "jxr": "image/jxr",
  "jxra": "image/jxra",
  "jxrs": "image/jxrs",
  "jxs": "image/jxs",
  "jxsc": "image/jxsc",
  "jxsi": "image/jxsi",
  "jxss": "image/jxss",
  "kar": "audio/midi",
  "ktx": "image/ktx",
  "ktx2": "image/ktx2",
  "less": "text/less",
  "lgr": "application/lgr+xml",
  "list": "text/plain",
  "litcoffee": "text/coffeescript",
  "log": "text/plain",
  "lostxml": "application/lost+xml",
  "lrf": "application/octet-stream",
  "m1v": "video/mpeg",
  "m21": "application/mp21",
  "m2a": "audio/mpeg",
  "m2t": "video/mp2t",
  "m2ts": "video/mp2t",
  "m2v": "video/mpeg",
  "m3a": "audio/mpeg",
  "m4a": "audio/mp4",
  "m4p": "application/mp4",
  "m4s": "video/iso.segment",
  "ma": "application/mathematica",
  "mads": "application/mads+xml",
  "maei": "application/mmt-aei+xml",
  "man": "text/troff",
  "manifest": "text/cache-manifest",
  "map": "application/json",
  "mar": "application/octet-stream",
  "markdown": "text/markdown",
  "mathml": "application/mathml+xml",
  "mb": "application/mathematica",
  "mbox": "application/mbox",
  "md": "text/markdown",
  "mdx": "text/mdx",
  "me": "text/troff",
  "mesh": "model/mesh",
  "meta4": "application/metalink4+xml",
  "metalink": "application/metalink+xml",
  "mets": "application/mets+xml",
  "mft": "application/rpki-manifest",
  "mid": "audio/midi",
  "midi": "audio/midi",
  "mime": "message/rfc822",
  "mj2": "video/mj2",
  "mjp2": "video/mj2",
  "mjs": "text/javascript",
  "mml": "text/mathml",
  "mods": "application/mods+xml",
  "mov": "video/quicktime",
  "mp2": "audio/mpeg",
  "mp21": "application/mp21",
  "mp2a": "audio/mpeg",
  "mp3": "audio/mpeg",
  "mp4": "video/mp4",
  "mp4a": "audio/mp4",
  "mp4s": "application/mp4",
  "mp4v": "video/mp4",
  "mpd": "application/dash+xml",
  "mpe": "video/mpeg",
  "mpeg": "video/mpeg",
  "mpf": "application/media-policy-dataset+xml",
  "mpg": "video/mpeg",
  "mpg4": "video/mp4",
  "mpga": "audio/mpeg",
  "mpp": "application/dash-patch+xml",
  "mrc": "application/marc",
  "mrcx": "application/marcxml+xml",
  "ms": "text/troff",
  "mscml": "application/mediaservercontrol+xml",
  "msh": "model/mesh",
  "msi": "application/octet-stream",
  "msix": "application/msix",
  "msixbundle": "application/msixbundle",
  "msm": "application/octet-stream",
  "msp": "application/octet-stream",
  "mtl": "model/mtl",
  "mts": "video/mp2t",
  "musd": "application/mmt-usd+xml",
  "mxf": "application/mxf",
  "mxmf": "audio/mobile-xmf",
  "mxml": "application/xv+xml",
  "n3": "text/n3",
  "nb": "application/mathematica",
  "nq": "application/n-quads",
  "nt": "application/n-triples",
  "obj": "model/obj",
  "oda": "application/oda",
  "oga": "audio/ogg",
  "ogg": "audio/ogg",
  "ogv": "video/ogg",
  "ogx": "application/ogg",
  "omdoc": "application/omdoc+xml",
  "onepkg": "application/onenote",
  "onetmp": "application/onenote",
  "onetoc": "application/onenote",
  "onetoc2": "application/onenote",
  "opf": "application/oebps-package+xml",
  "opus": "audio/ogg",
  "otf": "font/otf",
  "owl": "application/rdf+xml",
  "oxps": "application/oxps",
  "p10": "application/pkcs10",
  "p7c": "application/pkcs7-mime",
  "p7m": "application/pkcs7-mime",
  "p7s": "application/pkcs7-signature",
  "p8": "application/pkcs8",
  "pdf": "application/pdf",
  "pfr": "application/font-tdpfr",
  "pgp": "application/pgp-encrypted",
  "pkg": "application/octet-stream",
  "pki": "application/pkixcmp",
  "pkipath": "application/pkix-pkipath",
  "pls": "application/pls+xml",
  "png": "image/png",
  "prc": "model/prc",
  "prf": "application/pics-rules",
  "provx": "application/provenance+xml",
  "ps": "application/postscript",
  "pskcxml": "application/pskc+xml",
  "pti": "image/prs.pti",
  "qt": "video/quicktime",
  "raml": "application/raml+yaml",
  "rapd": "application/route-apd+xml",
  "rdf": "application/rdf+xml",
  "relo": "application/p2p-overlay+xml",
  "rif": "application/reginfo+xml",
  "rl": "application/resource-lists+xml",
  "rld": "application/resource-lists-diff+xml",
  "rmi": "audio/midi",
  "rnc": "application/relax-ng-compact-syntax",
  "rng": "application/xml",
  "roa": "application/rpki-roa",
  "roff": "text/troff",
  "rq": "application/sparql-query",
  "rs": "application/rls-services+xml",
  "rsat": "application/atsc-rsat+xml",
  "rsd": "application/rsd+xml",
  "rsheet": "application/urc-ressheet+xml",
  "rss": "application/rss+xml",
  "rtf": "text/rtf",
  "rtx": "text/richtext",
  "rusd": "application/route-usd+xml",
  "s3m": "audio/s3m",
  "sbml": "application/sbml+xml",
  "scq": "application/scvp-cv-request",
  "scs": "application/scvp-cv-response",
  "sdp": "application/sdp",
  "senmlx": "application/senml+xml",
  "sensmlx": "application/sensml+xml",
  "ser": "application/java-serialized-object",
  "setpay": "application/set-payment-initiation",
  "setreg": "application/set-registration-initiation",
  "sgi": "image/sgi",
  "sgm": "text/sgml",
  "sgml": "text/sgml",
  "shex": "text/shex",
  "shf": "application/shf+xml",
  "shtml": "text/html",
  "sieve": "application/sieve",
  "sig": "application/pgp-signature",
  "sil": "audio/silk",
  "silo": "model/mesh",
  "siv": "application/sieve",
  "slim": "text/slim",
  "slm": "text/slim",
  "sls": "application/route-s-tsid+xml",
  "smi": "application/smil+xml",
  "smil": "application/smil+xml",
  "snd": "audio/basic",
  "so": "application/octet-stream",
  "spdx": "text/spdx",
  "spp": "application/scvp-vp-response",
  "spq": "application/scvp-vp-request",
  "spx": "audio/ogg",
  "sql": "application/sql",
  "sru": "application/sru+xml",
  "srx": "application/sparql-results+xml",
  "ssdl": "application/ssdl+xml",
  "ssml": "application/ssml+xml",
  "stk": "application/hyperstudio",
  "stl": "model/stl",
  "stpx": "model/step+xml",
  "stpxz": "model/step-xml+zip",
  "stpz": "model/step+zip",
  "styl": "text/stylus",
  "stylus": "text/stylus",
  "svg": "image/svg+xml",
  "svgz": "image/svg+xml",
  "swidtag": "application/swid+xml",
  "t": "text/troff",
  "t38": "image/t38",
  "td": "application/urc-targetdesc+xml",
  "tei": "application/tei+xml",
  "teicorpus": "application/tei+xml",
  "text": "text/plain",
  "tfi": "application/thraud+xml",
  "tfx": "image/tiff-fx",
  "tif": "image/tiff",
  "tiff": "image/tiff",
  "toml": "application/toml",
  "tr": "text/troff",
  "trig": "application/trig",
  "ts": "video/mp2t",
  "tsd": "application/timestamped-data",
  "tsv": "text/tab-separated-values",
  "ttc": "font/collection",
  "ttf": "font/ttf",
  "ttl": "text/turtle",
  "ttml": "application/ttml+xml",
  "txt": "text/plain",
  "u3d": "model/u3d",
  "u8dsn": "message/global-delivery-status",
  "u8hdr": "message/global-headers",
  "u8mdn": "message/global-disposition-notification",
  "u8msg": "message/global",
  "ubj": "application/ubjson",
  "uri": "text/uri-list",
  "uris": "text/uri-list",
  "urls": "text/uri-list",
  "vcard": "text/vcard",
  "vrml": "model/vrml",
  "vtt": "text/vtt",
  "vxml": "application/voicexml+xml",
  "war": "application/java-archive",
  "wasm": "application/wasm",
  "wav": "audio/wav",
  "weba": "audio/webm",
  "webm": "video/webm",
  "webmanifest": "application/manifest+json",
  "webp": "image/webp",
  "wgsl": "text/wgsl",
  "wgt": "application/widget",
  "wif": "application/watcherinfo+xml",
  "wmf": "image/wmf",
  "woff": "font/woff",
  "woff2": "font/woff2",
  "wrl": "model/vrml",
  "wsdl": "application/wsdl+xml",
  "wspolicy": "application/wspolicy+xml",
  "x3d": "model/x3d+xml",
  "x3db": "model/x3d+fastinfoset",
  "x3dbz": "model/x3d+binary",
  "x3dv": "model/x3d-vrml",
  "x3dvz": "model/x3d+vrml",
  "x3dz": "model/x3d+xml",
  "xaml": "application/xaml+xml",
  "xav": "application/xcap-att+xml",
  "xca": "application/xcap-caps+xml",
  "xcs": "application/calendar+xml",
  "xdf": "application/xcap-diff+xml",
  "xdssc": "application/dssc+xml",
  "xel": "application/xcap-el+xml",
  "xenc": "application/xenc+xml",
  "xer": "application/patch-ops-error+xml",
  "xfdf": "application/xfdf",
  "xht": "application/xhtml+xml",
  "xhtml": "application/xhtml+xml",
  "xhvml": "application/xv+xml",
  "xlf": "application/xliff+xml",
  "xm": "audio/xm",
  "xml": "text/xml",
  "xns": "application/xcap-ns+xml",
  "xop": "application/xop+xml",
  "xpl": "application/xproc+xml",
  "xsd": "application/xml",
  "xsf": "application/prs.xsf+xml",
  "xsl": "application/xml",
  "xslt": "application/xml",
  "xspf": "application/xspf+xml",
  "xvm": "application/xv+xml",
  "xvml": "application/xv+xml",
  "yaml": "text/yaml",
  "yang": "application/yang",
  "yin": "application/yin+xml",
  "yml": "text/yaml",
  "zip": "application/zip"
};

function lookup(extn) {
	let tmp = ('' + extn).trim().toLowerCase();
	let idx = tmp.lastIndexOf('.');
	return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

const publicFilesMap = /* @__PURE__ */ new WeakMap();
async function initPublicFiles(config) {
  let fileNames;
  try {
    fileNames = await recursiveReaddir(config.publicDir);
  } catch (e) {
    if (e.code === ERR_SYMLINK_IN_RECURSIVE_READDIR) {
      return;
    }
    throw e;
  }
  const publicFiles = new Set(
    fileNames.map((fileName) => fileName.slice(config.publicDir.length))
  );
  publicFilesMap.set(config, publicFiles);
  return publicFiles;
}
function getPublicFiles(config) {
  return publicFilesMap.get(config);
}
function checkPublicFile(url, config) {
  const { publicDir } = config;
  if (!publicDir || url[0] !== "/") {
    return;
  }
  const fileName = cleanUrl(url);
  const publicFiles = getPublicFiles(config);
  if (publicFiles) {
    return publicFiles.has(fileName) ? normalizePath$3(path$b.join(publicDir, fileName)) : void 0;
  }
  const publicFile = normalizePath$3(path$b.join(publicDir, fileName));
  if (!publicFile.startsWith(withTrailingSlash(publicDir))) {
    return;
  }
  return fs__default.existsSync(publicFile) ? publicFile : void 0;
}

const assetUrlRE = /__VITE_ASSET__([\w$]+)__(?:\$_(.*?)__)?/g;
const jsSourceMapRE = /\.[cm]?js\.map$/;
const noInlineRE = /[?&]no-inline\b/;
const inlineRE$3 = /[?&]inline\b/;
const svgExtRE = /\.svg(?:$|\?)/;
const assetCache = /* @__PURE__ */ new WeakMap();
const cssEntriesMap = /* @__PURE__ */ new WeakMap();
function registerCustomMime() {
  mimes["ico"] = "image/x-icon";
  mimes["cur"] = "image/x-icon";
  mimes["flac"] = "audio/flac";
  mimes["eot"] = "application/vnd.ms-fontobject";
}
function renderAssetUrlInJS(pluginContext, chunk, opts, code) {
  const { environment } = pluginContext;
  const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
    opts.format,
    environment.config.isWorker
  );
  let match;
  let s;
  assetUrlRE.lastIndex = 0;
  while (match = assetUrlRE.exec(code)) {
    s ||= new MagicString(code);
    const [full, referenceId, postfix = ""] = match;
    const file = pluginContext.getFileName(referenceId);
    chunk.viteMetadata.importedAssets.add(cleanUrl(file));
    const filename = file + postfix;
    const replacement = toOutputFilePathInJS(
      environment,
      filename,
      "asset",
      chunk.fileName,
      "js",
      toRelativeRuntime
    );
    const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
    s.update(match.index, match.index + full.length, replacementString);
  }
  const publicAssetUrlMap = publicAssetUrlCache.get(
    environment.getTopLevelConfig()
  );
  publicAssetUrlRE.lastIndex = 0;
  while (match = publicAssetUrlRE.exec(code)) {
    s ||= new MagicString(code);
    const [full, hash] = match;
    const publicUrl = publicAssetUrlMap.get(hash).slice(1);
    const replacement = toOutputFilePathInJS(
      environment,
      publicUrl,
      "public",
      chunk.fileName,
      "js",
      toRelativeRuntime
    );
    const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
    s.update(match.index, match.index + full.length, replacementString);
  }
  return s;
}
function assetPlugin(config) {
  registerCustomMime();
  return {
    name: "vite:asset",
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      assetCache.set(this.environment, /* @__PURE__ */ new Map());
      cssEntriesMap.set(this.environment, /* @__PURE__ */ new Set());
    },
    resolveId: {
      handler(id) {
        if (!config.assetsInclude(cleanUrl(id)) && !urlRE$1.test(id)) {
          return;
        }
        const publicFile = checkPublicFile(id, config);
        if (publicFile) {
          return id;
        }
      }
    },
    load: {
      async handler(id) {
        if (id[0] === "\0") {
          return;
        }
        if (rawRE$1.test(id)) {
          const file = checkPublicFile(id, config) || cleanUrl(id);
          this.addWatchFile(file);
          return `export default ${JSON.stringify(
            await fsp.readFile(file, "utf-8")
          )}`;
        }
        if (!urlRE$1.test(id) && !config.assetsInclude(cleanUrl(id))) {
          return;
        }
        id = removeUrlQuery(id);
        let url = await fileToUrl$1(this, id);
        if (!url.startsWith("data:") && this.environment.mode === "dev") {
          const mod = this.environment.moduleGraph.getModuleById(id);
          if (mod && mod.lastHMRTimestamp > 0) {
            url = injectQuery(url, `t=${mod.lastHMRTimestamp}`);
          }
        }
        return {
          code: `export default ${JSON.stringify(encodeURIPath(url))}`,
          // Force rollup to keep this module from being shared between other entry points if it's an entrypoint.
          // If the resulting chunk is empty, it will be removed in generateBundle.
          moduleSideEffects: config.command === "build" && this.getModuleInfo(id)?.isEntry ? "no-treeshake" : false,
          meta: config.command === "build" ? { "vite:asset": true } : void 0
        };
      }
    },
    renderChunk(code, chunk, opts) {
      const s = renderAssetUrlInJS(this, chunk, opts, code);
      if (s) {
        return {
          code: s.toString(),
          map: this.environment.config.build.sourcemap ? s.generateMap({ hires: "boundary" }) : null
        };
      } else {
        return null;
      }
    },
    generateBundle(_, bundle) {
      let importedFiles;
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk" && chunk.isEntry && chunk.moduleIds.length === 1 && config.assetsInclude(chunk.moduleIds[0]) && this.getModuleInfo(chunk.moduleIds[0])?.meta["vite:asset"]) {
          if (!importedFiles) {
            importedFiles = /* @__PURE__ */ new Set();
            for (const file2 in bundle) {
              const chunk2 = bundle[file2];
              if (chunk2.type === "chunk") {
                for (const importedFile of chunk2.imports) {
                  importedFiles.add(importedFile);
                }
                for (const importedFile of chunk2.dynamicImports) {
                  importedFiles.add(importedFile);
                }
              }
            }
          }
          if (!importedFiles.has(file)) {
            delete bundle[file];
          }
        }
      }
      if (config.command === "build" && !this.environment.config.build.emitAssets) {
        for (const file in bundle) {
          if (bundle[file].type === "asset" && !file.endsWith("ssr-manifest.json") && !jsSourceMapRE.test(file)) {
            delete bundle[file];
          }
        }
      }
    }
  };
}
async function fileToUrl$1(pluginContext, id) {
  const { environment } = pluginContext;
  if (environment.config.command === "serve") {
    return fileToDevUrl(environment, id);
  } else {
    return fileToBuiltUrl(pluginContext, id);
  }
}
async function fileToDevUrl(environment, id, skipBase = false) {
  const config = environment.getTopLevelConfig();
  const publicFile = checkPublicFile(id, config);
  if (inlineRE$3.test(id)) {
    const file = publicFile || cleanUrl(id);
    const content = await fsp.readFile(file);
    return assetToDataURL(environment, file, content);
  }
  const cleanedId = cleanUrl(id);
  if (svgExtRE.test(cleanedId)) {
    const file = publicFile || cleanedId;
    const content = await fsp.readFile(file);
    if (shouldInline(environment, file, id, content, void 0, void 0)) {
      return assetToDataURL(environment, file, content);
    }
  }
  let rtn;
  if (publicFile) {
    rtn = id;
  } else if (id.startsWith(withTrailingSlash(config.root))) {
    rtn = "/" + path$b.posix.relative(config.root, id);
  } else {
    rtn = path$b.posix.join(FS_PREFIX, id);
  }
  if (skipBase) {
    return rtn;
  }
  const base = joinUrlSegments(config.server.origin ?? "", config.decodedBase);
  return joinUrlSegments(base, removeLeadingSlash(rtn));
}
function getPublicAssetFilename(hash, config) {
  return publicAssetUrlCache.get(config)?.get(hash);
}
const publicAssetUrlCache = /* @__PURE__ */ new WeakMap();
const publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\d]{8})__/g;
function publicFileToBuiltUrl(url, config) {
  if (config.command !== "build") {
    return joinUrlSegments(config.decodedBase, url);
  }
  const hash = getHash(url);
  let cache = publicAssetUrlCache.get(config);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    publicAssetUrlCache.set(config, cache);
  }
  if (!cache.get(hash)) {
    cache.set(hash, url);
  }
  return `__VITE_PUBLIC_ASSET__${hash}__`;
}
const GIT_LFS_PREFIX = Buffer$1.from("version https://git-lfs.github.com");
function isGitLfsPlaceholder(content) {
  if (content.length < GIT_LFS_PREFIX.length) return false;
  return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0;
}
async function fileToBuiltUrl(pluginContext, id, skipPublicCheck = false, forceInline) {
  const environment = pluginContext.environment;
  const topLevelConfig = environment.getTopLevelConfig();
  if (!skipPublicCheck) {
    const publicFile = checkPublicFile(id, topLevelConfig);
    if (publicFile) {
      if (inlineRE$3.test(id)) {
        id = publicFile;
      } else {
        return publicFileToBuiltUrl(id, topLevelConfig);
      }
    }
  }
  const cache = assetCache.get(environment);
  const cached = cache.get(id);
  if (cached) {
    return cached;
  }
  let { file, postfix } = splitFileAndPostfix(id);
  const content = await fsp.readFile(file);
  let url;
  if (shouldInline(environment, file, id, content, pluginContext, forceInline)) {
    url = assetToDataURL(environment, file, content);
  } else {
    const originalFileName = normalizePath$3(
      path$b.relative(environment.config.root, file)
    );
    const referenceId = pluginContext.emitFile({
      type: "asset",
      // Ignore directory structure for asset file names
      name: path$b.basename(file),
      originalFileName,
      source: content
    });
    if (environment.config.command === "build" && noInlineRE.test(postfix)) {
      postfix = postfix.replace(noInlineRE, "").replace(/^&/, "?");
    }
    url = `__VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}`;
  }
  cache.set(id, url);
  return url;
}
async function urlToBuiltUrl(pluginContext, url, importer, forceInline) {
  const topLevelConfig = pluginContext.environment.getTopLevelConfig();
  if (checkPublicFile(url, topLevelConfig)) {
    return publicFileToBuiltUrl(url, topLevelConfig);
  }
  const file = url[0] === "/" ? path$b.join(topLevelConfig.root, url) : path$b.join(path$b.dirname(importer), url);
  return fileToBuiltUrl(
    pluginContext,
    file,
    // skip public check since we just did it above
    true,
    forceInline
  );
}
function shouldInline(environment, file, id, content, buildPluginContext, forceInline) {
  if (noInlineRE.test(id)) return false;
  if (inlineRE$3.test(id)) return true;
  if (buildPluginContext) {
    if (environment.config.build.lib) return true;
    if (buildPluginContext.getModuleInfo(id)?.isEntry) return false;
  }
  if (forceInline !== void 0) return forceInline;
  if (file.endsWith(".html")) return false;
  if (file.endsWith(".svg") && id.includes("#")) return false;
  let limit;
  const { assetsInlineLimit } = environment.config.build;
  if (typeof assetsInlineLimit === "function") {
    const userShouldInline = assetsInlineLimit(file, content);
    if (userShouldInline != null) return userShouldInline;
    limit = DEFAULT_ASSETS_INLINE_LIMIT;
  } else {
    limit = Number(assetsInlineLimit);
  }
  return content.length < limit && !isGitLfsPlaceholder(content);
}
function assetToDataURL(environment, file, content) {
  if (environment.config.build.lib && isGitLfsPlaceholder(content)) {
    environment.logger.warn(
      colors$1.yellow(`Inlined file ${file} was not downloaded via Git LFS`)
    );
  }
  if (file.endsWith(".svg")) {
    return svgToDataURL(content);
  } else {
    const mimeType = lookup(file) ?? "application/octet-stream";
    return `data:${mimeType};base64,${content.toString("base64")}`;
  }
}
const nestedQuotesRE = /"[^"']*'[^"]*"|'[^'"]*"[^']*'/;
function svgToDataURL(content) {
  const stringContent = content.toString();
  if (stringContent.includes("<text") || stringContent.includes("<foreignObject") || nestedQuotesRE.test(stringContent)) {
    return `data:image/svg+xml;base64,${content.toString("base64")}`;
  } else {
    return "data:image/svg+xml," + stringContent.trim().replaceAll(/>\s+</g, "><").replaceAll('"', "'").replaceAll("%", "%25").replaceAll("#", "%23").replaceAll("<", "%3c").replaceAll(">", "%3e").replaceAll(/\s+/g, "%20");
  }
}

const endsWithJSRE = /\.[cm]?js$/;
function manifestPlugin() {
  const getState = perEnvironmentState(() => {
    return {
      manifest: {},
      outputCount: 0,
      reset() {
        this.manifest = {};
        this.outputCount = 0;
      }
    };
  });
  return {
    name: "vite:manifest",
    perEnvironmentStartEndDuringDev: true,
    applyToEnvironment(environment) {
      return !!environment.config.build.manifest;
    },
    buildStart() {
      getState(this).reset();
    },
    generateBundle({ format }, bundle) {
      const state = getState(this);
      const { manifest } = state;
      const { root } = this.environment.config;
      const buildOptions = this.environment.config.build;
      function getChunkName(chunk) {
        return getChunkOriginalFileName(chunk, root, format) ?? `_${path$b.basename(chunk.fileName)}`;
      }
      function getInternalImports(imports) {
        const filteredImports = [];
        for (const file of imports) {
          if (bundle[file] === void 0) {
            continue;
          }
          filteredImports.push(getChunkName(bundle[file]));
        }
        return filteredImports;
      }
      function createChunk(chunk) {
        const manifestChunk = {
          file: chunk.fileName,
          name: chunk.name
        };
        if (chunk.facadeModuleId) {
          manifestChunk.src = getChunkName(chunk);
        }
        if (chunk.isEntry) {
          manifestChunk.isEntry = true;
        }
        if (chunk.isDynamicEntry) {
          manifestChunk.isDynamicEntry = true;
        }
        if (chunk.imports.length) {
          const internalImports = getInternalImports(chunk.imports);
          if (internalImports.length > 0) {
            manifestChunk.imports = internalImports;
          }
        }
        if (chunk.dynamicImports.length) {
          const internalImports = getInternalImports(chunk.dynamicImports);
          if (internalImports.length > 0) {
            manifestChunk.dynamicImports = internalImports;
          }
        }
        if (chunk.viteMetadata?.importedCss.size) {
          manifestChunk.css = [...chunk.viteMetadata.importedCss];
        }
        if (chunk.viteMetadata?.importedAssets.size) {
          manifestChunk.assets = [...chunk.viteMetadata.importedAssets];
        }
        return manifestChunk;
      }
      function createAsset(asset, src, isEntry) {
        const manifestChunk = {
          file: asset.fileName,
          src
        };
        if (isEntry) manifestChunk.isEntry = true;
        return manifestChunk;
      }
      const entryCssReferenceIds = cssEntriesMap.get(this.environment);
      const entryCssAssetFileNames = new Set(entryCssReferenceIds);
      for (const id of entryCssReferenceIds) {
        try {
          const fileName = this.getFileName(id);
          entryCssAssetFileNames.add(fileName);
        } catch {
        }
      }
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          manifest[getChunkName(chunk)] = createChunk(chunk);
        } else if (chunk.type === "asset" && chunk.names.length > 0) {
          const src = chunk.originalFileNames.length > 0 ? chunk.originalFileNames[0] : `_${path$b.basename(chunk.fileName)}`;
          const isEntry = entryCssAssetFileNames.has(chunk.fileName);
          const asset = createAsset(chunk, src, isEntry);
          const file2 = manifest[src]?.file;
          if (!(file2 && endsWithJSRE.test(file2))) {
            manifest[src] = asset;
          }
          for (const originalFileName of chunk.originalFileNames.slice(1)) {
            const file3 = manifest[originalFileName]?.file;
            if (!(file3 && endsWithJSRE.test(file3))) {
              manifest[originalFileName] = asset;
            }
          }
        }
      }
      state.outputCount++;
      const output = buildOptions.rollupOptions.output;
      const outputLength = Array.isArray(output) ? output.length : 1;
      if (state.outputCount >= outputLength) {
        this.emitFile({
          fileName: typeof buildOptions.manifest === "string" ? buildOptions.manifest : ".vite/manifest.json",
          type: "asset",
          source: JSON.stringify(sortObjectKeys(manifest), void 0, 2)
        });
      }
    }
  };
}
function getChunkOriginalFileName(chunk, root, format) {
  if (chunk.facadeModuleId) {
    let name = normalizePath$3(path$b.relative(root, chunk.facadeModuleId));
    if (format === "system" && !chunk.name.includes("-legacy")) {
      const ext = path$b.extname(name);
      const endPos = ext.length !== 0 ? -ext.length : void 0;
      name = `${name.slice(0, endPos)}-legacy${ext}`;
    }
    return name.replace(/\0/g, "");
  }
}

const dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
const base64RE = /base64/i;
const dataUriPrefix = `\0/@data-uri/`;
function dataURIPlugin() {
  let resolved;
  return {
    name: "vite:data-uri",
    buildStart() {
      resolved = /* @__PURE__ */ new Map();
    },
    resolveId(id) {
      if (!id.trimStart().startsWith("data:")) {
        return;
      }
      const uri = new URL$3(id);
      if (uri.protocol !== "data:") {
        return;
      }
      const match = dataUriRE.exec(uri.pathname);
      if (!match) {
        return;
      }
      const [, mime, format, data] = match;
      if (mime !== "text/javascript") {
        throw new Error(
          `data URI with non-JavaScript mime type is not supported. If you're using legacy JavaScript MIME types (such as 'application/javascript'), please use 'text/javascript' instead.`
        );
      }
      const base64 = format && base64RE.test(format.substring(1));
      const content = base64 ? Buffer.from(data, "base64").toString("utf-8") : data;
      resolved.set(id, content);
      return dataUriPrefix + id;
    },
    load(id) {
      if (id.startsWith(dataUriPrefix)) {
        return resolved.get(id.slice(dataUriPrefix.length));
      }
    }
  };
}

/* es-module-lexer 1.6.0 */
var ImportType;!function(A){A[A.Static=1]="Static",A[A.Dynamic=2]="Dynamic",A[A.ImportMeta=3]="ImportMeta",A[A.StaticSourcePhase=4]="StaticSourcePhase",A[A.DynamicSourcePhase=5]="DynamicSourcePhase";}(ImportType||(ImportType={}));const A=1===new Uint8Array(new Uint16Array([1]).buffer)[0];function parse$d(E,g="@"){if(!C)return init.then((()=>parse$d(E)));const I=E.length+1,w=(C.__heap_base.value||C.__heap_base)+4*I-C.memory.buffer.byteLength;w>0&&C.memory.grow(Math.ceil(w/65536));const K=C.sa(I-1);if((A?B:Q)(E,new Uint16Array(C.memory.buffer,K,I)),!C.parse())throw Object.assign(new Error(`Parse error ${g}:${E.slice(0,C.e()).split("\n").length}:${C.e()-E.lastIndexOf("\n",C.e()-1)}`),{idx:C.e()});const o=[],D=[];for(;C.ri();){const A=C.is(),Q=C.ie(),B=C.it(),g=C.ai(),I=C.id(),w=C.ss(),K=C.se();let D;C.ip()&&(D=k(E.slice(-1===I?A-1:A,-1===I?Q+1:Q))),o.push({n:D,t:B,s:A,e:Q,ss:w,se:K,d:I,a:g});}for(;C.re();){const A=C.es(),Q=C.ee(),B=C.els(),g=C.ele(),I=E.slice(A,Q),w=I[0],K=B<0?void 0:E.slice(B,g),o=K?K[0]:"";D.push({s:A,e:Q,ls:B,le:g,n:'"'===w||"'"===w?k(I):I,ln:'"'===o||"'"===o?k(K):K});}function k(A){try{return (0, eval)(A)}catch(A){}}return [o,D,!!C.f(),!!C.ms()]}function Q(A,Q){const B=A.length;let C=0;for(;C<B;){const B=A.charCodeAt(C);Q[C++]=(255&B)<<8|B>>>8;}}function B(A,Q){const B=A.length;let C=0;for(;C<B;)Q[C]=A.charCodeAt(C++);}let C;const E=()=>{return A="AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=","undefined"!=typeof Buffer?Buffer.from(A,"base64"):Uint8Array.from(atob(A),(A=>A.charCodeAt(0)));var A;};const init=WebAssembly.compile(E()).then(WebAssembly.instantiate).then((({exports:A})=>{C=A;}));

var convertSourceMap$1 = {};

(function (exports) {

	Object.defineProperty(exports, 'commentRegex', {
	  get: function getCommentRegex () {
	    // Groups: 1: media type, 2: MIME type, 3: charset, 4: encoding, 5: data.
	    return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
	  }
	});


	Object.defineProperty(exports, 'mapFileCommentRegex', {
	  get: function getMapFileCommentRegex () {
	    // Matches sourceMappingURL in either // or /* comment styles.
	    return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
	  }
	});

	var decodeBase64;
	if (typeof Buffer !== 'undefined') {
	  if (typeof Buffer.from === 'function') {
	    decodeBase64 = decodeBase64WithBufferFrom;
	  } else {
	    decodeBase64 = decodeBase64WithNewBuffer;
	  }
	} else {
	  decodeBase64 = decodeBase64WithAtob;
	}

	function decodeBase64WithBufferFrom(base64) {
	  return Buffer.from(base64, 'base64').toString();
	}

	function decodeBase64WithNewBuffer(base64) {
	  if (typeof value === 'number') {
	    throw new TypeError('The value to decode must not be of type number.');
	  }
	  return new Buffer(base64, 'base64').toString();
	}

	function decodeBase64WithAtob(base64) {
	  return decodeURIComponent(escape(atob(base64)));
	}

	function stripComment(sm) {
	  return sm.split(',').pop();
	}

	function readFromFileMap(sm, read) {
	  var r = exports.mapFileCommentRegex.exec(sm);
	  // for some odd reason //# .. captures in 1 and /* .. */ in 2
	  var filename = r[1] || r[2];

	  try {
	    var sm = read(filename);
	    if (sm != null && typeof sm.catch === 'function') {
	      return sm.catch(throwError);
	    } else {
	      return sm;
	    }
	  } catch (e) {
	    throwError(e);
	  }

	  function throwError(e) {
	    throw new Error('An error occurred while trying to read the map file at ' + filename + '\n' + e.stack);
	  }
	}

	function Converter (sm, opts) {
	  opts = opts || {};

	  if (opts.hasComment) {
	    sm = stripComment(sm);
	  }

	  if (opts.encoding === 'base64') {
	    sm = decodeBase64(sm);
	  } else if (opts.encoding === 'uri') {
	    sm = decodeURIComponent(sm);
	  }

	  if (opts.isJSON || opts.encoding) {
	    sm = JSON.parse(sm);
	  }

	  this.sourcemap = sm;
	}

	Converter.prototype.toJSON = function (space) {
	  return JSON.stringify(this.sourcemap, null, space);
	};

	if (typeof Buffer !== 'undefined') {
	  if (typeof Buffer.from === 'function') {
	    Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
	  } else {
	    Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
	  }
	} else {
	  Converter.prototype.toBase64 = encodeBase64WithBtoa;
	}

	function encodeBase64WithBufferFrom() {
	  var json = this.toJSON();
	  return Buffer.from(json, 'utf8').toString('base64');
	}

	function encodeBase64WithNewBuffer() {
	  var json = this.toJSON();
	  if (typeof json === 'number') {
	    throw new TypeError('The json to encode must not be of type number.');
	  }
	  return new Buffer(json, 'utf8').toString('base64');
	}

	function encodeBase64WithBtoa() {
	  var json = this.toJSON();
	  return btoa(unescape(encodeURIComponent(json)));
	}

	Converter.prototype.toURI = function () {
	  var json = this.toJSON();
	  return encodeURIComponent(json);
	};

	Converter.prototype.toComment = function (options) {
	  var encoding, content, data;
	  if (options != null && options.encoding === 'uri') {
	    encoding = '';
	    content = this.toURI();
	  } else {
	    encoding = ';base64';
	    content = this.toBase64();
	  }
	  data = 'sourceMappingURL=data:application/json;charset=utf-8' + encoding + ',' + content;
	  return options != null && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
	};

	// returns copy instead of original
	Converter.prototype.toObject = function () {
	  return JSON.parse(this.toJSON());
	};

	Converter.prototype.addProperty = function (key, value) {
	  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
	  return this.setProperty(key, value);
	};

	Converter.prototype.setProperty = function (key, value) {
	  this.sourcemap[key] = value;
	  return this;
	};

	Converter.prototype.getProperty = function (key) {
	  return this.sourcemap[key];
	};

	exports.fromObject = function (obj) {
	  return new Converter(obj);
	};

	exports.fromJSON = function (json) {
	  return new Converter(json, { isJSON: true });
	};

	exports.fromURI = function (uri) {
	  return new Converter(uri, { encoding: 'uri' });
	};

	exports.fromBase64 = function (base64) {
	  return new Converter(base64, { encoding: 'base64' });
	};

	exports.fromComment = function (comment) {
	  var m, encoding;
	  comment = comment
	    .replace(/^\/\*/g, '//')
	    .replace(/\*\/$/g, '');
	  m = exports.commentRegex.exec(comment);
	  encoding = m && m[4] || 'uri';
	  return new Converter(comment, { encoding: encoding, hasComment: true });
	};

	function makeConverter(sm) {
	  return new Converter(sm, { isJSON: true });
	}

	exports.fromMapFileComment = function (comment, read) {
	  if (typeof read === 'string') {
	    throw new Error(
	      'String directory paths are no longer supported with `fromMapFileComment`\n' +
	      'Please review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading'
	    )
	  }

	  var sm = readFromFileMap(comment, read);
	  if (sm != null && typeof sm.then === 'function') {
	    return sm.then(makeConverter);
	  } else {
	    return makeConverter(sm);
	  }
	};

	// Finds last sourcemap comment in file or returns null if none was found
	exports.fromSource = function (content) {
	  var m = content.match(exports.commentRegex);
	  return m ? exports.fromComment(m.pop()) : null;
	};

	// Finds last sourcemap comment in file or returns null if none was found
	exports.fromMapFileSource = function (content, read) {
	  if (typeof read === 'string') {
	    throw new Error(
	      'String directory paths are no longer supported with `fromMapFileSource`\n' +
	      'Please review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading'
	    )
	  }
	  var m = content.match(exports.mapFileCommentRegex);
	  return m ? exports.fromMapFileComment(m.pop(), read) : null;
	};

	exports.removeComments = function (src) {
	  return src.replace(exports.commentRegex, '');
	};

	exports.removeMapFileComments = function (src) {
	  return src.replace(exports.mapFileCommentRegex, '');
	};

	exports.generateMapFileComment = function (file, options) {
	  var data = 'sourceMappingURL=' + file;
	  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
	}; 
} (convertSourceMap$1));

var convertSourceMap = /*@__PURE__*/getDefaultExportFromCjs(convertSourceMap$1);

const debug$h = createDebugger("vite:sourcemap", {
  onlyWhenFocused: true
});
const virtualSourceRE = /^(?:dep:|browser-external:|virtual:)|\0/;
async function computeSourceRoute(map, file) {
  let sourceRoot;
  try {
    sourceRoot = await fsp.realpath(
      path$b.resolve(path$b.dirname(file), map.sourceRoot || "")
    );
  } catch {
  }
  return sourceRoot;
}
async function injectSourcesContent(map, file, logger) {
  let sourceRootPromise;
  const missingSources = [];
  const sourcesContent = map.sourcesContent || [];
  const sourcesContentPromises = [];
  for (let index = 0; index < map.sources.length; index++) {
    const sourcePath = map.sources[index];
    if (sourcesContent[index] == null && sourcePath && !virtualSourceRE.test(sourcePath)) {
      sourcesContentPromises.push(
        (async () => {
          sourceRootPromise ??= computeSourceRoute(map, file);
          const sourceRoot = await sourceRootPromise;
          let resolvedSourcePath = cleanUrl(decodeURI(sourcePath));
          if (sourceRoot) {
            resolvedSourcePath = path$b.resolve(sourceRoot, resolvedSourcePath);
          }
          sourcesContent[index] = await fsp.readFile(resolvedSourcePath, "utf-8").catch(() => {
            missingSources.push(resolvedSourcePath);
            return null;
          });
        })()
      );
    }
  }
  await Promise.all(sourcesContentPromises);
  map.sourcesContent = sourcesContent;
  if (missingSources.length) {
    logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
    debug$h?.(`Missing sources:
  ` + missingSources.join(`
  `));
  }
}
function genSourceMapUrl(map) {
  if (typeof map !== "string") {
    map = JSON.stringify(map);
  }
  return `data:application/json;base64,${Buffer.from(map).toString("base64")}`;
}
function getCodeWithSourcemap(type, code, map) {
  if (debug$h) {
    code += `
/*${JSON.stringify(map, null, 2).replace(/\*\//g, "*\\/")}*/
`;
  }
  if (type === "js") {
    code += `
//# sourceMappingURL=${genSourceMapUrl(map)}`;
  } else if (type === "css") {
    code += `
/*# sourceMappingURL=${genSourceMapUrl(map)} */`;
  }
  return code;
}
function applySourcemapIgnoreList(map, sourcemapPath, sourcemapIgnoreList, logger) {
  let { x_google_ignoreList } = map;
  if (x_google_ignoreList === void 0) {
    x_google_ignoreList = [];
  }
  for (let sourcesIndex = 0; sourcesIndex < map.sources.length; ++sourcesIndex) {
    const sourcePath = map.sources[sourcesIndex];
    if (!sourcePath) continue;
    const ignoreList = sourcemapIgnoreList(
      path$b.isAbsolute(sourcePath) ? sourcePath : path$b.resolve(path$b.dirname(sourcemapPath), sourcePath),
      sourcemapPath
    );
    if (logger && typeof ignoreList !== "boolean") {
      logger.warn("sourcemapIgnoreList function must return a boolean.");
    }
    if (ignoreList && !x_google_ignoreList.includes(sourcesIndex)) {
      x_google_ignoreList.push(sourcesIndex);
    }
  }
  if (x_google_ignoreList.length > 0) {
    if (!map.x_google_ignoreList) map.x_google_ignoreList = x_google_ignoreList;
  }
}
async function extractSourcemapFromFile(code, filePath) {
  const map = (convertSourceMap.fromSource(code) || await convertSourceMap.fromMapFileSource(
    code,
    createConvertSourceMapReadMap(filePath)
  ))?.toObject();
  if (map) {
    return {
      code: code.replace(convertSourceMap.mapFileCommentRegex, blankReplacer),
      map
    };
  }
}
function createConvertSourceMapReadMap(originalFileName) {
  return (filename) => {
    return fsp.readFile(
      path$b.resolve(path$b.dirname(originalFileName), filename),
      "utf-8"
    );
  };
}

var src$1 = {};

// @ts-check
const path$9 = require$$0$2;
const fs$7 = require$$0$4;
const os$2 = require$$2;
const url$4 = require$$0$5;

const fsReadFileAsync = fs$7.promises.readFile;

/** @type {(name: string, sync: boolean) => string[]} */
function getDefaultSearchPlaces(name, sync) {
	return [
		'package.json',
		`.${name}rc.json`,
		`.${name}rc.js`,
		`.${name}rc.cjs`,
		...(sync ? [] : [`.${name}rc.mjs`]),
		`.config/${name}rc`,
		`.config/${name}rc.json`,
		`.config/${name}rc.js`,
		`.config/${name}rc.cjs`,
		...(sync ? [] : [`.config/${name}rc.mjs`]),
		`${name}.config.js`,
		`${name}.config.cjs`,
		...(sync ? [] : [`${name}.config.mjs`]),
	];
}

/**
 * @type {(p: string) => string}
 *
 * see #17
 * On *nix, if cwd is not under homedir,
 * the last path will be '', ('/build' -> '')
 * but it should be '/' actually.
 * And on Windows, this will never happen. ('C:\build' -> 'C:')
 */
function parentDir(p) {
	return path$9.dirname(p) || path$9.sep;
}

/** @type {import('./index').LoaderSync} */
const jsonLoader = (_, content) => JSON.parse(content);
// Use plain require in webpack context for dynamic import
const requireFunc =
	typeof __webpack_require__ === 'function' ? __non_webpack_require__ : __require;
/** @type {import('./index').LoadersSync} */
const defaultLoadersSync = Object.freeze({
	'.js': requireFunc,
	'.json': requireFunc,
	'.cjs': requireFunc,
	noExt: jsonLoader,
});
src$1.defaultLoadersSync = defaultLoadersSync;

/** @type {import('./index').Loader} */
const dynamicImport = async id => {
	try {
		const fileUrl = url$4.pathToFileURL(id).href;
		const mod = await import(/* webpackIgnore: true */ fileUrl);

		return mod.default;
	} catch (e) {
		try {
			return requireFunc(id);
		} catch (/** @type {any} */ requireE) {
			if (
				requireE.code === 'ERR_REQUIRE_ESM' ||
				(requireE instanceof SyntaxError &&
					requireE
						.toString()
						.includes('Cannot use import statement outside a module'))
			) {
				throw e;
			}
			throw requireE;
		}
	}
};

/** @type {import('./index').Loaders} */
const defaultLoaders = Object.freeze({
	'.js': dynamicImport,
	'.mjs': dynamicImport,
	'.cjs': dynamicImport,
	'.json': jsonLoader,
	noExt: jsonLoader,
});
src$1.defaultLoaders = defaultLoaders;

/**
 * @param {string} name
 * @param {import('./index').Options | import('./index').OptionsSync} options
 * @param {boolean} sync
 * @returns {Required<import('./index').Options | import('./index').OptionsSync>}
 */
function getOptions(name, options, sync) {
	/** @type {Required<import('./index').Options>} */
	const conf = {
		stopDir: os$2.homedir(),
		searchPlaces: getDefaultSearchPlaces(name, sync),
		ignoreEmptySearchPlaces: true,
		cache: true,
		transform: x => x,
		packageProp: [name],
		...options,
		loaders: {
			...(sync ? defaultLoadersSync : defaultLoaders),
			...options.loaders,
		},
	};
	conf.searchPlaces.forEach(place => {
		const key = path$9.extname(place) || 'noExt';
		const loader = conf.loaders[key];
		if (!loader) {
			throw new Error(`Missing loader for extension "${place}"`);
		}

		if (typeof loader !== 'function') {
			throw new Error(
				`Loader for extension "${place}" is not a function: Received ${typeof loader}.`,
			);
		}
	});

	return conf;
}

/** @type {(props: string | string[], obj: Record<string, any>) => unknown} */
function getPackageProp(props, obj) {
	if (typeof props === 'string' && props in obj) return obj[props];
	return (
		(Array.isArray(props) ? props : props.split('.')).reduce(
			(acc, prop) => (acc === undefined ? acc : acc[prop]),
			obj,
		) || null
	);
}

/** @param {string} filepath */
function validateFilePath(filepath) {
	if (!filepath) throw new Error('load must pass a non-empty string');
}

/** @type {(loader: import('./index').Loader, ext: string) => void} */
function validateLoader(loader, ext) {
	if (!loader) throw new Error(`No loader specified for extension "${ext}"`);
	if (typeof loader !== 'function') throw new Error('loader is not a function');
}

/** @type {(enableCache: boolean) => <T>(c: Map<string, T>, filepath: string, res: T) => T} */
const makeEmplace = enableCache => (c, filepath, res) => {
	if (enableCache) c.set(filepath, res);
	return res;
};

/** @type {import('./index').lilconfig} */
src$1.lilconfig = function lilconfig(name, options) {
	const {
		ignoreEmptySearchPlaces,
		loaders,
		packageProp,
		searchPlaces,
		stopDir,
		transform,
		cache,
	} = getOptions(name, options ?? {}, false);
	const searchCache = new Map();
	const loadCache = new Map();
	const emplace = makeEmplace(cache);

	return {
		async search(searchFrom = process.cwd()) {
			/** @type {import('./index').LilconfigResult} */
			const result = {
				config: null,
				filepath: '',
			};

			/** @type {Set<string>} */
			const visited = new Set();
			let dir = searchFrom;
			dirLoop: while (true) {
				if (cache) {
					const r = searchCache.get(dir);
					if (r !== undefined) {
						for (const p of visited) searchCache.set(p, r);
						return r;
					}
					visited.add(dir);
				}

				for (const searchPlace of searchPlaces) {
					const filepath = path$9.join(dir, searchPlace);
					try {
						await fs$7.promises.access(filepath);
					} catch {
						continue;
					}
					const content = String(await fsReadFileAsync(filepath));
					const loaderKey = path$9.extname(searchPlace) || 'noExt';
					const loader = loaders[loaderKey];

					// handle package.json
					if (searchPlace === 'package.json') {
						const pkg = await loader(filepath, content);
						const maybeConfig = getPackageProp(packageProp, pkg);
						if (maybeConfig != null) {
							result.config = maybeConfig;
							result.filepath = filepath;
							break dirLoop;
						}

						continue;
					}

					// handle other type of configs
					const isEmpty = content.trim() === '';
					if (isEmpty && ignoreEmptySearchPlaces) continue;

					if (isEmpty) {
						result.isEmpty = true;
						result.config = undefined;
					} else {
						validateLoader(loader, loaderKey);
						result.config = await loader(filepath, content);
					}
					result.filepath = filepath;
					break dirLoop;
				}
				if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
				dir = parentDir(dir);
			}

			const transformed =
				// not found
				result.filepath === '' && result.config === null
					? transform(null)
					: transform(result);

			if (cache) {
				for (const p of visited) searchCache.set(p, transformed);
			}

			return transformed;
		},
		async load(filepath) {
			validateFilePath(filepath);
			const absPath = path$9.resolve(process.cwd(), filepath);
			if (cache && loadCache.has(absPath)) {
				return loadCache.get(absPath);
			}
			const {base, ext} = path$9.parse(absPath);
			const loaderKey = ext || 'noExt';
			const loader = loaders[loaderKey];
			validateLoader(loader, loaderKey);
			const content = String(await fsReadFileAsync(absPath));

			if (base === 'package.json') {
				const pkg = await loader(absPath, content);
				return emplace(
					loadCache,
					absPath,
					transform({
						config: getPackageProp(packageProp, pkg),
						filepath: absPath,
					}),
				);
			}
			/** @type {import('./index').LilconfigResult} */
			const result = {
				config: null,
				filepath: absPath,
			};
			// handle other type of configs
			const isEmpty = content.trim() === '';
			if (isEmpty && ignoreEmptySearchPlaces)
				return emplace(
					loadCache,
					absPath,
					transform({
						config: undefined,
						filepath: absPath,
						isEmpty: true,
					}),
				);

			// cosmiconfig returns undefined for empty files
			result.config = isEmpty ? undefined : await loader(absPath, content);

			return emplace(
				loadCache,
				absPath,
				transform(isEmpty ? {...result, isEmpty, config: undefined} : result),
			);
		},
		clearLoadCache() {
			if (cache) loadCache.clear();
		},
		clearSearchCache() {
			if (cache) searchCache.clear();
		},
		clearCaches() {
			if (cache) {
				loadCache.clear();
				searchCache.clear();
			}
		},
	};
};

/** @type {import('./index').lilconfigSync} */
src$1.lilconfigSync = function lilconfigSync(name, options) {
	const {
		ignoreEmptySearchPlaces,
		loaders,
		packageProp,
		searchPlaces,
		stopDir,
		transform,
		cache,
	} = getOptions(name, options ?? {}, true);
	const searchCache = new Map();
	const loadCache = new Map();
	const emplace = makeEmplace(cache);

	return {
		search(searchFrom = process.cwd()) {
			/** @type {import('./index').LilconfigResult} */
			const result = {
				config: null,
				filepath: '',
			};

			/** @type {Set<string>} */
			const visited = new Set();
			let dir = searchFrom;
			dirLoop: while (true) {
				if (cache) {
					const r = searchCache.get(dir);
					if (r !== undefined) {
						for (const p of visited) searchCache.set(p, r);
						return r;
					}
					visited.add(dir);
				}

				for (const searchPlace of searchPlaces) {
					const filepath = path$9.join(dir, searchPlace);
					try {
						fs$7.accessSync(filepath);
					} catch {
						continue;
					}
					const loaderKey = path$9.extname(searchPlace) || 'noExt';
					const loader = loaders[loaderKey];
					const content = String(fs$7.readFileSync(filepath));

					// handle package.json
					if (searchPlace === 'package.json') {
						const pkg = loader(filepath, content);
						const maybeConfig = getPackageProp(packageProp, pkg);
						if (maybeConfig != null) {
							result.config = maybeConfig;
							result.filepath = filepath;
							break dirLoop;
						}

						continue;
					}

					// handle other type of configs
					const isEmpty = content.trim() === '';
					if (isEmpty && ignoreEmptySearchPlaces) continue;

					if (isEmpty) {
						result.isEmpty = true;
						result.config = undefined;
					} else {
						validateLoader(loader, loaderKey);
						result.config = loader(filepath, content);
					}
					result.filepath = filepath;
					break dirLoop;
				}
				if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
				dir = parentDir(dir);
			}

			const transformed =
				// not found
				result.filepath === '' && result.config === null
					? transform(null)
					: transform(result);

			if (cache) {
				for (const p of visited) searchCache.set(p, transformed);
			}

			return transformed;
		},
		load(filepath) {
			validateFilePath(filepath);
			const absPath = path$9.resolve(process.cwd(), filepath);
			if (cache && loadCache.has(absPath)) {
				return loadCache.get(absPath);
			}
			const {base, ext} = path$9.parse(absPath);
			const loaderKey = ext || 'noExt';
			const loader = loaders[loaderKey];
			validateLoader(loader, loaderKey);

			const content = String(fs$7.readFileSync(absPath));

			if (base === 'package.json') {
				const pkg = loader(absPath, content);
				return transform({
					config: getPackageProp(packageProp, pkg),
					filepath: absPath,
				});
			}
			const result = {
				config: null,
				filepath: absPath,
			};
			// handle other type of configs
			const isEmpty = content.trim() === '';
			if (isEmpty && ignoreEmptySearchPlaces)
				return emplace(
					loadCache,
					absPath,
					transform({
						filepath: absPath,
						config: undefined,
						isEmpty: true,
					}),
				);

			// cosmiconfig returns undefined for empty files
			result.config = isEmpty ? undefined : loader(absPath, content);

			return emplace(
				loadCache,
				absPath,
				transform(isEmpty ? {...result, isEmpty, config: undefined} : result),
			);
		},
		clearLoadCache() {
			if (cache) loadCache.clear();
		},
		clearSearchCache() {
			if (cache) searchCache.clear();
		},
		clearCaches() {
			if (cache) {
				loadCache.clear();
				searchCache.clear();
			}
		},
	};
};

// @ts-check
const { createRequire } = require$$0$6;
const { fileURLToPath, pathToFileURL } = require$$1$1;

const TS_EXT_RE = /\.[mc]?ts$/;

let tsx;

let jiti;

let importError = [];

/**
 * @param {string} name
 * @param {string} rootFile
 * @returns {Promise<any>}
 */
async function req$3(name, rootFile = fileURLToPath(import.meta.url)) {
  let url = createRequire(rootFile).resolve(name);

  try {
    return (await import(`${pathToFileURL(url)}?t=${Date.now()}`)).default
  } catch (err) {
    if (!TS_EXT_RE.test(url)) {
      /* c8 ignore start */
      throw err
    }
  }

  if (tsx === undefined) {
    try {
      tsx = await import('tsx/cjs/api');
    } catch (error) {
      importError.push(error);
    }
  }

  if (tsx) {
    let loaded = tsx.require(name, rootFile);
    return loaded && '__esModule' in loaded ? loaded.default : loaded
  }

  if (jiti === undefined) {
    try {
      jiti = (await import('jiti')).default;
    } catch (error) {
      importError.push(error);
    }
  }

  if (jiti) {
    return jiti(rootFile, { interopDefault: true })(name)
  }

  throw new Error(
    `'tsx' or 'jiti' is required for the TypeScript configuration files. Make sure it is installed\nError: ${importError
      .map(error => error.message)
      .join('\n')}`
  )
}

var req_1 = req$3;

// @ts-check
const req$2 = req_1;

/**
 * Load Options
 *
 * @private
 * @method options
 *
 * @param  {Object} config  PostCSS Config
 *
 * @return {Promise<Object>} options PostCSS Options
 */
async function options(config, file) {
  if (config.parser && typeof config.parser === 'string') {
    try {
      config.parser = await req$2(config.parser, file);
    } catch (err) {
      throw new Error(
        `Loading PostCSS Parser failed: ${err.message}\n\n(@${file})`
      )
    }
  }

  if (config.syntax && typeof config.syntax === 'string') {
    try {
      config.syntax = await req$2(config.syntax, file);
    } catch (err) {
      throw new Error(
        `Loading PostCSS Syntax failed: ${err.message}\n\n(@${file})`
      )
    }
  }

  if (config.stringifier && typeof config.stringifier === 'string') {
    try {
      config.stringifier = await req$2(config.stringifier, file);
    } catch (err) {
      throw new Error(
        `Loading PostCSS Stringifier failed: ${err.message}\n\n(@${file})`
      )
    }
  }

  return config
}

var options_1 = options;

// @ts-check
const req$1 = req_1;

/**
 * Plugin Loader
 *
 * @private
 * @method load
 *
 * @param  {String} plugin PostCSS Plugin Name
 * @param  {Object} options PostCSS Plugin Options
 *
 * @return {Promise<Function>} PostCSS Plugin
 */
async function load(plugin, options, file) {
  try {
    if (
      options === null ||
      options === undefined ||
      Object.keys(options).length === 0
    ) {
      return await req$1(plugin, file)
    } else {
      return (await req$1(plugin, file))(options)
      /* c8 ignore next */
    }
  } catch (err) {
    throw new Error(
      `Loading PostCSS Plugin failed: ${err.message}\n\n(@${file})`
    )
  }
}

/**
 * Load Plugins
 *
 * @private
 * @method plugins
 *
 * @param {Object} config PostCSS Config Plugins
 *
 * @return {Promise<Array>} plugins PostCSS Plugins
 */
async function plugins(config, file) {
  let list = [];

  if (Array.isArray(config.plugins)) {
    list = config.plugins.filter(Boolean);
  } else {
    list = Object.entries(config.plugins)
      .filter(([, options]) => {
        return options !== false
      })
      .map(([plugin, options]) => {
        return load(plugin, options, file)
      });
    list = await Promise.all(list);
  }

  if (list.length && list.length > 0) {
    list.forEach((plugin, i) => {
      if (plugin.default) {
        plugin = plugin.default;
      }

      if (plugin.postcss === true) {
        plugin = plugin();
      } else if (plugin.postcss) {
        plugin = plugin.postcss;
      }

      if (
        !(
          (typeof plugin === 'object' && Array.isArray(plugin.plugins)) ||
          (typeof plugin === 'object' && plugin.postcssPlugin) ||
          typeof plugin === 'function'
        )
      ) {
        throw new TypeError(
          `Invalid PostCSS Plugin found at: plugins[${i}]\n\n(@${file})`
        )
      }
    });
  }

  return list
}

var plugins_1 = plugins;

// @ts-check
const { resolve } = path$b;

const config$1 = src$1;

const loadOptions = options_1;
const loadPlugins = plugins_1;
const req = req_1;

const interopRequireDefault = obj =>
  obj && obj.__esModule ? obj : { default: obj };

/**
 * Process the result from cosmiconfig
 *
 * @param  {Object} ctx Config Context
 * @param  {Object} result Cosmiconfig result
 *
 * @return {Promise<Object>} PostCSS Config
 */
async function processResult(ctx, result) {
  let file = result.filepath || '';
  let projectConfig = interopRequireDefault(result.config).default || {};

  if (typeof projectConfig === 'function') {
    projectConfig = projectConfig(ctx);
  } else {
    projectConfig = Object.assign({}, projectConfig, ctx);
  }

  if (!projectConfig.plugins) {
    projectConfig.plugins = [];
  }

  let res = {
    file,
    options: await loadOptions(projectConfig, file),
    plugins: await loadPlugins(projectConfig, file)
  };
  delete projectConfig.plugins;
  return res
}

/**
 * Builds the Config Context
 *
 * @param  {Object} ctx Config Context
 *
 * @return {Object} Config Context
 */
function createContext(ctx) {
  /**
   * @type {Object}
   *
   * @prop {String} cwd=process.cwd() Config search start location
   * @prop {String} env=process.env.NODE_ENV Config Enviroment, will be set to `development` by `postcss-load-config` if `process.env.NODE_ENV` is `undefined`
   */
  ctx = Object.assign(
    {
      cwd: process.cwd(),
      env: process.env.NODE_ENV
    },
    ctx
  );

  if (!ctx.env) {
    process.env.NODE_ENV = 'development';
  }

  return ctx
}

async function loader(filepath) {
  return req(filepath)
}

let yaml;
async function yamlLoader(_, content) {
  if (!yaml) {
    try {
      yaml = await import('yaml');
    } catch (e) {
      /* c8 ignore start */
      throw new Error(
        `'yaml' is required for the YAML configuration files. Make sure it is installed\nError: ${e.message}`
      )
    }
  }
  return yaml.parse(content);
}

/** @return {import('lilconfig').Options} */
const withLoaders = (options = {}) => {
  let moduleName = 'postcss';

  return {
    ...options,
    loaders: {
      ...options.loaders,
      '.cjs': loader,
      '.cts': loader,
      '.js': loader,
      '.mjs': loader,
      '.mts': loader,
      '.ts': loader,
      '.yaml': yamlLoader,
      '.yml': yamlLoader
    },
    searchPlaces: [
      ...(options.searchPlaces || []),
      'package.json',
      `.${moduleName}rc`,
      `.${moduleName}rc.json`,
      `.${moduleName}rc.yaml`,
      `.${moduleName}rc.yml`,
      `.${moduleName}rc.ts`,
      `.${moduleName}rc.cts`,
      `.${moduleName}rc.mts`,
      `.${moduleName}rc.js`,
      `.${moduleName}rc.cjs`,
      `.${moduleName}rc.mjs`,
      `${moduleName}.config.ts`,
      `${moduleName}.config.cts`,
      `${moduleName}.config.mts`,
      `${moduleName}.config.js`,
      `${moduleName}.config.cjs`,
      `${moduleName}.config.mjs`
    ]
  }
};

/**
 * Load Config
 *
 * @method rc
 *
 * @param  {Object} ctx Config Context
 * @param  {String} path Config Path
 * @param  {Object} options Config Options
 *
 * @return {Promise} config PostCSS Config
 */
function rc(ctx, path, options) {
  /**
   * @type {Object} The full Config Context
   */
  ctx = createContext(ctx);

  /**
   * @type {String} `process.cwd()`
   */
  path = path ? resolve(path) : process.cwd();

  return config$1
    .lilconfig('postcss', withLoaders(options))
    .search(path)
    .then(result => {
      if (!result) {
        throw new Error(`No PostCSS Config found in: ${path}`)
      }
      return processResult(ctx, result)
    })
}

/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */
var src = rc;

var postcssrc = /*@__PURE__*/getDefaultExportFromCjs(src);

function matches$1(pattern, importee) {
    if (pattern instanceof RegExp) {
        return pattern.test(importee);
    }
    if (importee.length < pattern.length) {
        return false;
    }
    if (importee === pattern) {
        return true;
    }
    // eslint-disable-next-line prefer-template
    return importee.startsWith(pattern + '/');
}
function getEntries({ entries, customResolver }) {
    if (!entries) {
        return [];
    }
    const resolverFunctionFromOptions = resolveCustomResolver(customResolver);
    if (Array.isArray(entries)) {
        return entries.map((entry) => {
            return {
                find: entry.find,
                replacement: entry.replacement,
                resolverFunction: resolveCustomResolver(entry.customResolver) || resolverFunctionFromOptions
            };
        });
    }
    return Object.entries(entries).map(([key, value]) => {
        return { find: key, replacement: value, resolverFunction: resolverFunctionFromOptions };
    });
}
function getHookFunction(hook) {
    if (typeof hook === 'function') {
        return hook;
    }
    if (hook && 'handler' in hook && typeof hook.handler === 'function') {
        return hook.handler;
    }
    return null;
}
function resolveCustomResolver(customResolver) {
    if (typeof customResolver === 'function') {
        return customResolver;
    }
    if (customResolver) {
        return getHookFunction(customResolver.resolveId);
    }
    return null;
}
function alias$1(options = {}) {
    const entries = getEntries(options);
    if (entries.length === 0) {
        return {
            name: 'alias',
            resolveId: () => null
        };
    }
    return {
        name: 'alias',
        async buildStart(inputOptions) {
            await Promise.all([...(Array.isArray(options.entries) ? options.entries : []), options].map(({ customResolver }) => { var _a; return customResolver && ((_a = getHookFunction(customResolver.buildStart)) === null || _a === void 0 ? void 0 : _a.call(this, inputOptions)); }));
        },
        resolveId(importee, importer, resolveOptions) {
            // First match is supposed to be the correct one
            const matchedEntry = entries.find((entry) => matches$1(entry.find, importee));
            if (!matchedEntry) {
                return null;
            }
            const updatedId = importee.replace(matchedEntry.find, matchedEntry.replacement);
            if (matchedEntry.resolverFunction) {
                return matchedEntry.resolverFunction.call(this, updatedId, importer, resolveOptions);
            }
            return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => {
                if (resolved)
                    return resolved;
                if (!require$$0$2.isAbsolute(updatedId)) {
                    this.warn(`rewrote ${importee} to ${updatedId} but was not an abolute path and was not handled by other plugins. ` +
                        `This will lead to duplicated modules for the same path. ` +
                        `To avoid duplicating modules, you should resolve to an absolute path.`);
                }
                return { id: updatedId };
            });
        }
    };
}

const jsonExtRE = /\.json(?:$|\?)(?!commonjs-(?:proxy|external))/;
const jsonObjRE = /^\s*\{/;
const jsonLangs = `\\.(?:json|json5)(?:$|\\?)`;
const jsonLangRE = new RegExp(jsonLangs);
const isJSONRequest = (request) => jsonLangRE.test(request);
function jsonPlugin(options, isBuild) {
  const plugin = {
    name: "vite:json",
    transform: {
      handler(json, id) {
        if (!jsonExtRE.test(id)) return null;
        if (SPECIAL_QUERY_RE.test(id)) return null;
        if (inlineRE$3.test(id) || noInlineRE.test(id)) {
          this.warn(
            `
Using ?inline or ?no-inline for JSON imports will have no effect.
Please use ?url&inline or ?url&no-inline to control JSON file inlining behavior.
`
          );
        }
        json = stripBomTag(json);
        try {
          if (options.stringify !== false) {
            if (options.namedExports && jsonObjRE.test(json)) {
              const parsed = JSON.parse(json);
              const keys = Object.keys(parsed);
              let code = "";
              let defaultObjectCode = "{\n";
              for (const key of keys) {
                if (key === makeLegalIdentifier(key)) {
                  code += `export const ${key} = ${serializeValue(parsed[key])};
`;
                  defaultObjectCode += `  ${key},
`;
                } else {
                  defaultObjectCode += `  ${JSON.stringify(key)}: ${serializeValue(parsed[key])},
`;
                }
              }
              defaultObjectCode += "}";
              code += `export default ${defaultObjectCode};
`;
              return {
                code,
                map: { mappings: "" }
              };
            }
            if (options.stringify === true || // use 10kB as a threshold for 'auto'
            // https://v8.dev/blog/cost-of-javascript-2019#:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger
            json.length > 10 * 1e3) {
              if (isBuild) {
                json = JSON.stringify(JSON.parse(json));
              }
              return {
                code: `export default /* #__PURE__ */ JSON.parse(${JSON.stringify(json)})`,
                map: { mappings: "" }
              };
            }
          }
          return {
            code: dataToEsm(JSON.parse(json), {
              preferConst: true,
              namedExports: options.namedExports
            }),
            map: { mappings: "" }
          };
        } catch (e) {
          const position = extractJsonErrorPosition(e.message, json.length);
          const msg = position ? `, invalid JSON syntax found at position ${position}` : `.`;
          this.error(`Failed to parse JSON file` + msg, position);
        }
      }
    }
  };
  const handler = plugin.transform.handler;
  plugin.transform = handler;
  plugin.transform.handler = handler;
  return plugin;
}
function serializeValue(value) {
  const valueAsString = JSON.stringify(value);
  if (typeof value === "object" && value != null && valueAsString.length > 10 * 1e3) {
    return `/* #__PURE__ */ JSON.parse(${JSON.stringify(valueAsString)})`;
  }
  return valueAsString;
}
function extractJsonErrorPosition(errorMessage, inputLength) {
  if (errorMessage.startsWith("Unexpected end of JSON input")) {
    return inputLength - 1;
  }
  const errorMessageList = /at position (\d+)/.exec(errorMessage);
  return errorMessageList ? Math.max(parseInt(errorMessageList[1], 10) - 1, 0) : void 0;
}

function e(e,n,r){throw new Error(r?`No known conditions for "${n}" specifier in "${e}" package`:`Missing "${n}" specifier in "${e}" package`)}function n(n,i,o,f){let s,u,l=r(n,o),c=function(e){let n=new Set(["default",...e.conditions||[]]);return e.unsafe||n.add(e.require?"require":"import"),e.unsafe||n.add(e.browser?"browser":"node"),n}(f||{}),a=i[l];if(void 0===a){let e,n,r,t;for(t in i)n&&t.length<n.length||("/"===t[t.length-1]&&l.startsWith(t)?(u=l.substring(t.length),n=t):t.length>1&&(r=t.indexOf("*",1),~r&&(e=RegExp("^"+t.substring(0,r)+"(.*)"+t.substring(1+r)+"$").exec(l),e&&e[1]&&(u=e[1],n=t))));a=i[n];}return a||e(n,l),s=t(a,c),s||e(n,l,1),u&&function(e,n){let r,t=0,i=e.length,o=/[*]/g,f=/[/]$/;for(;t<i;t++)e[t]=o.test(r=e[t])?r.replace(o,n):f.test(r)?r+n:r;}(s,u),s}function r(e,n,r){if(e===n||"."===n)return ".";let t=e+"/",i=t.length,o=n.slice(0,i)===t,f=o?n.slice(i):n;return "#"===f[0]?f:"./"===f.slice(0,2)?f:"./"+f}function t(e,n,r){if(e){if("string"==typeof e)return r&&r.add(e),[e];let i,o;if(Array.isArray(e)){for(o=r||new Set,i=0;i<e.length;i++)t(e[i],n,o);if(!r&&o.size)return [...o]}else for(i in e)if(n.has(i))return t(e[i],n,r)}}function o(e,r,t){let i,o=e.exports;if(o){if("string"==typeof o)o={".":o};else for(i in o){"."!==i[0]&&(o={".":o});break}return n(e.name,o,r||".",t)}}function f(e,r,t){if(e.imports)return n(e.name,e.imports,r,t)}

const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

new Set(builtinModules);
function clearImports(imports) {
  return (imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
}
function getImportNames(cleanedImports) {
  const topLevelImports = cleanedImports.replace(/{([^}]*)}/, "");
  const namespacedImport = topLevelImports.match(/\* as \s*(\S*)/)?.[1];
  const defaultImport = topLevelImports.split(",").find((index) => !/[*{}]/.test(index))?.trim() || undefined;
  return {
    namespacedImport,
    defaultImport
  };
}

/**
 * @typedef ErrnoExceptionFields
 * @property {number | undefined} [errnode]
 * @property {string | undefined} [code]
 * @property {string | undefined} [path]
 * @property {string | undefined} [syscall]
 * @property {string | undefined} [url]
 *
 * @typedef {Error & ErrnoExceptionFields} ErrnoException
 */


const own$1 = {}.hasOwnProperty;

const classRegExp = /^([A-Z][a-z\d]*)+$/;
// Sorted by a rough estimate on most frequently used entries.
const kTypes = new Set([
  'string',
  'function',
  'number',
  'object',
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  'Function',
  'Object',
  'boolean',
  'bigint',
  'symbol'
]);

/**
 * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
 * We cannot use Intl.ListFormat because it's not available in
 * --without-intl builds.
 *
 * @param {Array<string>} array
 *   An array of strings.
 * @param {string} [type]
 *   The list type to be inserted before the last element.
 * @returns {string}
 */
function formatList(array, type = 'and') {
  return array.length < 3
    ? array.join(` ${type} `)
    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`
}

/** @type {Map<string, MessageFunction | string>} */
const messages = new Map();
const nodeInternalPrefix = '__node_internal_';
/** @type {number} */
let userStackTraceLimit;

createError(
  'ERR_INVALID_ARG_TYPE',
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    assert$1(typeof name === 'string', "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }

    let message = 'The ';
    if (name.endsWith(' argument')) {
      // For cases like 'first argument'
      message += `${name} `;
    } else {
      const type = name.includes('.') ? 'property' : 'argument';
      message += `"${name}" ${type} `;
    }

    message += 'must be ';

    /** @type {Array<string>} */
    const types = [];
    /** @type {Array<string>} */
    const instances = [];
    /** @type {Array<string>} */
    const other = [];

    for (const value of expected) {
      assert$1(
        typeof value === 'string',
        'All expected entries have to be of type string'
      );

      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        assert$1(
          value !== 'object',
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }

    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
      const pos = types.indexOf('object');
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push('Object');
      }
    }

    if (types.length > 0) {
      message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(
        types,
        'or'
      )}`;
      if (instances.length > 0 || other.length > 0) message += ' or ';
    }

    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, 'or')}`;
      if (other.length > 0) message += ' or ';
    }

    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, 'or')}`;
      } else {
        if (other[0].toLowerCase() !== other[0]) message += 'an ';
        message += `${other[0]}`;
      }
    }

    message += `. Received ${determineSpecificType(actual)}`;

    return message
  },
  TypeError
);

createError(
  'ERR_INVALID_MODULE_SPECIFIER',
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = undefined) => {
    return `Invalid module "${request}" ${reason}${
      base ? ` imported from ${base}` : ''
    }`
  },
  TypeError
);

createError(
  'ERR_INVALID_PACKAGE_CONFIG',
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path, base, message) => {
    return `Invalid package config ${path}${
      base ? ` while importing ${base}` : ''
    }${message ? `. ${message}` : ''}`
  },
  Error
);

createError(
  'ERR_INVALID_PACKAGE_TARGET',
  /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (packagePath, key, target, isImport = false, base = undefined) => {
    const relatedError =
      typeof target === 'string' &&
      !isImport &&
      target.length > 0 &&
      !target.startsWith('./');
    if (key === '.') {
      assert$1(isImport === false);
      return (
        `Invalid "exports" main target ${JSON.stringify(target)} defined ` +
        `in the package config ${packagePath}package.json${
          base ? ` imported from ${base}` : ''
        }${relatedError ? '; targets must start with "./"' : ''}`
      )
    }

    return `Invalid "${
      isImport ? 'imports' : 'exports'
    }" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${
      base ? ` imported from ${base}` : ''
    }${relatedError ? '; targets must start with "./"' : ''}`
  },
  Error
);

createError(
  'ERR_MODULE_NOT_FOUND',
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path, base, exactUrl = false) => {
    return `Cannot find ${
      exactUrl ? 'module' : 'package'
    } '${path}' imported from ${base}`
  },
  Error
);

createError(
  'ERR_NETWORK_IMPORT_DISALLOWED',
  "import of '%s' by %s is not supported: %s",
  Error
);

createError(
  'ERR_PACKAGE_IMPORT_NOT_DEFINED',
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${
      packagePath ? ` in package ${packagePath}package.json` : ''
    } imported from ${base}`
  },
  TypeError
);

createError(
  'ERR_PACKAGE_PATH_NOT_EXPORTED',
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base = undefined) => {
    if (subpath === '.')
      return `No "exports" main defined in ${packagePath}package.json${
        base ? ` imported from ${base}` : ''
      }`
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${
      base ? ` imported from ${base}` : ''
    }`
  },
  Error
);

createError(
  'ERR_UNSUPPORTED_DIR_IMPORT',
  "Directory import '%s' is not supported " +
    'resolving ES modules imported from %s',
  Error
);

createError(
  'ERR_UNSUPPORTED_RESOLVE_REQUEST',
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);

createError(
  'ERR_UNKNOWN_FILE_EXTENSION',
  /**
   * @param {string} extension
   * @param {string} path
   */
  (extension, path) => {
    return `Unknown file extension "${extension}" for ${path}`
  },
  TypeError
);

createError(
  'ERR_INVALID_ARG_VALUE',
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value, reason = 'is invalid') => {
    let inspected = inspect(value);

    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }

    const type = name.includes('.') ? 'property' : 'argument';

    return `The ${type} '${name}' ${reason}. Received ${inspected}`
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);

/**
 * Utility function for registering the error codes. Only used here. Exported
 * *only* to allow for testing.
 * @param {string} sym
 * @param {MessageFunction | string} value
 * @param {ErrorConstructor} constructor
 * @returns {new (...parameters: Array<any>) => Error}
 */
function createError(sym, value, constructor) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, value);

  return makeNodeErrorWithCode(constructor, sym)
}

/**
 * @param {ErrorConstructor} Base
 * @param {string} key
 * @returns {ErrorConstructor}
 */
function makeNodeErrorWithCode(Base, key) {
  // @ts-expect-error It’s a Node error.
  return NodeError
  /**
   * @param {Array<unknown>} parameters
   */
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    // Reset the limit and setting the name property.
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });

    captureLargerStackTrace(error);
    // @ts-expect-error It’s a Node error.
    error.code = key;
    return error
  }
}

/**
 * @returns {boolean}
 */
function isErrorStackTraceLimitWritable() {
  // Do no touch Error.stackTraceLimit as V8 would attempt to install
  // it again during deserialization.
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false
    }
  } catch {}

  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
  if (desc === undefined) {
    return Object.isExtensible(Error)
  }

  return own$1.call(desc, 'writable') && desc.writable !== undefined
    ? desc.writable
    : desc.set !== undefined
}

/**
 * This function removes unnecessary frames from Node.js core errors.
 * @template {(...parameters: unknown[]) => unknown} T
 * @param {T} wrappedFunction
 * @returns {T}
 */
function hideStackFrames(wrappedFunction) {
  // We rename the functions that will be hidden to cut off the stacktrace
  // at the outermost one
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, 'name', {value: hidden});
  return wrappedFunction
}

const captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function (error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }

    Error.captureStackTrace(error);

    // Reset the limit
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;

    return error
  }
);

/**
 * @param {string} key
 * @param {Array<unknown>} parameters
 * @param {Error} self
 * @returns {string}
 */
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  assert$1(message !== undefined, 'expected `message` to be found');

  if (typeof message === 'function') {
    assert$1(
      message.length <= parameters.length, // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not ` +
        `match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters)
  }

  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  assert$1(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not ` +
      `match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message

  parameters.unshift(message);
  return Reflect.apply(format$2, null, parameters)
}

/**
 * Determine the specific type of a value for type-mismatch errors.
 * @param {unknown} value
 * @returns {string}
 */
function determineSpecificType(value) {
  if (value === null || value === undefined) {
    return String(value)
  }

  if (typeof value === 'function' && value.name) {
    return `function ${value.name}`
  }

  if (typeof value === 'object') {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`
    }

    return `${inspect(value, {depth: -1})}`
  }

  let inspected = inspect(value, {colors: false});

  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }

  return `type ${typeof value} (${inspected})`
}

const ESM_STATIC_IMPORT_RE = /(?<=\s|^|;|\})import\s*([\s"']*(?<imports>[\p{L}\p{M}\w\t\n\r $*,/{}@.]+)from\s*)?["']\s*(?<specifier>(?<="\s*)[^"]*[^\s"](?=\s*")|(?<='\s*)[^']*[^\s'](?=\s*'))\s*["'][\s;]*/gmu;
const TYPE_RE = /^\s*?type\s/;
function parseStaticImport(matched) {
  const cleanedImports = clearImports(matched.imports);
  const namedImports = {};
  const _matches = cleanedImports.match(/{([^}]*)}/)?.[1]?.split(",") || [];
  for (const namedImport of _matches) {
    const _match = namedImport.match(/^\s*(\S*) as (\S*)\s*$/);
    const source = _match?.[1] || namedImport.trim();
    const importName = _match?.[2] || source;
    if (source && !TYPE_RE.test(source)) {
      namedImports[source] = importName;
    }
  }
  const { namespacedImport, defaultImport } = getImportNames(cleanedImports);
  return {
    ...matched,
    defaultImport,
    namespacedImport,
    namedImports
  };
}

const ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
const COMMENT_RE = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
function hasESMSyntax(code, opts = {}) {
  if (opts.stripComments) {
    code = code.replace(COMMENT_RE, "");
  }
  return ESM_RE.test(code);
}

const externalWithConversionNamespace = "vite:dep-pre-bundle:external-conversion";
const convertedExternalPrefix = "vite-dep-pre-bundle-external:";
const cjsExternalFacadeNamespace = "vite:cjs-external-facade";
const nonFacadePrefix = "vite-cjs-external-facade:";
const externalTypes = [
  "css",
  // supported pre-processor types
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss",
  // wasm
  "wasm",
  // known SFC types
  "vue",
  "svelte",
  "marko",
  "astro",
  "imba",
  // JSX/TSX may be configured to be compiled differently from how esbuild
  // handles it by default, so exclude them as well
  "jsx",
  "tsx",
  ...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(environment, qualified, external) {
  const { isProduction } = environment.config;
  const { extensions } = environment.config.optimizeDeps;
  const allExternalTypes = extensions ? externalTypes.filter((type) => !extensions.includes("." + type)) : externalTypes;
  const esmPackageCache = /* @__PURE__ */ new Map();
  const cjsPackageCache = /* @__PURE__ */ new Map();
  const _resolve = createBackCompatIdResolver(environment.getTopLevelConfig(), {
    asSrc: false,
    scan: true,
    packageCache: esmPackageCache
  });
  const _resolveRequire = createBackCompatIdResolver(
    environment.getTopLevelConfig(),
    {
      asSrc: false,
      isRequire: true,
      scan: true,
      packageCache: cjsPackageCache
    }
  );
  const resolve = (id, importer, kind, resolveDir) => {
    let _importer;
    {
      _importer = importer in qualified ? qualified[importer] : importer;
    }
    const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
    return resolver(environment, id, _importer);
  };
  const resolveResult = (id, resolved) => {
    if (resolved.startsWith(browserExternalId)) {
      return {
        path: id,
        namespace: "browser-external"
      };
    }
    if (resolved.startsWith(optionalPeerDepId)) {
      return {
        path: resolved,
        namespace: "optional-peer-dep"
      };
    }
    if (isBuiltin(environment.config.resolve.builtins, resolved)) {
      return;
    }
    if (isExternalUrl(resolved)) {
      return {
        path: resolved,
        external: true
      };
    }
    return {
      path: path$b.resolve(resolved)
    };
  };
  return {
    name: "vite:dep-pre-bundle",
    setup(build) {
      build.onEnd(() => {
        esmPackageCache.clear();
        cjsPackageCache.clear();
      });
      build.onResolve(
        {
          filter: new RegExp(
            `\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`
          )
        },
        async ({ path: id, importer, kind }) => {
          if (id.startsWith(convertedExternalPrefix)) {
            return {
              path: id.slice(convertedExternalPrefix.length),
              external: true
            };
          }
          const resolved = await resolve(id, importer, kind);
          if (resolved) {
            if (JS_TYPES_RE.test(resolved)) {
              return {
                path: resolved,
                external: false
              };
            }
            if (kind === "require-call") {
              return {
                path: resolved,
                namespace: externalWithConversionNamespace
              };
            }
            return {
              path: resolved,
              external: true
            };
          }
        }
      );
      build.onLoad(
        { filter: /./, namespace: externalWithConversionNamespace },
        (args) => {
          const modulePath = `"${convertedExternalPrefix}${args.path}"`;
          return {
            contents: isCSSRequest(args.path) && !isModuleCSSRequest(args.path) ? `import ${modulePath};` : `export { default } from ${modulePath};export * from ${modulePath};`,
            loader: "js"
          };
        }
      );
      function resolveEntry(id) {
        const flatId = flattenId(id);
        if (flatId in qualified) {
          return {
            path: qualified[flatId]
          };
        }
      }
      build.onResolve(
        { filter: /^[\w@][^:]/ },
        async ({ path: id, importer, kind }) => {
          if (moduleListContains(external, id)) {
            return {
              path: id,
              external: true
            };
          }
          let entry;
          if (!importer) {
            if (entry = resolveEntry(id)) return entry;
            const aliased = await _resolve(environment, id, void 0, true);
            if (aliased && (entry = resolveEntry(aliased))) {
              return entry;
            }
          }
          const resolved = await resolve(id, importer, kind);
          if (resolved) {
            return resolveResult(id, resolved);
          }
        }
      );
      build.onLoad(
        { filter: /.*/, namespace: "browser-external" },
        ({ path: path2 }) => {
          if (isProduction) {
            return {
              contents: "module.exports = {}"
            };
          } else {
            return {
              // Return in CJS to intercept named imports. Use `Object.create` to
              // create the Proxy in the prototype to workaround esbuild issue. Why?
              //
              // In short, esbuild cjs->esm flow:
              // 1. Create empty object using `Object.create(Object.getPrototypeOf(module.exports))`.
              // 2. Assign props of `module.exports` to the object.
              // 3. Return object for ESM use.
              //
              // If we do `module.exports = new Proxy({}, {})`, step 1 returns empty object,
              // step 2 does nothing as there's no props for `module.exports`. The final object
              // is just an empty object.
              //
              // Creating the Proxy in the prototype satisfies step 1 immediately, which means
              // the returned object is a Proxy that we can intercept.
              //
              // Note: Skip keys that are accessed by esbuild and browser devtools.
              contents: `module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path2}" has been externalized for browser compatibility. Cannot access "${path2}.\${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  }
}))`
            };
          }
        }
      );
      build.onLoad(
        { filter: /.*/, namespace: "optional-peer-dep" },
        ({ path: path2 }) => {
          if (isProduction) {
            return {
              contents: "module.exports = {}"
            };
          } else {
            const [, peerDep, parentDep] = path2.split(":");
            return {
              contents: `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
            };
          }
        }
      );
    }
  };
}
const matchesEntireLine = (text) => `^${escapeRegex(text)}$`;
function esbuildCjsExternalPlugin(externals, platform) {
  return {
    name: "cjs-external",
    setup(build) {
      const filter = new RegExp(externals.map(matchesEntireLine).join("|"));
      build.onResolve({ filter: new RegExp(`^${nonFacadePrefix}`) }, (args) => {
        return {
          path: args.path.slice(nonFacadePrefix.length),
          external: true
        };
      });
      build.onResolve({ filter }, (args) => {
        if (args.kind === "require-call" && platform !== "node") {
          return {
            path: args.path,
            namespace: cjsExternalFacadeNamespace
          };
        }
        return {
          path: args.path,
          external: true
        };
      });
      build.onLoad(
        { filter: /.*/, namespace: cjsExternalFacadeNamespace },
        (args) => ({
          contents: `import * as m from ${JSON.stringify(
            nonFacadePrefix + args.path
          )};module.exports = { ...m };`
        })
      );
    }
  };
}

const environmentColors = [
  colors$1.blue,
  colors$1.magenta,
  colors$1.green,
  colors$1.gray
];
function getDefaultResolvedEnvironmentOptions(config) {
  return {
    define: config.define,
    resolve: config.resolve,
    consumer: "server",
    optimizeDeps: config.optimizeDeps,
    dev: config.dev,
    build: config.build
  };
}
class PartialEnvironment {
  name;
  getTopLevelConfig() {
    return this._topLevelConfig;
  }
  config;
  /**
   * @deprecated use environment.config instead
   **/
  get options() {
    return this._options;
  }
  logger;
  /**
   * @internal
   */
  _options;
  /**
   * @internal
   */
  _topLevelConfig;
  constructor(name, topLevelConfig, options = topLevelConfig.environments[name]) {
    if (!/^[\w$]+$/.test(name)) {
      throw new Error(
        `Invalid environment name "${name}". Environment names must only contain alphanumeric characters and "$", "_".`
      );
    }
    this.name = name;
    this._topLevelConfig = topLevelConfig;
    this._options = options;
    this.config = new Proxy(
      options,
      {
        get: (target, prop) => {
          if (prop === "logger") {
            return this.logger;
          }
          if (prop in target) {
            return this._options[prop];
          }
          return this._topLevelConfig[prop];
        }
      }
    );
    const environment = colors$1.dim(`(${this.name})`);
    const colorIndex = [...this.name].reduce((acc, c) => acc + c.charCodeAt(0), 0) % environmentColors.length;
    const infoColor = environmentColors[colorIndex || 0];
    this.logger = {
      get hasWarned() {
        return topLevelConfig.logger.hasWarned;
      },
      info(msg, opts) {
        return topLevelConfig.logger.info(msg, {
          ...opts,
          environment: infoColor(environment)
        });
      },
      warn(msg, opts) {
        return topLevelConfig.logger.warn(msg, {
          ...opts,
          environment: colors$1.yellow(environment)
        });
      },
      warnOnce(msg, opts) {
        return topLevelConfig.logger.warnOnce(msg, {
          ...opts,
          environment: colors$1.yellow(environment)
        });
      },
      error(msg, opts) {
        return topLevelConfig.logger.error(msg, {
          ...opts,
          environment: colors$1.red(environment)
        });
      },
      clearScreen(type) {
        return topLevelConfig.logger.clearScreen(type);
      },
      hasErrorLogged(error) {
        return topLevelConfig.logger.hasErrorLogged(error);
      }
    };
  }
}
class BaseEnvironment extends PartialEnvironment {
  get plugins() {
    if (!this._plugins)
      throw new Error(
        `${this.name} environment.plugins called before initialized`
      );
    return this._plugins;
  }
  /**
   * @internal
   */
  _plugins;
  /**
   * @internal
   */
  _initiated = false;
  constructor(name, config, options = config.environments[name]) {
    super(name, config, options);
  }
}

// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
SingleLineComment = /\/\/.*/y;
HashbangComment = /^#!.*/;
JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
JSXText = /[^<>{}]+/y;
TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
Newline = RegExp(LineTerminatorSequence.source);
var jsTokens_1 = function*(input, {jsx = false} = {}) {
	var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
	({length} = input);
	lastIndex = 0;
	lastSignificantToken = "";
	stack = [
		{tag: "JS"}
	];
	braces = [];
	parenNesting = 0;
	postfixIncDec = false;
	if (match = HashbangComment.exec(input)) {
		yield ({
			type: "HashbangComment",
			value: match[0]
		});
		lastIndex = match[0].length;
	}
	while (lastIndex < length) {
		mode = stack[stack.length - 1];
		switch (mode.tag) {
			case "JS":
			case "JSNonExpressionParen":
			case "InterpolationInTemplate":
			case "InterpolationInJSX":
				if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
					RegularExpressionLiteral.lastIndex = lastIndex;
					if (match = RegularExpressionLiteral.exec(input)) {
						lastIndex = RegularExpressionLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield ({
							type: "RegularExpressionLiteral",
							value: match[0],
							closed: match[1] !== void 0 && match[1] !== "\\"
						});
						continue;
					}
				}
				Punctuator.lastIndex = lastIndex;
				if (match = Punctuator.exec(input)) {
					punctuator = match[0];
					nextLastIndex = Punctuator.lastIndex;
					nextLastSignificantToken = punctuator;
					switch (punctuator) {
						case "(":
							if (lastSignificantToken === "?NonExpressionParenKeyword") {
								stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
							}
							parenNesting++;
							postfixIncDec = false;
							break;
						case ")":
							parenNesting--;
							postfixIncDec = true;
							if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
								stack.pop();
								nextLastSignificantToken = "?NonExpressionParenEnd";
								postfixIncDec = false;
							}
							break;
						case "{":
							Punctuator.lastIndex = 0;
							isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
							braces.push(isExpression);
							postfixIncDec = false;
							break;
						case "}":
							switch (mode.tag) {
								case "InterpolationInTemplate":
									if (braces.length === mode.nesting) {
										Template.lastIndex = lastIndex;
										match = Template.exec(input);
										lastIndex = Template.lastIndex;
										lastSignificantToken = match[0];
										if (match[1] === "${") {
											lastSignificantToken = "?InterpolationInTemplate";
											postfixIncDec = false;
											yield ({
												type: "TemplateMiddle",
												value: match[0]
											});
										} else {
											stack.pop();
											postfixIncDec = true;
											yield ({
												type: "TemplateTail",
												value: match[0],
												closed: match[1] === "`"
											});
										}
										continue;
									}
									break;
								case "InterpolationInJSX":
									if (braces.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield ({
											type: "JSXPunctuator",
											value: "}"
										});
										continue;
									}
							}
							postfixIncDec = braces.pop();
							nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
							break;
						case "]":
							postfixIncDec = true;
							break;
						case "++":
						case "--":
							nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
							break;
						case "<":
							if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
								stack.push({tag: "JSXTag"});
								lastIndex += 1;
								lastSignificantToken = "<";
								yield ({
									type: "JSXPunctuator",
									value: punctuator
								});
								continue;
							}
							postfixIncDec = false;
							break;
						default:
							postfixIncDec = false;
					}
					lastIndex = nextLastIndex;
					lastSignificantToken = nextLastSignificantToken;
					yield ({
						type: "Punctuator",
						value: punctuator
					});
					continue;
				}
				Identifier.lastIndex = lastIndex;
				if (match = Identifier.exec(input)) {
					lastIndex = Identifier.lastIndex;
					nextLastSignificantToken = match[0];
					switch (match[0]) {
						case "for":
						case "if":
						case "while":
						case "with":
							if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
								nextLastSignificantToken = "?NonExpressionParenKeyword";
							}
					}
					lastSignificantToken = nextLastSignificantToken;
					postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
					yield ({
						type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
						value: match[0]
					});
					continue;
				}
				StringLiteral.lastIndex = lastIndex;
				if (match = StringLiteral.exec(input)) {
					lastIndex = StringLiteral.lastIndex;
					lastSignificantToken = match[0];
					postfixIncDec = true;
					yield ({
						type: "StringLiteral",
						value: match[0],
						closed: match[2] !== void 0
					});
					continue;
				}
				NumericLiteral.lastIndex = lastIndex;
				if (match = NumericLiteral.exec(input)) {
					lastIndex = NumericLiteral.lastIndex;
					lastSignificantToken = match[0];
					postfixIncDec = true;
					yield ({
						type: "NumericLiteral",
						value: match[0]
					});
					continue;
				}
				Template.lastIndex = lastIndex;
				if (match = Template.exec(input)) {
					lastIndex = Template.lastIndex;
					lastSignificantToken = match[0];
					if (match[1] === "${") {
						lastSignificantToken = "?InterpolationInTemplate";
						stack.push({
							tag: "InterpolationInTemplate",
							nesting: braces.length
						});
						postfixIncDec = false;
						yield ({
							type: "TemplateHead",
							value: match[0]
						});
					} else {
						postfixIncDec = true;
						yield ({
							type: "NoSubstitutionTemplate",
							value: match[0],
							closed: match[1] === "`"
						});
					}
					continue;
				}
				break;
			case "JSXTag":
			case "JSXTagEnd":
				JSXPunctuator.lastIndex = lastIndex;
				if (match = JSXPunctuator.exec(input)) {
					lastIndex = JSXPunctuator.lastIndex;
					nextLastSignificantToken = match[0];
					switch (match[0]) {
						case "<":
							stack.push({tag: "JSXTag"});
							break;
						case ">":
							stack.pop();
							if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
								nextLastSignificantToken = "?JSX";
								postfixIncDec = true;
							} else {
								stack.push({tag: "JSXChildren"});
							}
							break;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces.length
							});
							nextLastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							break;
						case "/":
							if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") {
									stack.pop();
								}
								stack.push({tag: "JSXTagEnd"});
							}
					}
					lastSignificantToken = nextLastSignificantToken;
					yield ({
						type: "JSXPunctuator",
						value: match[0]
					});
					continue;
				}
				JSXIdentifier.lastIndex = lastIndex;
				if (match = JSXIdentifier.exec(input)) {
					lastIndex = JSXIdentifier.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXIdentifier",
						value: match[0]
					});
					continue;
				}
				JSXString.lastIndex = lastIndex;
				if (match = JSXString.exec(input)) {
					lastIndex = JSXString.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXString",
						value: match[0],
						closed: match[2] !== void 0
					});
					continue;
				}
				break;
			case "JSXChildren":
				JSXText.lastIndex = lastIndex;
				if (match = JSXText.exec(input)) {
					lastIndex = JSXText.lastIndex;
					lastSignificantToken = match[0];
					yield ({
						type: "JSXText",
						value: match[0]
					});
					continue;
				}
				switch (input[lastIndex]) {
					case "<":
						stack.push({tag: "JSXTag"});
						lastIndex++;
						lastSignificantToken = "<";
						yield ({
							type: "JSXPunctuator",
							value: "<"
						});
						continue;
					case "{":
						stack.push({
							tag: "InterpolationInJSX",
							nesting: braces.length
						});
						lastIndex++;
						lastSignificantToken = "?InterpolationInJSX";
						postfixIncDec = false;
						yield ({
							type: "JSXPunctuator",
							value: "{"
						});
						continue;
				}
		}
		WhiteSpace.lastIndex = lastIndex;
		if (match = WhiteSpace.exec(input)) {
			lastIndex = WhiteSpace.lastIndex;
			yield ({
				type: "WhiteSpace",
				value: match[0]
			});
			continue;
		}
		LineTerminatorSequence.lastIndex = lastIndex;
		if (match = LineTerminatorSequence.exec(input)) {
			lastIndex = LineTerminatorSequence.lastIndex;
			postfixIncDec = false;
			if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
				lastSignificantToken = "?NoLineTerminatorHere";
			}
			yield ({
				type: "LineTerminatorSequence",
				value: match[0]
			});
			continue;
		}
		MultiLineComment.lastIndex = lastIndex;
		if (match = MultiLineComment.exec(input)) {
			lastIndex = MultiLineComment.lastIndex;
			if (Newline.test(match[0])) {
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
					lastSignificantToken = "?NoLineTerminatorHere";
				}
			}
			yield ({
				type: "MultiLineComment",
				value: match[0],
				closed: match[1] !== void 0
			});
			continue;
		}
		SingleLineComment.lastIndex = lastIndex;
		if (match = SingleLineComment.exec(input)) {
			lastIndex = SingleLineComment.lastIndex;
			postfixIncDec = false;
			yield ({
				type: "SingleLineComment",
				value: match[0]
			});
			continue;
		}
		firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
		lastIndex += firstCodePoint.length;
		lastSignificantToken = firstCodePoint;
		postfixIncDec = false;
		yield ({
			type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
			value: firstCodePoint
		});
	}
	return void 0;
};

var jsTokens = /*@__PURE__*/getDefaultExportFromCjs(jsTokens_1);

function stripLiteralJsTokens(code, options) {
  const FILL = " ";
  const FILL_COMMENT = " ";
  let result = "";
  const tokens = [];
  for (const token of jsTokens(code, { jsx: false })) {
    tokens.push(token);
    if (token.type === "SingleLineComment") {
      result += FILL_COMMENT.repeat(token.value.length);
      continue;
    }
    if (token.type === "MultiLineComment") {
      result += token.value.replace(/[^\n]/g, FILL_COMMENT);
      continue;
    }
    if (token.type === "StringLiteral") {
      if (!token.closed) {
        result += token.value;
        continue;
      }
      const body = token.value.slice(1, -1);
      {
        result += token.value[0] + FILL.repeat(body.length) + token.value[token.value.length - 1];
        continue;
      }
    }
    if (token.type === "NoSubstitutionTemplate") {
      const body = token.value.slice(1, -1);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "RegularExpressionLiteral") {
      const body = token.value;
      {
        result += body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${FILL.repeat($1.length)}/${$2}`);
        continue;
      }
    }
    if (token.type === "TemplateHead") {
      const body = token.value.slice(1, -2);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    if (token.type === "TemplateTail") {
      const body = token.value.slice(0, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "TemplateMiddle") {
      const body = token.value.slice(1, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    result += token.value;
  }
  return {
    result,
    tokens
  };
}

function stripLiteral(code, options) {
  return stripLiteralDetailed(code).result;
}
function stripLiteralDetailed(code, options) {
  return stripLiteralJsTokens(code);
}

function importGlobPlugin(config) {
  const importGlobMaps = /* @__PURE__ */ new Map();
  return {
    name: "vite:import-glob",
    buildStart() {
      importGlobMaps.clear();
    },
    transform: {
      async handler(code, id) {
        if (!code.includes("import.meta.glob")) return;
        const result = await transformGlobImport(
          code,
          id,
          config.root,
          (im, _, options) => this.resolve(im, id, options).then((i) => i?.id || im),
          config.experimental.importGlobRestoreExtension,
          config.logger
        );
        if (result) {
          const allGlobs = result.matches.map((i) => i.globsResolved);
          if (!importGlobMaps.has(this.environment)) {
            importGlobMaps.set(this.environment, /* @__PURE__ */ new Map());
          }
          const globMatchers = allGlobs.map((globs) => {
            const affirmed = [];
            const negated = [];
            for (const glob2 of globs) {
              (glob2[0] === "!" ? negated : affirmed).push(glob2);
            }
            const affirmedMatcher = picomatch$2(affirmed);
            const negatedMatcher = picomatch$2(negated);
            return (file) => {
              return (affirmed.length === 0 || affirmedMatcher(file)) && !(negated.length > 0 && negatedMatcher(file));
            };
          });
          importGlobMaps.get(this.environment).set(id, globMatchers);
          return transformStableResult(result.s, id, config);
        }
      }
    },
    hotUpdate({ type, file, modules: oldModules }) {
      if (type === "update") return;
      const importGlobMap = importGlobMaps.get(this.environment);
      if (!importGlobMap) return;
      const modules = [];
      for (const [id, globMatchers] of importGlobMap) {
        if (globMatchers.some((matcher) => matcher(file))) {
          const mod = this.environment.moduleGraph.getModuleById(id);
          if (mod) modules.push(mod);
        }
      }
      return modules.length > 0 ? [...oldModules, ...modules] : void 0;
    }
  };
}
const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g;
const objectKeysRE = /\bObject\.keys\(\s*$/;
const objectValuesRE = /\bObject\.values\(\s*$/;
const knownOptions = {
  as: ["string"],
  eager: ["boolean"],
  import: ["string"],
  exhaustive: ["boolean"],
  query: ["object", "string"]
};
const forceDefaultAs = ["raw", "url"];
function err$1(e, pos) {
  const error = new Error(e);
  error.pos = pos;
  return error;
}
function parseGlobOptions(rawOpts, optsStartIndex, logger) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    throw err$1(
      "Vite is unable to parse the glob options as the value is not static",
      optsStartIndex
    );
  }
  if (opts == null) {
    return {};
  }
  for (const key in opts) {
    if (!(key in knownOptions)) {
      throw err$1(`Unknown glob option "${key}"`, optsStartIndex);
    }
    const allowedTypes = knownOptions[key];
    const valueType = typeof opts[key];
    if (!allowedTypes.includes(valueType)) {
      throw err$1(
        `Expected glob option "${key}" to be of type ${allowedTypes.join(
          " or "
        )}, but got ${valueType}`,
        optsStartIndex
      );
    }
  }
  if (typeof opts.query === "object") {
    for (const key in opts.query) {
      const value = opts.query[key];
      if (!["string", "number", "boolean"].includes(typeof value)) {
        throw err$1(
          `Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value}`,
          optsStartIndex
        );
      }
    }
    opts.query = stringifyQuery(opts.query);
  }
  if (opts.as && logger) {
    const importSuggestion = forceDefaultAs.includes(opts.as) ? `, import: 'default'` : "";
    logger.warn(
      colors$1.yellow(
        `The glob option "as" has been deprecated in favour of "query". Please update \`as: '${opts.as}'\` to \`query: '?${opts.as}'${importSuggestion}\`.`
      )
    );
  }
  if (opts.as && forceDefaultAs.includes(opts.as)) {
    if (opts.import && opts.import !== "default" && opts.import !== "*")
      throw err$1(
        `Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`,
        optsStartIndex
      );
    opts.import = opts.import || "default";
  }
  if (opts.as && opts.query)
    throw err$1(
      'Options "as" and "query" cannot be used together',
      optsStartIndex
    );
  if (opts.as) opts.query = opts.as;
  if (opts.query && opts.query[0] !== "?") opts.query = `?${opts.query}`;
  return opts;
}
async function parseImportGlob(code, importer, root, resolveId, logger) {
  let cleanCode;
  try {
    cleanCode = stripLiteral(code);
  } catch {
    return [];
  }
  const matches = Array.from(cleanCode.matchAll(importGlobRE));
  const tasks = matches.map(async (match, index) => {
    const start = match.index;
    const err2 = (msg) => {
      const e = new Error(`Invalid glob import syntax: ${msg}`);
      e.pos = start;
      return e;
    };
    const end = findCorrespondingCloseParenthesisPosition(
      cleanCode,
      start + match[0].length
    ) + 1;
    if (end <= 0) {
      throw err2("Close parenthesis not found");
    }
    const statementCode = code.slice(start, end);
    const rootAst = (await parseAstAsync(statementCode)).body[0];
    if (rootAst.type !== "ExpressionStatement") {
      throw err2(`Expect CallExpression, got ${rootAst.type}`);
    }
    const ast = rootAst.expression;
    if (ast.type !== "CallExpression") {
      throw err2(`Expect CallExpression, got ${ast.type}`);
    }
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err2(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
    const arg1 = ast.arguments[0];
    const arg2 = ast.arguments[1];
    const globs = [];
    const validateLiteral = (element) => {
      if (!element) return;
      if (element.type === "Literal") {
        if (typeof element.value !== "string")
          throw err2(
            `Expected glob to be a string, but got "${typeof element.value}"`
          );
        globs.push(element.value);
      } else if (element.type === "TemplateLiteral") {
        if (element.expressions.length !== 0) {
          throw err2(
            `Expected glob to be a string, but got dynamic template literal`
          );
        }
        globs.push(element.quasis[0].value.raw);
      } else {
        throw err2("Could only use literals");
      }
    };
    if (arg1.type === "ArrayExpression") {
      for (const element of arg1.elements) {
        validateLiteral(element);
      }
    } else {
      validateLiteral(arg1);
    }
    let options = {};
    if (arg2) {
      if (arg2.type !== "ObjectExpression")
        throw err2(
          `Expected the second argument to be an object literal, but got "${arg2.type}"`
        );
      options = parseGlobOptions(
        code.slice(start + arg2.start, start + arg2.end),
        start + arg2.start,
        logger
      );
    }
    const globsResolved = await Promise.all(
      globs.map((glob2) => toAbsoluteGlob(glob2, root, importer, resolveId))
    );
    const isRelative = globs.every((i) => ".!".includes(i[0]));
    const sliceCode = cleanCode.slice(0, start);
    const onlyKeys = objectKeysRE.test(sliceCode);
    let onlyValues = false;
    if (!onlyKeys) {
      onlyValues = objectValuesRE.test(sliceCode);
    }
    return {
      index,
      globs,
      globsResolved,
      isRelative,
      options,
      start,
      end,
      onlyKeys,
      onlyValues
    };
  });
  return (await Promise.all(tasks)).filter(Boolean);
}
function findCorrespondingCloseParenthesisPosition(cleanCode, openPos) {
  const closePos = cleanCode.indexOf(")", openPos);
  if (closePos < 0) return -1;
  if (!cleanCode.slice(openPos, closePos).includes("(")) return closePos;
  let remainingParenthesisCount = 0;
  const cleanCodeLen = cleanCode.length;
  for (let pos = openPos; pos < cleanCodeLen; pos++) {
    switch (cleanCode[pos]) {
      case "(": {
        remainingParenthesisCount++;
        break;
      }
      case ")": {
        remainingParenthesisCount--;
        if (remainingParenthesisCount <= 0) {
          return pos;
        }
      }
    }
  }
  return -1;
}
const importPrefix = "__vite_glob_";
const { basename, dirname, relative } = posix$1;
async function transformGlobImport(code, id, root, resolveId, restoreQueryExtension = false, logger) {
  id = slash$1(id);
  root = slash$1(root);
  const isVirtual = isVirtualModule(id);
  const dir = isVirtual ? void 0 : dirname(id);
  const matches = await parseImportGlob(
    code,
    isVirtual ? void 0 : id,
    root,
    resolveId,
    logger
  );
  const matchedFiles = /* @__PURE__ */ new Set();
  if (!matches.length) return null;
  const s = new MagicString(code);
  const staticImports = (await Promise.all(
    matches.map(
      async ({
        globsResolved,
        isRelative,
        options,
        index,
        start,
        end,
        onlyKeys,
        onlyValues
      }) => {
        const cwd = getCommonBase(globsResolved) ?? root;
        const files = (await glob(globsResolved, {
          absolute: true,
          cwd,
          dot: !!options.exhaustive,
          expandDirectories: false,
          ignore: options.exhaustive ? [] : ["**/node_modules/**"]
        })).filter((file) => file !== id).sort();
        const objectProps = [];
        const staticImports2 = [];
        const resolvePaths = (file) => {
          if (!dir) {
            if (isRelative)
              throw new Error(
                "In virtual modules, all globs must start with '/'"
              );
            const filePath2 = `/${relative(root, file)}`;
            return { filePath: filePath2, importPath: filePath2 };
          }
          let importPath = relative(dir, file);
          if (importPath[0] !== ".") importPath = `./${importPath}`;
          let filePath;
          if (isRelative) {
            filePath = importPath;
          } else {
            filePath = relative(root, file);
            if (filePath[0] !== ".") filePath = `/${filePath}`;
          }
          return { filePath, importPath };
        };
        files.forEach((file, i) => {
          const paths = resolvePaths(file);
          const filePath = paths.filePath;
          let importPath = paths.importPath;
          let importQuery = options.query ?? "";
          if (onlyKeys) {
            objectProps.push(`${JSON.stringify(filePath)}: 0`);
            return;
          }
          if (importQuery && importQuery !== "?raw") {
            const fileExtension = basename(file).split(".").slice(-1)[0];
            if (fileExtension && restoreQueryExtension)
              importQuery = `${importQuery}&lang.${fileExtension}`;
          }
          importPath = `${importPath}${importQuery}`;
          const importKey = options.import && options.import !== "*" ? options.import : void 0;
          if (options.eager) {
            const variableName = `${importPrefix}${index}_${i}`;
            const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
            staticImports2.push(
              `import ${expression} from ${JSON.stringify(importPath)}`
            );
            objectProps.push(
              onlyValues ? `${variableName}` : `${JSON.stringify(filePath)}: ${variableName}`
            );
          } else {
            let importStatement = `import(${JSON.stringify(importPath)})`;
            if (importKey)
              importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
            objectProps.push(
              onlyValues ? `() => ${importStatement}` : `${JSON.stringify(filePath)}: () => ${importStatement}`
            );
          }
        });
        files.forEach((i) => matchedFiles.add(i));
        const originalLineBreakCount = code.slice(start, end).match(/\n/g)?.length ?? 0;
        const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
        let replacement = "";
        if (onlyKeys) {
          replacement = `{${objectProps.join(",")}${lineBreaks}}`;
        } else if (onlyValues) {
          replacement = `[${objectProps.join(",")}${lineBreaks}]`;
        } else {
          replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(
            ","
          )}${lineBreaks}})`;
        }
        s.overwrite(start, end, replacement);
        return staticImports2;
      }
    )
  )).flat();
  if (staticImports.length) s.prepend(`${staticImports.join(";")};`);
  return {
    s,
    matches,
    files: matchedFiles
  };
}
function globSafePath(path) {
  return escapePath(normalizePath$3(path));
}
function lastNthChar(str, n) {
  return str.charAt(str.length - 1 - n);
}
function globSafeResolvedPath(resolved, glob2) {
  let numEqual = 0;
  const maxEqual = Math.min(resolved.length, glob2.length);
  while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob2, numEqual)) {
    numEqual += 1;
  }
  const staticPartEnd = resolved.length - numEqual;
  const staticPart = resolved.slice(0, staticPartEnd);
  const dynamicPart = resolved.slice(staticPartEnd);
  return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob2, root, importer, resolveId) {
  let pre = "";
  if (glob2[0] === "!") {
    pre = "!";
    glob2 = glob2.slice(1);
  }
  root = globSafePath(root);
  const dir = importer ? globSafePath(dirname(importer)) : root;
  if (glob2[0] === "/") return pre + posix$1.join(root, glob2.slice(1));
  if (glob2.startsWith("./")) return pre + posix$1.join(dir, glob2.slice(2));
  if (glob2.startsWith("../")) return pre + posix$1.join(dir, glob2);
  if (glob2.startsWith("**")) return pre + glob2;
  const isSubImportsPattern = glob2[0] === "#" && glob2.includes("*");
  const resolved = normalizePath$3(
    await resolveId(glob2, importer, {
      custom: { "vite:import-glob": { isSubImportsPattern } }
    }) || glob2
  );
  if (isAbsolute$1(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob2);
  }
  throw new Error(
    `Invalid glob: "${glob2}" (resolved: "${resolved}"). It must start with '/' or './'`
  );
}
function getCommonBase(globsResolved) {
  const bases = globsResolved.filter((g) => g[0] !== "!").map((glob2) => {
    let { base } = picomatch$2.scan(glob2);
    if (posix$1.basename(base).includes(".")) base = posix$1.dirname(base);
    return base;
  });
  if (!bases.length) return null;
  let commonAncestor = "";
  const dirS = bases[0].split("/");
  for (let i = 0; i < dirS.length; i++) {
    const candidate = dirS.slice(0, i + 1).join("/");
    if (bases.every((base) => base.startsWith(candidate)))
      commonAncestor = candidate;
    else break;
  }
  if (!commonAncestor) commonAncestor = "/";
  return commonAncestor;
}
function isVirtualModule(id) {
  return id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
}

class ScanEnvironment extends BaseEnvironment {
  mode = "scan";
  get pluginContainer() {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`
      );
    return this._pluginContainer;
  }
  /**
   * @internal
   */
  _pluginContainer;
  async init() {
    if (this._initiated) {
      return;
    }
    this._initiated = true;
    this._plugins = await resolveEnvironmentPlugins(this);
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this.plugins,
      void 0,
      false
    );
  }
}
function devToScanEnvironment(environment) {
  return {
    mode: "scan",
    get name() {
      return environment.name;
    },
    getTopLevelConfig() {
      return environment.getTopLevelConfig();
    },
    /**
     * @deprecated use environment.config instead
     **/
    get options() {
      return environment.options;
    },
    get config() {
      return environment.config;
    },
    get logger() {
      return environment.logger;
    },
    get pluginContainer() {
      return environment.pluginContainer;
    },
    get plugins() {
      return environment.plugins;
    }
  };
}
const debug$g = createDebugger("vite:deps");
const htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
const importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
function scanImports(environment) {
  const start = performance$1.now();
  const deps = {};
  const missing = {};
  let entries;
  const { config } = environment;
  const scanContext = { cancelled: false };
  const esbuildContext = computeEntries(
    environment
  ).then((computedEntries) => {
    entries = computedEntries;
    if (!entries.length) {
      if (!config.optimizeDeps.entries && !config.optimizeDeps.include) {
        environment.logger.warn(
          colors$1.yellow(
            "(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."
          )
        );
      }
      return;
    }
    if (scanContext.cancelled) return;
    debug$g?.(
      `Crawling dependencies using entries: ${entries.map((entry) => `
  ${colors$1.dim(entry)}`).join("")}`
    );
    return prepareEsbuildScanner(
      environment,
      entries,
      deps,
      missing,
      scanContext
    );
  });
  const result = esbuildContext.then((context) => {
    function disposeContext() {
      return context?.dispose().catch((e) => {
        environment.logger.error("Failed to dispose esbuild context", {
          error: e
        });
      });
    }
    if (!context || scanContext.cancelled) {
      disposeContext();
      return { deps: {}, missing: {} };
    }
    return context.rebuild().then(() => {
      return {
        // Ensure a fixed order so hashes are stable and improve logs
        deps: orderedDependencies(deps),
        missing
      };
    }).finally(() => {
      return disposeContext();
    });
  }).catch(async (e) => {
    if (e.errors && e.message.includes("The build was canceled")) {
      return { deps: {}, missing: {} };
    }
    const prependMessage = colors$1.red(`  Failed to scan for dependencies from entries:
  ${entries.join("\n")}

  `);
    if (e.errors) {
      const msgs = await formatMessages(e.errors, {
        kind: "error",
        color: true
      });
      e.message = prependMessage + msgs.join("\n");
    } else {
      e.message = prependMessage + e.message;
    }
    throw e;
  }).finally(() => {
    if (debug$g) {
      const duration = (performance$1.now() - start).toFixed(2);
      const depsStr = Object.keys(orderedDependencies(deps)).sort().map((id) => `
  ${colors$1.cyan(id)} -> ${colors$1.dim(deps[id])}`).join("") || colors$1.dim("no dependencies found");
      debug$g(`Scan completed in ${duration}ms: ${depsStr}`);
    }
  });
  return {
    cancel: async () => {
      scanContext.cancelled = true;
      return esbuildContext.then((context) => context?.cancel());
    },
    result
  };
}
async function computeEntries(environment) {
  let entries = [];
  const explicitEntryPatterns = environment.config.optimizeDeps.entries;
  const buildInput = environment.config.build.rollupOptions.input;
  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, environment);
  } else if (buildInput) {
    const resolvePath = async (p) => {
      const id = (await environment.pluginContainer.resolveId(p, void 0, {
        scan: true
      }))?.id;
      if (id === void 0) {
        throw new Error(
          `failed to resolve rollupOptions.input value: ${JSON.stringify(p)}.`
        );
      }
      return id;
    };
    if (typeof buildInput === "string") {
      entries = [await resolvePath(buildInput)];
    } else if (Array.isArray(buildInput)) {
      entries = await Promise.all(buildInput.map(resolvePath));
    } else if (isObject$1(buildInput)) {
      entries = await Promise.all(Object.values(buildInput).map(resolvePath));
    } else {
      throw new Error("invalid rollupOptions.input value.");
    }
  } else {
    entries = await globEntries("**/*.html", environment);
  }
  entries = entries.filter(
    (entry) => isScannable(entry, environment.config.optimizeDeps.extensions) && fs__default.existsSync(entry)
  );
  return entries;
}
async function prepareEsbuildScanner(environment, entries, deps, missing, scanContext) {
  if (scanContext.cancelled) return;
  const plugin = esbuildScanPlugin(environment, deps, missing, entries);
  const { plugins = [], ...esbuildOptions } = environment.config.optimizeDeps.esbuildOptions ?? {};
  let tsconfigRaw = esbuildOptions.tsconfigRaw;
  if (!tsconfigRaw && !esbuildOptions.tsconfig) {
    const { tsconfig } = await loadTsconfigJsonForFile(
      path$b.join(environment.config.root, "_dummy.js")
    );
    if (tsconfig.compilerOptions?.experimentalDecorators) {
      tsconfigRaw = { compilerOptions: { experimentalDecorators: true } };
    }
  }
  return await esbuild.context({
    absWorkingDir: process.cwd(),
    write: false,
    stdin: {
      contents: entries.map((e) => `import ${JSON.stringify(e)}`).join("\n"),
      loader: "js"
    },
    bundle: true,
    format: "esm",
    logLevel: "silent",
    plugins: [...plugins, plugin],
    ...esbuildOptions,
    tsconfigRaw
  });
}
function orderedDependencies(deps) {
  const depsList = Object.entries(deps);
  depsList.sort((a, b) => a[0].localeCompare(b[0]));
  return Object.fromEntries(depsList);
}
function globEntries(pattern, environment) {
  const resolvedPatterns = arraify(pattern);
  if (resolvedPatterns.every((str) => !isDynamicPattern(str))) {
    return resolvedPatterns.map(
      (p) => normalizePath$3(path$b.resolve(environment.config.root, p))
    );
  }
  return glob(pattern, {
    absolute: true,
    cwd: environment.config.root,
    ignore: [
      "**/node_modules/**",
      `**/${environment.config.build.outDir}/**`,
      // if there aren't explicit entries, also ignore other common folders
      ...environment.config.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
    ]
  });
}
const scriptRE = /(<script(?:\s+[a-z_:][-\w:]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'<>=\s]+))?)*\s*>)(.*?)<\/script>/gis;
const commentRE$1 = /<!--.*?-->/gs;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteScriptModuleRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
const svelteModuleRE = /\smodule\b/i;
function esbuildScanPlugin(environment, depImports, missing, entries) {
  const seen = /* @__PURE__ */ new Map();
  async function resolveId(id, importer) {
    return environment.pluginContainer.resolveId(
      id,
      importer && normalizePath$3(importer),
      { scan: true }
    );
  }
  const resolve = async (id, importer) => {
    const key = id + (importer && path$b.dirname(importer));
    if (seen.has(key)) {
      return seen.get(key);
    }
    const resolved = await resolveId(id, importer);
    const res = resolved?.id;
    seen.set(key, res);
    return res;
  };
  const optimizeDepsOptions = environment.config.optimizeDeps;
  const include = optimizeDepsOptions.include;
  const exclude = [
    ...optimizeDepsOptions.exclude ?? [],
    "@vite/client",
    "@vite/env"
  ];
  const isUnlessEntry = (path2) => !entries.includes(path2);
  const externalUnlessEntry = ({ path: path2 }) => ({
    path: path2,
    external: isUnlessEntry(path2)
  });
  const doTransformGlobImport = async (contents, id, loader) => {
    let transpiledContents;
    if (loader !== "js") {
      transpiledContents = (await transform$1(contents, { loader })).code;
    } else {
      transpiledContents = contents;
    }
    const result = await transformGlobImport(
      transpiledContents,
      id,
      environment.config.root,
      resolve
    );
    return result?.s.toString() || transpiledContents;
  };
  return {
    name: "vite:dep-scan",
    setup(build) {
      const scripts = {};
      build.onResolve({ filter: externalRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: dataUrlRE }, ({ path: path2 }) => ({
        path: path2,
        external: true
      }));
      build.onResolve({ filter: virtualModuleRE }, ({ path: path2 }) => {
        return {
          // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
          path: path2.replace(virtualModulePrefix, ""),
          namespace: "script"
        };
      });
      build.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path2 }) => {
        return scripts[path2];
      });
      build.onResolve({ filter: htmlTypesRE }, async ({ path: path2, importer }) => {
        const resolved = await resolve(path2, importer);
        if (!resolved) return;
        if (isInNodeModules$1(resolved) && isOptimizable(resolved, optimizeDepsOptions))
          return;
        return {
          path: resolved,
          namespace: "html"
        };
      });
      const htmlTypeOnLoadCallback = async ({ path: p }) => {
        let raw = await fsp.readFile(p, "utf-8");
        raw = raw.replace(commentRE$1, "<!---->");
        const isHtml = p.endsWith(".html");
        let js = "";
        let scriptId = 0;
        const matches = raw.matchAll(scriptRE);
        for (const [, openTag, content] of matches) {
          const typeMatch = typeRE.exec(openTag);
          const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
          const langMatch = langRE.exec(openTag);
          const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
          if (isHtml && type !== "module") {
            continue;
          }
          if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
            continue;
          }
          let loader = "js";
          if (lang === "ts" || lang === "tsx" || lang === "jsx") {
            loader = lang;
          } else if (p.endsWith(".astro")) {
            loader = "ts";
          }
          const srcMatch = srcRE.exec(openTag);
          if (srcMatch) {
            const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
            js += `import ${JSON.stringify(src)}
`;
          } else if (content.trim()) {
            const contents = content + (loader.startsWith("ts") ? extractImportPaths(content) : "");
            const key = `${p}?id=${scriptId++}`;
            if (contents.includes("import.meta.glob")) {
              scripts[key] = {
                loader: "js",
                // since it is transpiled
                contents: await doTransformGlobImport(contents, p, loader),
                resolveDir: normalizePath$3(path$b.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            } else {
              scripts[key] = {
                loader,
                contents,
                resolveDir: normalizePath$3(path$b.dirname(p)),
                pluginData: {
                  htmlType: { loader }
                }
              };
            }
            const virtualModulePath = JSON.stringify(virtualModulePrefix + key);
            let addedImport = false;
            if (p.endsWith(".svelte")) {
              let isModule = svelteModuleRE.test(openTag);
              if (!isModule) {
                const contextMatch = svelteScriptModuleRE.exec(openTag);
                const context = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                isModule = context === "module";
              }
              if (!isModule) {
                addedImport = true;
                js += `import ${virtualModulePath}
`;
              }
            }
            if (!addedImport) {
              js += `export * from ${virtualModulePath}
`;
            }
          }
        }
        if (!p.endsWith(".vue") || !js.includes("export default")) {
          js += "\nexport default {}";
        }
        return {
          loader: "js",
          contents: js
        };
      };
      build.onLoad(
        { filter: htmlTypesRE, namespace: "html" },
        htmlTypeOnLoadCallback
      );
      build.onLoad(
        { filter: htmlTypesRE, namespace: "file" },
        htmlTypeOnLoadCallback
      );
      build.onResolve(
        {
          // avoid matching windows volume
          filter: /^[\w@][^:]/
        },
        async ({ path: id, importer }) => {
          if (moduleListContains(exclude, id)) {
            return externalUnlessEntry({ path: id });
          }
          if (depImports[id]) {
            return externalUnlessEntry({ path: id });
          }
          const resolved = await resolve(id, importer);
          if (resolved) {
            if (shouldExternalizeDep(resolved, id)) {
              return externalUnlessEntry({ path: id });
            }
            if (isInNodeModules$1(resolved) || include?.includes(id)) {
              if (isOptimizable(resolved, optimizeDepsOptions)) {
                depImports[id] = resolved;
              }
              return externalUnlessEntry({ path: id });
            } else if (isScannable(resolved, optimizeDepsOptions.extensions)) {
              const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
              return {
                path: path$b.resolve(resolved),
                namespace
              };
            } else {
              return externalUnlessEntry({ path: id });
            }
          } else {
            missing[id] = normalizePath$3(importer);
          }
        }
      );
      const setupExternalize = (filter, doExternalize) => {
        build.onResolve({ filter }, ({ path: path2 }) => {
          return {
            path: path2,
            external: doExternalize(path2)
          };
        });
      };
      setupExternalize(CSS_LANGS_RE, isUnlessEntry);
      setupExternalize(/\.(json|json5|wasm)$/, isUnlessEntry);
      setupExternalize(
        new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`),
        isUnlessEntry
      );
      setupExternalize(SPECIAL_QUERY_RE, () => true);
      build.onResolve(
        {
          filter: /.*/
        },
        async ({ path: id, importer }) => {
          const resolved = await resolve(id, importer);
          if (resolved) {
            if (shouldExternalizeDep(resolved, id) || !isScannable(resolved, optimizeDepsOptions.extensions)) {
              return externalUnlessEntry({ path: id });
            }
            const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
            return {
              path: path$b.resolve(cleanUrl(resolved)),
              namespace
            };
          } else {
            return externalUnlessEntry({ path: id });
          }
        }
      );
      build.onLoad({ filter: JS_TYPES_RE }, async ({ path: id }) => {
        let ext = path$b.extname(id).slice(1);
        if (ext === "mjs") ext = "js";
        const esbuildConfig = environment.config.esbuild;
        let contents = await fsp.readFile(id, "utf-8");
        if (ext.endsWith("x") && esbuildConfig && esbuildConfig.jsxInject) {
          contents = esbuildConfig.jsxInject + `
` + contents;
        }
        const loader = optimizeDepsOptions.esbuildOptions?.loader?.[`.${ext}`] ?? ext;
        if (contents.includes("import.meta.glob")) {
          return {
            loader: "js",
            // since it is transpiled,
            contents: await doTransformGlobImport(contents, id, loader)
          };
        }
        return {
          loader,
          contents
        };
      });
      build.onLoad({ filter: /.*/, namespace: "file" }, () => {
        return {
          loader: "js",
          contents: "export default {}"
        };
      });
    }
  };
}
function extractImportPaths(code) {
  code = code.replace(multilineCommentsRE, "/* */").replace(singlelineCommentsRE, "");
  let js = "";
  let m;
  importsRE.lastIndex = 0;
  while ((m = importsRE.exec(code)) != null) {
    js += `
import ${m[1]}`;
  }
  return js;
}
function shouldExternalizeDep(resolvedId, rawId) {
  if (!path$b.isAbsolute(resolvedId)) {
    return true;
  }
  if (resolvedId === rawId || resolvedId.includes("\0")) {
    return true;
  }
  return false;
}
function isScannable(id, extensions) {
  return JS_TYPES_RE.test(id) || htmlTypesRE.test(id) || extensions?.includes(path$b.extname(id)) || false;
}

function createOptimizeDepsIncludeResolver(environment) {
  const topLevelConfig = environment.getTopLevelConfig();
  const resolve = createBackCompatIdResolver(topLevelConfig, {
    asSrc: false,
    scan: true,
    packageCache: /* @__PURE__ */ new Map()
  });
  return async (id) => {
    const lastArrowIndex = id.lastIndexOf(">");
    if (lastArrowIndex === -1) {
      return await resolve(environment, id, void 0);
    }
    const nestedRoot = id.substring(0, lastArrowIndex).trim();
    const nestedPath = id.substring(lastArrowIndex + 1).trim();
    const basedir = nestedResolveBasedir(
      nestedRoot,
      topLevelConfig.root,
      topLevelConfig.resolve.preserveSymlinks
    );
    return await resolve(
      environment,
      nestedPath,
      path$b.resolve(basedir, "package.json")
    );
  };
}
function expandGlobIds(id, config) {
  const pkgName = getNpmPackageName(id);
  if (!pkgName) return [];
  const pkgData = resolvePackageData(
    pkgName,
    config.root,
    config.resolve.preserveSymlinks,
    config.packageCache
  );
  if (!pkgData) return [];
  const pattern = "." + id.slice(pkgName.length);
  const exports = pkgData.data.exports;
  if (exports) {
    if (typeof exports === "string" || Array.isArray(exports)) {
      return [pkgName];
    }
    const possibleExportPaths = [];
    for (const key in exports) {
      if (key[0] === ".") {
        if (key.includes("*")) {
          const exportsValue = getFirstExportStringValue(exports[key]);
          if (!exportsValue) continue;
          const exportValuePattern = exportsValue.replace(/\*/g, "**/*");
          const exportsValueGlobRe = new RegExp(
            exportsValue.split("*").map(escapeRegex).join("(.*)")
          );
          possibleExportPaths.push(
            ...globSync(exportValuePattern, {
              cwd: pkgData.dir,
              expandDirectories: false,
              ignore: ["node_modules"]
            }).map((filePath) => {
              if (exportsValue.startsWith("./")) {
                filePath = "./" + filePath;
              }
              const matched2 = exportsValueGlobRe.exec(slash$1(filePath));
              if (matched2) {
                let allGlobSame = matched2.length === 2;
                if (!allGlobSame) {
                  allGlobSame = true;
                  for (let i = 2; i < matched2.length; i++) {
                    if (matched2[i] !== matched2[i - 1]) {
                      allGlobSame = false;
                      break;
                    }
                  }
                }
                if (allGlobSame) {
                  return key.replace("*", matched2[1]).slice(2);
                }
              }
              return "";
            }).filter(Boolean)
          );
        } else {
          possibleExportPaths.push(key.slice(2));
        }
      }
    }
    const isMatch = picomatch$2(pattern);
    const matched = possibleExportPaths.filter((p) => isMatch(p)).map((match) => path$b.posix.join(pkgName, match));
    matched.unshift(pkgName);
    return matched;
  } else {
    const matched = globSync(pattern, {
      cwd: pkgData.dir,
      expandDirectories: false,
      ignore: ["node_modules"]
    }).map((match) => path$b.posix.join(pkgName, slash$1(match)));
    matched.unshift(pkgName);
    return matched;
  }
}
function getFirstExportStringValue(obj) {
  if (typeof obj === "string") {
    return obj;
  } else if (Array.isArray(obj)) {
    return obj[0];
  } else {
    for (const key in obj) {
      return getFirstExportStringValue(obj[key]);
    }
  }
}
function nestedResolveBasedir(id, basedir, preserveSymlinks = false) {
  const pkgs = id.split(">").map((pkg) => pkg.trim());
  for (const pkg of pkgs) {
    basedir = resolvePackageData(pkg, basedir, preserveSymlinks)?.dir || basedir;
  }
  return basedir;
}

const debug$f = createDebugger("vite:deps");
const jsExtensionRE = /\.js$/i;
const jsMapExtensionRE = /\.js\.map$/i;
function isDepOptimizationDisabled(optimizeDeps2) {
  return optimizeDeps2.disabled === true || optimizeDeps2.disabled === "dev" || !!optimizeDeps2.noDiscovery && !optimizeDeps2.include?.length;
}
async function optimizeDeps(config, force = config.optimizeDeps.force, asCommand = false) {
  const log = asCommand ? config.logger.info : debug$f;
  config.logger.warn(
    colors$1.yellow(
      "manually calling optimizeDeps is deprecated. This is done automatically and does not need to be called manually."
    )
  );
  const environment = new ScanEnvironment("client", config);
  await environment.init();
  const cachedMetadata = await loadCachedDepOptimizationMetadata(
    environment,
    force,
    asCommand
  );
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const deps = await discoverProjectDependencies(environment).result;
  await addManuallyIncludedOptimizeDeps(environment, deps);
  const depsString = depsLogString(Object.keys(deps));
  log?.(colors$1.green(`Optimizing dependencies:
  ${depsString}`));
  const depsInfo = toDiscoveredDependencies(environment, deps);
  const result = await runOptimizeDeps(environment, depsInfo).result;
  await result.commit();
  return result.metadata;
}
async function optimizeExplicitEnvironmentDeps(environment) {
  const cachedMetadata = await loadCachedDepOptimizationMetadata(
    environment,
    environment.config.optimizeDeps.force ?? false,
    false
  );
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const deps = {};
  await addManuallyIncludedOptimizeDeps(environment, deps);
  const depsInfo = toDiscoveredDependencies(environment, deps);
  const result = await runOptimizeDeps(environment, depsInfo).result;
  await result.commit();
  return result.metadata;
}
function initDepsOptimizerMetadata(environment, timestamp) {
  const { lockfileHash, configHash, hash } = getDepHash(environment);
  return {
    hash,
    lockfileHash,
    configHash,
    browserHash: getOptimizedBrowserHash(hash, {}, timestamp),
    optimized: {},
    chunks: {},
    discovered: {},
    depInfoList: []
  };
}
function addOptimizedDepInfo(metadata, type, depInfo) {
  metadata[type][depInfo.id] = depInfo;
  metadata.depInfoList.push(depInfo);
  return depInfo;
}
let firstLoadCachedDepOptimizationMetadata = true;
async function loadCachedDepOptimizationMetadata(environment, force = environment.config.optimizeDeps.force ?? false, asCommand = false) {
  const log = asCommand ? environment.logger.info : debug$f;
  if (firstLoadCachedDepOptimizationMetadata) {
    firstLoadCachedDepOptimizationMetadata = false;
    setTimeout(
      () => cleanupDepsCacheStaleDirs(environment.getTopLevelConfig()),
      0
    );
  }
  const depsCacheDir = getDepsCacheDir(environment);
  if (!force) {
    let cachedMetadata;
    try {
      const cachedMetadataPath = path$b.join(depsCacheDir, METADATA_FILENAME);
      cachedMetadata = parseDepsOptimizerMetadata(
        await fsp.readFile(cachedMetadataPath, "utf-8"),
        depsCacheDir
      );
    } catch {
    }
    if (cachedMetadata) {
      if (cachedMetadata.lockfileHash !== getLockfileHash(environment)) {
        environment.logger.info(
          "Re-optimizing dependencies because lockfile has changed",
          {
            timestamp: true
          }
        );
      } else if (cachedMetadata.configHash !== getConfigHash(environment)) {
        environment.logger.info(
          "Re-optimizing dependencies because vite config has changed",
          {
            timestamp: true
          }
        );
      } else {
        log?.(
          `(${environment.name}) Hash is consistent. Skipping. Use --force to override.`
        );
        return cachedMetadata;
      }
    }
  } else {
    environment.logger.info("Forced re-optimization of dependencies", {
      timestamp: true
    });
  }
  debug$f?.(
    `(${environment.name}) ${colors$1.green(`removing old cache dir ${depsCacheDir}`)}`
  );
  await fsp.rm(depsCacheDir, { recursive: true, force: true });
}
function discoverProjectDependencies(environment) {
  const { cancel, result } = scanImports(environment);
  return {
    cancel,
    result: result.then(({ deps, missing }) => {
      const missingIds = Object.keys(missing);
      if (missingIds.length) {
        throw new Error(
          `The following dependencies are imported but could not be resolved:

  ${missingIds.map(
            (id) => `${colors$1.cyan(id)} ${colors$1.white(
              colors$1.dim(`(imported by ${missing[id]})`)
            )}`
          ).join(`
  `)}

Are they installed?`
        );
      }
      return deps;
    })
  };
}
function toDiscoveredDependencies(environment, deps, timestamp) {
  const browserHash = getOptimizedBrowserHash(
    getDepHash(environment).hash,
    deps,
    timestamp
  );
  const discovered = {};
  for (const id in deps) {
    const src = deps[id];
    discovered[id] = {
      id,
      file: getOptimizedDepPath(environment, id),
      src,
      browserHash,
      exportsData: extractExportsData(environment, src)
    };
  }
  return discovered;
}
function depsLogString(qualifiedIds) {
  return colors$1.yellow(qualifiedIds.join(`, `));
}
function runOptimizeDeps(environment, depsInfo) {
  const optimizerContext = { cancelled: false };
  const depsCacheDir = getDepsCacheDir(environment);
  const processingCacheDir = getProcessingDepsCacheDir(environment);
  fs__default.mkdirSync(processingCacheDir, { recursive: true });
  debug$f?.(colors$1.green(`creating package.json in ${processingCacheDir}`));
  fs__default.writeFileSync(
    path$b.resolve(processingCacheDir, "package.json"),
    `{
  "type": "module"
}
`
  );
  const metadata = initDepsOptimizerMetadata(environment);
  metadata.browserHash = getOptimizedBrowserHash(
    metadata.hash,
    depsFromOptimizedDepInfo(depsInfo)
  );
  const qualifiedIds = Object.keys(depsInfo);
  let cleaned = false;
  let committed = false;
  const cleanUp = () => {
    if (!cleaned && !committed) {
      cleaned = true;
      debug$f?.(colors$1.green(`removing cache dir ${processingCacheDir}`));
      try {
        fs__default.rmSync(processingCacheDir, { recursive: true, force: true });
      } catch {
      }
    }
  };
  const successfulResult = {
    metadata,
    cancel: cleanUp,
    commit: async () => {
      if (cleaned) {
        throw new Error(
          "Can not commit a Deps Optimization run as it was cancelled"
        );
      }
      committed = true;
      const dataPath = path$b.join(processingCacheDir, METADATA_FILENAME);
      debug$f?.(
        colors$1.green(`creating ${METADATA_FILENAME} in ${processingCacheDir}`)
      );
      fs__default.writeFileSync(
        dataPath,
        stringifyDepsOptimizerMetadata(metadata, depsCacheDir)
      );
      const temporaryPath = depsCacheDir + getTempSuffix();
      const depsCacheDirPresent = fs__default.existsSync(depsCacheDir);
      if (isWindows$3) {
        if (depsCacheDirPresent) {
          debug$f?.(colors$1.green(`renaming ${depsCacheDir} to ${temporaryPath}`));
          await safeRename(depsCacheDir, temporaryPath);
        }
        debug$f?.(
          colors$1.green(`renaming ${processingCacheDir} to ${depsCacheDir}`)
        );
        await safeRename(processingCacheDir, depsCacheDir);
      } else {
        if (depsCacheDirPresent) {
          debug$f?.(colors$1.green(`renaming ${depsCacheDir} to ${temporaryPath}`));
          fs__default.renameSync(depsCacheDir, temporaryPath);
        }
        debug$f?.(
          colors$1.green(`renaming ${processingCacheDir} to ${depsCacheDir}`)
        );
        fs__default.renameSync(processingCacheDir, depsCacheDir);
      }
      if (depsCacheDirPresent) {
        debug$f?.(colors$1.green(`removing cache temp dir ${temporaryPath}`));
        fsp.rm(temporaryPath, { recursive: true, force: true });
      }
    }
  };
  if (!qualifiedIds.length) {
    return {
      cancel: async () => cleanUp(),
      result: Promise.resolve(successfulResult)
    };
  }
  const cancelledResult = {
    metadata,
    commit: async () => cleanUp(),
    cancel: cleanUp
  };
  const start = performance$1.now();
  const preparedRun = prepareEsbuildOptimizerRun(
    environment,
    depsInfo,
    processingCacheDir,
    optimizerContext
  );
  const runResult = preparedRun.then(({ context, idToExports }) => {
    function disposeContext() {
      return context?.dispose().catch((e) => {
        environment.logger.error("Failed to dispose esbuild context", {
          error: e
        });
      });
    }
    if (!context || optimizerContext.cancelled) {
      disposeContext();
      return cancelledResult;
    }
    return context.rebuild().then((result) => {
      const meta = result.metafile;
      const processingCacheDirOutputPath = path$b.relative(
        process.cwd(),
        processingCacheDir
      );
      for (const id in depsInfo) {
        const output = esbuildOutputFromId(
          meta.outputs,
          id,
          processingCacheDir
        );
        const { exportsData, ...info } = depsInfo[id];
        addOptimizedDepInfo(metadata, "optimized", {
          ...info,
          // We only need to hash the output.imports in to check for stability, but adding the hash
          // and file path gives us a unique hash that may be useful for other things in the future
          fileHash: getHash(
            metadata.hash + depsInfo[id].file + JSON.stringify(output.imports)
          ),
          browserHash: metadata.browserHash,
          // After bundling we have more information and can warn the user about legacy packages
          // that require manual configuration
          needsInterop: needsInterop(
            environment,
            id,
            idToExports[id],
            output
          )
        });
      }
      for (const o of Object.keys(meta.outputs)) {
        if (!jsMapExtensionRE.test(o)) {
          const id = path$b.relative(processingCacheDirOutputPath, o).replace(jsExtensionRE, "");
          const file = getOptimizedDepPath(environment, id);
          if (!findOptimizedDepInfoInRecord(
            metadata.optimized,
            (depInfo) => depInfo.file === file
          )) {
            addOptimizedDepInfo(metadata, "chunks", {
              id,
              file,
              needsInterop: false,
              browserHash: metadata.browserHash
            });
          }
        } else {
          const output = meta.outputs[o];
          if (output.bytes === 93) {
            const jsMapPath = path$b.resolve(o);
            const jsPath = jsMapPath.slice(0, -4);
            if (fs__default.existsSync(jsPath) && fs__default.existsSync(jsMapPath)) {
              const map = JSON.parse(fs__default.readFileSync(jsMapPath, "utf-8"));
              if (map.sources.length === 0) {
                const js = fs__default.readFileSync(jsPath, "utf-8");
                fs__default.writeFileSync(
                  jsPath,
                  js.slice(0, js.lastIndexOf("//# sourceMappingURL="))
                );
              }
            }
          }
        }
      }
      debug$f?.(
        `Dependencies bundled in ${(performance$1.now() - start).toFixed(2)}ms`
      );
      return successfulResult;
    }).catch((e) => {
      if (e.errors && e.message.includes("The build was canceled")) {
        return cancelledResult;
      }
      throw e;
    }).finally(() => {
      return disposeContext();
    });
  });
  runResult.catch(() => {
    cleanUp();
  });
  return {
    async cancel() {
      optimizerContext.cancelled = true;
      const { context } = await preparedRun;
      await context?.cancel();
      cleanUp();
    },
    result: runResult
  };
}
async function prepareEsbuildOptimizerRun(environment, depsInfo, processingCacheDir, optimizerContext) {
  const flatIdDeps = {};
  const idToExports = {};
  const { optimizeDeps: optimizeDeps2 } = environment.config;
  const { plugins: pluginsFromConfig = [], ...esbuildOptions } = optimizeDeps2.esbuildOptions ?? {};
  await Promise.all(
    Object.keys(depsInfo).map(async (id) => {
      const src = depsInfo[id].src;
      const exportsData = await (depsInfo[id].exportsData ?? extractExportsData(environment, src));
      if (exportsData.jsxLoader && !esbuildOptions.loader?.[".js"]) {
        esbuildOptions.loader = {
          ".js": "jsx",
          ...esbuildOptions.loader
        };
      }
      const flatId = flattenId(id);
      flatIdDeps[flatId] = src;
      idToExports[id] = exportsData;
    })
  );
  if (optimizerContext.cancelled) return { context: void 0, idToExports };
  const define = {
    "process.env.NODE_ENV": environment.config.keepProcessEnv ? (
      // define process.env.NODE_ENV even for keepProcessEnv === true
      // as esbuild will replace it automatically when `platform` is `'browser'`
      "process.env.NODE_ENV"
    ) : JSON.stringify(process.env.NODE_ENV || environment.config.mode)
  };
  const platform = optimizeDeps2.esbuildOptions?.platform ?? // We generally don't want to use platform 'neutral', as esbuild has custom handling
  // when the platform is 'node' or 'browser' that can't be emulated by using mainFields
  // and conditions
  (environment.config.consumer === "client" || environment.config.ssr.target === "webworker" ? "browser" : "node");
  const external = [...optimizeDeps2.exclude ?? []];
  const plugins = [...pluginsFromConfig];
  if (external.length) {
    plugins.push(esbuildCjsExternalPlugin(external, platform));
  }
  plugins.push(esbuildDepPlugin(environment, flatIdDeps, external));
  const context = await esbuild.context({
    absWorkingDir: process.cwd(),
    entryPoints: Object.keys(flatIdDeps),
    bundle: true,
    platform,
    define,
    format: "esm",
    // See https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694
    banner: platform === "node" ? {
      js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`
    } : void 0,
    target: ESBUILD_MODULES_TARGET,
    external,
    logLevel: "error",
    splitting: true,
    sourcemap: true,
    outdir: processingCacheDir,
    ignoreAnnotations: true,
    metafile: true,
    plugins,
    charset: "utf8",
    ...esbuildOptions,
    supported: {
      ...defaultEsbuildSupported,
      ...esbuildOptions.supported
    }
  });
  return { context, idToExports };
}
async function addManuallyIncludedOptimizeDeps(environment, deps) {
  const { logger } = environment;
  const { optimizeDeps: optimizeDeps2 } = environment.config;
  const optimizeDepsInclude = optimizeDeps2.include ?? [];
  if (optimizeDepsInclude.length) {
    const unableToOptimize = (id, msg) => {
      if (optimizeDepsInclude.includes(id)) {
        logger.warn(
          `${msg}: ${colors$1.cyan(id)}, present in ${environment.name} 'optimizeDeps.include'`
        );
      }
    };
    const includes = [...optimizeDepsInclude];
    for (let i = 0; i < includes.length; i++) {
      const id = includes[i];
      if (isDynamicPattern(id)) {
        const globIds = expandGlobIds(id, environment.getTopLevelConfig());
        includes.splice(i, 1, ...globIds);
        i += globIds.length - 1;
      }
    }
    const resolve = createOptimizeDepsIncludeResolver(environment);
    for (const id of includes) {
      const normalizedId = normalizeId(id);
      if (!deps[normalizedId]) {
        const entry = await resolve(id);
        if (entry) {
          if (isOptimizable(entry, optimizeDeps2)) {
            deps[normalizedId] = entry;
          } else {
            unableToOptimize(id, "Cannot optimize dependency");
          }
        } else {
          unableToOptimize(id, "Failed to resolve dependency");
        }
      }
    }
  }
}
function depsFromOptimizedDepInfo(depsInfo) {
  const obj = {};
  for (const key in depsInfo) {
    obj[key] = depsInfo[key].src;
  }
  return obj;
}
function getOptimizedDepPath(environment, id) {
  return normalizePath$3(
    path$b.resolve(getDepsCacheDir(environment), flattenId(id) + ".js")
  );
}
function getDepsCacheSuffix(environment) {
  return environment.name === "client" ? "" : `_${environment.name}`;
}
function getDepsCacheDir(environment) {
  return getDepsCacheDirPrefix(environment) + getDepsCacheSuffix(environment);
}
function getProcessingDepsCacheDir(environment) {
  return getDepsCacheDirPrefix(environment) + getDepsCacheSuffix(environment) + getTempSuffix();
}
function getTempSuffix() {
  return "_temp_" + getHash(
    `${process.pid}:${Date.now().toString()}:${Math.random().toString(16).slice(2)}`
  );
}
function getDepsCacheDirPrefix(environment) {
  return normalizePath$3(path$b.resolve(environment.config.cacheDir, "deps"));
}
function createIsOptimizedDepFile(environment) {
  const depsCacheDirPrefix = getDepsCacheDirPrefix(environment);
  return (id) => id.startsWith(depsCacheDirPrefix);
}
function createIsOptimizedDepUrl(environment) {
  const { root } = environment.config;
  const depsCacheDir = getDepsCacheDirPrefix(environment);
  const depsCacheDirRelative = normalizePath$3(path$b.relative(root, depsCacheDir));
  const depsCacheDirPrefix = depsCacheDirRelative.startsWith("../") ? (
    // if the cache directory is outside root, the url prefix would be something
    // like '/@fs/absolute/path/to/node_modules/.vite'
    `/@fs/${removeLeadingSlash(normalizePath$3(depsCacheDir))}`
  ) : (
    // if the cache directory is inside root, the url prefix would be something
    // like '/node_modules/.vite'
    `/${depsCacheDirRelative}`
  );
  return function isOptimizedDepUrl(url) {
    return url.startsWith(depsCacheDirPrefix);
  };
}
function parseDepsOptimizerMetadata(jsonMetadata, depsCacheDir) {
  const { hash, lockfileHash, configHash, browserHash, optimized, chunks } = JSON.parse(jsonMetadata, (key, value) => {
    if (key === "file" || key === "src") {
      return normalizePath$3(path$b.resolve(depsCacheDir, value));
    }
    return value;
  });
  if (!chunks || Object.values(optimized).some((depInfo) => !depInfo.fileHash)) {
    return;
  }
  const metadata = {
    hash,
    lockfileHash,
    configHash,
    browserHash,
    optimized: {},
    discovered: {},
    chunks: {},
    depInfoList: []
  };
  for (const id of Object.keys(optimized)) {
    addOptimizedDepInfo(metadata, "optimized", {
      ...optimized[id],
      id,
      browserHash
    });
  }
  for (const id of Object.keys(chunks)) {
    addOptimizedDepInfo(metadata, "chunks", {
      ...chunks[id],
      id,
      browserHash,
      needsInterop: false
    });
  }
  return metadata;
}
function stringifyDepsOptimizerMetadata(metadata, depsCacheDir) {
  const { hash, configHash, lockfileHash, browserHash, optimized, chunks } = metadata;
  return JSON.stringify(
    {
      hash,
      configHash,
      lockfileHash,
      browserHash,
      optimized: Object.fromEntries(
        Object.values(optimized).map(
          ({ id, src, file, fileHash, needsInterop: needsInterop2 }) => [
            id,
            {
              src,
              file,
              fileHash,
              needsInterop: needsInterop2
            }
          ]
        )
      ),
      chunks: Object.fromEntries(
        Object.values(chunks).map(({ id, file }) => [id, { file }])
      )
    },
    (key, value) => {
      if (key === "file" || key === "src") {
        return normalizePath$3(path$b.relative(depsCacheDir, value));
      }
      return value;
    },
    2
  );
}
function esbuildOutputFromId(outputs, id, cacheDirOutputPath) {
  const cwd = process.cwd();
  const flatId = flattenId(id) + ".js";
  const normalizedOutputPath = normalizePath$3(
    path$b.relative(cwd, path$b.join(cacheDirOutputPath, flatId))
  );
  const output = outputs[normalizedOutputPath];
  if (output) {
    return output;
  }
  for (const [key, value] of Object.entries(outputs)) {
    if (normalizePath$3(path$b.relative(cwd, key)) === normalizedOutputPath) {
      return value;
    }
  }
}
async function extractExportsData(environment, filePath) {
  await init;
  const { optimizeDeps: optimizeDeps2 } = environment.config;
  const esbuildOptions = optimizeDeps2.esbuildOptions ?? {};
  if (optimizeDeps2.extensions?.some((ext) => filePath.endsWith(ext))) {
    const result = await build$3({
      ...esbuildOptions,
      entryPoints: [filePath],
      write: false,
      format: "esm"
    });
    const [, exports2, , hasModuleSyntax2] = parse$d(result.outputFiles[0].text);
    return {
      hasModuleSyntax: hasModuleSyntax2,
      exports: exports2.map((e) => e.n)
    };
  }
  let parseResult;
  let usedJsxLoader = false;
  const entryContent = await fsp.readFile(filePath, "utf-8");
  try {
    parseResult = parse$d(entryContent);
  } catch {
    const loader = esbuildOptions.loader?.[path$b.extname(filePath)] || "jsx";
    debug$f?.(
      `Unable to parse: ${filePath}.
 Trying again with a ${loader} transform.`
    );
    const transformed = await transformWithEsbuild(
      entryContent,
      filePath,
      { loader },
      void 0,
      environment.config
    );
    parseResult = parse$d(transformed.code);
    usedJsxLoader = true;
  }
  const [, exports, , hasModuleSyntax] = parseResult;
  const exportsData = {
    hasModuleSyntax,
    exports: exports.map((e) => e.n),
    jsxLoader: usedJsxLoader
  };
  return exportsData;
}
function needsInterop(environment, id, exportsData, output) {
  if (environment.config.optimizeDeps.needsInterop?.includes(id)) {
    return true;
  }
  const { hasModuleSyntax, exports } = exportsData;
  if (!hasModuleSyntax) {
    return true;
  }
  if (output) {
    const generatedExports = output.exports;
    if (isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports)) {
      return true;
    }
  }
  return false;
}
function isSingleDefaultExport(exports) {
  return exports.length === 1 && exports[0] === "default";
}
const lockfileFormats = [
  {
    path: "node_modules/.package-lock.json",
    checkPatchesDir: "patches",
    manager: "npm"
  },
  {
    // Yarn non-PnP
    path: "node_modules/.yarn-state.yml",
    checkPatchesDir: false,
    manager: "yarn"
  },
  {
    // Yarn v3+ PnP
    path: ".pnp.cjs",
    checkPatchesDir: ".yarn/patches",
    manager: "yarn"
  },
  {
    // Yarn v2 PnP
    path: ".pnp.js",
    checkPatchesDir: ".yarn/patches",
    manager: "yarn"
  },
  {
    // yarn 1
    path: "node_modules/.yarn-integrity",
    checkPatchesDir: "patches",
    manager: "yarn"
  },
  {
    path: "node_modules/.pnpm/lock.yaml",
    // Included in lockfile
    checkPatchesDir: false,
    manager: "pnpm"
  },
  {
    path: "bun.lock",
    checkPatchesDir: "patches",
    manager: "bun"
  },
  {
    path: "bun.lockb",
    checkPatchesDir: "patches",
    manager: "bun"
  }
].sort((_, { manager }) => {
  return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1;
});
const lockfilePaths = lockfileFormats.map((l) => l.path);
function getConfigHash(environment) {
  const { config } = environment;
  const { optimizeDeps: optimizeDeps2 } = config;
  const content = JSON.stringify(
    {
      define: !config.keepProcessEnv ? process.env.NODE_ENV || config.mode : null,
      root: config.root,
      resolve: config.resolve,
      assetsInclude: config.assetsInclude,
      plugins: config.plugins.map((p) => p.name),
      optimizeDeps: {
        include: optimizeDeps2.include ? unique(optimizeDeps2.include).sort() : void 0,
        exclude: optimizeDeps2.exclude ? unique(optimizeDeps2.exclude).sort() : void 0,
        esbuildOptions: {
          ...optimizeDeps2.esbuildOptions,
          plugins: optimizeDeps2.esbuildOptions?.plugins?.map((p) => p.name)
        }
      }
    },
    (_, value) => {
      if (typeof value === "function" || value instanceof RegExp) {
        return value.toString();
      }
      return value;
    }
  );
  return getHash(content);
}
function getLockfileHash(environment) {
  const lockfilePath = lookupFile(environment.config.root, lockfilePaths);
  let content = lockfilePath ? fs__default.readFileSync(lockfilePath, "utf-8") : "";
  if (lockfilePath) {
    const normalizedLockfilePath = lockfilePath.replaceAll("\\", "/");
    const lockfileFormat = lockfileFormats.find(
      (f) => normalizedLockfilePath.endsWith(f.path)
    );
    if (lockfileFormat.checkPatchesDir) {
      const baseDir = lockfilePath.slice(0, -lockfileFormat.path.length);
      const fullPath = path$b.join(
        baseDir,
        lockfileFormat.checkPatchesDir
      );
      const stat = tryStatSync(fullPath);
      if (stat?.isDirectory()) {
        content += stat.mtimeMs.toString();
      }
    }
  }
  return getHash(content);
}
function getDepHash(environment) {
  const lockfileHash = getLockfileHash(environment);
  const configHash = getConfigHash(environment);
  const hash = getHash(lockfileHash + configHash);
  return {
    hash,
    lockfileHash,
    configHash
  };
}
function getOptimizedBrowserHash(hash, deps, timestamp = "") {
  return getHash(hash + JSON.stringify(deps) + timestamp);
}
function optimizedDepInfoFromId(metadata, id) {
  return metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id];
}
function optimizedDepInfoFromFile(metadata, file) {
  return metadata.depInfoList.find((depInfo) => depInfo.file === file);
}
function findOptimizedDepInfoInRecord(dependenciesInfo, callbackFn) {
  for (const o of Object.keys(dependenciesInfo)) {
    const info = dependenciesInfo[o];
    if (callbackFn(info, o)) {
      return info;
    }
  }
}
async function optimizedDepNeedsInterop(environment, metadata, file) {
  const depInfo = optimizedDepInfoFromFile(metadata, file);
  if (depInfo?.src && depInfo.needsInterop === void 0) {
    depInfo.exportsData ??= extractExportsData(environment, depInfo.src);
    depInfo.needsInterop = needsInterop(
      environment,
      depInfo.id,
      await depInfo.exportsData
    );
  }
  return depInfo?.needsInterop;
}
const MAX_TEMP_DIR_AGE_MS = 24 * 60 * 60 * 1e3;
async function cleanupDepsCacheStaleDirs(config) {
  try {
    const cacheDir = path$b.resolve(config.cacheDir);
    if (fs__default.existsSync(cacheDir)) {
      const dirents = await fsp.readdir(cacheDir, { withFileTypes: true });
      for (const dirent of dirents) {
        if (dirent.isDirectory() && dirent.name.includes("_temp_")) {
          const tempDirPath = path$b.resolve(config.cacheDir, dirent.name);
          const stats = await fsp.stat(tempDirPath).catch(() => null);
          if (stats?.mtime && Date.now() - stats.mtime.getTime() > MAX_TEMP_DIR_AGE_MS) {
            debug$f?.(`removing stale cache temp dir ${tempDirPath}`);
            await fsp.rm(tempDirPath, { recursive: true, force: true });
          }
        }
      }
    }
  } catch (err) {
    config.logger.error(err);
  }
}
const GRACEFUL_RENAME_TIMEOUT = 5e3;
const safeRename = promisify$4(function gracefulRename(from, to, cb) {
  const start = Date.now();
  let backoff = 0;
  fs__default.rename(from, to, function CB(er) {
    if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
      setTimeout(function() {
        fs__default.stat(to, function(stater, _st) {
          if (stater && stater.code === "ENOENT") fs__default.rename(from, to, CB);
          else CB(er);
        });
      }, backoff);
      if (backoff < 100) backoff += 10;
      return;
    }
    cb(er);
  });
});

var index$1 = {
	__proto__: null,
	addManuallyIncludedOptimizeDeps: addManuallyIncludedOptimizeDeps,
	addOptimizedDepInfo: addOptimizedDepInfo,
	cleanupDepsCacheStaleDirs: cleanupDepsCacheStaleDirs,
	createIsOptimizedDepFile: createIsOptimizedDepFile,
	createIsOptimizedDepUrl: createIsOptimizedDepUrl,
	depsFromOptimizedDepInfo: depsFromOptimizedDepInfo,
	depsLogString: depsLogString,
	discoverProjectDependencies: discoverProjectDependencies,
	extractExportsData: extractExportsData,
	getDepsCacheDir: getDepsCacheDir,
	getOptimizedDepPath: getOptimizedDepPath,
	initDepsOptimizerMetadata: initDepsOptimizerMetadata,
	isDepOptimizationDisabled: isDepOptimizationDisabled,
	loadCachedDepOptimizationMetadata: loadCachedDepOptimizationMetadata,
	optimizeDeps: optimizeDeps,
	optimizeExplicitEnvironmentDeps: optimizeExplicitEnvironmentDeps,
	optimizedDepInfoFromFile: optimizedDepInfoFromFile,
	optimizedDepInfoFromId: optimizedDepInfoFromId,
	optimizedDepNeedsInterop: optimizedDepNeedsInterop,
	runOptimizeDeps: runOptimizeDeps,
	toDiscoveredDependencies: toDiscoveredDependencies
};

const debug$e = createDebugger("vite:external");
const isExternalCache = /* @__PURE__ */ new WeakMap();
function shouldExternalize(environment, id, importer) {
  let isExternal = isExternalCache.get(environment);
  if (!isExternal) {
    isExternal = createIsExternal(environment);
    isExternalCache.set(environment, isExternal);
  }
  return isExternal(id, importer);
}
function createIsConfiguredAsExternal(environment) {
  const { config } = environment;
  const { root, resolve } = config;
  const { external, noExternal } = resolve;
  const noExternalFilter = typeof noExternal !== "boolean" && !(Array.isArray(noExternal) && noExternal.length === 0) && createFilter$1(void 0, noExternal, { resolve: false });
  const targetConditions = resolve.externalConditions;
  const resolveOptions = {
    ...resolve,
    root,
    isProduction: false,
    isBuild: true,
    conditions: targetConditions
  };
  const isExternalizable = (id, importer, configuredAsExternal) => {
    if (!bareImportRE.test(id) || id.includes("\0")) {
      return false;
    }
    try {
      const resolved = tryNodeResolve(
        id,
        // Skip passing importer in build to avoid externalizing non-hoisted dependencies
        // unresolvable from root (which would be unresolvable from output bundles also)
        config.command === "build" ? void 0 : importer,
        resolveOptions,
        void 0,
        false
      );
      if (!resolved) {
        return false;
      }
      if (!configuredAsExternal && !isInNodeModules$1(resolved.id)) {
        return false;
      }
      return canExternalizeFile(resolved.id);
    } catch {
      debug$e?.(
        `Failed to node resolve "${id}". Skipping externalizing it by default.`
      );
      return false;
    }
  };
  return (id, importer) => {
    if (
      // If this id is defined as external, force it as external
      // Note that individual package entries are allowed in `external`
      external !== true && external.includes(id)
    ) {
      return true;
    }
    const pkgName = getNpmPackageName(id);
    if (!pkgName) {
      return isExternalizable(id, importer, false);
    }
    if (
      // A package name in ssr.external externalizes every
      // externalizable package entry
      external !== true && external.includes(pkgName)
    ) {
      return isExternalizable(id, importer, true);
    }
    if (typeof noExternal === "boolean") {
      return !noExternal;
    }
    if (noExternalFilter && !noExternalFilter(pkgName)) {
      return false;
    }
    return isExternalizable(id, importer, external === true);
  };
}
function createIsExternal(environment) {
  const processedIds = /* @__PURE__ */ new Map();
  const isConfiguredAsExternal = createIsConfiguredAsExternal(environment);
  return (id, importer) => {
    if (processedIds.has(id)) {
      return processedIds.get(id);
    }
    let isExternal = false;
    if (id[0] !== "." && !path$b.isAbsolute(id)) {
      isExternal = isBuiltin(environment.config.resolve.builtins, id) || isConfiguredAsExternal(id, importer);
    }
    processedIds.set(id, isExternal);
    return isExternal;
  };
}
function canExternalizeFile(filePath) {
  const ext = path$b.extname(filePath);
  return !ext || ext === ".js" || ext === ".mjs" || ext === ".cjs";
}

const normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
const normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
const ERR_RESOLVE_PACKAGE_ENTRY_FAIL = "ERR_RESOLVE_PACKAGE_ENTRY_FAIL";
const browserExternalId = "__vite-browser-external";
const optionalPeerDepId = "__vite-optional-peer-dep";
const subpathImportsPrefix = "#";
const startsWithWordCharRE = /^\w/;
const debug$d = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function resolvePlugin(resolveOptions) {
  const { root, isProduction, asSrc, preferRelative = false } = resolveOptions;
  const rootInRoot = tryStatSync(path$b.join(root, root))?.isDirectory() ?? false;
  return {
    name: "vite:resolve",
    async resolveId(id, importer, resolveOpts) {
      if (id[0] === "\0" || id.startsWith("virtual:") || // When injected directly in html/client code
      id.startsWith("/virtual:")) {
        return;
      }
      const depsOptimizer = resolveOptions.optimizeDeps && this.environment.mode === "dev" ? this.environment.depsOptimizer : void 0;
      if (id.startsWith(browserExternalId)) {
        return id;
      }
      const isRequire = resolveOpts.custom?.["node-resolve"]?.isRequire ?? false;
      const currentEnvironmentOptions = this.environment.config;
      const options = {
        isRequire,
        ...currentEnvironmentOptions.resolve,
        ...resolveOptions,
        // plugin options + resolve options overrides
        scan: resolveOpts.scan ?? resolveOptions.scan
      };
      const resolvedImports = resolveSubpathImports(id, importer, options);
      if (resolvedImports) {
        id = resolvedImports;
        if (resolveOpts.custom?.["vite:import-glob"]?.isSubImportsPattern) {
          return normalizePath$3(path$b.join(root, id));
        }
      }
      let res;
      if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) {
        const optimizedPath = id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath$3(path$b.resolve(root, id.slice(1)));
        return optimizedPath;
      }
      if (asSrc && id.startsWith(FS_PREFIX)) {
        res = fsPathFromId(id);
        debug$d?.(`[@fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        return ensureVersionQuery(res, id, options, depsOptimizer);
      }
      if (asSrc && id[0] === "/" && (rootInRoot || !id.startsWith(withTrailingSlash(root)))) {
        const fsPath = path$b.resolve(root, id.slice(1));
        if (res = tryFsResolve(fsPath, options)) {
          debug$d?.(`[url] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          return ensureVersionQuery(res, id, options, depsOptimizer);
        }
      }
      if (id[0] === "." || (preferRelative || importer?.endsWith(".html")) && startsWithWordCharRE.test(id)) {
        const basedir = importer ? path$b.dirname(importer) : process.cwd();
        const fsPath = path$b.resolve(basedir, id);
        const normalizedFsPath = normalizePath$3(fsPath);
        if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
          if (!options.isBuild && !DEP_VERSION_RE.test(normalizedFsPath)) {
            const browserHash = optimizedDepInfoFromFile(
              depsOptimizer.metadata,
              normalizedFsPath
            )?.browserHash;
            if (browserHash) {
              return injectQuery(normalizedFsPath, `v=${browserHash}`);
            }
          }
          return normalizedFsPath;
        }
        if (options.mainFields.includes("browser") && (res = tryResolveBrowserMapping(fsPath, importer, options, true))) {
          return res;
        }
        if (res = tryFsResolve(fsPath, options)) {
          res = ensureVersionQuery(res, id, options, depsOptimizer);
          debug$d?.(`[relative] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          if (!options.idOnly && !options.scan && options.isBuild) {
            const resPkg = findNearestPackageData(
              path$b.dirname(res),
              options.packageCache
            );
            if (resPkg) {
              return {
                id: res,
                moduleSideEffects: resPkg.hasSideEffects(res)
              };
            }
          }
          return res;
        }
      }
      if (id.startsWith("file://")) {
        const { file, postfix } = splitFileAndPostfix(id);
        id = fileURLToPath$1(file) + postfix;
      }
      if (isWindows$3 && id[0] === "/") {
        const basedir = importer ? path$b.dirname(importer) : process.cwd();
        const fsPath = path$b.resolve(basedir, id);
        if (res = tryFsResolve(fsPath, options)) {
          debug$d?.(`[drive-relative] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
          return ensureVersionQuery(res, id, options, depsOptimizer);
        }
      }
      if (isNonDriveRelativeAbsolutePath(id) && (res = tryFsResolve(id, options))) {
        debug$d?.(`[fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        return ensureVersionQuery(res, id, options, depsOptimizer);
      }
      if (isExternalUrl(id)) {
        return options.idOnly ? id : { id, external: true };
      }
      if (isDataUrl(id)) {
        return null;
      }
      if (bareImportRE.test(id)) {
        const external = options.externalize && options.isBuild && currentEnvironmentOptions.consumer === "server" && shouldExternalize(this.environment, id, importer);
        if (!external && asSrc && depsOptimizer && !options.scan && (res = await tryOptimizedResolve(
          depsOptimizer,
          id,
          importer,
          options.preserveSymlinks,
          options.packageCache
        ))) {
          return res;
        }
        if (options.mainFields.includes("browser") && (res = tryResolveBrowserMapping(
          id,
          importer,
          options,
          false,
          external
        ))) {
          return res;
        }
        if (res = tryNodeResolve(id, importer, options, depsOptimizer, external)) {
          return res;
        }
        if (currentEnvironmentOptions.consumer === "server" && isBuiltin(options.builtins, id)) {
          return options.idOnly ? id : { id, external: true, moduleSideEffects: false };
        } else if (currentEnvironmentOptions.consumer === "server" && isNodeLikeBuiltin(id)) {
          if (!(options.external === true || options.external.includes(id))) {
            let message = `Automatically externalized node built-in module "${id}"`;
            if (importer) {
              message += ` imported from "${path$b.relative(
                process.cwd(),
                importer
              )}"`;
            }
            message += `. Consider adding it to environments.${this.environment.name}.external if it is intended.`;
            this.warn(message);
          }
          return options.idOnly ? id : { id, external: true, moduleSideEffects: false };
        } else if (currentEnvironmentOptions.consumer === "client" && isNodeLikeBuiltin(id)) {
          if (options.noExternal === true && // if both noExternal and external are true, noExternal will take the higher priority and bundle it.
          // only if the id is explicitly listed in external, we will externalize it and skip this error.
          (options.external === true || !options.external.includes(id))) {
            let message = `Cannot bundle built-in module "${id}"`;
            if (importer) {
              message += ` imported from "${path$b.relative(
                process.cwd(),
                importer
              )}"`;
            }
            message += `. Consider disabling environments.${this.environment.name}.noExternal or remove the built-in dependency.`;
            this.error(message);
          }
          if (!asSrc) {
            debug$d?.(
              `externalized node built-in "${id}" to empty module. (imported by: ${colors$1.white(colors$1.dim(importer))})`
            );
          } else if (isProduction) {
            this.warn(
              `Module "${id}" has been externalized for browser compatibility, imported by "${importer}". See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`
            );
          }
          return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
        }
      }
      debug$d?.(`[fallthrough] ${colors$1.dim(id)}`);
    },
    load: {
      handler(id) {
        if (id.startsWith(browserExternalId)) {
          if (isProduction) {
            return `export default {}`;
          } else {
            id = id.slice(browserExternalId.length + 1);
            return `  export default new Proxy({}, {
    get(_, key) {
      throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  })`;
          }
        }
        if (id.startsWith(optionalPeerDepId)) {
          if (isProduction) {
            return `export default {}`;
          } else {
            const [, peerDep, parentDep] = id.split(":");
            return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`;
          }
        }
      }
    }
  };
}
function resolveSubpathImports(id, importer, options) {
  if (!importer || !id.startsWith(subpathImportsPrefix)) return;
  const basedir = path$b.dirname(importer);
  const pkgData = findNearestPackageData(basedir, options.packageCache);
  if (!pkgData) return;
  let { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id.slice(1));
  idWithoutPostfix = "#" + idWithoutPostfix;
  let importsPath = resolveExportsOrImports(
    pkgData.data,
    idWithoutPostfix,
    options,
    "imports"
  );
  if (importsPath?.[0] === ".") {
    importsPath = path$b.relative(basedir, path$b.join(pkgData.dir, importsPath));
    if (importsPath[0] !== ".") {
      importsPath = `./${importsPath}`;
    }
  }
  return importsPath + postfix;
}
function ensureVersionQuery(resolved, id, options, depsOptimizer) {
  if (!options.isBuild && !options.scan && depsOptimizer && !(resolved === normalizedClientEntry$1 || resolved === normalizedEnvEntry$1)) {
    const isNodeModule = isInNodeModules$1(id) || isInNodeModules$1(resolved);
    if (isNodeModule && !DEP_VERSION_RE.test(resolved)) {
      const versionHash = depsOptimizer.metadata.browserHash;
      if (versionHash && isOptimizable(resolved, depsOptimizer.options)) {
        resolved = injectQuery(resolved, `v=${versionHash}`);
      }
    }
  }
  return resolved;
}
function tryFsResolve(fsPath, options, tryIndex = true, skipPackageJson = false) {
  const hashIndex = fsPath.indexOf("#");
  if (hashIndex >= 0 && isInNodeModules$1(fsPath)) {
    const queryIndex = fsPath.indexOf("?");
    if (queryIndex < 0 || queryIndex > hashIndex) {
      const file2 = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath;
      const res2 = tryCleanFsResolve(file2, options, tryIndex, skipPackageJson);
      if (res2) return res2 + fsPath.slice(file2.length);
    }
  }
  const { file, postfix } = splitFileAndPostfix(fsPath);
  const res = tryCleanFsResolve(file, options, tryIndex, skipPackageJson);
  if (res) return res + postfix;
}
const knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/;
const isPossibleTsOutput = (url) => knownTsOutputRE.test(url);
function tryCleanFsResolve(file, options, tryIndex = true, skipPackageJson = false) {
  const { tryPrefix, extensions, preserveSymlinks } = options;
  const fileResult = tryResolveRealFileOrType(file, options.preserveSymlinks);
  if (fileResult?.path) return fileResult.path;
  let res;
  const possibleJsToTs = isPossibleTsOutput(file);
  if (possibleJsToTs || options.extensions.length || tryPrefix) {
    const dirPath = path$b.dirname(file);
    if (isDirectory(dirPath)) {
      if (possibleJsToTs) {
        const fileExt = path$b.extname(file);
        const fileName = file.slice(0, -fileExt.length);
        if (res = tryResolveRealFile(
          fileName + fileExt.replace("js", "ts"),
          preserveSymlinks
        ))
          return res;
        if (fileExt === ".js" && (res = tryResolveRealFile(fileName + ".tsx", preserveSymlinks)))
          return res;
      }
      if (res = tryResolveRealFileWithExtensions(
        file,
        extensions,
        preserveSymlinks
      ))
        return res;
      if (tryPrefix) {
        const prefixed = `${dirPath}/${options.tryPrefix}${path$b.basename(file)}`;
        if (res = tryResolveRealFile(prefixed, preserveSymlinks)) return res;
        if (res = tryResolveRealFileWithExtensions(
          prefixed,
          extensions,
          preserveSymlinks
        ))
          return res;
      }
    }
  }
  if (tryIndex && fileResult?.type === "directory") {
    const dirPath = file;
    if (!skipPackageJson) {
      let pkgPath = `${dirPath}/package.json`;
      try {
        if (fs__default.existsSync(pkgPath)) {
          if (!options.preserveSymlinks) {
            pkgPath = safeRealpathSync(pkgPath);
          }
          const pkg = loadPackageData(pkgPath);
          return resolvePackageEntry(dirPath, pkg, options);
        }
      } catch (e) {
        if (e.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e.code !== "ENOENT")
          throw e;
      }
    }
    if (res = tryResolveRealFileWithExtensions(
      `${dirPath}/index`,
      extensions,
      preserveSymlinks
    ))
      return res;
    if (tryPrefix) {
      if (res = tryResolveRealFileWithExtensions(
        `${dirPath}/${options.tryPrefix}index`,
        extensions,
        preserveSymlinks
      ))
        return res;
    }
  }
}
function tryNodeResolve(id, importer, options, depsOptimizer, externalize) {
  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options;
  const deepMatch = deepImportRE.exec(id);
  const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id);
  let basedir;
  if (dedupe.includes(pkgId)) {
    basedir = root;
  } else if (importer && path$b.isAbsolute(importer) && // css processing appends `*` for importer
  (importer.endsWith("*") || fs__default.existsSync(cleanUrl(importer)))) {
    basedir = path$b.dirname(importer);
  } else {
    basedir = root;
  }
  const isModuleBuiltin = (id2) => isBuiltin(options.builtins, id2);
  let selfPkg = null;
  if (!isModuleBuiltin(id) && !id.includes("\0") && bareImportRE.test(id)) {
    const selfPackageData = findNearestPackageData(basedir, packageCache);
    selfPkg = selfPackageData?.data.exports && selfPackageData.data.name === pkgId ? selfPackageData : null;
  }
  const pkg = selfPkg || resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache);
  if (!pkg) {
    if (basedir !== root && // root has no peer dep
    !isModuleBuiltin(id) && !id.includes("\0") && bareImportRE.test(id)) {
      const mainPkg = findNearestMainPackageData(basedir, packageCache)?.data;
      if (mainPkg) {
        const pkgName = getNpmPackageName(id);
        if (pkgName != null && mainPkg.peerDependencies?.[pkgName] && mainPkg.peerDependenciesMeta?.[pkgName]?.optional) {
          return {
            id: `${optionalPeerDepId}:${id}:${mainPkg.name}`
          };
        }
      }
    }
    return;
  }
  const resolveId = deepMatch ? resolveDeepImport : resolvePackageEntry;
  const unresolvedId = deepMatch ? "." + id.slice(pkgId.length) : id;
  let resolved = resolveId(unresolvedId, pkg, options);
  if (!resolved) {
    return;
  }
  const processResult = (resolved2) => {
    if (!externalize) {
      return resolved2;
    }
    if (!canExternalizeFile(resolved2.id)) {
      return resolved2;
    }
    let resolvedId = id;
    if (deepMatch && !pkg.data.exports && path$b.extname(id) !== path$b.extname(resolved2.id)) {
      const index = resolved2.id.indexOf(id);
      if (index > -1) {
        resolvedId = resolved2.id.slice(index);
        debug$d?.(
          `[processResult] ${colors$1.cyan(id)} -> ${colors$1.dim(resolvedId)}`
        );
      }
    }
    return { ...resolved2, id: resolvedId, external: true };
  };
  if (!options.idOnly && (!options.scan && isBuild || externalize)) {
    return processResult({
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved)
    });
  }
  if (!isInNodeModules$1(resolved) || // linked
  !depsOptimizer || // resolving before listening to the server
  options.scan) {
    return { id: resolved };
  }
  const isJsType = isOptimizable(resolved, depsOptimizer.options);
  const exclude = depsOptimizer.options.exclude;
  const skipOptimization = depsOptimizer.options.noDiscovery || !isJsType || importer && isInNodeModules$1(importer) || exclude?.includes(pkgId) || exclude?.includes(id) || SPECIAL_QUERY_RE.test(resolved);
  if (skipOptimization) {
    const versionHash = depsOptimizer.metadata.browserHash;
    if (versionHash && isJsType) {
      resolved = injectQuery(resolved, `v=${versionHash}`);
    }
  } else {
    const optimizedInfo = depsOptimizer.registerMissingImport(id, resolved);
    resolved = depsOptimizer.getOptimizedDepId(optimizedInfo);
  }
  return { id: resolved };
}
async function tryOptimizedResolve(depsOptimizer, id, importer, preserveSymlinks, packageCache) {
  await depsOptimizer.scanProcessing;
  const metadata = depsOptimizer.metadata;
  const depInfo = optimizedDepInfoFromId(metadata, id);
  if (depInfo) {
    return depsOptimizer.getOptimizedDepId(depInfo);
  }
  if (!importer) return;
  let idPkgDir;
  const nestedIdMatch = `> ${id}`;
  for (const optimizedData of metadata.depInfoList) {
    if (!optimizedData.src) continue;
    if (!optimizedData.id.endsWith(nestedIdMatch)) continue;
    if (idPkgDir == null) {
      const pkgName = getNpmPackageName(id);
      if (!pkgName) break;
      idPkgDir = resolvePackageData(
        pkgName,
        importer,
        preserveSymlinks,
        packageCache
      )?.dir;
      if (idPkgDir == null) break;
      idPkgDir = normalizePath$3(idPkgDir);
    }
    if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) {
      return depsOptimizer.getOptimizedDepId(optimizedData);
    }
  }
}
function resolvePackageEntry(id, { dir, data, setResolvedCache, getResolvedCache }, options) {
  const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id);
  const cached = getResolvedCache(".", options);
  if (cached) {
    return cached + postfix;
  }
  try {
    let entryPoint;
    if (data.exports) {
      entryPoint = resolveExportsOrImports(data, ".", options, "exports");
    }
    if (!entryPoint) {
      for (const field of options.mainFields) {
        if (field === "browser") {
          entryPoint = tryResolveBrowserEntry(dir, data, options);
          if (entryPoint) {
            break;
          }
        } else if (typeof data[field] === "string") {
          entryPoint = data[field];
          break;
        }
      }
    }
    entryPoint ||= data.main;
    const entryPoints = entryPoint ? [entryPoint] : ["index.js", "index.json", "index.node"];
    for (let entry of entryPoints) {
      let skipPackageJson = false;
      if (options.mainFields[0] === "sass" && !options.extensions.includes(path$b.extname(entry))) {
        entry = "";
        skipPackageJson = true;
      } else {
        const { browser: browserField } = data;
        if (options.mainFields.includes("browser") && isObject$1(browserField)) {
          entry = mapWithBrowserField(entry, browserField) || entry;
        }
      }
      const entryPointPath = path$b.join(dir, entry);
      const resolvedEntryPoint = tryFsResolve(
        entryPointPath,
        options,
        true,
        skipPackageJson
      );
      if (resolvedEntryPoint) {
        debug$d?.(
          `[package entry] ${colors$1.cyan(idWithoutPostfix)} -> ${colors$1.dim(
            resolvedEntryPoint
          )}${postfix !== "" ? ` (postfix: ${postfix})` : ""}`
        );
        setResolvedCache(".", resolvedEntryPoint, options);
        return resolvedEntryPoint + postfix;
      }
    }
  } catch (e) {
    packageEntryFailure(id, e.message);
  }
  packageEntryFailure(id);
}
function packageEntryFailure(id, details) {
  const err = new Error(
    `Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : ".")
  );
  err.code = ERR_RESOLVE_PACKAGE_ENTRY_FAIL;
  throw err;
}
function resolveExportsOrImports(pkg, key, options, type) {
  const conditions = options.conditions.map((condition) => {
    if (condition === DEV_PROD_CONDITION) {
      return options.isProduction ? "production" : "development";
    }
    return condition;
  });
  if (options.isRequire) {
    conditions.push("require");
  } else {
    conditions.push("import");
  }
  const fn = type === "imports" ? f : o;
  const result = fn(pkg, key, { conditions, unsafe: true });
  return result ? result[0] : void 0;
}
function resolveDeepImport(id, { setResolvedCache, getResolvedCache, dir, data }, options) {
  const cache = getResolvedCache(id, options);
  if (cache) {
    return cache;
  }
  let relativeId = id;
  const { exports: exportsField, browser: browserField } = data;
  if (exportsField) {
    if (isObject$1(exportsField) && !Array.isArray(exportsField)) {
      const { file, postfix } = splitFileAndPostfix(relativeId);
      const exportsId = resolveExportsOrImports(data, file, options, "exports");
      if (exportsId !== void 0) {
        relativeId = exportsId + postfix;
      } else {
        relativeId = void 0;
      }
    } else {
      relativeId = void 0;
    }
    if (!relativeId) {
      throw new Error(
        `Package subpath '${relativeId}' is not defined by "exports" in ${path$b.join(dir, "package.json")}.`
      );
    }
  } else if (options.mainFields.includes("browser") && isObject$1(browserField)) {
    const { file, postfix } = splitFileAndPostfix(relativeId);
    const mapped = mapWithBrowserField(file, browserField);
    if (mapped) {
      relativeId = mapped + postfix;
    } else if (mapped === false) {
      setResolvedCache(id, browserExternalId, options);
      return browserExternalId;
    }
  }
  if (relativeId) {
    const resolved = tryFsResolve(
      path$b.join(dir, relativeId),
      options,
      !exportsField
      // try index only if no exports field
    );
    if (resolved) {
      debug$d?.(
        `[node/deep-import] ${colors$1.cyan(id)} -> ${colors$1.dim(resolved)}`
      );
      setResolvedCache(id, resolved, options);
      return resolved;
    }
  }
}
function tryResolveBrowserMapping(id, importer, options, isFilePath, externalize) {
  let res;
  const pkg = importer && findNearestPackageData(path$b.dirname(importer), options.packageCache);
  if (pkg && isObject$1(pkg.data.browser)) {
    const mapId = isFilePath ? "./" + slash$1(path$b.relative(pkg.dir, id)) : id;
    const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
    if (browserMappedPath) {
      if (res = bareImportRE.test(browserMappedPath) ? tryNodeResolve(
        browserMappedPath,
        importer,
        options,
        void 0,
        void 0
      )?.id : tryFsResolve(path$b.join(pkg.dir, browserMappedPath), options)) {
        debug$d?.(`[browser mapped] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
        let result = { id: res };
        if (options.idOnly) {
          return result;
        }
        if (!options.scan && options.isBuild) {
          const resPkg = findNearestPackageData(
            path$b.dirname(res),
            options.packageCache
          );
          if (resPkg) {
            result = {
              id: res,
              moduleSideEffects: resPkg.hasSideEffects(res)
            };
          }
        }
        return externalize ? { ...result, external: true } : result;
      }
    } else if (browserMappedPath === false) {
      return browserExternalId;
    }
  }
}
function tryResolveBrowserEntry(dir, data, options) {
  const browserEntry = typeof data.browser === "string" ? data.browser : isObject$1(data.browser) && data.browser["."];
  if (browserEntry) {
    if (!options.isRequire && options.mainFields.includes("module") && typeof data.module === "string" && data.module !== browserEntry) {
      const resolvedBrowserEntry = tryFsResolve(
        path$b.join(dir, browserEntry),
        options
      );
      if (resolvedBrowserEntry) {
        const content = fs__default.readFileSync(resolvedBrowserEntry, "utf-8");
        if (hasESMSyntax(content)) {
          return browserEntry;
        } else {
          return data.module;
        }
      }
    } else {
      return browserEntry;
    }
  }
}
function mapWithBrowserField(relativePathInPkgDir, map) {
  const normalizedPath = path$b.posix.normalize(relativePathInPkgDir);
  for (const key in map) {
    const normalizedKey = path$b.posix.normalize(key);
    if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
      return map[key];
    }
  }
}
function equalWithoutSuffix(path2, key, suffix) {
  return key.endsWith(suffix) && key.slice(0, -suffix.length) === path2;
}
function tryResolveRealFile(file, preserveSymlinks) {
  const stat = tryStatSync(file);
  if (stat?.isFile()) return getRealPath(file, preserveSymlinks);
}
function tryResolveRealFileWithExtensions(filePath, extensions, preserveSymlinks) {
  for (const ext of extensions) {
    const res = tryResolveRealFile(filePath + ext, preserveSymlinks);
    if (res) return res;
  }
}
function tryResolveRealFileOrType(file, preserveSymlinks) {
  const fileStat = tryStatSync(file);
  if (fileStat?.isFile()) {
    return { path: getRealPath(file, preserveSymlinks), type: "file" };
  }
  if (fileStat?.isDirectory()) {
    return { type: "directory" };
  }
  return;
}
function getRealPath(resolved, preserveSymlinks) {
  if (!preserveSymlinks) {
    resolved = safeRealpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function isDirectory(path2) {
  const stat = tryStatSync(path2);
  return stat?.isDirectory() ?? false;
}

const debug$c = createDebugger("vite:optimize-deps");
function optimizedDepsPlugin() {
  return {
    name: "vite:optimized-deps",
    applyToEnvironment(environment) {
      return !isDepOptimizationDisabled(environment.config.optimizeDeps);
    },
    resolveId(id) {
      const environment = this.environment;
      if (environment.depsOptimizer?.isOptimizedDepFile(id)) {
        return id;
      }
    },
    // this.load({ id }) isn't implemented in PluginContainer
    // The logic to register an id to wait until it is processed
    // is in importAnalysis, see call to delayDepsOptimizerUntil
    async load(id) {
      const environment = this.environment;
      const depsOptimizer = environment.depsOptimizer;
      if (depsOptimizer?.isOptimizedDepFile(id)) {
        const metadata = depsOptimizer.metadata;
        const file = cleanUrl(id);
        const versionMatch = DEP_VERSION_RE.exec(file);
        const browserHash = versionMatch ? versionMatch[1].split("=")[1] : void 0;
        const info = optimizedDepInfoFromFile(metadata, file);
        if (info) {
          if (browserHash && info.browserHash !== browserHash) {
            throwOutdatedRequest(id);
          }
          try {
            await info.processing;
          } catch {
            throwProcessingError(id);
          }
          const newMetadata = depsOptimizer.metadata;
          if (metadata !== newMetadata) {
            const currentInfo = optimizedDepInfoFromFile(newMetadata, file);
            if (info.browserHash !== currentInfo?.browserHash) {
              throwOutdatedRequest(id);
            }
          }
        }
        debug$c?.(`load ${colors$1.cyan(file)}`);
        try {
          return await fsp.readFile(file, "utf-8");
        } catch {
          const newMetadata = depsOptimizer.metadata;
          if (optimizedDepInfoFromFile(newMetadata, file)) {
            throwOutdatedRequest(id);
          }
          throwFileNotFoundInOptimizedDep(id);
        }
      }
    }
  };
}
function throwProcessingError(id) {
  const err = new Error(
    `Something unexpected happened while optimizing "${id}". The current page should have reloaded by now`
  );
  err.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR;
  throw err;
}
function throwOutdatedRequest(id) {
  const err = new Error(
    `There is a new version of the pre-bundle for "${id}", a page reload is going to ask for it.`
  );
  err.code = ERR_OUTDATED_OPTIMIZED_DEP;
  throw err;
}
function throwFileNotFoundInOptimizedDep(id) {
  const err = new Error(
    `The file does not exist at "${id}" which is in the optimize deps directory. The dependency might be incompatible with the dep optimizer. Try adding it to \`optimizeDeps.exclude\`.`
  );
  err.code = ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR;
  throw err;
}

var main = {exports: {}};

var version$1 = "16.5.0";
var require$$4 = {
	version: version$1};

const fs$6 = require$$0$4;
const path$8 = require$$0$2;
const os$1 = require$$2;
const crypto$1 = require$$3;
const packageJson = require$$4;

const version = packageJson.version;

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

// Parse src into an Object
function parse$c (src) {
  const obj = {};

  // Convert buffer to string
  let lines = src.toString();

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n');

  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];

    // Default undefined or null to empty string
    let value = (match[2] || '');

    // Remove whitespace
    value = value.trim();

    // Check if double quoted
    const maybeQuote = value[0];

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n');
      value = value.replace(/\\r/g, '\r');
    }

    // Add to object
    obj[key] = value;
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options);

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = 'MISSING_DATA';
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',');
  const length = keys.length;

  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim();

      // Get instructions for decrypt
      const attrs = _instructions(result, key);

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`);
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`);
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
      err.code = 'INVALID_DOTENV_KEY';
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password;
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part');
    err.code = 'INVALID_DOTENV_KEY';
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment');
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
    err.code = 'INVALID_DOTENV_KEY';
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null;

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs$6.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
    }
  } else {
    possibleVaultPath = path$8.resolve(process.cwd(), '.env.vault');
  }

  if (fs$6.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path$8.join(os$1.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  const debug = Boolean(options && options.debug);
  if (debug) {
    _debug('Loading env from encrypted .env.vault');
  }

  const parsed = DotenvModule._parseVault(options);

  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }

  DotenvModule.populate(processEnv, parsed, options);

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path$8.resolve(process.cwd(), '.env');
  let encoding = 'utf8';
  const debug = Boolean(options && options.debug);

  if (options && options.encoding) {
    encoding = options.encoding;
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default');
    }
  }

  let optionPaths = [dotenvPath]; // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)];
    } else {
      optionPaths = []; // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError;
  const parsedAll = {};
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs$6.readFileSync(path, { encoding }));

      DotenvModule.populate(parsedAll, parsed, options);
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`);
      }
      lastError = e;
    }
  }

  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }

  DotenvModule.populate(processEnv, parsedAll, options);

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options);

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex');
  let ciphertext = Buffer.from(encrypted, 'base64');

  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);

  try {
    const aesgcm = crypto$1.createDecipheriv('aes-256-gcm', key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError;
    const invalidKeyLength = error.message === 'Invalid key length';
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
      err.code = 'INVALID_DOTENV_KEY';
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
      err.code = 'DECRYPTION_FAILED';
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug);
  const override = Boolean(options && options.override);

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
    err.code = 'OBJECT_REQUIRED';
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse: parse$c,
  populate
};

main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
var parse_1$2 = main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;

main.exports = DotenvModule;

function _resolveEscapeSequences (value) {
  return value.replace(/\\\$/g, '$')
}

function expandValue (value, processEnv, runningParsed) {
  const env = { ...runningParsed, ...processEnv }; // process.env wins

  const regex = /(?<!\\)\${([^{}]+)}|(?<!\\)\$([A-Za-z_][A-Za-z0-9_]*)/g;

  let result = value;
  let match;
  const seen = new Set(); // self-referential checker

  while ((match = regex.exec(result)) !== null) {
    seen.add(result);

    const [template, bracedExpression, unbracedExpression] = match;
    const expression = bracedExpression || unbracedExpression;

    // match the operators `:+`, `+`, `:-`, and `-`
    const opRegex = /(:\+|\+|:-|-)/;
    // find first match
    const opMatch = expression.match(opRegex);
    const splitter = opMatch ? opMatch[0] : null;

    const r = expression.split(splitter);

    let defaultValue;
    let value;

    const key = r.shift();

    if ([':+', '+'].includes(splitter)) {
      defaultValue = env[key] ? r.join(splitter) : '';
      value = null;
    } else {
      defaultValue = r.join(splitter);
      value = env[key];
    }

    if (value) {
      // self-referential check
      if (seen.has(value)) {
        result = result.replace(template, defaultValue);
      } else {
        result = result.replace(template, value);
      }
    } else {
      result = result.replace(template, defaultValue);
    }

    // if the result equaled what was in process.env and runningParsed then stop expanding
    if (result === runningParsed[key]) {
      break
    }

    regex.lastIndex = 0; // reset regex search position to re-evaluate after each replacement
  }

  return result
}

function expand$2 (options) {
  // for use with progressive expansion
  // const runningParsed = {}

  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }

  // dotenv.config() ran before this so the assumption is process.env has already been set
  for (const key in options.parsed) {
    let value = options.parsed[key];

    // short-circuit scenario: process.env was already set prior to the file value
    if (processEnv[key] && processEnv[key] !== value) {
      value = processEnv[key];
    } else {
      // PATCH: we pass options.parsed instead of runningParsed
      //        to allow variables declared in other files to be used
      value = expandValue(value, processEnv, options.parsed);
    }

    options.parsed[key] = _resolveEscapeSequences(value);

    // for use with progressive expansion
    // runningParsed[key] = _resolveEscapeSequences(value)
  }

  for (const processKey in options.parsed) {
    processEnv[processKey] = options.parsed[processKey];
  }

  return options
}

var expand_1$1 = expand$2;

const debug$b = createDebugger("vite:env");
function getEnvFilesForMode(mode, envDir) {
  if (envDir !== false) {
    return [
      /** default file */
      `.env`,
      /** local file */
      `.env.local`,
      /** mode file */
      `.env.${mode}`,
      /** mode local file */
      `.env.${mode}.local`
    ].map((file) => normalizePath$3(path$b.join(envDir, file)));
  }
  return [];
}
function loadEnv(mode, envDir, prefixes = "VITE_") {
  const start = performance.now();
  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`;
  if (mode === "local") {
    throw new Error(
      `"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`
    );
  }
  prefixes = arraify(prefixes);
  const env = {};
  const envFiles = getEnvFilesForMode(mode, envDir);
  debug$b?.(`loading env files: %O`, envFiles);
  const parsed = Object.fromEntries(
    envFiles.flatMap((filePath) => {
      if (!tryStatSync(filePath)?.isFile()) return [];
      return Object.entries(parse_1$2(fs__default.readFileSync(filePath)));
    })
  );
  debug$b?.(`env files loaded in ${getTime()}`);
  if (parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === void 0) {
    process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV;
  }
  if (parsed.BROWSER && process.env.BROWSER === void 0) {
    process.env.BROWSER = parsed.BROWSER;
  }
  if (parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === void 0) {
    process.env.BROWSER_ARGS = parsed.BROWSER_ARGS;
  }
  const processEnv = { ...process.env };
  expand_1$1({ parsed, processEnv });
  for (const [key, value] of Object.entries(parsed)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env[key] = value;
    }
  }
  for (const key in process.env) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env[key] = process.env[key];
    }
  }
  debug$b?.(`using resolved env: %O`, env);
  return env;
}
function resolveEnvPrefix({
  envPrefix = "VITE_"
}) {
  envPrefix = arraify(envPrefix);
  if (envPrefix.includes("")) {
    throw new Error(
      `envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`
    );
  }
  return envPrefix;
}

const docsURL = "https://vite.dev";
const deprecationCode = {
  removePluginHookSsrArgument: "changes/this-environment-in-hooks",
  removePluginHookHandleHotUpdate: "changes/hotupdate-hook",
  removeServerModuleGraph: "changes/per-environment-apis",
  removeServerHot: "changes/per-environment-apis",
  removeServerTransformRequest: "changes/per-environment-apis",
  removeSsrLoadModule: "changes/ssr-using-modulerunner"
};
const deprecationMessages = {
  removePluginHookSsrArgument: "Plugin hook `options.ssr` is replaced with `this.environment.config.consumer === 'server'`.",
  removePluginHookHandleHotUpdate: "Plugin hook `handleHotUpdate()` is replaced with `hotUpdate()`.",
  removeServerModuleGraph: "The `server.moduleGraph` is replaced with `this.environment.moduleGraph`.",
  removeServerHot: "The `server.hot` is replaced with `this.environment.hot`.",
  removeServerTransformRequest: "The `server.transformRequest` is replaced with `this.environment.transformRequest`.",
  removeSsrLoadModule: "The `server.ssrLoadModule` is replaced with Environment Runner."
};
let _ignoreDeprecationWarnings = false;
function warnFutureDeprecation(config, type, extraMessage, stacktrace = true) {
  if (_ignoreDeprecationWarnings || !config.future || config.future[type] !== "warn")
    return;
  let msg = `[vite future] ${deprecationMessages[type]}`;
  if (extraMessage) {
    msg += ` ${extraMessage}`;
  }
  msg = colors$1.yellow(msg);
  const docs = `${docsURL}/changes/${deprecationCode[type].toLowerCase()}`;
  msg += colors$1.gray(`
  ${stacktrace ? "\u251C" : "\u2514"}\u2500\u2500\u2500 `) + colors$1.underline(docs) + "\n";
  if (stacktrace) {
    const stack = new Error().stack;
    if (stack) {
      let stacks = stack.split("\n").slice(3).filter((i) => !i.includes("/node_modules/vite/dist/"));
      if (stacks.length === 0) {
        stacks.push("No stack trace found.");
      }
      stacks = stacks.map(
        (i, idx) => `  ${idx === stacks.length - 1 ? "\u2514" : "\u2502"} ${i.trim()}`
      );
      msg += colors$1.dim(stacks.join("\n")) + "\n";
    }
  }
  config.logger.warnOnce(msg);
}
function ignoreDeprecationWarnings(fn) {
  const before = _ignoreDeprecationWarnings;
  _ignoreDeprecationWarnings = true;
  const ret = fn();
  _ignoreDeprecationWarnings = before;
  return ret;
}

function prepareError(err) {
  return {
    message: stripVTControlCharacters(err.message),
    stack: stripVTControlCharacters(cleanStack(err.stack || "")),
    id: err.id,
    frame: stripVTControlCharacters(err.frame || ""),
    plugin: err.plugin,
    pluginCode: err.pluginCode?.toString(),
    loc: err.loc
  };
}
function buildErrorMessage(err, args = [], includeStack = true) {
  if (err.plugin) args.push(`  Plugin: ${colors$1.magenta(err.plugin)}`);
  const loc = err.loc ? `:${err.loc.line}:${err.loc.column}` : "";
  if (err.id) args.push(`  File: ${colors$1.cyan(err.id)}${loc}`);
  if (err.frame) args.push(colors$1.yellow(pad$1(err.frame)));
  if (includeStack && err.stack) args.push(pad$1(cleanStack(err.stack)));
  return args.join("\n");
}
function cleanStack(stack) {
  return stack.split(/\n/).filter((l) => /^\s*at/.test(l)).join("\n");
}
function logError(server, err) {
  const msg = buildErrorMessage(err, [
    colors$1.red(`Internal server error: ${err.message}`)
  ]);
  server.config.logger.error(msg, {
    clear: true,
    timestamp: true,
    error: err
  });
  server.environments.client.hot.send({
    type: "error",
    err: prepareError(err)
  });
}
function errorMiddleware(server, allowNext = false) {
  return function viteErrorMiddleware(err, _req, res, next) {
    logError(server, err);
    if (allowNext) {
      next();
    } else {
      res.statusCode = 500;
      res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              const error = ${JSON.stringify(prepareError(err)).replace(
        /</g,
        "\\u003c"
      )}
              try {
                const { ErrorOverlay } = await import(${JSON.stringify(path$b.posix.join(server.config.base, CLIENT_PUBLIC_PATH))})
                document.body.appendChild(new ErrorOverlay(error))
              } catch {
                const h = (tag, text) => {
                  const el = document.createElement(tag)
                  el.textContent = text
                  return el
                }
                document.body.appendChild(h('h1', 'Internal Server Error'))
                document.body.appendChild(h('h2', error.message))
                document.body.appendChild(h('pre', error.stack))
                document.body.appendChild(h('p', '(Error overlay failed to load)'))
              }
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
    }
  };
}

var node = {exports: {}};

var debug$a = {exports: {}};

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$b(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$b(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

(function (module, exports) {
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = ms;

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0, i;

	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  return debug;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  exports.names = [];
	  exports.skips = [];

	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	} 
} (debug$a, debug$a.exports));

var debugExports = debug$a.exports;

/**
 * Module dependencies.
 */

(function (module, exports) {
	var tty = require$$0$3;
	var util = require$$1;

	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debugExports;
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	/**
	 * Build up the default `inspectOpts` object from the environment variables.
	 *
	 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	 */

	exports.inspectOpts = Object.keys(process.env).filter(function (key) {
	  return /^debug_/i.test(key);
	}).reduce(function (obj, key) {
	  // camel-case
	  var prop = key
	    .substring(6)
	    .toLowerCase()
	    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

	  // coerce string value into JS value
	  var val = process.env[key];
	  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
	  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
	  else if (val === 'null') val = null;
	  else val = Number(val);

	  obj[prop] = val;
	  return obj;
	}, {});

	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */

	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

	if (1 !== fd && 2 !== fd) {
	  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
	}

	var stream = 1 === fd ? process.stdout :
	             2 === fd ? process.stderr :
	             createWritableStdioStream(fd);

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
	  return 'colors' in exports.inspectOpts
	    ? Boolean(exports.inspectOpts.colors)
	    : tty.isatty(fd);
	}

	/**
	 * Map %o to `util.inspect()`, all on a single line.
	 */

	exports.formatters.o = function(v) {
	  this.inspectOpts.colors = this.useColors;
	  return util.inspect(v, this.inspectOpts)
	    .split('\n').map(function(str) {
	      return str.trim()
	    }).join(' ');
	};

	/**
	 * Map %o to `util.inspect()`, allowing multiple lines if needed.
	 */

	exports.formatters.O = function(v) {
	  this.inspectOpts.colors = this.useColors;
	  return util.inspect(v, this.inspectOpts);
	};

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var name = this.namespace;
	  var useColors = this.useColors;

	  if (useColors) {
	    var c = this.color;
	    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

	    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
	    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
	  } else {
	    args[0] = new Date().toUTCString()
	      + ' ' + name + ' ' + args[0];
	  }
	}

	/**
	 * Invokes `util.format()` with the specified arguments and writes to `stream`.
	 */

	function log() {
	  return stream.write(util.format.apply(util, arguments) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return process.env.DEBUG;
	}

	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */

	function createWritableStdioStream (fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');

	  // Note stream._type is used for test-module-load-list.js

	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';

	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    case 'FILE':
	      var fs = require$$0$4;
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;

	    case 'PIPE':
	    case 'TCP':
	      var net = require$$4$1;
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });

	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';

	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }

	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;

	  stream._isStdio = true;

	  return stream;
	}

	/**
	 * Init logic for `debug` instances.
	 *
	 * Create a new `inspectOpts` object in case `useColors` is set
	 * differently for a particular `debug` instance.
	 */

	function init (debug) {
	  debug.inspectOpts = {};

	  var keys = Object.keys(exports.inspectOpts);
	  for (var i = 0; i < keys.length; i++) {
	    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	  }
	}

	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */

	exports.enable(load()); 
} (node, node.exports));

var nodeExports = node.exports;

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var encodeurl = encodeUrl$1;

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl$1 (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

var escapeHtml_1 = escapeHtml$1;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml$1(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

var escapeHtml$2 = /*@__PURE__*/getDefaultExportFromCjs(escapeHtml_1);

var onFinished$2 = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eeFirst = first$1;

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = [];

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0];

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);

      // listen to the event
      ee.on(event, fn);
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      });
    }
  }

  function callback() {
    cleanup();
    done.apply(null, arguments);
  }

  function cleanup() {
    var x;
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i];
      x.ee.removeListener(x.event, x.fn);
    }
  }

  function thunk(fn) {
    done = fn;
  }

  thunk.cancel = cleanup;

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === 'error'
      ? arg1
      : null;

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    done(err, ee, event, args);
  }
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

onFinished$2.exports = onFinished$1;
onFinished$2.exports.isFinished = isFinished$1;

/**
 * Module dependencies.
 * @private
 */

var first = eeFirst;

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer$2 = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished$1(msg, listener) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener, null, msg);
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener);

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished$1(msg) {
  var socket = msg.socket;

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;

  function onFinish(error) {
    eeMsg.cancel();
    eeSocket.cancel();

    finished = true;
    callback(error);
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket);

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish);
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket);
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket);

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket);
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished;

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }

  attached.queue.push(listener);
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null;
    if (!listener.queue) return

    var queue = listener.queue;
    listener.queue = null;

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }

  listener.queue = [];

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}

var onFinishedExports = onFinished$2.exports;

var parseurl$1 = {exports: {}};

/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var url$3 = require$$0$5;
var parse$a = url$3.parse;
var Url = url$3.Url;

/**
 * Module exports.
 * @public
 */

parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url;

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedUrl = parsed)
}
/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl;

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedOriginalUrl = parsed)
}
/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse$a(str)
  }

  var pathname = str;
  var query = null;
  var search = null;

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse$a(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {};

  url.path = str;
  url.href = str;
  url.pathname = pathname;

  if (search !== null) {
    url.query = query;
    url.search = search;
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}

var parseurlExports = parseurl$1.exports;

var require$$0$1 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var codes = require$$0$1;

/**
 * Module exports.
 * @public
 */

var statuses$1 = status;

// status code to message map
status.STATUS_CODES = codes;

// array of status codes
status.codes = populateStatusesMap(status, codes);

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
};

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
};

/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap (statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code)
    return code
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n)
    return n
  }

  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"')
  return n
}

/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var unpipe_1 = unpipe$1;

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data');

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe$1(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe();
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener;
  var listeners = stream.listeners('close');

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i];

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream);
  }
}

/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var debug$9 = nodeExports('finalhandler');
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var onFinished = onFinishedExports;
var parseUrl$2 = parseurlExports;
var statuses = statuses$1;
var unpipe = unpipe_1;

/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;

/* istanbul ignore next */
var defer$1 = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)); };
var isFinished = onFinished.isFinished;

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>')
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

var finalhandler_1 = finalhandler$1;

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler$1 (req, res, options) {
  var opts = options || {};

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development';

  // get error callback
  var onerror = opts.onerror;

  return function (err) {
    var headers;
    var msg;
    var status;

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug$9('cannot 404 after headers sent');
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err);

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res);
      } else {
        // respect headers from error
        headers = getErrorHeaders(err);
      }

      // get error message
      msg = getErrorMessage(err, status, env);
    } else {
      // not found
      status = 404;
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
    }

    debug$9('default %s', status);

    // schedule onerror callback
    if (err && onerror) {
      defer$1(onerror, err, req, res);
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug$9('cannot %d after headers sent', status);
      req.socket.destroy();
      return
    }

    // send response
    send$2(req, res, status, headers, msg);
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null);
  var keys = Object.keys(err.headers);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    headers[key] = err.headers[key];
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg;

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack;

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString();
    }
  }

  return msg || statuses[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl$2.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode;

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500;
  }

  return status
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== 'boolean'
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send$2 (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message);

    // response status
    res.statusCode = status;
    res.statusMessage = statuses[status];

    // response headers
    setHeaders(res, headers);

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'none'");
    res.setHeader('X-Content-Type-Options', 'nosniff');

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));

    if (req.method === 'HEAD') {
      res.end();
      return
    }

    res.end(body, 'utf8');
  }

  if (isFinished(req)) {
    write();
    return
  }

  // unpipe everything from the request
  unpipe(req);

  // flush the request
  onFinished(req, write);
  req.resume();
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  if (!headers) {
    return
  }

  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res.setHeader(key, headers[key]);
  }
}

var utilsMerge = {exports: {}};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

(function (module, exports) {
	module.exports = function(a, b){
	  if (a && b) {
	    for (var key in b) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	}; 
} (utilsMerge));

var utilsMergeExports = utilsMerge.exports;

/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var debug$8 = nodeExports('connect:dispatcher');
var EventEmitter$3 = require$$0$7.EventEmitter;
var finalhandler = finalhandler_1;
var http$4 = require$$1$2;
var merge = utilsMergeExports;
var parseUrl$1 = parseurlExports;

/**
 * Module exports.
 * @public
 */

var connect = createServer$1;

/**
 * Module variables.
 * @private
 */

var env = process.env.NODE_ENV || 'development';
var proto = {};

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

/**
 * Create a new connect server.
 *
 * @return {function}
 * @public
 */

function createServer$1() {
  function app(req, res, next){ app.handle(req, res, next); }
  merge(app, proto);
  merge(app, EventEmitter$3.prototype);
  app.route = '/';
  app.stack = [];
  return app;
}

/**
 * Utilize the given middleware `handle` to the given `route`,
 * defaulting to _/_. This "route" is the mount-point for the
 * middleware, when given a value other than _/_ the middleware
 * is only effective when that segment is present in the request's
 * pathname.
 *
 * For example if we were to mount a function at _/admin_, it would
 * be invoked on _/admin_, and _/admin/settings_, however it would
 * not be invoked for _/_, or _/posts_.
 *
 * @param {String|Function|Server} route, callback or server
 * @param {Function|Server} callback or server
 * @return {Server} for chaining
 * @public
 */

proto.use = function use(route, fn) {
  var handle = fn;
  var path = route;

  // default route to '/'
  if (typeof route !== 'string') {
    handle = route;
    path = '/';
  }

  // wrap sub-apps
  if (typeof handle.handle === 'function') {
    var server = handle;
    server.route = path;
    handle = function (req, res, next) {
      server.handle(req, res, next);
    };
  }

  // wrap vanilla http.Servers
  if (handle instanceof http$4.Server) {
    handle = handle.listeners('request')[0];
  }

  // strip trailing slash
  if (path[path.length - 1] === '/') {
    path = path.slice(0, -1);
  }

  // add the middleware
  debug$8('use %s %s', path || '/', handle.name || 'anonymous');
  this.stack.push({ route: path, handle: handle });

  return this;
};

/**
 * Handle server requests, punting them down
 * the middleware stack.
 *
 * @private
 */

proto.handle = function handle(req, res, out) {
  var index = 0;
  var protohost = getProtohost(req.url) || '';
  var removed = '';
  var slashAdded = false;
  var stack = this.stack;

  // final function handler
  var done = out || finalhandler(req, res, {
    env: env,
    onerror: logerror
  });

  // store the original URL
  req.originalUrl = req.originalUrl || req.url;

  function next(err) {
    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    if (removed.length !== 0) {
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = '';
    }

    // next callback
    var layer = stack[index++];

    // all done
    if (!layer) {
      defer(done, err);
      return;
    }

    // route data
    var path = parseUrl$1(req).pathname || '/';
    var route = layer.route;

    // skip this layer if the route doesn't match
    if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
      return next(err);
    }

    // skip if route match does not border "/", ".", or end
    var c = path.length > route.length && path[route.length];
    if (c && c !== '/' && c !== '.') {
      return next(err);
    }

    // trim off the part of the url that matches the route
    if (route.length !== 0 && route !== '/') {
      removed = route;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }
    }

    // call the layer handle
    call(layer.handle, route, err, req, res, next);
  }

  next();
};

/**
 * Listen for connections.
 *
 * This method takes the same arguments
 * as node's `http.Server#listen()`.
 *
 * HTTP and HTTPS:
 *
 * If you run your application both as HTTP
 * and HTTPS you may wrap them individually,
 * since your Connect "server" is really just
 * a JavaScript `Function`.
 *
 *      var connect = require('connect')
 *        , http = require('http')
 *        , https = require('https');
 *
 *      var app = connect();
 *
 *      http.createServer(app).listen(80);
 *      https.createServer(options, app).listen(443);
 *
 * @return {http.Server}
 * @api public
 */

proto.listen = function listen() {
  var server = http$4.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Invoke a route handle.
 * @private
 */

function call(handle, route, err, req, res, next) {
  var arity = handle.length;
  var error = err;
  var hasError = Boolean(err);

  debug$8('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);

  try {
    if (hasError && arity === 4) {
      // error-handling middleware
      handle(err, req, res, next);
      return;
    } else if (!hasError && arity < 4) {
      // request-handling middleware
      handle(req, res, next);
      return;
    }
  } catch (e) {
    // replace the error
    error = e;
  }

  // continue
  next(error);
}

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  if (env !== 'test') console.error(err.stack || err.toString());
}

/**
 * Get get protocol + host for a URL.
 *
 * @param {string} url
 * @private
 */

function getProtohost(url) {
  if (url.length === 0 || url[0] === '/') {
    return undefined;
  }

  var fqdnIndex = url.indexOf('://');

  return fqdnIndex !== -1 && url.lastIndexOf('?', fqdnIndex) === -1
    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined;
}

var connect$1 = /*@__PURE__*/getDefaultExportFromCjs(connect);

var lib = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var vary$1 = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

vary$1.exports = vary;
vary$1.exports.append = append$1;

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append$1 (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse$9(String(field))
    : field;

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header;
  var vals = parse$9(header.toLowerCase());

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val
        ? val + ', ' + fields[i]
        : fields[i];
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse$9 (header) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break
      default:
        end = i + 1;
        break
    }
  }

  // final token
  list.push(header.substring(start, end));

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val);

  // set new header
  if ((val = append$1(header, field))) {
    res.setHeader('Vary', val);
  }
}

var varyExports = vary$1.exports;

(function () {

  var assign = objectAssign;
  var vary = varyExports;

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureMethods(options));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  lib.exports = middlewareWrapper;

}());

var libExports = lib.exports;
var corsMiddleware = /*@__PURE__*/getDefaultExportFromCjs(libExports);

var chokidar = {};

const fs$5 = require$$0$4;
const { Readable } = require$$0$8;
const sysPath$3 = require$$0$2;
const { promisify: promisify$3 } = require$$1;
const picomatch$1 = picomatch$2;

const readdir$1 = promisify$3(fs$5.readdir);
const stat$3 = promisify$3(fs$5.stat);
const lstat$2 = promisify$3(fs$5.lstat);
const realpath$1 = promisify$3(fs$5.realpath);

/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

const BANG$2 = '!';
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
const FILE_TYPE = 'files';
const DIR_TYPE = 'directories';
const FILE_DIR_TYPE = 'files_directories';
const EVERYTHING_TYPE = 'all';
const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

const isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);
const [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));
const wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));

const normalizeFilter$1 = filter => {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    const glob = picomatch$1(filter.trim());
    return entry => glob(entry.basename);
  }

  if (Array.isArray(filter)) {
    const positive = [];
    const negative = [];
    for (const item of filter) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG$2) {
        negative.push(picomatch$1(trimmed.slice(1)));
      } else {
        positive.push(picomatch$1(trimmed));
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return entry =>
          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));
      }
      return entry => !negative.some(f => f(entry.basename));
    }
    return entry => positive.some(f => f(entry.basename));
  }
};

class ReaddirpStream extends Readable {
  static get defaultOptions() {
    return {
      root: '.',
      /* eslint-disable no-unused-vars */
      fileFilter: (path) => true,
      directoryFilter: (path) => true,
      /* eslint-enable no-unused-vars */
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    };
  }

  constructor(options = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    });
    const opts = { ...ReaddirpStream.defaultOptions, ...options };
    const { root, type } = opts;

    this._fileFilter = normalizeFilter$1(opts.fileFilter);
    this._directoryFilter = normalizeFilter$1(opts.directoryFilter);

    const statMethod = opts.lstat ? lstat$2 : stat$3;
    // Use bigint stats if it's windows and stat() supports options (node 10+).
    if (wantBigintFsStats) {
      this._stat = path => statMethod(path, { bigint: true });
    } else {
      this._stat = statMethod;
    }

    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath$3.resolve(root);
    this._isDirent = ('Dirent' in fs$5) && !opts.alwaysStat;
    this._statsProp = this._isDirent ? 'dirent' : 'stats';
    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };

    // Launch stream with one parent, the root dir.
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = undefined;
  }

  async _read(batch) {
    if (this.reading) return;
    this.reading = true;

    try {
      while (!this.destroyed && batch > 0) {
        const { path, depth, files = [] } = this.parent || {};

        if (files.length > 0) {
          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));
          for (const entry of await Promise.all(slice)) {
            if (this.destroyed) return;

            const entryType = await this._getEntryType(entry);
            if (entryType === 'directory' && this._directoryFilter(entry)) {
              if (depth <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
              }

              if (this._wantsDir) {
                this.push(entry);
                batch--;
              }
            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {
              if (this._wantsFile) {
                this.push(entry);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed) return;
        }
      }
    } catch (error) {
      this.destroy(error);
    } finally {
      this.reading = false;
    }
  }

  async _exploreDir(path, depth) {
    let files;
    try {
      files = await readdir$1(path, this._rdOptions);
    } catch (error) {
      this._onError(error);
    }
    return { files, depth, path };
  }

  async _formatEntry(dirent, path) {
    let entry;
    try {
      const basename = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));
      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };
      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err) {
      this._onError(err);
    }
    return entry;
  }

  _onError(err) {
    if (isNormalFlowError(err) && !this.destroyed) {
      this.emit('warn', err);
    } else {
      this.destroy(err);
    }
  }

  async _getEntryType(entry) {
    // entry may be undefined, because a warning or an error were emitted
    // and the statsProp is undefined
    const stats = entry && entry[this._statsProp];
    if (!stats) {
      return;
    }
    if (stats.isFile()) {
      return 'file';
    }
    if (stats.isDirectory()) {
      return 'directory';
    }
    if (stats && stats.isSymbolicLink()) {
      const full = entry.fullPath;
      try {
        const entryRealPath = await realpath$1(full);
        const entryRealPathStats = await lstat$2(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return 'file';
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
            const recursiveError = new Error(
              `Circular symlink detected: "${full}" points to "${entryRealPath}"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return 'directory';
        }
      } catch (error) {
        this._onError(error);
      }
    }
  }

  _includeAsFile(entry) {
    const stats = entry && entry[this._statsProp];

    return stats && this._wantsEverything && !stats.isDirectory();
  }
}

/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */
const readdirp$1 = (root, options = {}) => {
  let type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
  }

  options.root = root;
  return new ReaddirpStream(options);
};

const readdirpPromise = (root, options = {}) => {
  return new Promise((resolve, reject) => {
    const files = [];
    readdirp$1(root, options)
      .on('data', entry => files.push(entry))
      .on('end', () => resolve(files))
      .on('error', error => reject(error));
  });
};

readdirp$1.promise = readdirpPromise;
readdirp$1.ReaddirpStream = ReaddirpStream;
readdirp$1.default = readdirp$1;

var readdirp_1 = readdirp$1;

var anymatch$2 = {exports: {}};

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

var normalizePath$2 = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};

var anymatch_1 = anymatch$2.exports;

Object.defineProperty(anymatch_1, "__esModule", { value: true });

const picomatch = picomatch$2;
const normalizePath$1 = normalizePath$2;

/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */
const BANG$1 = '!';
const DEFAULT_OPTIONS = {returnIndex: false};
const arrify$1 = (item) => Array.isArray(item) ? item : [item];

/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */
const createPattern = (matcher, options) => {
  if (typeof matcher === 'function') {
    return matcher;
  }
  if (typeof matcher === 'string') {
    const glob = picomatch(matcher, options);
    return (string) => matcher === string || glob(string);
  }
  if (matcher instanceof RegExp) {
    return (string) => matcher.test(string);
  }
  return (string) => false;
};

/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */
const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(_path))
  }
  const path = normalizePath$1(_path, false);

  for (let index = 0; index < negPatterns.length; index++) {
    const nglob = negPatterns[index];
    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  const applied = isList && [path].concat(args.slice(1));
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (isList ? pattern(...applied) : pattern(path)) {
      return returnIndex ? index : true;
    }
  }

  return returnIndex ? -1 : false;
};

/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */
const anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;
  const returnIndex = opts.returnIndex || false;

  // Early cache for matchers.
  const mtchers = arrify$1(matchers);
  const negatedGlobs = mtchers
    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)
    .map(item => item.slice(1))
    .map(item => picomatch(item, opts));
  const patterns = mtchers
    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))
    .map(matcher => createPattern(matcher, opts));

  if (testString == null) {
    return (testString, ri = false) => {
      const returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    }
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch$1.default = anymatch$1;
anymatch$2.exports = anymatch$1;

var anymatchExports = anymatch$2.exports;

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = isExtglob$1;
var chars = { '{': '}', '(': ')', '[': ']'};
var strictCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var relaxedCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var isGlob$2 = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck;

  // optionally relax check
  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};

var isGlob$1 = isGlob$2;
var pathPosixDirname = require$$0$2.posix.dirname;
var isWin32 = require$$2.platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
var globParent$1 = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob$1(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};

var utils$3 = {};

(function (exports) {

	exports.isInteger = num => {
	  if (typeof num === 'number') {
	    return Number.isInteger(num);
	  }
	  if (typeof num === 'string' && num.trim() !== '') {
	    return Number.isInteger(Number(num));
	  }
	  return false;
	};

	/**
	 * Find a node of the given type
	 */

	exports.find = (node, type) => node.nodes.find(node => node.type === type);

	/**
	 * Find a node of the given type
	 */

	exports.exceedsLimit = (min, max, step = 1, limit) => {
	  if (limit === false) return false;
	  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
	  return ((Number(max) - Number(min)) / Number(step)) >= limit;
	};

	/**
	 * Escape the given node with '\\' before node.value
	 */

	exports.escapeNode = (block, n = 0, type) => {
	  const node = block.nodes[n];
	  if (!node) return;

	  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
	    if (node.escaped !== true) {
	      node.value = '\\' + node.value;
	      node.escaped = true;
	    }
	  }
	};

	/**
	 * Returns true if the given brace node should be enclosed in literal braces
	 */

	exports.encloseBrace = node => {
	  if (node.type !== 'brace') return false;
	  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
	    node.invalid = true;
	    return true;
	  }
	  return false;
	};

	/**
	 * Returns true if a brace node is invalid.
	 */

	exports.isInvalidBrace = block => {
	  if (block.type !== 'brace') return false;
	  if (block.invalid === true || block.dollar) return true;
	  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
	    block.invalid = true;
	    return true;
	  }
	  if (block.open !== true || block.close !== true) {
	    block.invalid = true;
	    return true;
	  }
	  return false;
	};

	/**
	 * Returns true if a node is an open or close node
	 */

	exports.isOpenOrClose = node => {
	  if (node.type === 'open' || node.type === 'close') {
	    return true;
	  }
	  return node.open === true || node.close === true;
	};

	/**
	 * Reduce an array of text nodes.
	 */

	exports.reduce = nodes => nodes.reduce((acc, node) => {
	  if (node.type === 'text') acc.push(node.value);
	  if (node.type === 'range') node.type = 'text';
	  return acc;
	}, []);

	/**
	 * Flatten an array
	 */

	exports.flatten = (...args) => {
	  const result = [];

	  const flat = arr => {
	    for (let i = 0; i < arr.length; i++) {
	      const ele = arr[i];

	      if (Array.isArray(ele)) {
	        flat(ele);
	        continue;
	      }

	      if (ele !== undefined) {
	        result.push(ele);
	      }
	    }
	    return result;
	  };

	  flat(args);
	  return result;
	}; 
} (utils$3));

const utils$2 = utils$3;

var stringify$4 = (ast, options = {}) => {
  const stringify = (node, parent = {}) => {
    const invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);
    const invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (const child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};

/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

var isNumber$2 = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};

/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */

const isNumber$1 = isNumber$2;

const toRegexRange$1 = (min, max, options) => {
  if (isNumber$1(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber$1(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false) || [];
  let intersected = filterPatterns(neg, pos, '-?', true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});

/**
 * Expose `toRegexRange`
 */

var toRegexRange_1 = toRegexRange$1;

/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

const util = require$$1;
const toRegexRange = toRegexRange_1;

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify$3 = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options, maxLen) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$3(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options, maxLen)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }

  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill$2 = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill$2(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill$2(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

var fillRange = fill$2;

const fill$1 = fillRange;
const utils$1 = utils$3;

const compile$1 = (ast, options = {}) => {
  const walk = (node, parent = {}) => {
    const invalidBlock = utils$1.isInvalidBrace(parent);
    const invalidNode = node.invalid === true && options.escapeInvalid === true;
    const invalid = invalidBlock === true || invalidNode === true;
    const prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }

    if (node.isClose === true) {
      console.log('node.isClose', prefix, node.value);
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? prefix + node.value : '(';
    }

    if (node.type === 'close') {
      return invalid ? prefix + node.value : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      const args = utils$1.reduce(node.nodes);
      const range = fill$1(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (const child of node.nodes) {
        output += walk(child, node);
      }
    }

    return output;
  };

  return walk(ast);
};

var compile_1 = compile$1;

const fill = fillRange;
const stringify$2 = stringify$4;
const utils = utils$3;

const append = (queue = '', stash = '', enclose = false) => {
  const result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (const item of queue) {
    if (Array.isArray(item)) {
      for (const value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
      }
    }
  }
  return utils.flatten(result);
};

const expand$1 = (ast, options = {}) => {
  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;

  const walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify$2(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      const args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify$2(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    const enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      const child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

var expand_1 = expand$1;

var constants$2 = {
  MAX_LENGTH: 10000,

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_COMMA: ',', /* , */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};

const stringify$1 = stringify$4;

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$2;

/**
 * parse
 */

const parse$8 = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  const opts = options || {};
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  const ast = { type: 'root', input, nodes: [] };
  const stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  const length = input.length;
  let index = 0;
  let depth = 0;
  let value;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      const open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      const brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      const type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        const open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify$1(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      const siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        const before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      const parent = stack[stack.length - 1];
      const index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

var parse_1$1 = parse$8;

const stringify = stringify$4;
const compile = compile_1;
const expand = expand_1;
const parse$7 = parse_1$1;

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces$1 = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (const pattern of input) {
      const result = braces$1.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces$1.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces$1.parse = (input, options = {}) => parse$7(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces$1.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

  return options.expand !== true
    ? braces$1.compile(input, options)
    : braces$1.expand(input, options);
};

/**
 * Expose "braces"
 */

var braces_1 = braces$1;

var require$$0 = [
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"afdesign",
	"afphoto",
	"afpub",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"appimage",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"flatpak",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"odp",
	"ods",
	"odt",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"ott",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rpm",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"snap",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
];

var binaryExtensions$1 = require$$0;

const path$7 = require$$0$2;
const binaryExtensions = binaryExtensions$1;

const extensions = new Set(binaryExtensions);

var isBinaryPath$1 = filePath => extensions.has(path$7.extname(filePath).slice(1).toLowerCase());

var constants$1 = {};

(function (exports) {

	const {sep} = require$$0$2;
	const {platform} = process;
	const os = require$$2;

	exports.EV_ALL = 'all';
	exports.EV_READY = 'ready';
	exports.EV_ADD = 'add';
	exports.EV_CHANGE = 'change';
	exports.EV_ADD_DIR = 'addDir';
	exports.EV_UNLINK = 'unlink';
	exports.EV_UNLINK_DIR = 'unlinkDir';
	exports.EV_RAW = 'raw';
	exports.EV_ERROR = 'error';

	exports.STR_DATA = 'data';
	exports.STR_END = 'end';
	exports.STR_CLOSE = 'close';

	exports.FSEVENT_CREATED = 'created';
	exports.FSEVENT_MODIFIED = 'modified';
	exports.FSEVENT_DELETED = 'deleted';
	exports.FSEVENT_MOVED = 'moved';
	exports.FSEVENT_CLONED = 'cloned';
	exports.FSEVENT_UNKNOWN = 'unknown';
	exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
	exports.FSEVENT_TYPE_FILE = 'file';
	exports.FSEVENT_TYPE_DIRECTORY = 'directory';
	exports.FSEVENT_TYPE_SYMLINK = 'symlink';

	exports.KEY_LISTENERS = 'listeners';
	exports.KEY_ERR = 'errHandlers';
	exports.KEY_RAW = 'rawEmitters';
	exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];

	exports.DOT_SLASH = `.${sep}`;

	exports.BACK_SLASH_RE = /\\/g;
	exports.DOUBLE_SLASH_RE = /\/\//;
	exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
	exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
	exports.REPLACER_RE = /^\.[/\\]/;

	exports.SLASH = '/';
	exports.SLASH_SLASH = '//';
	exports.BRACE_START = '{';
	exports.BANG = '!';
	exports.ONE_DOT = '.';
	exports.TWO_DOTS = '..';
	exports.STAR = '*';
	exports.GLOBSTAR = '**';
	exports.ROOT_GLOBSTAR = '/**/*';
	exports.SLASH_GLOBSTAR = '/**';
	exports.DIR_SUFFIX = 'Dir';
	exports.ANYMATCH_OPTS = {dot: true};
	exports.STRING_TYPE = 'string';
	exports.FUNCTION_TYPE = 'function';
	exports.EMPTY_STR = '';
	exports.EMPTY_FN = () => {};
	exports.IDENTITY_FN = val => val;

	exports.isWindows = platform === 'win32';
	exports.isMacos = platform === 'darwin';
	exports.isLinux = platform === 'linux';
	exports.isIBMi = os.type() === 'OS400'; 
} (constants$1));

const fs$4 = require$$0$4;
const sysPath$2 = require$$0$2;
const { promisify: promisify$2 } = require$$1;
const isBinaryPath = isBinaryPath$1;
const {
  isWindows: isWindows$2,
  isLinux,
  EMPTY_FN: EMPTY_FN$2,
  EMPTY_STR: EMPTY_STR$1,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE: EV_CHANGE$2,
  EV_ADD: EV_ADD$2,
  EV_ADD_DIR: EV_ADD_DIR$2,
  EV_ERROR: EV_ERROR$2,
  STR_DATA: STR_DATA$1,
  STR_END: STR_END$2,
  BRACE_START: BRACE_START$1,
  STAR
} = constants$1;

const THROTTLE_MODE_WATCH = 'watch';

const open$1 = promisify$2(fs$4.open);
const stat$2 = promisify$2(fs$4.stat);
const lstat$1 = promisify$2(fs$4.lstat);
const close = promisify$2(fs$4.close);
const fsrealpath = promisify$2(fs$4.realpath);

const statMethods$1 = { lstat: lstat$1, stat: stat$2 };

// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};

const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)
      );
    }
  };
  try {
    return fs$4.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], (listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const {listener, errHandler, rawEmitter} = handlers;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher) return;
    watcher.on(EV_ERROR$2, async (error) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows$2 && error.code === 'EPERM') {
        try {
          const fd = await open$1(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const {listener, rawEmitter} = handlers;
  let cont = FsWatchFileInstances.get(fullPath);

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    fs$4.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs$4.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs$4.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */
let NodeFsHandler$1 = class NodeFsHandler {

/**
 * @param {import("../index").FSWatcher} fsW
 */
constructor(fsW) {
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath$2.dirname(path);
  const basename = sysPath$2.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath$2.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = EMPTY_FN$2;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath$2.dirname(file);
  const basename = sysPath$2.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  const listener = async (path, newStats) => {
    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
    if (!newStats || newStats.mtimeMs === 0) {
      try {
        const newStats = await stat$2(file);
        if (this.fsw.closed) return;
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE$2, file, newStats);
        }
        if (isLinux && prevStats.ino !== newStats.ino) {
          this.fsw._closeFile(path);
          prevStats = newStats;
          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
        } else {
          prevStats = newStats;
        }
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
      // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit(EV_CHANGE$2, file, newStats);
      }
      prevStats = newStats;
    }
  };
  // kick off the watcher
  const closer = this._watchWithNodeFs(file, listener);

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;
    this.fsw._emit(EV_ADD$2, file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */
async _handleSymlink(entry, directory, path, item) {
  if (this.fsw.closed) {
    return;
  }
  const full = entry.fullPath;
  const dir = this.fsw._getWatchedDir(directory);

  if (!this.fsw.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this.fsw._incrReadyCount();

    let linkPath;
    try {
      linkPath = await fsrealpath(path);
    } catch (e) {
      this.fsw._emitReady();
      return true;
    }

    if (this.fsw.closed) return;
    if (dir.has(item)) {
      if (this.fsw._symlinkPaths.get(full) !== linkPath) {
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_CHANGE$2, path, entry.stats);
      }
    } else {
      dir.add(item);
      this.fsw._symlinkPaths.set(full, linkPath);
      this.fsw._emit(EV_ADD$2, path, entry.stats);
    }
    this.fsw._emitReady();
    return true;
  }

  // don't follow the same symlink more than once
  if (this.fsw._symlinkPaths.has(full)) {
    return true;
  }

  this.fsw._symlinkPaths.set(full, true);
}

_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
  // Normalize the directory name on Windows
  directory = sysPath$2.join(directory, EMPTY_STR$1);

  if (!wh.hasGlob) {
    throttler = this.fsw._throttle('readdir', directory, 1000);
    if (!throttler) return;
  }

  const previous = this.fsw._getWatchedDir(wh.path);
  const current = new Set();

  let stream = this.fsw._readdirp(directory, {
    fileFilter: entry => wh.filterPath(entry),
    directoryFilter: entry => wh.filterDir(entry),
    depth: 0
  }).on(STR_DATA$1, async (entry) => {
    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    const item = entry.path;
    let path = sysPath$2.join(directory, item);
    current.add(item);

    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
      return;
    }

    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    // Files that present in current directory snapshot
    // but absent in previous are added to watch list and
    // emit `add` event.
    if (item === target || !target && !previous.has(item)) {
      this.fsw._incrReadyCount();

      // ensure relativeness of path is preserved in case of watcher reuse
      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));

      this._addToNodeFs(path, initialAdd, wh, depth + 1);
    }
  }).on(EV_ERROR$2, this._boundHandleError);

  return new Promise(resolve =>
    stream.once(STR_END$2, () => {
      if (this.fsw.closed) {
        stream = undefined;
        return;
      }
      const wasThrottled = throttler ? throttler.clear() : false;

      resolve();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.getChildren().filter((item) => {
        return item !== directory &&
          !current.has(item) &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath$2.resolve(directory, item)
          }));
      }).forEach((item) => {
        this.fsw._remove(directory, item);
      });

      stream = undefined;

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
    })
  );
}

/**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targeted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */
async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
  const tracked = parentDir.has(sysPath$2.basename(dir));
  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath$2.basename(dir));
  this.fsw._getWatchedDir(dir);
  let throttler;
  let closer;

  const oDepth = this.fsw.options.depth;
  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
    if (!target) {
      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
      if (this.fsw.closed) return;
    }

    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
      // if current directory is removed, do nothing
      if (stats && stats.mtimeMs === 0) return;

      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
    });
  }
  return closer;
}

/**
 * Handle added file, directory, or glob pattern.
 * Delegates call to _handleFile / _handleDir after checks.
 * @param {String} path to file or ir
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @param {Object} priorWh depth relative to user-supplied path
 * @param {Number} depth Child path actually targeted for watch
 * @param {String=} target Child path actually targeted for watch
 * @returns {Promise}
 */
async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
  const ready = this.fsw._emitReady;
  if (this.fsw._isIgnored(path) || this.fsw.closed) {
    ready();
    return false;
  }

  const wh = this.fsw._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = entry => priorWh.filterPath(entry);
    wh.filterDir = entry => priorWh.filterDir(entry);
  }

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods$1[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      ready();
      return false;
    }

    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);
    let closer;
    if (stats.isDirectory()) {
      const absPath = sysPath$2.resolve(path);
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
      if (this.fsw.closed) return;
      // preserve this symlink's target path
      if (absPath !== targetPath && targetPath !== undefined) {
        this.fsw._symlinkPaths.set(absPath, targetPath);
      }
    } else if (stats.isSymbolicLink()) {
      const targetPath = follow ? await fsrealpath(path) : path;
      if (this.fsw.closed) return;
      const parent = sysPath$2.dirname(wh.watchPath);
      this.fsw._getWatchedDir(parent).add(wh.watchPath);
      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
      if (this.fsw.closed) return;

      // preserve this symlink's target path
      if (targetPath !== undefined) {
        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);
      }
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd);
    }
    ready();

    this.fsw._addPathCloser(path, closer);
    return false;

  } catch (error) {
    if (this.fsw._handleError(error)) {
      ready();
      return path;
    }
  }
}

};

var nodefsHandler = NodeFsHandler$1;

var fseventsHandler = {exports: {}};

const fs$3 = require$$0$4;
const sysPath$1 = require$$0$2;
const { promisify: promisify$1 } = require$$1;

let fsevents;
try {
  fsevents = __require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj = Number.parseInt(mtch[1], 10);
    const min = Number.parseInt(mtch[2], 10);
    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

const {
  EV_ADD: EV_ADD$1,
  EV_CHANGE: EV_CHANGE$1,
  EV_ADD_DIR: EV_ADD_DIR$1,
  EV_UNLINK: EV_UNLINK$1,
  EV_ERROR: EV_ERROR$1,
  STR_DATA,
  STR_END: STR_END$1,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,

  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE: FUNCTION_TYPE$1,
  EMPTY_FN: EMPTY_FN$1,
  IDENTITY_FN
} = constants$1;

const Depth = (value) => isNaN(value) ? {} : {depth: value};

const stat$1 = promisify$1(fs$3.stat);
const lstat = promisify$1(fs$3.lstat);
const realpath = promisify$1(fs$3.realpath);

const statMethods = { stat: stat$1, lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
const FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
const consolidateThreshhold = 10;

const wrongEventFlags = new Set([
  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
const createFSEventsInstance = (path, callback) => {
  const stop = fsevents.watch(path, callback);
  return {stop};
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;

  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  const resolvedPath = sysPath$1.resolve(path);
  const hasSymlink = resolvedPath !== realPath;

  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath$1.sep)
    ) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(list => {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return () => {
    const lst = cont.listeners;

    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
const couldConsolidate = (path) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
const canUse = () => fsevents && FSEventsWatchers.size < 128;

// determines subdirectory traversal levels from root to path
const calcDepth = (path, root) => {
  let i = 0;
  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;
  return i;
};

// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
const sameTypes = (info, stats) => (
  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||
  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||
  info.type === FSEVENT_TYPE_FILE && stats.isFile()
);

/**
 * @mixin
 */
let FsEventsHandler$1 = class FsEventsHandler {

/**
 * @param {import('../index').FSWatcher} fsw
 */
constructor(fsw) {
  this.fsw = fsw;
}
checkIgnored(path, stats) {
  const ipaths = this.fsw._ignoredPaths;
  if (this.fsw._isIgnored(path, stats)) {
    ipaths.add(path);
    if (stats && stats.isDirectory()) {
      ipaths.add(path + ROOT_GLOBSTAR);
    }
    return true;
  }

  ipaths.delete(path);
  ipaths.delete(path + ROOT_GLOBSTAR);
}

addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
}

async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  try {
    const stats = await stat$1(path);
    if (this.fsw.closed) return;
    if (sameTypes(info, stats)) {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  } catch (error) {
    if (error.code === 'EACCES') {
      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
    } else {
      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }
}

handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
  if (this.fsw.closed || this.checkIgnored(path)) return;

  if (event === EV_UNLINK$1) {
    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
    // suppress unlink events on never before seen files
    if (isDirectory || watchedDir.has(item)) {
      this.fsw._remove(parent, item, isDirectory);
    }
  } else {
    if (event === EV_ADD$1) {
      // track new directories
      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
        // push symlinks back to the top of the stack to get handled
        const curDepth = opts.depth === undefined ?
          undefined : calcDepth(fullPath, realPath) + 1;
        return this._addToFsEvents(path, false, true, curDepth);
      }

      // track new paths
      // (other than symlinks being followed, which will be tracked soon)
      this.fsw._getWatchedDir(parent).add(item);
    }
    /**
     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
     */
    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
    this.fsw._emit(eventName, path);
    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);
  }
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} watchPath  - file/dir path to be watched with fsevents
 * @param {String} realPath   - real path (in case of symlinks)
 * @param {Function} transform  - path transformer
 * @param {Function} globFilter - path filter in case a glob pattern was provided
 * @returns {Function} closer for the watcher instance
*/
_watchWithFsEvents(watchPath, realPath, transform, globFilter) {
  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
  const opts = this.fsw.options;
  const watchCallback = async (fullPath, flags, info) => {
    // PATCH: bypass the callback for better perf when fullPath hit the ignored file list
    if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
    if (
      opts.depth !== undefined &&
      calcDepth(fullPath, realPath) > opts.depth
    ) return;
    const path = transform(sysPath$1.join(
      watchPath, sysPath$1.relative(watchPath, fullPath)
    ));
    if (globFilter && !globFilter(path)) return;
    // ensure directories are tracked
    const parent = sysPath$1.dirname(path);
    const item = sysPath$1.basename(path);
    const watchedDir = this.fsw._getWatchedDir(
      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent
    );

    // correct for wrong events emitted
    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
      if (typeof opts.ignored === FUNCTION_TYPE$1) {
        let stats;
        try {
          stats = await stat$1(path);
        } catch (error) {}
        if (this.fsw.closed) return;
        if (this.checkIgnored(path, stats)) return;
        if (sameTypes(info, stats)) {
          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
        } else {
          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } else {
      switch (info.event) {
      case FSEVENT_CREATED:
      case FSEVENT_MODIFIED:
        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      case FSEVENT_DELETED:
      case FSEVENT_MOVED:
        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  };

  const closer = setFSEventsListener(
    watchPath,
    realPath,
    watchCallback,
    this.fsw._emitRaw
  );

  this.fsw._emitReady();
  return closer;
}

/**
 * Handle symlinks encountered during directory scan
 * @param {String} linkPath path to symlink
 * @param {String} fullPath absolute path to the symlink
 * @param {Function} transform pre-existing path transformer
 * @param {Number} curDepth level of subdirectories traversed to where symlink is
 * @returns {Promise<void>}
 */
async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
  // don't follow the same symlink more than once
  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;

  this.fsw._symlinkPaths.set(fullPath, true);
  this.fsw._incrReadyCount();

  try {
    const linkTarget = await realpath(linkPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(linkTarget)) {
      return this.fsw._emitReady();
    }

    this.fsw._incrReadyCount();

    // add the linkTarget for watching with a wrapper for transform
    // that causes emitted paths to incorporate the link's path
    this._addToFsEvents(linkTarget || linkPath, (path) => {
      let aliasedPath = linkPath;
      if (linkTarget && linkTarget !== DOT_SLASH) {
        aliasedPath = path.replace(linkTarget, linkPath);
      } else if (path !== DOT_SLASH) {
        aliasedPath = sysPath$1.join(linkPath, path);
      }
      return transform(aliasedPath);
    }, false, curDepth);
  } catch(error) {
    if (this.fsw._handleError(error)) {
      return this.fsw._emitReady();
    }
  }
}

/**
 *
 * @param {Path} newPath
 * @param {fs.Stats} stats
 */
emitAdd(newPath, stats, processPath, opts, forceAdd) {
  const pp = processPath(newPath);
  const isDir = stats.isDirectory();
  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));
  const base = sysPath$1.basename(pp);

  // ensure empty dirs get tracked
  if (isDir) this.fsw._getWatchedDir(pp);
  if (dirObj.has(base)) return;
  dirObj.add(base);

  if (!opts.ignoreInitial || forceAdd === true) {
    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
  }
}

initWatch(realPath, path, wh, processPath) {
  if (this.fsw.closed) return;
  const closer = this._watchWithFsEvents(
    wh.watchPath,
    sysPath$1.resolve(realPath || wh.watchPath),
    processPath,
    wh.globFilter
  );
  this.fsw._addPathCloser(path, closer);
}

/**
 * Handle added path with fsevents
 * @param {String} path file/dir path or glob pattern
 * @param {Function|Boolean=} transform converts working path to what the user expects
 * @param {Boolean=} forceAdd ensure add is emitted
 * @param {Number=} priorDepth Level of subdirectories already traversed.
 * @returns {Promise<void>}
 */
async _addToFsEvents(path, transform, forceAdd, priorDepth) {
  if (this.fsw.closed) {
    return;
  }
  const opts = this.fsw.options;
  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;

  const wh = this.fsw._getWatchHelpers(path);

  // evaluate what is at the path we're being asked to watch
  try {
    const stats = await statMethods[wh.statMethod](wh.watchPath);
    if (this.fsw.closed) return;
    if (this.fsw._isIgnored(wh.watchPath, stats)) {
      throw null;
    }
    if (stats.isDirectory()) {
      // emit addDir unless this is a glob parent
      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);

      // don't recurse further if it would exceed depth setting
      if (priorDepth && priorDepth > opts.depth) return;

      // scan the contents of the dir
      this.fsw._readdirp(wh.watchPath, {
        fileFilter: entry => wh.filterPath(entry),
        directoryFilter: entry => wh.filterDir(entry),
        ...Depth(opts.depth - (priorDepth || 0))
      }).on(STR_DATA, (entry) => {
        // need to check filterPath on dirs b/c filterDir is less restrictive
        if (this.fsw.closed) {
          return;
        }
        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;

        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);
        const {fullPath} = entry;

        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
          // preserve the current depth here since it can't be derived from
          // real paths past the symlink
          const curDepth = opts.depth === undefined ?
            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;

          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
        } else {
          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
        }
      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
        this.fsw._emitReady();
      });
    } else {
      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
      this.fsw._emitReady();
    }
  } catch (error) {
    if (!error || this.fsw._handleError(error)) {
      // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
      this.fsw._emitReady();
      this.fsw._emitReady();
    }
  }

  if (opts.persistent && forceAdd !== true) {
    if (typeof transform === FUNCTION_TYPE$1) {
      // realpath has already been resolved
      this.initWatch(undefined, path, wh, processPath);
    } else {
      let realPath;
      try {
        realPath = await realpath(wh.watchPath);
      } catch (e) {}
      this.initWatch(realPath, path, wh, processPath);
    }
  }
}

};

fseventsHandler.exports = FsEventsHandler$1;
fseventsHandler.exports.canUse = canUse;

var fseventsHandlerExports = fseventsHandler.exports;

const { EventEmitter: EventEmitter$2 } = require$$0$7;
const fs$2 = require$$0$4;
const sysPath = require$$0$2;
const { promisify } = require$$1;
const readdirp = readdirp_1;
const anymatch = anymatchExports.default;
const globParent = globParent$1;
const isGlob = isGlob$2;
const braces = braces_1;
const normalizePath = normalizePath$2;

const NodeFsHandler = nodefsHandler;
const FsEventsHandler = fseventsHandlerExports;
const {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,

  STR_CLOSE,
  STR_END,

  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,

  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,

  isWindows: isWindows$1,
  isMacos,
  isIBMi
} = constants$1;

const stat = promisify(fs$2.stat);
const readdir = promisify(fs$2.readdir);

/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

const arrify = (value = []) => Array.isArray(value) ? value : [value];
const flatten = (list, result = []) => {
  list.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

const unifyPaths = (paths_) => {
  /**
   * @type {Array<String>}
   */
  const paths = flatten(arrify(paths_));
  if (!paths.every(p => typeof p === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};

// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string) => {
  let str = string.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str = SLASH + str;
  }
  return str;
};

// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));

const normalizeIgnored = (cwd = EMPTY_STR) => (path) => {
  if (typeof path !== STRING_TYPE) return path;
  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
};

const getAbsolutePath = (path, cwd) => {
  if (sysPath.isAbsolute(path)) {
    return path;
  }
  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }
  return sysPath.join(cwd, path);
};

const undef = (opts, key) => opts[key] === undefined;

/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */
class DirEntry {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */
    this.items = new Set();
  }

  add(item) {
    const {items} = this;
    if (!items) return;
    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
  }

  async remove(item) {
    const {items} = this;
    if (!items) return;
    items.delete(item);
    if (items.size > 0) return;

    const dir = this.path;
    try {
      await readdir(dir);
    } catch (err) {
      if (this._removeWatcher) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }

  has(item) {
    const {items} = this;
    if (!items) return;
    return items.has(item);
  }

  /**
   * @returns {Array<String>}
   */
  getChildren() {
    const {items} = this;
    if (!items) return;
    return [...items.values()];
  }

  dispose() {
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
  }
}

const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
  constructor(path, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */
    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  checkGlobSymlink(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === EMPTY_STR
    if (this.globSymlink === undefined) {
      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?
        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};
    }

    if (this.globSymlink) {
      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }

    return entry.fullPath;
  }

  entryPath(entry) {
    return sysPath.join(this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
    );
  }

  filterPath(entry) {
    const {stats} = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?
      this.globFilter(resolvedPath) : true;
    return matchesGlob &&
      this.fsw._isntIgnored(resolvedPath, stats) &&
      this.fsw._hasReadPermissions(stats);
  }

  getDirParts(path) {
    if (!this.hasGlob) return [];
    const parts = [];
    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
    expandedPath.forEach((path) => {
      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
    });
    return parts;
  }

  filterDir(entry) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i) => {
          if (part === GLOBSTAR) globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
  }
}

/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter$2 {
// Not indenting methods for history sake; for now.
constructor(_opts) {
  super();

  const opts = {};
  if (_opts) Object.assign(opts, _opts); // for frozen objects

  /** @type {Map<String, DirEntry>} */
  this._watched = new Map();
  /** @type {Map<String, Array>} */
  this._closers = new Map();
  /** @type {Set<String>} */
  this._ignoredPaths = new Set();

  /** @type {Map<ThrottleType, Map>} */
  this._throttled = new Map();

  /** @type {Map<Path, String|Boolean>} */
  this._symlinkPaths = new Map();

  this._streams = new Set();
  this.closed = false;

  // Set up default options.
  if (undef(opts, 'persistent')) opts.persistent = true;
  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef(opts, 'interval')) opts.interval = 100;
  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  const canUseFsEvents = FsEventsHandler.canUse();
  if (!canUseFsEvents) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs_watch.
  if (undef(opts, 'usePolling') && !opts.useFsEvents) {
    opts.usePolling = isMacos;
  }

  // Always default to polling on IBM i because fs.watch() is not available on IBM i.
  if(isIBMi) {
    opts.usePolling = true;
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  const envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    const envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower;
    }
  }
  const envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = Number.parseInt(envInterval, 10);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = new Map();

  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  const awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;
    this._pendingWrites = new Map();
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  let readyCalls = 0;
  this._emitReady = () => {
    readyCalls++;
    if (readyCalls >= this._readyCount) {
      this._emitReady = EMPTY_FN;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(() => this.emit(EV_READY));
    }
  };
  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
  this._readyEmitted = false;
  this.options = opts;

  // Initialize with proper watcher.
  if (opts.useFsEvents) {
    this._fsEventsHandler = new FsEventsHandler(this);
  } else {
    this._nodeFsHandler = new NodeFsHandler(this);
  }

  // You’re frozen when your heart’s not open.
  Object.freeze(opts);
}

// Public methods

/**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param {Path|Array<Path>} paths_
 * @param {String=} _origAdd private; for handling non-existent paths to be watched
 * @param {Boolean=} _internal private; indicates a non-user add
 * @returns {FSWatcher} for chaining
 */
add(paths_, _origAdd, _internal) {
  const {cwd, disableGlobbing} = this.options;
  this.closed = false;
  let paths = unifyPaths(paths_);
  if (cwd) {
    paths = paths.map((path) => {
      const absPath = getAbsolutePath(path, cwd);

      // Check `path` instead of `absPath` because the cwd portion can't be a glob
      if (disableGlobbing || !isGlob(path)) {
        return absPath;
      }
      return normalizePath(absPath);
    });
  }

  // set aside negated glob strings
  paths = paths.filter((path) => {
    if (path.startsWith(BANG)) {
      this._ignoredPaths.add(path.slice(1));
      return false;
    }

    // if a path is being added that was previously ignored, stop ignoring it
    this._ignoredPaths.delete(path);
    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;

    return true;
  });

  if (this.options.useFsEvents && this._fsEventsHandler) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount += paths.length;
    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    Promise.all(
      paths.map(async path => {
        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
        if (res) this._emitReady();
        return res;
      })
    ).then(results => {
      if (this.closed) return;
      results.filter(item => item).forEach(item => {
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      });
    });
  }

  return this;
}

/**
 * Close watchers or start ignoring events from specified paths.
 * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
 * @returns {FSWatcher} for chaining
*/
unwatch(paths_) {
  if (this.closed) return this;
  const paths = unifyPaths(paths_);
  const {cwd} = this.options;

  paths.forEach((path) => {
    // convert to absolute path unless relative path already matches
    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
      if (cwd) path = sysPath.join(cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths.add(path);
    if (this._watched.has(path)) {
      this._ignoredPaths.add(path + SLASH_GLOBSTAR);
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;
  });

  return this;
}

/**
 * Close watchers and remove all listeners from watched paths.
 * @returns {Promise<void>}.
*/
close() {
  if (this.closed) return this._closePromise;
  this.closed = true;

  // Memory management.
  this.removeAllListeners();
  const closers = [];
  this._closers.forEach(closerList => closerList.forEach(closer => {
    const promise = closer();
    if (promise instanceof Promise) closers.push(promise);
  }));
  this._streams.forEach(stream => stream.destroy());
  this._userIgnored = undefined;
  this._readyCount = 0;
  this._readyEmitted = false;
  this._watched.forEach(dirent => dirent.dispose());
  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {
    this[`_${key}`].clear();
  });

  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
  return this._closePromise;
}

/**
 * Expose list of watched paths
 * @returns {Object} for chaining
*/
getWatched() {
  const watchList = {};
  this._watched.forEach((entry, dir) => {
    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || ONE_DOT] = entry.getChildren().sort();
  });
  return watchList;
}

emitWithAll(event, args) {
  this.emit(...args);
  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
}

// Common helpers
// --------------

/**
 * Normalize and emit events.
 * Calling _emit DOES NOT MEAN emit() would be called!
 * @param {EventName} event Type of event
 * @param {Path} path File or directory path
 * @param {*=} val1 arguments to be passed with event
 * @param {*=} val2
 * @param {*=} val3
 * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
async _emit(event, path, val1, val2, val3) {
  if (this.closed) return;

  const opts = this.options;
  if (isWindows$1) path = sysPath.normalize(path);
  if (opts.cwd) path = sysPath.relative(opts.cwd, path);
  /** @type Array<any> */
  const args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  const awf = opts.awaitWriteFinish;
  let pw;
  if (awf && (pw = this._pendingWrites.get(path))) {
    pw.lastChange = new Date();
    return this;
  }

  if (opts.atomic) {
    if (event === EV_UNLINK) {
      this._pendingUnlinks.set(path, args);
      setTimeout(() => {
        this._pendingUnlinks.forEach((entry, path) => {
          this.emit(...entry);
          this.emit(EV_ALL, ...entry);
          this._pendingUnlinks.delete(path);
        });
      }, typeof opts.atomic === 'number' ? opts.atomic : 100);
      return this;
    }
    if (event === EV_ADD && this._pendingUnlinks.has(path)) {
      event = args[0] = EV_CHANGE;
      this._pendingUnlinks.delete(path);
    }
  }

  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
    const awfEmit = (err, stats) => {
      if (err) {
        event = args[0] = EV_ERROR;
        args[1] = err;
        this.emitWithAll(event, args);
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        this.emitWithAll(event, args);
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === EV_CHANGE) {
    const isThrottled = !this._throttle(EV_CHANGE, path, 50);
    if (isThrottled) return this;
  }

  if (opts.alwaysStat && val1 === undefined &&
    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)
  ) {
    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
    let stats;
    try {
      stats = await stat(fullPath);
    } catch (err) {}
    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
    if (!stats || this.closed) return;
    args.push(stats);
  }
  this.emitWithAll(event, args);

  return this;
}

/**
 * Common handler for errors
 * @param {Error} error
 * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
_handleError(error) {
  const code = error && error.code;
  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
  ) {
    this.emit(EV_ERROR, error);
  }
  return error || this.closed;
}

/**
 * Helper utility for throttling
 * @param {ThrottleType} actionType type being throttled
 * @param {Path} path being acted upon
 * @param {Number} timeout duration of time to suppress duplicate actions
 * @returns {Object|false} tracking object or false if action should be suppressed
 */
_throttle(actionType, path, timeout) {
  if (!this._throttled.has(actionType)) {
    this._throttled.set(actionType, new Map());
  }

  /** @type {Map<Path, Object>} */
  const action = this._throttled.get(actionType);
  /** @type {Object} */
  const actionPath = action.get(path);

  if (actionPath) {
    actionPath.count++;
    return false;
  }

  let timeoutObject;
  const clear = () => {
    const item = action.get(path);
    const count = item ? item.count : 0;
    action.delete(path);
    clearTimeout(timeoutObject);
    if (item) clearTimeout(item.timeoutObject);
    return count;
  };
  timeoutObject = setTimeout(clear, timeout);
  const thr = {timeoutObject, clear, count: 0};
  action.set(path, thr);
  return thr;
}

_incrReadyCount() {
  return this._readyCount++;
}

/**
 * Awaits write operation to finish.
 * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
 * @param {Path} path being acted upon
 * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
 * @param {EventName} event
 * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
 */
_awaitWriteFinish(path, threshold, event, awfEmit) {
  let timeoutHandler;

  let fullPath = path;
  if (this.options.cwd && !sysPath.isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  const now = new Date();

  const awaitWriteFinish = (prevStat) => {
    fs$2.stat(fullPath, (err, curStat) => {
      if (err || !this._pendingWrites.has(path)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      const now = Number(new Date());

      if (prevStat && curStat.size !== prevStat.size) {
        this._pendingWrites.get(path).lastChange = now;
      }
      const pw = this._pendingWrites.get(path);
      const df = now - pw.lastChange;

      if (df >= threshold) {
        this._pendingWrites.delete(path);
        awfEmit(undefined, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish,
          this.options.awaitWriteFinish.pollInterval,
          curStat
        );
      }
    });
  };

  if (!this._pendingWrites.has(path)) {
    this._pendingWrites.set(path, {
      lastChange: now,
      cancelWait: () => {
        this._pendingWrites.delete(path);
        clearTimeout(timeoutHandler);
        return event;
      }
    });
    timeoutHandler = setTimeout(
      awaitWriteFinish,
      this.options.awaitWriteFinish.pollInterval
    );
  }
}

_getGlobIgnored() {
  return [...this._ignoredPaths.values()];
}

/**
 * Determines whether user has asked to ignore this path.
 * @param {Path} path filepath or dir
 * @param {fs.Stats=} stats result of fs.stat
 * @returns {Boolean}
 */
_isIgnored(path, stats) {
  if (this.options.atomic && DOT_RE.test(path)) return true;
  if (!this._userIgnored) {
    const {cwd} = this.options;
    const ign = this.options.ignored;

    const ignored = ign && ign.map(normalizeIgnored(cwd));
    const paths = arrify(ignored)
      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))
      .map((path) => path + SLASH_GLOBSTAR);
    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
  }

  return this._userIgnored([path, stats]);
}

_isntIgnored(path, stat) {
  return !this._isIgnored(path, stat);
}

/**
 * Provides a set of common helpers and properties relating to symlink and glob handling.
 * @param {Path} path file, directory, or glob pattern being watched
 * @param {Number=} depth at any depth > 0, this isn't a glob
 * @returns {WatchHelper} object containing helpers for this path
 */
_getWatchHelpers(path, depth) {
  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  const follow = this.options.followSymlinks;

  return new WatchHelper(path, watchPath, follow, this);
}

// Directory helpers
// -----------------

/**
 * Provides directory tracking objects
 * @param {String} directory path of the directory
 * @returns {DirEntry} the directory's tracking object
 */
_getWatchedDir(directory) {
  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
  const dir = sysPath.resolve(directory);
  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
  return this._watched.get(dir);
}

// File helpers
// ------------

/**
 * Check for read permissions.
 * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
 * @param {fs.Stats} stats - object, result of fs_stat
 * @returns {Boolean} indicates whether the file can be read
*/
_hasReadPermissions(stats) {
  if (this.options.ignorePermissionErrors) return true;

  // stats.mode may be bigint
  const md = stats && Number.parseInt(stats.mode, 10);
  const st = md & 0o777;
  const it = Number.parseInt(st.toString(8)[0], 10);
  return Boolean(4 & it);
}

/**
 * Handles emitting unlink events for
 * files and directories, and via recursion, for
 * files and directories within directories that are unlinked
 * @param {String} directory within which the following item is located
 * @param {String} item      base path of item/directory
 * @returns {void}
*/
_remove(directory, item, isDirectory) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  const path = sysPath.join(directory, item);
  const fullPath = sysPath.resolve(path);
  isDirectory = isDirectory != null
    ? isDirectory
    : this._watched.has(path) || this._watched.has(fullPath);

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  const wp = this._getWatchedDir(path);
  const nestedDirectoryChildren = wp.getChildren();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

  // Check if item was on the watched list and remove it
  const parent = this._getWatchedDir(directory);
  const wasTracked = parent.has(item);
  parent.remove(item);

  // Fixes issue #1042 -> Relative paths were detected and added as symlinks
  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
  // but never removed from the map in case the path was deleted.
  // This leads to an incorrect state if the path was recreated:
  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
  if (this._symlinkPaths.has(fullPath)) {
    this._symlinkPaths.delete(fullPath);
  }

  // If we wait for this file to be fully written, cancel the wait.
  let relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
    const event = this._pendingWrites.get(relPath).cancelWait();
    if (event === EV_ADD) return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  this._watched.delete(path);
  this._watched.delete(fullPath);
  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
}

/**
 * Closes all watchers for a path
 * @param {Path} path
 */
_closePath(path) {
  this._closeFile(path);
  const dir = sysPath.dirname(path);
  this._getWatchedDir(dir).remove(sysPath.basename(path));
}

/**
 * Closes only file-specific watchers
 * @param {Path} path
 */
_closeFile(path) {
  const closers = this._closers.get(path);
  if (!closers) return;
  closers.forEach(closer => closer());
  this._closers.delete(path);
}

/**
 *
 * @param {Path} path
 * @param {Function} closer
 */
_addPathCloser(path, closer) {
  if (!closer) return;
  let list = this._closers.get(path);
  if (!list) {
    list = [];
    this._closers.set(path, list);
  }
  list.push(closer);
}

_readdirp(root, opts) {
  if (this.closed) return;
  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};
  let stream = readdirp(root, options);
  this._streams.add(stream);
  stream.once(STR_CLOSE, () => {
    stream = undefined;
  });
  stream.once(STR_END, () => {
    if (stream) {
      this._streams.delete(stream);
      stream = undefined;
    }
  });
  return stream;
}

}

// Export FSWatcher class
chokidar.FSWatcher = FSWatcher;

/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */
const watch = (paths, options) => {
  const watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

chokidar.watch = watch;

var shellQuote$1 = {};

var quote = function quote(xs) {
	return xs.map(function (s) {
		if (s === '') {
			return '\'\'';
		}
		if (s && typeof s === 'object') {
			return s.op.replace(/(.)/g, '\\$1');
		}
		if ((/["\s]/).test(s) && !(/'/).test(s)) {
			return "'" + s.replace(/(['\\])/g, '\\$1') + "'";
		}
		if ((/["'\s]/).test(s)) {
			return '"' + s.replace(/(["\\$`!])/g, '\\$1') + '"';
		}
		return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, '$1\\$2');
	}).join(' ');
};

// '<(' is process substitution operator and
// can be parsed the same as control operator
var CONTROL = '(?:' + [
	'\\|\\|',
	'\\&\\&',
	';;',
	'\\|\\&',
	'\\<\\(',
	'\\<\\<\\<',
	'>>',
	'>\\&',
	'<\\&',
	'[&;()|<>]'
].join('|') + ')';
var controlRE = new RegExp('^' + CONTROL + '$');
var META = '|&;()<> \\t';
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';
var hash = /^#$/;

var SQ = "'";
var DQ = '"';
var DS = '$';

var TOKEN = '';
var mult = 0x100000000; // Math.pow(16, 8);
for (var i = 0; i < 4; i++) {
	TOKEN += (mult * Math.random()).toString(16);
}
var startsWithToken = new RegExp('^' + TOKEN);

function matchAll(s, r) {
	var origIndex = r.lastIndex;

	var matches = [];
	var matchObj;

	while ((matchObj = r.exec(s))) {
		matches.push(matchObj);
		if (r.lastIndex === matchObj.index) {
			r.lastIndex += 1;
		}
	}

	r.lastIndex = origIndex;

	return matches;
}

function getVar(env, pre, key) {
	var r = typeof env === 'function' ? env(key) : env[key];
	if (typeof r === 'undefined' && key != '') {
		r = '';
	} else if (typeof r === 'undefined') {
		r = '$';
	}

	if (typeof r === 'object') {
		return pre + TOKEN + JSON.stringify(r) + TOKEN;
	}
	return pre + r;
}

function parseInternal(string, env, opts) {
	if (!opts) {
		opts = {};
	}
	var BS = opts.escape || '\\';
	var BAREWORD = '(\\' + BS + '[\'"' + META + ']|[^\\s\'"' + META + '])+';

	var chunker = new RegExp([
		'(' + CONTROL + ')', // control chars
		'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'
	].join('|'), 'g');

	var matches = matchAll(string, chunker);

	if (matches.length === 0) {
		return [];
	}
	if (!env) {
		env = {};
	}

	var commented = false;

	return matches.map(function (match) {
		var s = match[0];
		if (!s || commented) {
			return void 0;
		}
		if (controlRE.test(s)) {
			return { op: s };
		}

		// Hand-written scanner/parser for Bash quoting rules:
		//
		// 1. inside single quotes, all characters are printed literally.
		// 2. inside double quotes, all characters are printed literally
		//    except variables prefixed by '$' and backslashes followed by
		//    either a double quote or another backslash.
		// 3. outside of any quotes, backslashes are treated as escape
		//    characters and not printed (unless they are themselves escaped)
		// 4. quote context can switch mid-token if there is no whitespace
		//     between the two quote contexts (e.g. all'one'"token" parses as
		//     "allonetoken")
		var quote = false;
		var esc = false;
		var out = '';
		var isGlob = false;
		var i;

		function parseEnvVar() {
			i += 1;
			var varend;
			var varname;
			var char = s.charAt(i);

			if (char === '{') {
				i += 1;
				if (s.charAt(i) === '}') {
					throw new Error('Bad substitution: ' + s.slice(i - 2, i + 1));
				}
				varend = s.indexOf('}', i);
				if (varend < 0) {
					throw new Error('Bad substitution: ' + s.slice(i));
				}
				varname = s.slice(i, varend);
				i = varend;
			} else if ((/[*@#?$!_-]/).test(char)) {
				varname = char;
				i += 1;
			} else {
				var slicedFromI = s.slice(i);
				varend = slicedFromI.match(/[^\w\d_]/);
				if (!varend) {
					varname = slicedFromI;
					i = s.length;
				} else {
					varname = slicedFromI.slice(0, varend.index);
					i += varend.index - 1;
				}
			}
			return getVar(env, '', varname);
		}

		for (i = 0; i < s.length; i++) {
			var c = s.charAt(i);
			isGlob = isGlob || (!quote && (c === '*' || c === '?'));
			if (esc) {
				out += c;
				esc = false;
			} else if (quote) {
				if (c === quote) {
					quote = false;
				} else if (quote == SQ) {
					out += c;
				} else { // Double quote
					if (c === BS) {
						i += 1;
						c = s.charAt(i);
						if (c === DQ || c === BS || c === DS) {
							out += c;
						} else {
							out += BS + c;
						}
					} else if (c === DS) {
						out += parseEnvVar();
					} else {
						out += c;
					}
				}
			} else if (c === DQ || c === SQ) {
				quote = c;
			} else if (controlRE.test(c)) {
				return { op: s };
			} else if (hash.test(c)) {
				commented = true;
				var commentObj = { comment: string.slice(match.index + i + 1) };
				if (out.length) {
					return [out, commentObj];
				}
				return [commentObj];
			} else if (c === BS) {
				esc = true;
			} else if (c === DS) {
				out += parseEnvVar();
			} else {
				out += c;
			}
		}

		if (isGlob) {
			return { op: 'glob', pattern: out };
		}

		return out;
	}).reduce(function (prev, arg) { // finalize parsed arguments
		// TODO: replace this whole reduce with a concat
		return typeof arg === 'undefined' ? prev : prev.concat(arg);
	}, []);
}

var parse$6 = function parse(s, env, opts) {
	var mapped = parseInternal(s, env, opts);
	if (typeof env !== 'function') {
		return mapped;
	}
	return mapped.reduce(function (acc, s) {
		if (typeof s === 'object') {
			return acc.concat(s);
		}
		var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
		if (xs.length === 1) {
			return acc.concat(xs[0]);
		}
		return acc.concat(xs.filter(Boolean).map(function (x) {
			if (startsWithToken.test(x)) {
				return JSON.parse(x.split(TOKEN)[1]);
			}
			return x;
		}));
	}, []);
};

shellQuote$1.quote = quote;
shellQuote$1.parse = parse$6;

var macos = {
  '/Applications/Atom.app/Contents/MacOS/Atom': 'atom',
  '/Applications/Atom Beta.app/Contents/MacOS/Atom Beta':
    '/Applications/Atom Beta.app/Contents/MacOS/Atom Beta',
  '/Applications/Brackets.app/Contents/MacOS/Brackets': 'brackets',
  '/Applications/Sublime Text.app/Contents/MacOS/Sublime Text':
    '/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl',
  '/Applications/Sublime Text.app/Contents/MacOS/sublime_text':
    '/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl',
  '/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2':
    '/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl',
  '/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text':
    '/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl',
  '/Applications/Visual Studio Code.app/Contents/MacOS/Electron': 'code',
  '/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron':
    'code-insiders',
  '/Applications/VSCodium.app/Contents/MacOS/Electron': 'codium',
  '/Applications/Cursor.app/Contents/MacOS/Cursor': 'cursor',
  '/Applications/AppCode.app/Contents/MacOS/appcode':
    '/Applications/AppCode.app/Contents/MacOS/appcode',
  '/Applications/CLion.app/Contents/MacOS/clion':
    '/Applications/CLion.app/Contents/MacOS/clion',
  '/Applications/IntelliJ IDEA.app/Contents/MacOS/idea':
    '/Applications/IntelliJ IDEA.app/Contents/MacOS/idea',
  '/Applications/IntelliJ IDEA Ultimate.app/Contents/MacOS/idea':
    '/Applications/IntelliJ IDEA Ultimate.app/Contents/MacOS/idea',
  '/Applications/IntelliJ IDEA Community Edition.app/Contents/MacOS/idea':
    '/Applications/IntelliJ IDEA Community Edition.app/Contents/MacOS/idea',
  '/Applications/PhpStorm.app/Contents/MacOS/phpstorm':
    '/Applications/PhpStorm.app/Contents/MacOS/phpstorm',
  '/Applications/PyCharm.app/Contents/MacOS/pycharm':
    '/Applications/PyCharm.app/Contents/MacOS/pycharm',
  '/Applications/PyCharm CE.app/Contents/MacOS/pycharm':
    '/Applications/PyCharm CE.app/Contents/MacOS/pycharm',
  '/Applications/RubyMine.app/Contents/MacOS/rubymine':
    '/Applications/RubyMine.app/Contents/MacOS/rubymine',
  '/Applications/WebStorm.app/Contents/MacOS/webstorm':
    '/Applications/WebStorm.app/Contents/MacOS/webstorm',
  '/Applications/MacVim.app/Contents/MacOS/MacVim': 'mvim',
  '/Applications/GoLand.app/Contents/MacOS/goland':
    '/Applications/GoLand.app/Contents/MacOS/goland',
  '/Applications/Rider.app/Contents/MacOS/rider':
    '/Applications/Rider.app/Contents/MacOS/rider',
  '/Applications/Zed.app/Contents/MacOS/zed': 'zed'
};

var linux = {
  atom: 'atom',
  Brackets: 'brackets',
  'code-insiders': 'code-insiders',
  code: 'code',
  vscodium: 'vscodium',
  codium: 'codium',
  emacs: 'emacs',
  gvim: 'gvim',
  idea: 'idea',
  'idea.sh': 'idea',
  phpstorm: 'phpstorm',
  'phpstorm.sh': 'phpstorm',
  pycharm: 'pycharm',
  'pycharm.sh': 'pycharm',
  rubymine: 'rubymine',
  'rubymine.sh': 'rubymine',
  sublime_text: 'subl',
  vim: 'vim',
  webstorm: 'webstorm',
  'webstorm.sh': 'webstorm',
  goland: 'goland',
  'goland.sh': 'goland',
  rider: 'rider',
  'rider.sh': 'rider'
};

var windows$1 = [
  'Brackets.exe',
  'Code.exe',
  'Code - Insiders.exe',
  'VSCodium.exe',
  'Cursor.exe',
  'atom.exe',
  'sublime_text.exe',
  'notepad++.exe',
  'clion.exe',
  'clion64.exe',
  'idea.exe',
  'idea64.exe',
  'phpstorm.exe',
  'phpstorm64.exe',
  'pycharm.exe',
  'pycharm64.exe',
  'rubymine.exe',
  'rubymine64.exe',
  'webstorm.exe',
  'webstorm64.exe',
  'goland.exe',
  'goland64.exe',
  'rider.exe',
  'rider64.exe'
];

const path$6 = require$$0$2;
const shellQuote = shellQuote$1;
const childProcess$1 = require$$2$1;

// Map from full process name to binary that starts the process
// We can't just re-use full process name, because it will spawn a new instance
// of the app every time
const COMMON_EDITORS_MACOS = macos;
const COMMON_EDITORS_LINUX = linux;
const COMMON_EDITORS_WIN = windows$1;

var guess = function guessEditor (specifiedEditor) {
  if (specifiedEditor) {
    return shellQuote.parse(specifiedEditor)
  }

  if (process.env.LAUNCH_EDITOR) {
    return [process.env.LAUNCH_EDITOR]
  }

  if (process.versions.webcontainer) {
    return [process.env.EDITOR || 'code']
  }

  // We can find out which editor is currently running by:
  // `ps x` on macOS and Linux
  // `Get-Process` on Windows
  try {
    if (process.platform === 'darwin') {
      const output = childProcess$1
        .execSync('ps x -o comm=', {
          stdio: ['pipe', 'pipe', 'ignore']
        })
        .toString();
      const processNames = Object.keys(COMMON_EDITORS_MACOS);
      const processList = output.split('\n');
      for (let i = 0; i < processNames.length; i++) {
        const processName = processNames[i];
        // Find editor by exact match.
        if (processList.includes(processName)) {
          return [COMMON_EDITORS_MACOS[processName]]
        }
        const processNameWithoutApplications = processName.replace('/Applications', '');
        // Find editor installation not in /Applications.
        if (output.indexOf(processNameWithoutApplications) !== -1) {
          // Use the CLI command if one is specified
          if (processName !== COMMON_EDITORS_MACOS[processName]) {
            return [COMMON_EDITORS_MACOS[processName]]
          }
          // Use a partial match to find the running process path.  If one is found, use the
          // existing path since it can be running from anywhere.
          const runningProcess = processList.find((procName) => procName.endsWith(processNameWithoutApplications));
          if (runningProcess !== undefined) {
            return [runningProcess]
          }
        }
      }
    } else if (process.platform === 'win32') {
      const output = childProcess$1
        .execSync(
          'powershell -NoProfile -Command "' +
            '[Console]::OutputEncoding=[Text.Encoding]::UTF8;' +
            'Get-CimInstance -Query \\"select executablepath from win32_process where executablepath is not null\\" | % { $_.ExecutablePath }' +
            '"',
          {
            stdio: ['pipe', 'pipe', 'ignore']
          }
        )
        .toString();
      const runningProcesses = output.split('\r\n');
      for (let i = 0; i < runningProcesses.length; i++) {
        const fullProcessPath = runningProcesses[i].trim();
        const shortProcessName = path$6.basename(fullProcessPath);

        if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) {
          return [fullProcessPath]
        }
      }
    } else if (process.platform === 'linux') {
      // --no-heading No header line
      // x List all processes owned by you
      // -o comm Need only names column
      const output = childProcess$1
        .execSync('ps x --no-heading -o comm --sort=comm', {
          stdio: ['pipe', 'pipe', 'ignore']
        })
        .toString();
      const processNames = Object.keys(COMMON_EDITORS_LINUX);
      for (let i = 0; i < processNames.length; i++) {
        const processName = processNames[i];
        if (output.indexOf(processName) !== -1) {
          return [COMMON_EDITORS_LINUX[processName]]
        }
      }
    }
  } catch (ignoreError) {
    // Ignore...
  }

  // Last resort, use old skool env vars
  if (process.env.VISUAL) {
    return [process.env.VISUAL]
  } else if (process.env.EDITOR) {
    return [process.env.EDITOR]
  }

  return [null]
};

const path$5 = require$$0$2;

// normalize file/line numbers into command line args for specific editors
var getArgs = function getArgumentsForPosition (
  editor,
  fileName,
  lineNumber,
  columnNumber = 1
) {
  const editorBasename = path$5.basename(editor).replace(/\.(exe|cmd|bat)$/i, '');
  switch (editorBasename) {
    case 'atom':
    case 'Atom':
    case 'Atom Beta':
    case 'subl':
    case 'sublime':
    case 'sublime_text':
    case 'wstorm':
    case 'charm':
    case 'zed':
      return [`${fileName}:${lineNumber}:${columnNumber}`]
    case 'notepad++':
      return ['-n' + lineNumber, '-c' + columnNumber, fileName]
    case 'vim':
    case 'mvim':
      return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName]
    case 'joe':
    case 'gvim':
      return ['+' + `${lineNumber}`, fileName]
    case 'emacs':
    case 'emacsclient':
      return [`+${lineNumber}:${columnNumber}`, fileName]
    case 'rmate':
    case 'mate':
    case 'mine':
      return ['--line', lineNumber, fileName]
    case 'code':
    case 'Code':
    case 'code-insiders':
    case 'Code - Insiders':
    case 'codium':
    case 'cursor':
    case 'vscodium':
    case 'VSCodium':
      return ['-r', '-g', `${fileName}:${lineNumber}:${columnNumber}`]
    case 'appcode':
    case 'clion':
    case 'clion64':
    case 'idea':
    case 'idea64':
    case 'phpstorm':
    case 'phpstorm64':
    case 'pycharm':
    case 'pycharm64':
    case 'rubymine':
    case 'rubymine64':
    case 'webstorm':
    case 'webstorm64':
    case 'goland':
    case 'goland64':
    case 'rider':
    case 'rider64':
      return ['--line', lineNumber, '--column', columnNumber, fileName]
  }

  if (process.env.LAUNCH_EDITOR) {
    return [fileName, lineNumber, columnNumber]
  }

  // For all others, drop the lineNumber until we have
  // a mapping above, since providing the lineNumber incorrectly
  // can result in errors or confusing behavior.
  return [fileName]
};

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/facebookincubator/create-react-app/blob/master/LICENSE
 *
 * Modified by Yuxi Evan You
 */

const fs$1 = require$$0$4;
const os = require$$2;
const path$4 = require$$0$2;
const colors = picocolorsExports;
const childProcess = require$$2$1;

const guessEditor = guess;
const getArgumentsForPosition = getArgs;

function wrapErrorCallback (cb) {
  return (fileName, errorMessage) => {
    console.log();
    console.log(
      colors.red('Could not open ' + path$4.basename(fileName) + ' in the editor.')
    );
    if (errorMessage) {
      if (errorMessage[errorMessage.length - 1] !== '.') {
        errorMessage += '.';
      }
      console.log(
        colors.red('The editor process exited with an error: ' + errorMessage)
      );
    }
    console.log();
    if (cb) cb(fileName, errorMessage);
  }
}

function isTerminalEditor (editor) {
  switch (editor) {
    case 'vim':
    case 'emacs':
    case 'nano':
      return true
  }
  return false
}

const positionRE = /:(\d+)(:(\d+))?$/;
function parseFile (file) {
  // support `file://` protocol
  if (file.startsWith('file://')) {
    file = require$$0$5.fileURLToPath(file);
  }

  const fileName = file.replace(positionRE, '');
  const match = file.match(positionRE);
  const lineNumber = match && match[1];
  const columnNumber = match && match[3];
  return {
    fileName,
    lineNumber,
    columnNumber
  }
}

let _childProcess = null;

function launchEditor (file, specifiedEditor, onErrorCallback) {
  const parsed = parseFile(file);
  let { fileName } = parsed;
  const { lineNumber, columnNumber } = parsed;

  if (!fs$1.existsSync(fileName)) {
    return
  }

  if (typeof specifiedEditor === 'function') {
    onErrorCallback = specifiedEditor;
    specifiedEditor = undefined;
  }

  onErrorCallback = wrapErrorCallback(onErrorCallback);

  const [editor, ...args] = guessEditor(specifiedEditor);
  if (!editor) {
    onErrorCallback(fileName, null);
    return
  }

  if (
    process.platform === 'linux' &&
    fileName.startsWith('/mnt/') &&
    /Microsoft/i.test(os.release())
  ) {
    // Assume WSL / "Bash on Ubuntu on Windows" is being used, and
    // that the file exists on the Windows file system.
    // `os.release()` is "4.4.0-43-Microsoft" in the current release
    // build of WSL, see: https://github.com/Microsoft/BashOnWindows/issues/423#issuecomment-221627364
    // When a Windows editor is specified, interop functionality can
    // handle the path translation, but only if a relative path is used.
    fileName = path$4.relative('', fileName);
  }

  if (lineNumber) {
    const extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber);
    args.push.apply(args, extraArgs);
  } else {
    args.push(fileName);
  }

  if (_childProcess && isTerminalEditor(editor)) {
    // There's an existing editor process already and it's attached
    // to the terminal, so go kill it. Otherwise two separate editor
    // instances attach to the stdin/stdout which gets confusing.
    _childProcess.kill('SIGKILL');
  }

  if (process.platform === 'win32') {
    // On Windows, we need to use `exec` with the `shell: true` option,
    // and some more sanitization is required.

    // However, CMD.exe on Windows is vulnerable to RCE attacks given a file name of the
    // form "C:\Users\myusername\Downloads\& curl 172.21.93.52".
    // `create-react-app` used a safe file name pattern to validate user-provided file names:
    // - https://github.com/facebook/create-react-app/pull/4866
    // - https://github.com/facebook/create-react-app/pull/5431
    // But that's not a viable solution for this package because
    // it's depended on by so many meta frameworks that heavily rely on
    // special characters in file names for filesystem-based routing.
    // We need to at least:
    // - Support `+` because it's used in SvelteKit and Vike
    // - Support `$` because it's used in Remix
    // - Support `(` and `)` because they are used in Analog, SolidStart, and Vike
    // - Support `@` because it's used in Vike
    // - Support `[` and `]` because they are widely used for [slug]
    // So here we choose to use `^` to escape special characters instead.

    // According to https://ss64.com/nt/syntax-esc.html,
    // we can use `^` to escape `&`, `<`, `>`, `|`, `%`, and `^`
    // I'm not sure if we have to escape all of these, but let's do it anyway
    function escapeCmdArgs (cmdArgs) {
      return cmdArgs.replace(/([&|<>,;=^])/g, '^$1')
    }

    // Need to double quote the editor path in case it contains spaces;
    // If the fileName contains spaces, we also need to double quote it in the arguments
    // However, there's a case that it's concatenated with line number and column number
    // which is separated by `:`. We need to double quote the whole string in this case.
    // Also, if the string contains the escape character `^`, it needs to be quoted, too.
    function doubleQuoteIfNeeded(str) {
      if (str.includes('^')) {
        // If a string includes an escaped character, not only does it need to be quoted,
        // but the quotes need to be escaped too.
        return `^"${str}^"`
      } else if (str.includes(' ')) {
        return `"${str}"`
      } 
      return str
    }
    const launchCommand = [editor, ...args.map(escapeCmdArgs)]
      .map(doubleQuoteIfNeeded)
      .join(' ');

    _childProcess = childProcess.exec(launchCommand, {
      stdio: 'inherit',
      shell: true
    });
  } else {
    _childProcess = childProcess.spawn(editor, args, { stdio: 'inherit' });
  }
  _childProcess.on('exit', function (errorCode) {
    _childProcess = null;

    if (errorCode) {
      onErrorCallback(fileName, '(code ' + errorCode + ')');
    }
  });

  _childProcess.on('error', function (error) {
    let { code, message } = error;
    if ('ENOENT' === code) {
      message = `${message} ('${editor}' command does not exist in 'PATH')`;
    }
    onErrorCallback(fileName, message);
  });
}

var launchEditor_1 = launchEditor;

const url$2 = require$$0$5;
const path$3 = require$$0$2;
const launch = launchEditor_1;

var launchEditorMiddleware = (specifiedEditor, srcRoot, onErrorCallback) => {
  if (typeof specifiedEditor === 'function') {
    onErrorCallback = specifiedEditor;
    specifiedEditor = undefined;
  }

  if (typeof srcRoot === 'function') {
    onErrorCallback = srcRoot;
    srcRoot = undefined;
  }

  srcRoot = srcRoot || process.cwd();

  return function launchEditorMiddleware (req, res) {
    const { file } = url$2.parse(req.url, true).query || {};
    if (!file) {
      res.statusCode = 500;
      res.end(`launch-editor-middleware: required query param "file" is missing.`);
    } else {
      launch(path$3.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
      res.end();
    }
  }
};

var launchEditorMiddleware$1 = /*@__PURE__*/getDefaultExportFromCjs(launchEditorMiddleware);

async function resolveHttpServer({ proxy }, app, httpsOptions) {
  if (!httpsOptions) {
    const { createServer } = await import('node:http');
    return createServer(app);
  }
  if (proxy) {
    const { createServer } = await import('node:https');
    return createServer(httpsOptions, app);
  } else {
    const { createSecureServer } = await import('node:http2');
    return createSecureServer(
      {
        // Manually increase the session memory to prevent 502 ENHANCE_YOUR_CALM
        // errors on large numbers of requests
        maxSessionMemory: 1e3,
        ...httpsOptions,
        allowHTTP1: true
      },
      // @ts-expect-error TODO: is this correct?
      app
    );
  }
}
async function resolveHttpsConfig(https) {
  if (!https) return void 0;
  const [ca, cert, key, pfx] = await Promise.all([
    readFileIfExists(https.ca),
    readFileIfExists(https.cert),
    readFileIfExists(https.key),
    readFileIfExists(https.pfx)
  ]);
  return { ...https, ca, cert, key, pfx };
}
async function readFileIfExists(value) {
  if (typeof value === "string") {
    return fsp.readFile(path$b.resolve(value)).catch(() => value);
  }
  return value;
}
async function httpServerStart(httpServer, serverOptions) {
  let { port, strictPort, host, logger } = serverOptions;
  return new Promise((resolve, reject) => {
    const onError = (e) => {
      if (e.code === "EADDRINUSE") {
        if (strictPort) {
          httpServer.removeListener("error", onError);
          reject(new Error(`Port ${port} is already in use`));
        } else {
          logger.info(`Port ${port} is in use, trying another one...`);
          httpServer.listen(++port, host);
        }
      } else {
        httpServer.removeListener("error", onError);
        reject(e);
      }
    };
    httpServer.on("error", onError);
    httpServer.listen(port, host, () => {
      httpServer.removeListener("error", onError);
      resolve(port);
    });
  });
}
function setClientErrorHandler(server, logger) {
  server.on("clientError", (err, socket) => {
    let msg = "400 Bad Request";
    if (err.code === "HPE_HEADER_OVERFLOW") {
      msg = "431 Request Header Fields Too Large";
      logger.warn(
        colors$1.yellow(
          "Server responded with status code 431. See https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large."
        )
      );
    }
    if (err.code === "ECONNRESET" || !socket.writable) {
      return;
    }
    socket.end(`HTTP/1.1 ${msg}\r
\r
`);
  });
}

let offset;
function calculateOffsetOnce() {
  if (offset !== void 0) {
    return;
  }
  try {
    new Function("throw new Error(1)")();
  } catch (e) {
    const match = /:(\d+):\d+\)$/.exec(e.stack.split("\n")[1]);
    offset = match ? +match[1] - 1 : 0;
  }
}
function ssrRewriteStacktrace(stack, moduleGraph) {
  calculateOffsetOnce();
  return stack.split("\n").map((line) => {
    return line.replace(
      /^ {4}at (?:(\S.*?)\s\()?(.+?):(\d+)(?::(\d+))?\)?/,
      (input, varName, id, line2, column) => {
        if (!id) return input;
        const mod = moduleGraph.getModuleById(id);
        const rawSourceMap = mod?.transformResult?.map;
        if (!rawSourceMap) {
          return input;
        }
        const traced = new TraceMap(rawSourceMap);
        const pos = originalPositionFor$1(traced, {
          line: Number(line2) - offset,
          // stacktrace's column is 1-indexed, but sourcemap's one is 0-indexed
          column: Number(column) - 1
        });
        if (!pos.source) {
          return input;
        }
        const trimmedVarName = varName?.trim();
        const sourceFile = path$b.resolve(path$b.dirname(id), pos.source);
        const source = `${sourceFile}:${pos.line}:${pos.column + 1}`;
        if (!trimmedVarName || trimmedVarName === "eval") {
          return `    at ${source}`;
        } else {
          return `    at ${trimmedVarName} (${source})`;
        }
      }
    );
  }).join("\n");
}
function rebindErrorStacktrace(e, stacktrace) {
  const { configurable, writable } = Object.getOwnPropertyDescriptor(
    e,
    "stack"
  );
  if (configurable) {
    Object.defineProperty(e, "stack", {
      value: stacktrace,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else if (writable) {
    e.stack = stacktrace;
  }
}
const rewroteStacktraces = /* @__PURE__ */ new WeakSet();
function ssrFixStacktrace(e, moduleGraph) {
  if (!e.stack) return;
  if (rewroteStacktraces.has(e)) return;
  const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
  rebindErrorStacktrace(e, stacktrace);
  rewroteStacktraces.add(e);
}

function createHMROptions(environment, options) {
  if (environment.config.server.hmr === false || options.hmr === false) {
    return false;
  }
  if (!("api" in environment.hot)) return false;
  return {
    logger: options.hmr?.logger
  };
}
const prepareStackTrace = {
  retrieveFile(id) {
    if (existsSync$1(id)) {
      return readFileSync$1(id, "utf-8");
    }
  }
};
function resolveSourceMapOptions(options) {
  if (options.sourcemapInterceptor != null) {
    if (options.sourcemapInterceptor === "prepareStackTrace") {
      return prepareStackTrace;
    }
    if (typeof options.sourcemapInterceptor === "object") {
      return { ...prepareStackTrace, ...options.sourcemapInterceptor };
    }
    return options.sourcemapInterceptor;
  }
  if (typeof process !== "undefined" && "setSourceMapsEnabled" in process) {
    return "node";
  }
  return prepareStackTrace;
}
const createServerModuleRunnerTransport = (options) => {
  const hmrClient = {
    send: (payload) => {
      if (payload.type !== "custom") {
        throw new Error(
          "Cannot send non-custom events from the client to the server."
        );
      }
      options.channel.send(payload);
    }
  };
  let handler;
  return {
    connect({ onMessage }) {
      options.channel.api.outsideEmitter.on("send", onMessage);
      onMessage({ type: "connected" });
      handler = onMessage;
    },
    disconnect() {
      if (handler) {
        options.channel.api.outsideEmitter.off("send", handler);
      }
    },
    send(payload) {
      if (payload.type !== "custom") {
        throw new Error(
          "Cannot send non-custom events from the server to the client."
        );
      }
      options.channel.api.innerEmitter.emit(
        payload.event,
        payload.data,
        hmrClient
      );
    }
  };
};
function createServerModuleRunner(environment, options = {}) {
  const hmr = createHMROptions(environment, options);
  return new ModuleRunner(
    {
      ...options,
      root: environment.config.root,
      transport: createServerModuleRunnerTransport({
        channel: environment.hot
      }),
      hmr,
      sourcemapInterceptor: resolveSourceMapOptions(options)
    },
    options.evaluator
  );
}

async function ssrLoadModule(url, server, fixStacktrace) {
  const environment = server.environments.ssr;
  server._ssrCompatModuleRunner ||= new SSRCompatModuleRunner(environment);
  url = unwrapId$1(url);
  return instantiateModule(
    url,
    server._ssrCompatModuleRunner,
    environment,
    fixStacktrace
  );
}
async function instantiateModule(url, runner, environment, fixStacktrace) {
  const mod = await environment.moduleGraph.ensureEntryFromUrl(url);
  if (mod.ssrError) {
    throw mod.ssrError;
  }
  try {
    return await runner.import(url);
  } catch (e) {
    if (e.stack && fixStacktrace) {
      ssrFixStacktrace(e, environment.moduleGraph);
    }
    environment.logger.error(
      buildErrorMessage(e, [
        colors$1.red(`Error when evaluating SSR module ${url}: ${e.message}`)
      ]),
      {
        timestamp: true,
        clear: environment.config.clearScreen,
        error: e
      }
    );
    throw e;
  }
}
class SSRCompatModuleRunner extends ModuleRunner {
  constructor(environment) {
    super(
      {
        root: environment.config.root,
        transport: createServerModuleRunnerTransport({
          channel: environment.hot
        }),
        sourcemapInterceptor: false,
        hmr: false
      },
      new ESModulesEvaluator()
    );
    this.environment = environment;
  }
  async directRequest(url, mod, callstack) {
    const id = mod.meta && "id" in mod.meta && mod.meta.id;
    if (!id) {
      return super.directRequest(url, mod, callstack);
    }
    const viteMod = this.environment.moduleGraph.getModuleById(id);
    if (!viteMod) {
      return super.directRequest(id, mod, callstack);
    }
    try {
      const exports = await super.directRequest(id, mod, callstack);
      viteMod.ssrModule = exports;
      return exports;
    } catch (err) {
      viteMod.ssrError = err;
      throw err;
    }
  }
}

/**
 * @param {import('estree').Node} param
 * @returns {string[]}
 */
function extract_names(param) {
	return extract_identifiers(param).map((node) => node.name);
}

/**
 * @param {import('estree').Node} param
 * @param {import('estree').Identifier[]} nodes
 * @returns {import('estree').Identifier[]}
 */
function extract_identifiers(param, nodes = []) {
	switch (param.type) {
		case 'Identifier':
			nodes.push(param);
			break;

		case 'MemberExpression':
			let object = param;
			while (object.type === 'MemberExpression') {
				object = /** @type {any} */ (object.object);
			}
			nodes.push(/** @type {any} */ (object));
			break;

		case 'ObjectPattern':
			for (const prop of param.properties) {
				if (prop.type === 'RestElement') {
					extract_identifiers(prop.argument, nodes);
				} else {
					extract_identifiers(prop.value, nodes);
				}
			}

			break;

		case 'ArrayPattern':
			for (const element of param.elements) {
				if (element) extract_identifiers(element, nodes);
			}

			break;

		case 'RestElement':
			extract_identifiers(param.argument, nodes);
			break;

		case 'AssignmentPattern':
			extract_identifiers(param.left, nodes);
			break;
	}

	return nodes;
}

/**
 * @typedef { import('estree').Node} Node
 * @typedef {{
 *   skip: () => void;
 *   remove: () => void;
 *   replace: (node: Node) => void;
 * }} WalkerContext
 */

class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 * @param {Node} node
	 */
	replace(parent, prop, index, node) {
		if (parent && prop) {
			if (index != null) {
				/** @type {Array<Node>} */ (parent[prop])[index] = node;
			} else {
				/** @type {Node} */ (parent[prop]) = node;
			}
		}
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 */
	remove(parent, prop, index) {
		if (parent && prop) {
			if (index !== null && index !== undefined) {
				/** @type {Array<Node>} */ (parent[prop]).splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
}

/**
 * @typedef { import('estree').Node} Node
 * @typedef { import('./walker.js').WalkerContext} WalkerContext
 * @typedef {(
 *    this: WalkerContext,
 *    node: Node,
 *    parent: Node | null,
 *    key: string | number | symbol | null | undefined,
 *    index: number | null | undefined
 * ) => void} SyncHandler
 */

class SyncWalker extends WalkerBase {
	/**
	 *
	 * @param {SyncHandler} [enter]
	 * @param {SyncHandler} [leave]
	 */
	constructor(enter, leave) {
		super();

		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};

		/** @type {SyncHandler | undefined} */
		this.enter = enter;

		/** @type {SyncHandler | undefined} */
		this.leave = leave;
	}

	/**
	 * @template {Node} Parent
	 * @param {Node} node
	 * @param {Parent | null} parent
	 * @param {keyof Parent} [prop]
	 * @param {number | null} [index]
	 * @returns {Node | null}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			/** @type {keyof Node} */
			let key;

			for (key in node) {
				/** @type {unknown} */
				const value = node[key];

				if (value && typeof value === 'object') {
					if (Array.isArray(value)) {
						const nodes = /** @type {Array<unknown>} */ (value);
						for (let i = 0; i < nodes.length; i += 1) {
							const item = nodes[i];
							if (isNode(item)) {
								if (!this.visit(item, node, key, i)) {
									// removed
									i--;
								}
							}
						}
					} else if (isNode(value)) {
						this.visit(value, node, key, null);
					}
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
}

/**
 * Ducktype a node.
 *
 * @param {unknown} value
 * @returns {value is Node}
 */
function isNode(value) {
	return (
		value !== null && typeof value === 'object' && 'type' in value && typeof value.type === 'string'
	);
}

/**
 * @typedef {import('estree').Node} Node
 * @typedef {import('./sync.js').SyncHandler} SyncHandler
 * @typedef {import('./async.js').AsyncHandler} AsyncHandler
 */

/**
 * @param {Node} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {Node | null}
 */
function walk$1(ast, { enter, leave }) {
	const instance = new SyncWalker(enter, leave);
	return instance.visit(ast, null);
}

const ssrModuleExportsKey = `__vite_ssr_exports__`;
const ssrImportKey = `__vite_ssr_import__`;
const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
const ssrExportAllKey = `__vite_ssr_exportAll__`;
const ssrImportMetaKey = `__vite_ssr_import_meta__`;
const hashbangRE = /^#!.*\n/;
async function ssrTransform(code, inMap, url, originalCode, options) {
  if (options?.json?.stringify && isJSONRequest(url)) {
    return ssrTransformJSON(code, inMap);
  }
  return ssrTransformScript(code, inMap, url, originalCode);
}
async function ssrTransformJSON(code, inMap) {
  return {
    code: code.replace("export default", `${ssrModuleExportsKey}.default =`),
    map: inMap,
    deps: [],
    dynamicDeps: [],
    ssr: true
  };
}
async function ssrTransformScript(code, inMap, url, originalCode) {
  const s = new MagicString(code);
  let ast;
  try {
    ast = await parseAstAsync(code);
  } catch (err) {
    if (err.code === "PARSE_ERROR") {
      err.message = `Parse failure: ${err.message}
`;
      err.id = url;
      if (typeof err.pos === "number") {
        err.loc = numberToPos(code, err.pos);
        err.loc.file = url;
        err.frame = generateCodeFrame(code, err.pos);
        err.message += `At file: ${url}:${err.loc.line}:${err.loc.column}`;
      } else {
        err.message += `At file: ${url}`;
      }
    }
    throw err;
  }
  let uid = 0;
  const deps = /* @__PURE__ */ new Set();
  const dynamicDeps = /* @__PURE__ */ new Set();
  const idToImportMap = /* @__PURE__ */ new Map();
  const declaredConst = /* @__PURE__ */ new Set();
  const fileStartIndex = hashbangRE.exec(code)?.[0].length ?? 0;
  let hoistIndex = fileStartIndex;
  function defineImport(index, importNode, metadata) {
    const source = importNode.source.value;
    deps.add(source);
    const metadataArg = (metadata?.importedNames?.length ?? 0) > 0 ? `, ${JSON.stringify(metadata)}` : "";
    const importId = `__vite_ssr_import_${uid++}__`;
    const transformedImport = `const ${importId} = await ${ssrImportKey}(${JSON.stringify(
      source
    )}${metadataArg});`;
    s.update(importNode.start, importNode.end, transformedImport);
    const nonWhitespaceRegex = /\S/g;
    nonWhitespaceRegex.lastIndex = index;
    nonWhitespaceRegex.exec(code);
    if (importNode.start > nonWhitespaceRegex.lastIndex) {
      s.move(importNode.start, importNode.end, index);
    } else {
      hoistIndex = importNode.end;
    }
    let linesSpanned = 1;
    for (let i = importNode.start; i < importNode.end; i++) {
      if (code[i] === "\n") {
        linesSpanned++;
      }
    }
    if (linesSpanned > 1) {
      s.prependRight(importNode.end, "\n".repeat(linesSpanned - 1));
    }
    return importId;
  }
  function defineExport(name, local = name) {
    s.appendLeft(
      fileStartIndex,
      `Object.defineProperty(${ssrModuleExportsKey}, ${JSON.stringify(name)}, { enumerable: true, configurable: true, get(){ try { return ${local} } catch {} }});
`
    );
  }
  const imports = [];
  const exports = [];
  const reExportImportIdMap = /* @__PURE__ */ new Map();
  for (const node of ast.body) {
    if (node.type === "ImportDeclaration") {
      imports.push(node);
    } else if (node.type === "ExportDefaultDeclaration") {
      exports.push(node);
    } else if (node.type === "ExportNamedDeclaration" || node.type === "ExportAllDeclaration") {
      imports.push(node);
      exports.push(node);
    }
  }
  for (const node of imports) {
    if (node.type === "ExportNamedDeclaration") {
      if (node.source) {
        const importId2 = defineImport(
          hoistIndex,
          node,
          {
            importedNames: node.specifiers.map(
              (s2) => getIdentifierNameOrLiteralValue$1(s2.local)
            )
          }
        );
        reExportImportIdMap.set(node, importId2);
      }
      continue;
    }
    if (node.type === "ExportAllDeclaration") {
      if (node.source) {
        const importId2 = defineImport(hoistIndex, node);
        reExportImportIdMap.set(node, importId2);
      }
      continue;
    }
    const importId = defineImport(hoistIndex, node, {
      importedNames: node.specifiers.map((s2) => {
        if (s2.type === "ImportSpecifier")
          return getIdentifierNameOrLiteralValue$1(s2.imported);
        else if (s2.type === "ImportDefaultSpecifier") return "default";
      }).filter(isDefined)
    });
    for (const spec of node.specifiers) {
      if (spec.type === "ImportSpecifier") {
        if (spec.imported.type === "Identifier") {
          idToImportMap.set(
            spec.local.name,
            `${importId}.${spec.imported.name}`
          );
        } else {
          idToImportMap.set(
            spec.local.name,
            `${importId}[${JSON.stringify(spec.imported.value)}]`
          );
        }
      } else if (spec.type === "ImportDefaultSpecifier") {
        idToImportMap.set(spec.local.name, `${importId}.default`);
      } else {
        idToImportMap.set(spec.local.name, importId);
      }
    }
  }
  for (const node of exports) {
    if (node.type === "ExportNamedDeclaration") {
      if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          defineExport(node.declaration.id.name);
        } else {
          for (const declaration of node.declaration.declarations) {
            const names = extract_names(declaration.id);
            for (const name of names) {
              defineExport(name);
            }
          }
        }
        s.remove(node.start, node.declaration.start);
      } else {
        if (node.source) {
          const importId = reExportImportIdMap.get(node);
          for (const spec of node.specifiers) {
            const exportedAs = getIdentifierNameOrLiteralValue$1(
              spec.exported
            );
            if (spec.local.type === "Identifier") {
              defineExport(exportedAs, `${importId}.${spec.local.name}`);
            } else {
              defineExport(
                exportedAs,
                `${importId}[${JSON.stringify(spec.local.value)}]`
              );
            }
          }
        } else {
          s.remove(node.start, node.end);
          for (const spec of node.specifiers) {
            const local = spec.local.name;
            const binding = idToImportMap.get(local);
            const exportedAs = getIdentifierNameOrLiteralValue$1(
              spec.exported
            );
            defineExport(exportedAs, binding || local);
          }
        }
      }
    }
    if (node.type === "ExportDefaultDeclaration") {
      const expressionTypes = ["FunctionExpression", "ClassExpression"];
      if ("id" in node.declaration && node.declaration.id && !expressionTypes.includes(node.declaration.type)) {
        const { name } = node.declaration.id;
        s.remove(
          node.start,
          node.start + 15
          /* 'export default '.length */
        );
        defineExport("default", name);
      } else {
        const name = `__vite_ssr_export_default__`;
        s.update(
          node.start,
          node.start + 14,
          `const ${name} =`
        );
        defineExport("default", name);
      }
    }
    if (node.type === "ExportAllDeclaration") {
      const importId = reExportImportIdMap.get(node);
      if (node.exported) {
        const exportedAs = getIdentifierNameOrLiteralValue$1(
          node.exported
        );
        defineExport(exportedAs, `${importId}`);
      } else {
        s.appendLeft(node.end, `${ssrExportAllKey}(${importId});
`);
      }
    }
  }
  walk(ast, {
    onStatements(statements) {
      for (let i = 0; i < statements.length - 1; i++) {
        const stmt = statements[i];
        if (code[stmt.end - 1] !== ";" && stmt.type !== "FunctionDeclaration" && stmt.type !== "ClassDeclaration" && stmt.type !== "BlockStatement" && stmt.type !== "ImportDeclaration") {
          s.appendLeft(stmt.end, ";");
        }
      }
    },
    onIdentifier(id, parent, parentStack) {
      const grandparent = parentStack[1];
      const binding = idToImportMap.get(id.name);
      if (!binding) {
        return;
      }
      if (isStaticProperty(parent) && parent.shorthand) {
        if (!isNodeInPattern(parent) || isInDestructuringAssignment(parent, parentStack)) {
          s.appendLeft(id.end, `: ${binding}`);
        }
      } else if (parent.type === "PropertyDefinition" && grandparent?.type === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
        if (!declaredConst.has(id.name)) {
          declaredConst.add(id.name);
          const topNode = parentStack[parentStack.length - 2];
          s.prependRight(topNode.start, `const ${id.name} = ${binding};
`);
        }
      } else if (parent.type === "CallExpression") {
        s.update(id.start, id.end, binding);
        s.prependRight(id.start, `(0,`);
        s.appendLeft(id.end, `)`);
      } else if (
        // don't transform class name identifier
        !(parent.type === "ClassExpression" && id === parent.id)
      ) {
        s.update(id.start, id.end, binding);
      }
    },
    onImportMeta(node) {
      s.update(node.start, node.end, ssrImportMetaKey);
    },
    onDynamicImport(node) {
      s.update(node.start, node.start + 6, ssrDynamicImportKey);
      if (node.type === "ImportExpression" && node.source.type === "Literal") {
        dynamicDeps.add(node.source.value);
      }
    }
  });
  let map;
  if (inMap?.mappings === "") {
    map = inMap;
  } else {
    map = s.generateMap({ hires: "boundary" });
    map.sources = [path$b.basename(url)];
    map.sourcesContent = [originalCode];
    if (inMap && inMap.mappings && "sources" in inMap && inMap.sources.length > 0) {
      map = combineSourcemaps(url, [
        map,
        inMap
      ]);
    }
  }
  return {
    code: s.toString(),
    map,
    ssr: true,
    deps: [...deps],
    dynamicDeps: [...dynamicDeps]
  };
}
function getIdentifierNameOrLiteralValue$1(node) {
  return node.type === "Identifier" ? node.name : node.value;
}
const isNodeInPatternWeakSet = /* @__PURE__ */ new WeakSet();
const setIsNodeInPattern = (node) => isNodeInPatternWeakSet.add(node);
const isNodeInPattern = (node) => isNodeInPatternWeakSet.has(node);
function walk(root, { onIdentifier, onImportMeta, onDynamicImport, onStatements }) {
  const parentStack = [];
  const varKindStack = [];
  const scopeMap = /* @__PURE__ */ new WeakMap();
  const identifiers = [];
  const setScope = (node, name) => {
    let scopeIds = scopeMap.get(node);
    if (scopeIds && scopeIds.has(name)) {
      return;
    }
    if (!scopeIds) {
      scopeIds = /* @__PURE__ */ new Set();
      scopeMap.set(node, scopeIds);
    }
    scopeIds.add(name);
  };
  function isInScope(name, parents) {
    return parents.some((node) => scopeMap.get(node)?.has(name));
  }
  function handlePattern(p, parentScope) {
    if (p.type === "Identifier") {
      setScope(parentScope, p.name);
    } else if (p.type === "RestElement") {
      handlePattern(p.argument, parentScope);
    } else if (p.type === "ObjectPattern") {
      p.properties.forEach((property) => {
        if (property.type === "RestElement") {
          setScope(parentScope, property.argument.name);
        } else {
          handlePattern(property.value, parentScope);
        }
      });
    } else if (p.type === "ArrayPattern") {
      p.elements.forEach((element) => {
        if (element) {
          handlePattern(element, parentScope);
        }
      });
    } else if (p.type === "AssignmentPattern") {
      handlePattern(p.left, parentScope);
    } else {
      setScope(parentScope, p.name);
    }
  }
  walk$1(root, {
    enter(node, parent) {
      if (node.type === "ImportDeclaration") {
        return this.skip();
      }
      if (node.type === "Program" || node.type === "BlockStatement" || node.type === "StaticBlock") {
        onStatements(node.body);
      } else if (node.type === "SwitchCase") {
        onStatements(node.consequent);
      }
      if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) {
        parentStack.unshift(parent);
      }
      if (node.type === "VariableDeclaration") {
        varKindStack.unshift(node.kind);
      }
      if (node.type === "MetaProperty" && node.meta.name === "import") {
        onImportMeta(node);
      } else if (node.type === "ImportExpression") {
        onDynamicImport(node);
      }
      if (node.type === "Identifier") {
        if (!isInScope(node.name, parentStack) && isRefIdentifier(node, parent, parentStack)) {
          identifiers.push([node, parentStack.slice(0)]);
        }
      } else if (isFunction$1(node)) {
        if (node.type === "FunctionDeclaration") {
          const parentScope = findParentScope(parentStack);
          if (parentScope) {
            setScope(parentScope, node.id.name);
          }
        }
        if (node.type === "FunctionExpression" && node.id) {
          setScope(node, node.id.name);
        }
        node.params.forEach((p) => {
          if (p.type === "ObjectPattern" || p.type === "ArrayPattern") {
            handlePattern(p, node);
            return;
          }
          walk$1(p.type === "AssignmentPattern" ? p.left : p, {
            enter(child, parent2) {
              if (parent2?.type === "AssignmentPattern" && parent2.right === child) {
                return this.skip();
              }
              if (child.type !== "Identifier") return;
              if (isStaticPropertyKey(child, parent2)) return;
              if (parent2?.type === "TemplateLiteral" && parent2.expressions.includes(child) || parent2?.type === "CallExpression" && parent2.callee === child) {
                return;
              }
              setScope(node, child.name);
            }
          });
        });
      } else if (node.type === "ClassDeclaration") {
        const parentScope = findParentScope(parentStack);
        if (parentScope) {
          setScope(parentScope, node.id.name);
        }
      } else if (node.type === "ClassExpression" && node.id) {
        setScope(node, node.id.name);
      } else if (node.type === "Property" && parent.type === "ObjectPattern") {
        setIsNodeInPattern(node);
      } else if (node.type === "VariableDeclarator") {
        const parentFunction = findParentScope(
          parentStack,
          varKindStack[0] === "var"
        );
        if (parentFunction) {
          handlePattern(node.id, parentFunction);
        }
      } else if (node.type === "CatchClause" && node.param) {
        handlePattern(node.param, node);
      }
    },
    leave(node, parent) {
      if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) {
        parentStack.shift();
      }
      if (node.type === "VariableDeclaration") {
        varKindStack.shift();
      }
    }
  });
  identifiers.forEach(([node, stack]) => {
    if (!isInScope(node.name, stack)) onIdentifier(node, stack[0], stack);
  });
}
function isRefIdentifier(id, parent, parentStack) {
  if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
    return false;
  }
  if (isFunction$1(parent)) {
    if (parent.id === id) {
      return false;
    }
    if (parent.params.includes(id)) {
      return false;
    }
  }
  if (parent.type === "MethodDefinition" && !parent.computed) {
    return false;
  }
  if (isStaticPropertyKey(id, parent)) {
    return false;
  }
  if (isNodeInPattern(parent) && parent.value === id) {
    return false;
  }
  if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
    return false;
  }
  if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
    return false;
  }
  if (parent.type === "ExportSpecifier" || parent.type === "ExportAllDeclaration") {
    return false;
  }
  if (id.name === "arguments") {
    return false;
  }
  return true;
}
const isStaticProperty = (node) => node.type === "Property" && !node.computed;
const isStaticPropertyKey = (node, parent) => parent && isStaticProperty(parent) && parent.key === node;
const functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/;
function isFunction$1(node) {
  return functionNodeTypeRE.test(node.type);
}
const blockNodeTypeRE = /^BlockStatement$|^For(?:In|Of)?Statement$/;
function isBlock(node) {
  return blockNodeTypeRE.test(node.type);
}
function findParentScope(parentStack, isVar = false) {
  return parentStack.find(isVar ? isFunction$1 : isBlock);
}
function isInDestructuringAssignment(parent, parentStack) {
  if (parent.type === "Property" || parent.type === "ArrayPattern") {
    return parentStack.some((i) => i.type === "AssignmentExpression");
  }
  return false;
}

let isDockerCached;

function hasDockerEnv() {
	try {
		fs__default.statSync('/.dockerenv');
		return true;
	} catch {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs__default.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch {
		return false;
	}
}

function isDocker() {
	// TODO: Use `??=` when targeting Node.js 16.
	if (isDockerCached === undefined) {
		isDockerCached = hasDockerEnv() || hasDockerCGroup();
	}

	return isDockerCached;
}

let cachedResult;

// Podman detection
const hasContainerEnv = () => {
	try {
		fs__default.statSync('/run/.containerenv');
		return true;
	} catch {
		return false;
	}
};

function isInsideContainer() {
	// TODO: Use `??=` when targeting Node.js 16.
	if (cachedResult === undefined) {
		cachedResult = hasContainerEnv() || isDocker();
	}

	return cachedResult;
}

const isWsl = () => {
	if (process$1.platform !== 'linux') {
		return false;
	}

	if (os$3.release().toLowerCase().includes('microsoft')) {
		if (isInsideContainer()) {
			return false;
		}

		return true;
	}

	try {
		return fs__default.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft')
			? !isInsideContainer() : false;
	} catch {
		return false;
	}
};

var isWsl$1 = process$1.env.__IS_WSL_TEST__ ? isWsl : isWsl();

function defineLazyProperty(object, propertyName, valueGetter) {
	const define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});

	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = valueGetter();
			define(result);
			return result;
		},
		set(value) {
			define(value);
		}
	});

	return object;
}

const execFileAsync$3 = promisify$4(execFile);

async function defaultBrowserId() {
	if (process$1.platform !== 'darwin') {
		throw new Error('macOS only');
	}

	const {stdout} = await execFileAsync$3('defaults', ['read', 'com.apple.LaunchServices/com.apple.launchservices.secure', 'LSHandlers']);

	// `(?!-)` is to prevent matching `LSHandlerRoleAll = "-";`.
	const match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);

	return match?.groups.id ?? 'com.apple.Safari';
}

const execFileAsync$2 = promisify$4(execFile);

async function runAppleScript(script, {humanReadableOutput = true} = {}) {
	if (process$1.platform !== 'darwin') {
		throw new Error('macOS only');
	}

	const outputArguments = humanReadableOutput ? [] : ['-ss'];

	const {stdout} = await execFileAsync$2('osascript', ['-e', script, outputArguments]);
	return stdout.trim();
}

async function bundleName(bundleId) {
	return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

const execFileAsync$1 = promisify$4(execFile);

// Windows doesn't have browser IDs in the same way macOS/Linux does so we give fake
// ones that look real and match the macOS/Linux versions for cross-platform apps.
const windowsBrowserProgIds = {
	AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {name: 'Edge', id: 'com.microsoft.edge.old'},
	MSEdgeDHTML: {name: 'Edge', id: 'com.microsoft.edge'}, // On macOS, it's "com.microsoft.edgemac"
	MSEdgeHTM: {name: 'Edge', id: 'com.microsoft.edge'}, // Newer Edge/Win10 releases
	'IE.HTTP': {name: 'Internet Explorer', id: 'com.microsoft.ie'},
	FirefoxURL: {name: 'Firefox', id: 'org.mozilla.firefox'},
	ChromeHTML: {name: 'Chrome', id: 'com.google.chrome'},
	BraveHTML: {name: 'Brave', id: 'com.brave.Browser'},
	BraveBHTML: {name: 'Brave Beta', id: 'com.brave.Browser.beta'},
	BraveSSHTM: {name: 'Brave Nightly', id: 'com.brave.Browser.nightly'},
};

class UnknownBrowserError extends Error {}

async function defaultBrowser$1(_execFileAsync = execFileAsync$1) {
	const {stdout} = await _execFileAsync('reg', [
		'QUERY',
		' HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice',
		'/v',
		'ProgId',
	]);

	const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
	if (!match) {
		throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
	}

	const {id} = match.groups;

	const browser = windowsBrowserProgIds[id];
	if (!browser) {
		throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
	}

	return browser;
}

const execFileAsync = promisify$4(execFile);

// Inlined: https://github.com/sindresorhus/titleize/blob/main/index.js
const titleize = string => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, x => x.toUpperCase());

async function defaultBrowser() {
	if (process$1.platform === 'darwin') {
		const id = await defaultBrowserId();
		const name = await bundleName(id);
		return {name, id};
	}

	if (process$1.platform === 'linux') {
		const {stdout} = await execFileAsync('xdg-mime', ['query', 'default', 'x-scheme-handler/http']);
		const id = stdout.trim();
		const name = titleize(id.replace(/.desktop$/, '').replace('-', ' '));
		return {name, id};
	}

	if (process$1.platform === 'win32') {
		return defaultBrowser$1();
	}

	throw new Error('Only macOS, Linux, and Windows are supported');
}

// Path to included `xdg-open`.
const __dirname = path$b.dirname(fileURLToPath$1(import.meta.url));
const localXdgOpenPath = path$b.join(__dirname, 'xdg-open');

const {platform, arch} = process$1;

/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string} The mount point.
*/
const getWslDrivesMountPoint = (() => {
	// Default value for "root" param
	// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
	const defaultMountPoint = '/mnt/';

	let mountPoint;

	return async function () {
		if (mountPoint) {
			// Return memoized mount point value
			return mountPoint;
		}

		const configFilePath = '/etc/wsl.conf';

		let isConfigFileExists = false;
		try {
			await fsp.access(configFilePath, constants$3.F_OK);
			isConfigFileExists = true;
		} catch {}

		if (!isConfigFileExists) {
			return defaultMountPoint;
		}

		const configContent = await fsp.readFile(configFilePath, {encoding: 'utf8'});
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);

		if (!configMountPoint) {
			return defaultMountPoint;
		}

		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;

		return mountPoint;
	};
})();

const pTryEach = async (array, mapper) => {
	let latestError;

	for (const item of array) {
		try {
			return await mapper(item); // eslint-disable-line no-await-in-loop
		} catch (error) {
			latestError = error;
		}
	}

	throw latestError;
};

const baseOpen = async options => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options,
	};

	if (Array.isArray(options.app)) {
		return pTryEach(options.app, singleApp => baseOpen({
			...options,
			app: singleApp,
		}));
	}

	let {name: app, arguments: appArguments = []} = options.app ?? {};
	appArguments = [...appArguments];

	if (Array.isArray(app)) {
		return pTryEach(app, appName => baseOpen({
			...options,
			app: {
				name: appName,
				arguments: appArguments,
			},
		}));
	}

	if (app === 'browser' || app === 'browserPrivate') {
		// IDs from default-browser for macOS and windows are the same
		const ids = {
			'com.google.chrome': 'chrome',
			'google-chrome.desktop': 'chrome',
			'org.mozilla.firefox': 'firefox',
			'firefox.desktop': 'firefox',
			'com.microsoft.msedge': 'edge',
			'com.microsoft.edge': 'edge',
			'com.microsoft.edgemac': 'edge',
			'microsoft-edge.desktop': 'edge',
		};

		// Incognito flags for each browser in `apps`.
		const flags = {
			chrome: '--incognito',
			firefox: '--private-window',
			edge: '--inPrivate',
		};

		const browser = await defaultBrowser();
		if (browser.id in ids) {
			const browserName = ids[browser.id];

			if (app === 'browserPrivate') {
				appArguments.push(flags[browserName]);
			}

			return baseOpen({
				...options,
				app: {
					name: apps[browserName],
					arguments: appArguments,
				},
			});
		}

		throw new Error(`${browser.name} is not supported as a default browser`);
	}

	let command;
	const cliArguments = [];
	const childProcessOptions = {};

	if (platform === 'darwin') {
		command = 'open';

		if (options.wait) {
			cliArguments.push('--wait-apps');
		}

		if (options.background) {
			cliArguments.push('--background');
		}

		if (options.newInstance) {
			cliArguments.push('--new');
		}

		if (app) {
			cliArguments.push('-a', app);
		}
	} else if (platform === 'win32' || (isWsl$1 && !isInsideContainer() && !app)) {
		const mountPoint = await getWslDrivesMountPoint();

		command = isWsl$1
			? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`
			: `${process$1.env.SYSTEMROOT || process$1.env.windir || 'C:\\Windows'}\\System32\\WindowsPowerShell\\v1.0\\powershell`;

		cliArguments.push(
			'-NoProfile',
			'-NonInteractive',
			'-ExecutionPolicy',
			'Bypass',
			'-EncodedCommand',
		);

		if (!isWsl$1) {
			childProcessOptions.windowsVerbatimArguments = true;
		}

		const encodedArguments = ['Start'];

		if (options.wait) {
			encodedArguments.push('-Wait');
		}

		if (app) {
			// Double quote with double quotes to ensure the inner quotes are passed through.
			// Inner quotes are delimited for PowerShell interpretation with backticks.
			encodedArguments.push(`"\`"${app}\`""`);
			if (options.target) {
				appArguments.push(options.target);
			}
		} else if (options.target) {
			encodedArguments.push(`"${options.target}"`);
		}

		if (appArguments.length > 0) {
			appArguments = appArguments.map(argument => `"\`"${argument}\`""`);
			encodedArguments.push('-ArgumentList', appArguments.join(','));
		}

		// Using Base64-encoded command, accepted by PowerShell, to allow special characters.
		options.target = Buffer$1.from(encodedArguments.join(' '), 'utf16le').toString('base64');
	} else {
		if (app) {
			command = app;
		} else {
			// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
			const isBundled = !__dirname || __dirname === '/';

			// Check if local `xdg-open` exists and is executable.
			let exeLocalXdgOpen = false;
			try {
				await fsp.access(localXdgOpenPath, constants$3.X_OK);
				exeLocalXdgOpen = true;
			} catch {}

			const useSystemXdgOpen = process$1.versions.electron
				?? (platform === 'android' || isBundled || !exeLocalXdgOpen);
			command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
		}

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		}

		if (!options.wait) {
			// `xdg-open` will block the process unless stdio is ignored
			// and it's detached from the parent even if it's unref'd.
			childProcessOptions.stdio = 'ignore';
			childProcessOptions.detached = true;
		}
	}

	if (platform === 'darwin' && appArguments.length > 0) {
		cliArguments.push('--args', ...appArguments);
	}

	// This has to come after `--args`.
	if (options.target) {
		cliArguments.push(options.target);
	}

	const subprocess = childProcess$2.spawn(command, cliArguments, childProcessOptions);

	if (options.wait) {
		return new Promise((resolve, reject) => {
			subprocess.once('error', reject);

			subprocess.once('close', exitCode => {
				if (!options.allowNonzeroExitCode && exitCode > 0) {
					reject(new Error(`Exited with code ${exitCode}`));
					return;
				}

				resolve(subprocess);
			});
		});
	}

	subprocess.unref();

	return subprocess;
};

const open = (target, options) => {
	if (typeof target !== 'string') {
		throw new TypeError('Expected a `target`');
	}

	return baseOpen({
		...options,
		target,
	});
};

function detectArchBinary(binary) {
	if (typeof binary === 'string' || Array.isArray(binary)) {
		return binary;
	}

	const {[arch]: archBinary} = binary;

	if (!archBinary) {
		throw new Error(`${arch} is not supported`);
	}

	return archBinary;
}

function detectPlatformBinary({[platform]: platformBinary}, {wsl}) {
	if (wsl && isWsl$1) {
		return detectArchBinary(wsl);
	}

	if (!platformBinary) {
		throw new Error(`${platform} is not supported`);
	}

	return detectArchBinary(platformBinary);
}

const apps = {};

defineLazyProperty(apps, 'chrome', () => detectPlatformBinary({
	darwin: 'google chrome',
	win32: 'chrome',
	linux: ['google-chrome', 'google-chrome-stable', 'chromium'],
}, {
	wsl: {
		ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
		x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'],
	},
}));

defineLazyProperty(apps, 'firefox', () => detectPlatformBinary({
	darwin: 'firefox',
	win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
	linux: 'firefox',
}, {
	wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe',
}));

defineLazyProperty(apps, 'edge', () => detectPlatformBinary({
	darwin: 'microsoft edge',
	win32: 'msedge',
	linux: ['microsoft-edge', 'microsoft-edge-dev'],
}, {
	wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',
}));

defineLazyProperty(apps, 'browser', () => 'browser');

defineLazyProperty(apps, 'browserPrivate', () => 'browserPrivate');

var crossSpawn = {exports: {}};

var windows;
var hasRequiredWindows;

function requireWindows () {
	if (hasRequiredWindows) return windows;
	hasRequiredWindows = 1;
	windows = isexe;
	isexe.sync = sync;

	var fs = require$$0$4;

	function checkPathExt (path, options) {
	  var pathext = options.pathExt !== undefined ?
	    options.pathExt : process.env.PATHEXT;

	  if (!pathext) {
	    return true
	  }

	  pathext = pathext.split(';');
	  if (pathext.indexOf('') !== -1) {
	    return true
	  }
	  for (var i = 0; i < pathext.length; i++) {
	    var p = pathext[i].toLowerCase();
	    if (p && path.substr(-p.length).toLowerCase() === p) {
	      return true
	    }
	  }
	  return false
	}

	function checkStat (stat, path, options) {
	  if (!stat.isSymbolicLink() && !stat.isFile()) {
	    return false
	  }
	  return checkPathExt(path, options)
	}

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, path, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), path, options)
	}
	return windows;
}

var mode;
var hasRequiredMode;

function requireMode () {
	if (hasRequiredMode) return mode;
	hasRequiredMode = 1;
	mode = isexe;
	isexe.sync = sync;

	var fs = require$$0$4;

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), options)
	}

	function checkStat (stat, options) {
	  return stat.isFile() && checkMode(stat, options)
	}

	function checkMode (stat, options) {
	  var mod = stat.mode;
	  var uid = stat.uid;
	  var gid = stat.gid;

	  var myUid = options.uid !== undefined ?
	    options.uid : process.getuid && process.getuid();
	  var myGid = options.gid !== undefined ?
	    options.gid : process.getgid && process.getgid();

	  var u = parseInt('100', 8);
	  var g = parseInt('010', 8);
	  var o = parseInt('001', 8);
	  var ug = u | g;

	  var ret = (mod & o) ||
	    (mod & g) && gid === myGid ||
	    (mod & u) && uid === myUid ||
	    (mod & ug) && myUid === 0;

	  return ret
	}
	return mode;
}

var core;
if (process.platform === 'win32' || commonjsGlobal.TESTING_WINDOWS) {
  core = requireWindows();
} else {
  core = requireMode();
}

var isexe_1 = isexe$1;
isexe$1.sync = sync;

function isexe$1 (path, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe$1(path, options || {}, function (er, is) {
        if (er) {
          reject(er);
        } else {
          resolve(is);
        }
      });
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys';

const path$2 = require$$0$2;
const COLON = isWindows ? ';' : ':';
const isexe = isexe_1;

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' });

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON;

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    );
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : '';
  const pathExt = isWindows ? pathExtExe.split(colon) : [''];

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('');
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
};

const which$1 = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt;
    opt = {};
  }
  if (!opt)
    opt = {};

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found = [];

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd;

    resolve(subStep(p, i, 0));
  });

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii];
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext);
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    });
  });

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
};

const whichSync = (cmd, opt) => {
  opt = opt || {};

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found = [];

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd;

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j];
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe });
        if (is) {
          if (opt.all)
            found.push(cur);
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
};

var which_1 = which$1;
which$1.sync = whichSync;

var pathKey$1 = {exports: {}};

const pathKey = (options = {}) => {
	const environment = options.env || process.env;
	const platform = options.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

pathKey$1.exports = pathKey;
// TODO: Remove this for the next major release
pathKey$1.exports.default = pathKey;

var pathKeyExports = pathKey$1.exports;

const path$1 = require$$0$2;
const which = which_1;
const getPathKey = pathKeyExports;

function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path$1.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path$1.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand$1(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

var resolveCommand_1 = resolveCommand$1;

var _escape = {};

// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd
    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input
    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(?=(\\+?)?)\1$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

_escape.command = escapeCommand;
_escape.argument = escapeArgument;

var shebangRegex$1 = /^#!(.*)/;

const shebangRegex = shebangRegex$1;

var shebangCommand$1 = (string = '') => {
	const match = string.match(shebangRegex);

	if (!match) {
		return null;
	}

	const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
	const binary = path.split('/').pop();

	if (binary === 'env') {
		return argument;
	}

	return argument ? `${binary} ${argument}` : binary;
};

const fs = require$$0$4;
const shebangCommand = shebangCommand$1;

function readShebang$1(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

var readShebang_1 = readShebang$1;

const path = require$$0$2;
const resolveCommand = resolveCommand_1;
const escape$1 = _escape;
const readShebang = readShebang_1;

const isWin$1 = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin$1) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape$1.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parse$5(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}

var parse_1 = parse$5;

const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed);

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

var enoent$1 = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};

const cp = require$$2$1;
const parse$4 = parse_1;
const enoent = enoent$1;

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse$4(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse$4(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

crossSpawn.exports = spawn;
crossSpawn.exports.spawn = spawn;
crossSpawn.exports.sync = spawnSync;

crossSpawn.exports._parse = parse$4;
crossSpawn.exports._enoent = enoent;

var crossSpawnExports = crossSpawn.exports;
var spawn$1 = /*@__PURE__*/getDefaultExportFromCjs(crossSpawnExports);

function openBrowser(url, opt, logger) {
  const browser = process.env.BROWSER || "";
  if (browser.toLowerCase().endsWith(".js")) {
    executeNodeScript(browser, url, logger);
  } else if (browser.toLowerCase() !== "none") {
    const browserArgs = process.env.BROWSER_ARGS ? process.env.BROWSER_ARGS.split(" ") : [];
    startBrowserProcess(browser, browserArgs, url, logger);
  }
}
function executeNodeScript(scriptPath, url, logger) {
  const extraArgs = process.argv.slice(2);
  const child = spawn$1(process.execPath, [scriptPath, ...extraArgs, url], {
    stdio: "inherit"
  });
  child.on("close", (code) => {
    if (code !== 0) {
      logger.error(
        colors$1.red(
          `
The script specified as BROWSER environment variable failed.

${colors$1.cyan(
            scriptPath
          )} exited with code ${code}.`
        ),
        { error: null }
      );
    }
  });
}
const supportedChromiumBrowsers = [
  "Google Chrome Canary",
  "Google Chrome Dev",
  "Google Chrome Beta",
  "Google Chrome",
  "Microsoft Edge",
  "Brave Browser",
  "Vivaldi",
  "Chromium"
];
async function startBrowserProcess(browser, browserArgs, url, logger) {
  const preferredOSXBrowser = browser === "google chrome" ? "Google Chrome" : browser;
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (!preferredOSXBrowser || supportedChromiumBrowsers.includes(preferredOSXBrowser));
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const ps = await execAsync("ps cax");
      const openedBrowser = preferredOSXBrowser && ps.includes(preferredOSXBrowser) ? preferredOSXBrowser : supportedChromiumBrowsers.find((b) => ps.includes(b));
      if (openedBrowser) {
        await execAsync(
          `osascript openChrome.applescript "${url}" "${openedBrowser}"`,
          {
            cwd: join$1(VITE_PACKAGE_DIR, "bin")
          }
        );
        return true;
      }
    } catch {
    }
  }
  if (process.platform === "darwin" && browser === "open") {
    browser = void 0;
  }
  try {
    const options = browser ? { app: { name: browser, arguments: browserArgs } } : {};
    new Promise((_, reject) => {
      open(url, options).then((subprocess) => {
        subprocess.on("error", reject);
      }).catch(reject);
    }).catch((err) => {
      logger.error(err.stack || err.message);
    });
    return true;
  } catch {
    return false;
  }
}
function execAsync(command, options) {
  return new Promise((resolve, reject) => {
    exec(command, options, (error, stdout) => {
      if (error) {
        reject(error);
      } else {
        resolve(stdout.toString());
      }
    });
  });
}

function bindCLIShortcuts(server, opts) {
  if (!server.httpServer || !process.stdin.isTTY || process.env.CI) {
    return;
  }
  const isDev = isDevServer(server);
  if (isDev) {
    server._shortcutsOptions = opts;
  }
  if (opts?.print) {
    server.config.logger.info(
      colors$1.dim(colors$1.green("  \u279C")) + colors$1.dim("  press ") + colors$1.bold("h + enter") + colors$1.dim(" to show help")
    );
  }
  const shortcuts = (opts?.customShortcuts ?? []).concat(
    isDev ? BASE_DEV_SHORTCUTS : BASE_PREVIEW_SHORTCUTS
  );
  let actionRunning = false;
  const onInput = async (input) => {
    if (actionRunning) return;
    if (input === "h") {
      const loggedKeys = /* @__PURE__ */ new Set();
      server.config.logger.info("\n  Shortcuts");
      for (const shortcut2 of shortcuts) {
        if (loggedKeys.has(shortcut2.key)) continue;
        loggedKeys.add(shortcut2.key);
        if (shortcut2.action == null) continue;
        server.config.logger.info(
          colors$1.dim("  press ") + colors$1.bold(`${shortcut2.key} + enter`) + colors$1.dim(` to ${shortcut2.description}`)
        );
      }
      return;
    }
    const shortcut = shortcuts.find((shortcut2) => shortcut2.key === input);
    if (!shortcut || shortcut.action == null) return;
    actionRunning = true;
    await shortcut.action(server);
    actionRunning = false;
  };
  const rl = readline.createInterface({ input: process.stdin });
  rl.on("line", onInput);
  server.httpServer.on("close", () => rl.close());
}
const BASE_DEV_SHORTCUTS = [
  {
    key: "r",
    description: "restart the server",
    async action(server) {
      await restartServerWithUrls(server);
    }
  },
  {
    key: "u",
    description: "show server url",
    action(server) {
      server.config.logger.info("");
      server.printUrls();
    }
  },
  {
    key: "o",
    description: "open in browser",
    action(server) {
      server.openBrowser();
    }
  },
  {
    key: "c",
    description: "clear console",
    action(server) {
      server.config.logger.clearScreen("error");
    }
  },
  {
    key: "q",
    description: "quit",
    async action(server) {
      try {
        await server.close();
      } finally {
        process.exit();
      }
    }
  }
];
const BASE_PREVIEW_SHORTCUTS = [
  {
    key: "o",
    description: "open in browser",
    action(server) {
      const url = server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0];
      if (url) {
        openBrowser(url, true, server.config.logger);
      } else {
        server.config.logger.warn("No URL available to open in browser");
      }
    }
  },
  {
    key: "q",
    description: "quit",
    async action(server) {
      try {
        await server.close();
      } finally {
        process.exit();
      }
    }
  }
];

function getResolvedOutDirs(root, outDir, outputOptions) {
  const resolvedOutDir = path$b.resolve(root, outDir);
  if (!outputOptions) return /* @__PURE__ */ new Set([resolvedOutDir]);
  return new Set(
    arraify(outputOptions).map(
      ({ dir }) => dir ? path$b.resolve(root, dir) : resolvedOutDir
    )
  );
}
function resolveEmptyOutDir(emptyOutDir, root, outDirs, logger) {
  if (emptyOutDir != null) return emptyOutDir;
  for (const outDir of outDirs) {
    if (!normalizePath$3(outDir).startsWith(withTrailingSlash(root))) {
      logger?.warn(
        colors$1.yellow(
          `
${colors$1.bold(`(!)`)} outDir ${colors$1.white(
            colors$1.dim(outDir)
          )} is not inside project root and will not be emptied.
Use --emptyOutDir to override.
`
        )
      );
      return false;
    }
  }
  return true;
}
function resolveChokidarOptions(options, resolvedOutDirs, emptyOutDir, cacheDir) {
  const { ignored: ignoredList, ...otherOptions } = options ?? {};
  const ignored = [
    "**/.git/**",
    "**/node_modules/**",
    "**/test-results/**",
    // Playwright
    escapePath(cacheDir) + "/**",
    ...arraify(ignoredList || [])
  ];
  if (emptyOutDir) {
    ignored.push(
      ...[...resolvedOutDirs].map((outDir) => escapePath(outDir) + "/**")
    );
  }
  const resolvedWatchOptions = {
    ignored,
    ignoreInitial: true,
    ignorePermissionErrors: true,
    ...otherOptions
  };
  return resolvedWatchOptions;
}
class NoopWatcher extends EventEmitter$4 {
  constructor(options) {
    super();
    this.options = options;
  }
  add() {
    return this;
  }
  unwatch() {
    return this;
  }
  getWatched() {
    return {};
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
  async close() {
  }
}
function createNoopWatcher(options) {
  return new NoopWatcher(options);
}

var bufferUtil$1 = {exports: {}};

const BINARY_TYPES$2 = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob$1 = typeof Blob !== 'undefined';

if (hasBlob$1) BINARY_TYPES$2.push('blob');

var constants = {
  BINARY_TYPES: BINARY_TYPES$2,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob: hasBlob$1,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};

const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;

const FastBuffer$2 = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat$1(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER$3;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }

  return buf;
}

bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = require('bufferutil');

    bufferUtil$1.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    bufferUtil$1.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var bufferUtilExports = bufferUtil$1.exports;

const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
let Limiter$1 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
};

var limiter = Limiter$1;

const zlib = zlib$1;

const bufferUtil = bufferUtilExports;
const Limiter = limiter;
const { kStatusCode: kStatusCode$2 } = constants;

const FastBuffer$1 = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError$1 = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
let PerMessageDeflate$4 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError$1];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer$1(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
};

var permessageDeflate = PerMessageDeflate$4;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError$1] = new RangeError('Max payload size exceeded');
  this[kError$1].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}

var validation = {exports: {}};

const { isUtf8 } = require$$0$9;

const { hasBlob } = constants;

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars$2 = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode$2(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob$2(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

validation.exports = {
  isBlob: isBlob$2,
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};

if (isUtf8) {
  validation.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = require('utf-8-validate');

    validation.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}

var validationExports = validation.exports;

const { Writable: Writable$1 } = require$$0$8;

const PerMessageDeflate$3 = permessageDeflate;
const {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$3
} = constants;
const { concat, toArrayBuffer, unmask } = bufferUtilExports;
const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
let Receiver$1 = class Receiver extends Writable$1 {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES$1[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket$3] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER$2;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER$2);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode$1(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode$1] = statusCode;
    return err;
  }
};

var receiver = Receiver$1;

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */
const { randomFillSync } = require$$3;

const PerMessageDeflate$2 = permessageDeflate;
const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$2 } = constants;
const { isBlob: isBlob$1, isValidStatusCode } = validationExports;
const { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
let Sender$1 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP$2;
    this[kWebSocket$2] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob$1(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob$1(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer$1(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};

var sender = Sender$1;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}

const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
let Event$1 = class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
};

Object.defineProperty(Event$1.prototype, 'target', { enumerable: true });
Object.defineProperty(Event$1.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event$1 {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event$1 {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event$1 {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute$1] &&
        listener[kListener$1] === handler &&
        !listener[kForOnEventAttribute$1]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event$1('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

var eventTarget = {
  EventTarget};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}

const { tokenChars: tokenChars$1 } = validationExports;

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse$3(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format$1(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

var extension$1 = { format: format$1, parse: parse$3 };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

const EventEmitter$1 = require$$0$7;
const https$2 = require$$1$3;
const http$3 = require$$1$2;
const net = require$$4$1;
const tls = require$$4$2;
const { randomBytes, createHash: createHash$1 } = require$$3;
const { URL: URL$2 } = require$$0$5;

const PerMessageDeflate$1 = permessageDeflate;
const Receiver = receiver;
const Sender = sender;
const { isBlob } = validationExports;

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP: NOOP$1
} = constants;
const {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
const { format, parse: parse$2 } = extension$1;
const { toBuffer } = bufferUtilExports;

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
let WebSocket$1 = class WebSocket extends EventEmitter$1 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket$1] = this;
    sender[kWebSocket$1] = this;
    socket[kWebSocket$1] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError$1);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$1(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake$1(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
};

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$1, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$1.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$1, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$1.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$1, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$1.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket$1, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket$1.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket$1.prototype.addEventListener = addEventListener;
WebSocket$1.prototype.removeEventListener = removeEventListener;

var websocket = WebSocket$1;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL$2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake$1(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL$2(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake$1(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket$1.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake$1(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash$1('sha1')
      .update(key + GUID$1)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake$1(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake$1(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse$2(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate$1.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake$1(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate$1.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket$1.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake$1(websocket, stream, message) {
  websocket._readyState = WebSocket$1.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket$1];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket$1] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket$1];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket$1];

  if (websocket._socket[kWebSocket$1] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket$1].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket$1];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP$1);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket$1].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket$1];

  if (websocket.readyState === WebSocket$1.CLOSED) return;
  if (websocket.readyState === WebSocket$1.OPEN) {
    websocket._readyState = WebSocket$1.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket$1];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket$1.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket$1] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket$1];

  websocket._readyState = WebSocket$1.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError$1() {
  const websocket = this[kWebSocket$1];

  this.removeListener('error', socketOnError$1);
  this.on('error', NOOP$1);

  if (websocket) {
    websocket._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}

const { tokenChars } = validationExports;

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse$1(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

var subprotocol$1 = { parse: parse$1 };

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

const EventEmitter = require$$0$7;
const http$2 = require$$1$2;
const { createHash } = require$$3;

const extension = extension$1;
const PerMessageDeflate = permessageDeflate;
const subprotocol = subprotocol$1;
const WebSocket = websocket;
const { GUID, kWebSocket } = constants;

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http$2.createServer((req, res) => {
        const body = http$2.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

var websocketServer = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}

var WebSocketServerRaw_ = /*@__PURE__*/getDefaultExportFromCjs(websocketServer);

const allowedHostsServerCache = /* @__PURE__ */ new WeakMap();
const allowedHostsPreviewCache = /* @__PURE__ */ new WeakMap();
const isFileOrExtensionProtocolRE = /^(?:file|.+-extension):/i;
function getAdditionalAllowedHosts(resolvedServerOptions, resolvedPreviewOptions) {
  const list = [];
  if (typeof resolvedServerOptions.host === "string" && resolvedServerOptions.host) {
    list.push(resolvedServerOptions.host);
  }
  if (typeof resolvedServerOptions.hmr === "object" && resolvedServerOptions.hmr.host) {
    list.push(resolvedServerOptions.hmr.host);
  }
  if (typeof resolvedPreviewOptions.host === "string" && resolvedPreviewOptions.host) {
    list.push(resolvedPreviewOptions.host);
  }
  if (resolvedServerOptions.origin) {
    try {
      const serverOriginUrl = new URL(resolvedServerOptions.origin);
      list.push(serverOriginUrl.hostname);
    } catch {
    }
  }
  return list;
}
function isHostAllowedWithoutCache(allowedHosts, additionalAllowedHosts, host) {
  if (isFileOrExtensionProtocolRE.test(host)) {
    return true;
  }
  const trimmedHost = host.trim();
  if (trimmedHost[0] === "[") {
    const endIpv6 = trimmedHost.indexOf("]");
    if (endIpv6 < 0) {
      return false;
    }
    return net$1.isIP(trimmedHost.slice(1, endIpv6)) === 6;
  }
  const colonPos = trimmedHost.indexOf(":");
  const hostname = colonPos === -1 ? trimmedHost : trimmedHost.slice(0, colonPos);
  if (net$1.isIP(hostname) === 4) {
    return true;
  }
  if (hostname === "localhost" || hostname.endsWith(".localhost")) {
    return true;
  }
  for (const additionalAllowedHost of additionalAllowedHosts) {
    if (additionalAllowedHost === hostname) {
      return true;
    }
  }
  for (const allowedHost of allowedHosts) {
    if (allowedHost === hostname) {
      return true;
    }
    if (allowedHost[0] === "." && (allowedHost.slice(1) === hostname || hostname.endsWith(allowedHost))) {
      return true;
    }
  }
  return false;
}
function isHostAllowed(config, isPreview, host) {
  const allowedHosts = isPreview ? config.preview.allowedHosts : config.server.allowedHosts;
  if (allowedHosts === true) {
    return true;
  }
  const cache = isPreview ? allowedHostsPreviewCache : allowedHostsServerCache;
  if (!cache.has(config)) {
    cache.set(config, /* @__PURE__ */ new Set());
  }
  const cachedAllowedHosts = cache.get(config);
  if (cachedAllowedHosts.has(host)) {
    return true;
  }
  const result = isHostAllowedWithoutCache(
    allowedHosts,
    config.additionalAllowedHosts,
    host
  );
  if (result) {
    cachedAllowedHosts.add(host);
  }
  return result;
}
function hostCheckMiddleware(config, isPreview) {
  return function viteHostCheckMiddleware(req, res, next) {
    const hostHeader = req.headers.host;
    if (!hostHeader || !isHostAllowed(config, isPreview, hostHeader)) {
      const hostname = hostHeader?.replace(/:\d+$/, "");
      const hostnameWithQuotes = JSON.stringify(hostname);
      const optionName = `${isPreview ? "preview" : "server"}.allowedHosts`;
      res.writeHead(403, {
        "Content-Type": "text/plain"
      });
      res.end(
        `Blocked request. This host (${hostnameWithQuotes}) is not allowed.
To allow this host, add ${hostnameWithQuotes} to \`${optionName}\` in vite.config.js.`
      );
      return;
    }
    return next();
  };
}

const WebSocketServerRaw = process.versions.bun ? (
  // @ts-expect-error: Bun defines `import.meta.require`
  import.meta.require("ws").WebSocketServer
) : WebSocketServerRaw_;
const HMR_HEADER = "vite-hmr";
const isWebSocketServer = Symbol("isWebSocketServer");
const wsServerEvents = [
  "connection",
  "error",
  "headers",
  "listening",
  "message"
];
function noop$2() {
}
function hasValidToken(config, url) {
  const token = url.searchParams.get("token");
  if (!token) return false;
  try {
    const isValidToken = crypto$2.timingSafeEqual(
      Buffer.from(token),
      Buffer.from(config.webSocketToken)
    );
    return isValidToken;
  } catch {
  }
  return false;
}
function createWebSocketServer(server, config, httpsOptions) {
  if (config.server.ws === false) {
    return {
      [isWebSocketServer]: true,
      get clients() {
        return /* @__PURE__ */ new Set();
      },
      async close() {
      },
      on: noop$2,
      off: noop$2,
      setInvokeHandler: noop$2,
      handleInvoke: async () => ({
        error: {
          name: "TransportError",
          message: "handleInvoke not implemented",
          stack: new Error().stack
        }
      }),
      listen: noop$2,
      send: noop$2
    };
  }
  let wsHttpServer = void 0;
  const hmr = isObject$1(config.server.hmr) && config.server.hmr;
  const hmrServer = hmr && hmr.server;
  const hmrPort = hmr && hmr.port;
  const portsAreCompatible = !hmrPort || hmrPort === config.server.port;
  const wsServer = hmrServer || portsAreCompatible && server;
  let hmrServerWsListener;
  const customListeners = /* @__PURE__ */ new Map();
  const clientsMap = /* @__PURE__ */ new WeakMap();
  const port = hmrPort || 24678;
  const host = hmr && hmr.host || void 0;
  const shouldHandle = (req) => {
    const protocol = req.headers["sec-websocket-protocol"];
    if (protocol === "vite-ping") return true;
    const hostHeader = req.headers.host;
    if (!hostHeader || !isHostAllowed(config, false, hostHeader)) {
      return false;
    }
    if (config.legacy?.skipWebSocketTokenCheck) {
      return true;
    }
    if (req.headers.origin) {
      const parsedUrl = new URL(`http://example.com${req.url}`);
      return hasValidToken(config, parsedUrl);
    }
    return true;
  };
  const handleUpgrade = (req, socket, head, isPing) => {
    wss.handleUpgrade(req, socket, head, (ws) => {
      if (isPing) {
        ws.close(
          /* Normal Closure */
          1e3
        );
        return;
      }
      wss.emit("connection", ws, req);
    });
  };
  const wss = new WebSocketServerRaw({ noServer: true });
  wss.shouldHandle = shouldHandle;
  if (wsServer) {
    let hmrBase = config.base;
    const hmrPath = hmr ? hmr.path : void 0;
    if (hmrPath) {
      hmrBase = path$b.posix.join(hmrBase, hmrPath);
    }
    hmrServerWsListener = (req, socket, head) => {
      const protocol = req.headers["sec-websocket-protocol"];
      const parsedUrl = new URL(`http://example.com${req.url}`);
      if ([HMR_HEADER, "vite-ping"].includes(protocol) && parsedUrl.pathname === hmrBase) {
        handleUpgrade(req, socket, head, protocol === "vite-ping");
      }
    };
    wsServer.on("upgrade", hmrServerWsListener);
  } else {
    const route = (_, res) => {
      const statusCode = 426;
      const body = STATUS_CODES[statusCode];
      if (!body)
        throw new Error(`No body text found for the ${statusCode} status code`);
      res.writeHead(statusCode, {
        "Content-Length": body.length,
        "Content-Type": "text/plain"
      });
      res.end(body);
    };
    if (httpsOptions) {
      wsHttpServer = createServer$2(httpsOptions, route);
    } else {
      wsHttpServer = createServer$3(route);
    }
    wsHttpServer.on("upgrade", (req, socket, head) => {
      const protocol = req.headers["sec-websocket-protocol"];
      if (protocol === "vite-ping" && server && !server.listening) {
        req.destroy();
        return;
      }
      handleUpgrade(req, socket, head, protocol === "vite-ping");
    });
    wsHttpServer.on("error", (e) => {
      if (e.code === "EADDRINUSE") {
        config.logger.error(
          colors$1.red(
            `WebSocket server error: Port ${e.port} is already in use`
          ),
          { error: e }
        );
      } else {
        config.logger.error(
          colors$1.red(`WebSocket server error:
${e.stack || e.message}`),
          { error: e }
        );
      }
    });
  }
  wss.on("connection", (socket) => {
    socket.on("message", (raw) => {
      if (!customListeners.size) return;
      let parsed;
      try {
        parsed = JSON.parse(String(raw));
      } catch {
      }
      if (!parsed || parsed.type !== "custom" || !parsed.event) return;
      const listeners = customListeners.get(parsed.event);
      if (!listeners?.size) return;
      const client = getSocketClient(socket);
      listeners.forEach(
        (listener) => listener(parsed.data, client, parsed.invoke)
      );
    });
    socket.on("error", (err) => {
      config.logger.error(`${colors$1.red(`ws error:`)}
${err.stack}`, {
        timestamp: true,
        error: err
      });
    });
    socket.send(JSON.stringify({ type: "connected" }));
    if (bufferedError) {
      socket.send(JSON.stringify(bufferedError));
      bufferedError = null;
    }
  });
  wss.on("error", (e) => {
    if (e.code === "EADDRINUSE") {
      config.logger.error(
        colors$1.red(`WebSocket server error: Port ${e.port} is already in use`),
        { error: e }
      );
    } else {
      config.logger.error(
        colors$1.red(`WebSocket server error:
${e.stack || e.message}`),
        { error: e }
      );
    }
  });
  function getSocketClient(socket) {
    if (!clientsMap.has(socket)) {
      clientsMap.set(socket, {
        send: (...args) => {
          let payload;
          if (typeof args[0] === "string") {
            payload = {
              type: "custom",
              event: args[0],
              data: args[1]
            };
          } else {
            payload = args[0];
          }
          socket.send(JSON.stringify(payload));
        },
        socket
      });
    }
    return clientsMap.get(socket);
  }
  let bufferedError = null;
  const normalizedHotChannel = normalizeHotChannel(
    {
      send(payload) {
        if (payload.type === "error" && !wss.clients.size) {
          bufferedError = payload;
          return;
        }
        const stringified = JSON.stringify(payload);
        wss.clients.forEach((client) => {
          if (client.readyState === 1) {
            client.send(stringified);
          }
        });
      },
      on(event, fn) {
        if (!customListeners.has(event)) {
          customListeners.set(event, /* @__PURE__ */ new Set());
        }
        customListeners.get(event).add(fn);
      },
      off(event, fn) {
        customListeners.get(event)?.delete(fn);
      },
      listen() {
        wsHttpServer?.listen(port, host);
      },
      close() {
        if (hmrServerWsListener && wsServer) {
          wsServer.off("upgrade", hmrServerWsListener);
        }
        return new Promise((resolve, reject) => {
          wss.clients.forEach((client) => {
            client.terminate();
          });
          wss.close((err) => {
            if (err) {
              reject(err);
            } else {
              if (wsHttpServer) {
                wsHttpServer.close((err2) => {
                  if (err2) {
                    reject(err2);
                  } else {
                    resolve();
                  }
                });
              } else {
                resolve();
              }
            }
          });
        });
      }
    },
    config.server.hmr !== false,
    // Don't normalize client as we already handles the send, and to keep `.socket`
    false
  );
  return {
    ...normalizedHotChannel,
    on: (event, fn) => {
      if (wsServerEvents.includes(event)) {
        wss.on(event, fn);
        return;
      }
      normalizedHotChannel.on(event, fn);
    },
    off: (event, fn) => {
      if (wsServerEvents.includes(event)) {
        wss.off(event, fn);
        return;
      }
      normalizedHotChannel.off(event, fn);
    },
    async close() {
      await normalizedHotChannel.close();
    },
    [isWebSocketServer]: true,
    get clients() {
      return new Set(Array.from(wss.clients).map(getSocketClient));
    }
  };
}

function baseMiddleware(rawBase, middlewareMode) {
  return function viteBaseMiddleware(req, res, next) {
    const url = req.url;
    const pathname = cleanUrl(url);
    const base = rawBase;
    if (pathname.startsWith(base)) {
      req.url = stripBase(url, base);
      return next();
    }
    if (middlewareMode) {
      return next();
    }
    if (pathname === "/" || pathname === "/index.html") {
      res.writeHead(302, {
        Location: base + url.slice(pathname.length)
      });
      res.end();
      return;
    }
    const redirectPath = withTrailingSlash(url) !== base ? joinUrlSegments(base, url) : base;
    if (req.headers.accept?.includes("text/html")) {
      res.writeHead(404, {
        "Content-Type": "text/html"
      });
      res.end(
        `The server is configured with a public base URL of ${base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`
      );
      return;
    } else {
      res.writeHead(404, {
        "Content-Type": "text/plain"
      });
      res.end(
        `The server is configured with a public base URL of ${base} - did you mean to visit ${redirectPath} instead?`
      );
      return;
    }
  };
}

var httpProxy$3 = {exports: {}};

var eventemitter3 = {exports: {}};

(function (module) {

	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Add a listener for a given event.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} context The context to invoke the listener with.
	 * @param {Boolean} once Specify if the listener is a one-time listener.
	 * @returns {EventEmitter}
	 * @private
	 */
	function addListener(emitter, event, fn, context, once) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('The listener must be a function');
	  }

	  var listener = new EE(fn, context || emitter, once)
	    , evt = prefix ? prefix + event : event;

	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
	  else emitter._events[evt] = [emitter._events[evt], listener];

	  return emitter;
	}

	/**
	 * Clear event by name.
	 *
	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	 * @param {(String|Symbol)} evt The Event name.
	 * @private
	 */
	function clearEvent(emitter, evt) {
	  if (--emitter._eventsCount === 0) emitter._events = new Events();
	  else delete emitter._events[evt];
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;

	  if (this._eventsCount === 0) return names;

	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Array} The registered listeners.
	 * @public
	 */
	EventEmitter.prototype.listeners = function listeners(event) {
	  var evt = prefix ? prefix + event : event
	    , handlers = this._events[evt];

	  if (!handlers) return [];
	  if (handlers.fn) return [handlers.fn];

	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
	    ee[i] = handlers[i].fn;
	  }

	  return ee;
	};

	/**
	 * Return the number of listeners listening to a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Number} The number of listeners.
	 * @public
	 */
	EventEmitter.prototype.listenerCount = function listenerCount(event) {
	  var evt = prefix ? prefix + event : event
	    , listeners = this._events[evt];

	  if (!listeners) return 0;
	  if (listeners.fn) return 1;
	  return listeners.length;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  return addListener(this, event, fn, context, false);
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {*} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  return addListener(this, event, fn, context, true);
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {(String|Symbol)} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {*} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    clearEvent(this, evt);
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (
	      listeners.fn === fn &&
	      (!once || listeners.once) &&
	      (!context || listeners.context === context)
	    ) {
	      clearEvent(this, evt);
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	        listeners[i].fn !== fn ||
	        (once && !listeners[i].once) ||
	        (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else clearEvent(this, evt);
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {(String|Symbol)} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) clearEvent(this, evt);
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	{
	  module.exports = EventEmitter;
	} 
} (eventemitter3));

var eventemitter3Exports = eventemitter3.exports;

var common$3 = {};

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

(function (exports) {
	var common   = exports,
	    url      = require$$0$5,
	    required = requiresPort;

	var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i,
	    isSSL = /^https|wss/;

	/**
	 * Simple Regex for testing if protocol is https
	 */
	common.isSSL = isSSL;
	/**
	 * Copies the right headers from `options` and `req` to
	 * `outgoing` which is then used to fire the proxied
	 * request.
	 *
	 * Examples:
	 *
	 *    common.setupOutgoing(outgoing, options, req)
	 *    // => { host: ..., hostname: ...}
	 *
	 * @param {Object} Outgoing Base object to be filled with required properties
	 * @param {Object} Options Config object passed to the proxy
	 * @param {ClientRequest} Req Request Object
	 * @param {String} Forward String to select forward or target
	 * 
	 * @return {Object} Outgoing Object with all required properties set
	 *
	 * @api private
	 */

	common.setupOutgoing = function(outgoing, options, req, forward) {
	  outgoing.port = options[forward || 'target'].port ||
	                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);

	  ['host', 'hostname', 'socketPath', 'pfx', 'key',
	    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(
	    function(e) { outgoing[e] = options[forward || 'target'][e]; }
	  );

	  outgoing.method = options.method || req.method;
	  outgoing.headers = Object.assign({}, req.headers);

	  if (options.headers){
	    Object.assign(outgoing.headers, options.headers);
	  }

	  if (options.auth) {
	    outgoing.auth = options.auth;
	  }
	  
	  if (options.ca) {
	      outgoing.ca = options.ca;
	  }

	  if (isSSL.test(options[forward || 'target'].protocol)) {
	    outgoing.rejectUnauthorized = (typeof options.secure === "undefined") ? true : options.secure;
	  }


	  outgoing.agent = options.agent || false;
	  outgoing.localAddress = options.localAddress;

	  //
	  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do
	  // as node core doesn't handle this COMPLETELY properly yet.
	  //
	  if (!outgoing.agent) {
	    outgoing.headers = outgoing.headers || {};
	    if (typeof outgoing.headers.connection !== 'string'
	        || !upgradeHeader.test(outgoing.headers.connection)
	       ) { outgoing.headers.connection = 'close'; }
	  }


	  // the final path is target path + relative path requested by user:
	  var target = options[forward || 'target'];
	  var targetPath = target && options.prependPath !== false
	    ? (target.path || '')
	    : '';

	  //
	  // Remark: Can we somehow not use url.parse as a perf optimization?
	  //
	  var outgoingPath = !options.toProxy
	    ? (url.parse(req.url).path || '')
	    : req.url;

	  //
	  // Remark: ignorePath will just straight up ignore whatever the request's
	  // path is. This can be labeled as FOOT-GUN material if you do not know what
	  // you are doing and are using conflicting options.
	  //
	  outgoingPath = !options.ignorePath ? outgoingPath : '';

	  outgoing.path = common.urlJoin(targetPath, outgoingPath);

	  if (options.changeOrigin) {
	    outgoing.headers.host =
	      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)
	        ? outgoing.host + ':' + outgoing.port
	        : outgoing.host;
	  }
	  return outgoing;
	};

	/**
	 * Set the proper configuration for sockets,
	 * set no delay and set keep alive, also set
	 * the timeout to 0.
	 *
	 * Examples:
	 *
	 *    common.setupSocket(socket)
	 *    // => Socket
	 *
	 * @param {Socket} Socket instance to setup
	 * 
	 * @return {Socket} Return the configured socket.
	 *
	 * @api private
	 */

	common.setupSocket = function(socket) {
	  socket.setTimeout(0);
	  socket.setNoDelay(true);

	  socket.setKeepAlive(true, 0);

	  return socket;
	};

	/**
	 * Get the port number from the host. Or guess it based on the connection type.
	 *
	 * @param {Request} req Incoming HTTP request.
	 *
	 * @return {String} The port number.
	 *
	 * @api private
	 */
	common.getPort = function(req) {
	  var res = req.headers.host ? req.headers.host.match(/:(\d+)/) : '';

	  return res ?
	    res[1] :
	    common.hasEncryptedConnection(req) ? '443' : '80';
	};

	/**
	 * Check if the request has an encrypted connection.
	 *
	 * @param {Request} req Incoming HTTP request.
	 *
	 * @return {Boolean} Whether the connection is encrypted or not.
	 *
	 * @api private
	 */
	common.hasEncryptedConnection = function(req) {
	  return Boolean(req.connection.encrypted || req.connection.pair);
	};

	/**
	 * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>
	 *
	 * @return {String} The generated path.
	 *
	 * @api private
	 */

	common.urlJoin = function() {
	    //
	    // We do not want to mess with the query string. All we want to touch is the path.
	    //
	  var args = Array.prototype.slice.call(arguments),
	      lastIndex = args.length - 1,
	      last = args[lastIndex],
	      lastSegs = last.split('?'),
	      retSegs;

	  args[lastIndex] = lastSegs.shift();

	  //
	  // Join all strings, but remove empty strings so we don't get extra slashes from
	  // joining e.g. ['', 'am']
	  //
	  retSegs = [
	    args.filter(Boolean).join('/')
	        .replace(/\/+/g, '/')
	        .replace('http:/', 'http://')
	        .replace('https:/', 'https://')
	  ];

	  // Only join the query string if it exists so we don't have trailing a '?'
	  // on every request

	  // Handle case where there could be multiple ? in the URL.
	  retSegs.push.apply(retSegs, lastSegs);

	  return retSegs.join('?')
	};

	/**
	 * Rewrites or removes the domain of a cookie header
	 *
	 * @param {String|Array} Header
	 * @param {Object} Config, mapping of domain to rewritten domain.
	 *                 '*' key to match any domain, null value to remove the domain.
	 *
	 * @api private
	 */
	common.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {
	  if (Array.isArray(header)) {
	    return header.map(function (headerElement) {
	      return rewriteCookieProperty(headerElement, config, property);
	    });
	  }
	  return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", 'i'), function(match, prefix, previousValue) {
	    var newValue;
	    if (previousValue in config) {
	      newValue = config[previousValue];
	    } else if ('*' in config) {
	      newValue = config['*'];
	    } else {
	      //no match, return previous value
	      return match;
	    }
	    if (newValue) {
	      //replace value
	      return prefix + newValue;
	    } else {
	      //remove value
	      return '';
	    }
	  });
	};

	/**
	 * Check the host and see if it potentially has a port in it (keep it simple)
	 *
	 * @returns {Boolean} Whether we have one or not
	 *
	 * @api private
	 */
	function hasPort(host) {
	  return !!~host.indexOf(':');
	}} (common$3));

var url$1    = require$$0$5,
    common$2 = common$3;


var redirectRegex = /^201|30(1|2|7|8)$/;

/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */

var webOutgoing = { // <--

  /**
   * If is a HTTP 1.0 request, remove chunk headers
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  removeChunked: function removeChunked(req, res, proxyRes) {
    if (req.httpVersion === '1.0') {
      delete proxyRes.headers['transfer-encoding'];
    }
  },

  /**
   * If is a HTTP 1.0 request, set the correct connection header
   * or if connection header not present, then use `keep-alive`
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  setConnection: function setConnection(req, res, proxyRes) {
    if (req.httpVersion === '1.0') {
      proxyRes.headers.connection = req.headers.connection || 'close';
    } else if (req.httpVersion !== '2.0' && !proxyRes.headers.connection) {
      proxyRes.headers.connection = req.headers.connection || 'keep-alive';
    }
  },

  setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {
    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)
        && proxyRes.headers['location']
        && redirectRegex.test(proxyRes.statusCode)) {
      var target = url$1.parse(options.target);
      var u = url$1.parse(proxyRes.headers['location']);

      // make sure the redirected host matches the target host before rewriting
      if (target.host != u.host) {
        return;
      }

      if (options.hostRewrite) {
        u.host = options.hostRewrite;
      } else if (options.autoRewrite) {
        u.host = req.headers['host'];
      }
      if (options.protocolRewrite) {
        u.protocol = options.protocolRewrite;
      }

      proxyRes.headers['location'] = u.format();
    }
  },
  /**
   * Copy headers from proxyResponse to response
   * set each header in response object.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
   *
   * @api private
   */
  writeHeaders: function writeHeaders(req, res, proxyRes, options) {
    var rewriteCookieDomainConfig = options.cookieDomainRewrite,
        rewriteCookiePathConfig = options.cookiePathRewrite,
        preserveHeaderKeyCase = options.preserveHeaderKeyCase,
        rawHeaderKeyMap,
        setHeader = function(key, header) {
          if (header == undefined) return;
          if (rewriteCookieDomainConfig && key.toLowerCase() === 'set-cookie') {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, 'domain');
          }
          if (rewriteCookiePathConfig && key.toLowerCase() === 'set-cookie') {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, 'path');
          }
          res.setHeader(String(key).trim(), header);
        };

    if (typeof rewriteCookieDomainConfig === 'string') { //also test for ''
      rewriteCookieDomainConfig = { '*': rewriteCookieDomainConfig };
    }

    if (typeof rewriteCookiePathConfig === 'string') { //also test for ''
      rewriteCookiePathConfig = { '*': rewriteCookiePathConfig };
    }

    // message.rawHeaders is added in: v0.11.6
    // https://nodejs.org/api/http.html#http_message_rawheaders
    if (preserveHeaderKeyCase && proxyRes.rawHeaders != undefined) {
      rawHeaderKeyMap = {};
      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
        var key = proxyRes.rawHeaders[i];
        rawHeaderKeyMap[key.toLowerCase()] = key;
      }
    }

    Object.keys(proxyRes.headers).forEach(function(key) {
      var header = proxyRes.headers[key];
      if (preserveHeaderKeyCase && rawHeaderKeyMap) {
        key = rawHeaderKeyMap[key] || key;
      }
      setHeader(key, header);
    });
  },

  /**
   * Set the statusCode from the proxyResponse
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  writeStatusCode: function writeStatusCode(req, res, proxyRes) {
    // From Node.js docs: response.writeHead(statusCode[, statusMessage][, headers])
    if(proxyRes.statusMessage) {
      res.statusCode = proxyRes.statusCode;
      res.statusMessage = proxyRes.statusMessage;
    } else {
      res.statusCode = proxyRes.statusCode;
    }
  }

};

var followRedirects$1 = {exports: {}};

var debug$7;

var debug_1 = function () {
  if (!debug$7) {
    try {
      /* eslint global-require: off */
      debug$7 = nodeExports$1("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug$7 !== "function") {
      debug$7 = function () { /* */ };
    }
  }
  debug$7.apply(null, arguments);
};

var url = require$$0$5;
var URL$1 = url.URL;
var http$1 = require$$1$2;
var https$1 = require$$1$3;
var Writable = require$$0$8.Writable;
var assert = require$$4$3;
var debug$6 = debug_1;

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL$1(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop$1;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230§5.3.1: When making a request directly to an origin server, […]
  // a client MUST send only the absolute path […] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, […]
  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug$6("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug$6("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop$1() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL$1(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop$1);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL$1 && value instanceof URL$1;
}

// Exports
followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
followRedirects$1.exports.wrap = wrap;

var followRedirectsExports = followRedirects$1.exports;

var httpNative   = require$$1$2,
    httpsNative  = require$$1$3,
    web_o  = webOutgoing,
    common$1 = common$3,
    followRedirects = followRedirectsExports;

web_o = Object.keys(web_o).map(function(pass) {
  return web_o[pass];
});

var nativeAgents = { http: httpNative, https: httpsNative };

/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */


var webIncoming = {

  /**
   * Sets `content-length` to '0' if request is of DELETE type.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */

  deleteLength: function deleteLength(req, res, options) {
    if((req.method === 'DELETE' || req.method === 'OPTIONS')
       && !req.headers['content-length']) {
      req.headers['content-length'] = '0';
      delete req.headers['transfer-encoding'];
    }
  },

  /**
   * Sets timeout in request socket if it was specified in options.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */

  timeout: function timeout(req, res, options) {
    if(options.timeout) {
      req.socket.setTimeout(options.timeout);
    }
  },

  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */

  XHeaders: function XHeaders(req, res, options) {
    if(!options.xfwd) return;

    var encrypted = req.isSpdy || common$1.hasEncryptedConnection(req);
    var values = {
      for  : req.connection.remoteAddress || req.socket.remoteAddress,
      port : common$1.getPort(req),
      proto: encrypted ? 'https' : 'http'
    };

    ['for', 'port', 'proto'].forEach(function(header) {
      req.headers['x-forwarded-' + header] =
        (req.headers['x-forwarded-' + header] || '') +
        (req.headers['x-forwarded-' + header] ? ',' : '') +
        values[header];
    });

    req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';
  },

  /**
   * Does the actual proxying. If `forward` is enabled fires up
   * a ForwardStream, same happens for ProxyStream. The request
   * just dies otherwise.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */

  stream: function stream(req, res, options, _, server, clb) {

    // And we begin!
    server.emit('start', req, res, options.target || options.forward);

    var agents = options.followRedirects ? followRedirects : nativeAgents;
    var http = agents.http;
    var https = agents.https;

    if(options.forward) {
      // If forward enable, so just pipe the request
      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(
        common$1.setupOutgoing(options.ssl || {}, options, req, 'forward')
      );

      // error handler (e.g. ECONNRESET, ECONNREFUSED)
      // Handle errors on incoming request as well as it makes sense to
      var forwardError = createErrorHandler(forwardReq, options.forward);
      req.on('error', forwardError);
      forwardReq.on('error', forwardError);

      (options.buffer || req).pipe(forwardReq);
      if(!options.target) { return res.end(); }
    }

    // Request initalization
    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(
      common$1.setupOutgoing(options.ssl || {}, options, req)
    );

    // Enable developers to modify the proxyReq before headers are sent
    proxyReq.on('socket', function(socket) {
      if(server && !proxyReq.getHeader('expect')) {
        server.emit('proxyReq', proxyReq, req, res, options);
      }
    });

    // allow outgoing socket to timeout so that we could
    // show an error page at the initial request
    if(options.proxyTimeout) {
      proxyReq.setTimeout(options.proxyTimeout, function() {
         proxyReq.abort();
      });
    }

    // Ensure we abort proxy if request is aborted
    req.on('aborted', function () {
      proxyReq.abort();
    });

    // handle errors in proxy and incoming request, just like for forward proxy
    var proxyError = createErrorHandler(proxyReq, options.target);
    req.on('error', proxyError);
    proxyReq.on('error', proxyError);

    function createErrorHandler(proxyReq, url) {
      return function proxyError(err) {
        if (req.socket.destroyed && err.code === 'ECONNRESET') {
          server.emit('econnreset', err, req, res, url);
          return proxyReq.abort();
        }

        if (clb) {
          clb(err, req, res, url);
        } else {
          server.emit('error', err, req, res, url);
        }
      }
    }

    (options.buffer || req).pipe(proxyReq);

    proxyReq.on('response', function(proxyRes) {
      if(server) { server.emit('proxyRes', proxyRes, req, res); }

      if(!res.headersSent && !options.selfHandleResponse) {
        for(var i=0; i < web_o.length; i++) {
          if(web_o[i](req, res, proxyRes, options)) { break; }
        }
      }

      if (!res.finished) {
        // Allow us to listen when the proxy has completed
        proxyRes.on('end', function () {
          if (server) server.emit('end', req, res, proxyRes);
        });
        // We pipe to the response unless its expected to be handled by the user
        if (!options.selfHandleResponse) proxyRes.pipe(res);
      } else {
        if (server) server.emit('end', req, res, proxyRes);
      }
    });
  }

};

var http   = require$$1$2,
    https  = require$$1$3,
    common = common$3;

/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */

/*
 * Websockets Passes
 *
 */


var wsIncoming = {
  /**
   * WebSocket requests must have the `GET` method and
   * the `upgrade:websocket` header
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   *
   * @api private
   */

  checkMethodAndHeader : function checkMethodAndHeader(req, socket) {
    if (req.method !== 'GET' || !req.headers.upgrade) {
      socket.destroy();
      return true;
    }

    if (req.headers.upgrade.toLowerCase() !== 'websocket') {
      socket.destroy();
      return true;
    }
  },

  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */

  XHeaders : function XHeaders(req, socket, options) {
    if(!options.xfwd) return;

    var values = {
      for  : req.connection.remoteAddress || req.socket.remoteAddress,
      port : common.getPort(req),
      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'
    };

    ['for', 'port', 'proto'].forEach(function(header) {
      req.headers['x-forwarded-' + header] =
        (req.headers['x-forwarded-' + header] || '') +
        (req.headers['x-forwarded-' + header] ? ',' : '') +
        values[header];
    });
  },

  /**
   * Does the actual proxying. Make the request and upgrade it
   * send the Switching Protocols request and pipe the sockets.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  stream : function stream(req, socket, options, head, server, clb) {

    var createHttpHeader = function(line, headers) {
      return Object.keys(headers).reduce(function (head, key) {
        var value = headers[key];

        if (!Array.isArray(value)) {
          head.push(key + ': ' + value);
          return head;
        }

        for (var i = 0; i < value.length; i++) {
          head.push(key + ': ' + value[i]);
        }
        return head;
      }, [line])
      .join('\r\n') + '\r\n\r\n';
    };

    common.setupSocket(socket);

    if (head && head.length) socket.unshift(head);


    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(
      common.setupOutgoing(options.ssl || {}, options, req)
    );

    // Enable developers to modify the proxyReq before headers are sent
    if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }

    // Error Handler
    proxyReq.on('error', onOutgoingError);
    proxyReq.on('response', function (res) {
      // if upgrade event isn't going to happen, close the socket
      if (!res.upgrade) {
        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));
        res.pipe(socket);
      }
    });

    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {
      proxySocket.on('error', onOutgoingError);

      // Allow us to listen when the websocket has completed
      proxySocket.on('end', function () {
        server.emit('close', proxyRes, proxySocket, proxyHead);
      });

      // The pipe below will end proxySocket if socket closes cleanly, but not
      // if it errors (eg, vanishes from the net and starts returning
      // EHOSTUNREACH). We need to do that explicitly.
      socket.on('error', function () {
        proxySocket.end();
      });

      common.setupSocket(proxySocket);

      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);

      //
      // Remark: Handle writing the headers to the socket when switching protocols
      // Also handles when a header is an array
      //
      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));

      proxySocket.pipe(socket).pipe(proxySocket);

      server.emit('open', proxySocket);
      server.emit('proxySocket', proxySocket);  //DEPRECATED.
    });

    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT

    function onOutgoingError(err) {
      if (clb) {
        clb(err, req, socket);
      } else {
        server.emit('error', err, req, socket);
      }
      socket.end();
    }
  }
};

(function (module) {
	var httpProxy = module.exports,
	    parse_url = require$$0$5.parse,
	    EE3       = eventemitter3Exports,
	    http      = require$$1$2,
	    https     = require$$1$3,
	    web       = webIncoming,
	    ws        = wsIncoming;

	httpProxy.Server = ProxyServer;

	/**
	 * Returns a function that creates the loader for
	 * either `ws` or `web`'s  passes.
	 *
	 * Examples:
	 *
	 *    httpProxy.createRightProxy('ws')
	 *    // => [Function]
	 *
	 * @param {String} Type Either 'ws' or 'web'
	 * 
	 * @return {Function} Loader Function that when called returns an iterator for the right passes
	 *
	 * @api private
	 */

	function createRightProxy(type) {

	  return function(options) {
	    return function(req, res /*, [head], [opts] */) {
	      var passes = (type === 'ws') ? this.wsPasses : this.webPasses,
	          args = [].slice.call(arguments),
	          cntr = args.length - 1,
	          head, cbl;

	      /* optional args parse begin */
	      if(typeof args[cntr] === 'function') {
	        cbl = args[cntr];

	        cntr--;
	      }

	      var requestOptions = options;
	      if(
	        !(args[cntr] instanceof Buffer) &&
	        args[cntr] !== res
	      ) {
	        //Copy global options
	        requestOptions = Object.assign({}, options);
	        //Overwrite with request options
	        Object.assign(requestOptions, args[cntr]);

	        cntr--;
	      }

	      if(args[cntr] instanceof Buffer) {
	        head = args[cntr];
	      }

	      /* optional args parse end */

	      ['target', 'forward'].forEach(function(e) {
	        if (typeof requestOptions[e] === 'string')
	          requestOptions[e] = parse_url(requestOptions[e]);
	      });

	      if (!requestOptions.target && !requestOptions.forward) {
	        return this.emit('error', new Error('Must provide a proper URL as target'));
	      }

	      for(var i=0; i < passes.length; i++) {
	        /**
	         * Call of passes functions
	         * pass(req, res, options, head)
	         *
	         * In WebSockets case the `res` variable
	         * refer to the connection socket
	         * pass(req, socket, options, head)
	         */
	        if(passes[i](req, res, requestOptions, head, this, cbl)) { // passes can return a truthy value to halt the loop
	          break;
	        }
	      }
	    };
	  };
	}
	httpProxy.createRightProxy = createRightProxy;

	function ProxyServer(options) {
	  EE3.call(this);

	  options = options || {};
	  options.prependPath = options.prependPath === false ? false : true;

	  this.web = this.proxyRequest           = createRightProxy('web')(options);
	  this.ws  = this.proxyWebsocketRequest  = createRightProxy('ws')(options);
	  this.options = options;

	  this.webPasses = Object.keys(web).map(function(pass) {
	    return web[pass];
	  });

	  this.wsPasses = Object.keys(ws).map(function(pass) {
	    return ws[pass];
	  });

	  this.on('error', this.onError, this);

	}

	require$$1.inherits(ProxyServer, EE3);

	ProxyServer.prototype.onError = function (err) {
	  //
	  // Remark: Replicate node core behavior using EE3
	  // so we force people to handle their own errors
	  //
	  if(this.listeners('error').length === 1) {
	    throw err;
	  }
	};

	ProxyServer.prototype.listen = function(port, hostname) {
	  var self    = this,
	      closure = function(req, res) { self.web(req, res); };

	  this._server  = this.options.ssl ?
	    https.createServer(this.options.ssl, closure) :
	    http.createServer(closure);

	  if(this.options.ws) {
	    this._server.on('upgrade', function(req, socket, head) { self.ws(req, socket, head); });
	  }

	  this._server.listen(port, hostname);

	  return this;
	};

	ProxyServer.prototype.close = function(callback) {
	  var self = this;
	  if (this._server) {
	    this._server.close(done);
	  }

	  // Wrap callback to nullify server after all open connections are closed.
	  function done() {
	    self._server = null;
	    if (callback) {
	      callback.apply(null, arguments);
	    }
	  }	};

	ProxyServer.prototype.before = function(type, passName, callback) {
	  if (type !== 'ws' && type !== 'web') {
	    throw new Error('type must be `web` or `ws`');
	  }
	  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,
	      i = false;

	  passes.forEach(function(v, idx) {
	    if(v.name === passName) i = idx;
	  });

	  if(i === false) throw new Error('No such pass');

	  passes.splice(i, 0, callback);
	};
	ProxyServer.prototype.after = function(type, passName, callback) {
	  if (type !== 'ws' && type !== 'web') {
	    throw new Error('type must be `web` or `ws`');
	  }
	  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,
	      i = false;

	  passes.forEach(function(v, idx) {
	    if(v.name === passName) i = idx;
	  });

	  if(i === false) throw new Error('No such pass');

	  passes.splice(i++, 0, callback);
	}; 
} (httpProxy$3));

var httpProxyExports = httpProxy$3.exports;

// Use explicit /index.js to help browserify negociation in require '/lib/http-proxy' (!)
var ProxyServer = httpProxyExports.Server;


/**
 * Creates the proxy server.
 *
 * Examples:
 *
 *    httpProxy.createProxyServer({ .. }, 8000)
 *    // => '{ web: [Function], ws: [Function] ... }'
 *
 * @param {Object} Options Config object passed to the proxy
 *
 * @return {Object} Proxy Proxy object with handlers for `ws` and `web` requests
 *
 * @api public
 */


function createProxyServer(options) {
  /*
   *  `options` is needed and it must have the following layout:
   *
   *  {
   *    target : <url string to be parsed with the url module>
   *    forward: <url string to be parsed with the url module>
   *    agent  : <object to be passed to http(s).request>
   *    ssl    : <object to be passed to https.createServer()>
   *    ws     : <true/false, if you want to proxy websockets>
   *    xfwd   : <true/false, adds x-forward headers>
   *    secure : <true/false, verify SSL certificate>
   *    toProxy: <true/false, explicitly specify if we are proxying to another proxy>
   *    prependPath: <true/false, Default: true - specify whether you want to prepend the target's path to the proxy path>
   *    ignorePath: <true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request>
   *    localAddress : <Local interface string to bind for outgoing connections>
   *    changeOrigin: <true/false, Default: false - changes the origin of the host header to the target URL>
   *    preserveHeaderKeyCase: <true/false, Default: false - specify whether you want to keep letter case of response header key >
   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.
   *    hostRewrite: rewrites the location hostname on (201/301/302/307/308) redirects, Default: null.
   *    autoRewrite: rewrites the location host/port on (201/301/302/307/308) redirects based on requested host/port. Default: false.
   *    protocolRewrite: rewrites the location protocol on (201/301/302/307/308) redirects to 'http' or 'https'. Default: null.
   *  }
   *
   *  NOTE: `options.ws` and `options.ssl` are optional.
   *    `options.target and `options.forward` cannot be
   *    both missing
   *  }
   */

  return new ProxyServer(options);
}


ProxyServer.createProxyServer = createProxyServer;
ProxyServer.createServer      = createProxyServer;
ProxyServer.createProxy       = createProxyServer;




/**
 * Export the proxy "Server" as the main export.
 */
var httpProxy$2 = ProxyServer;

/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque s’adagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */

var httpProxy = httpProxy$2;

var httpProxy$1 = /*@__PURE__*/getDefaultExportFromCjs(httpProxy);

const debug$5 = createDebugger("vite:proxy");
const rewriteOriginHeader = (proxyReq, options, config) => {
  if (options.rewriteWsOrigin) {
    const { target } = options;
    if (proxyReq.headersSent) {
      config.logger.warn(
        colors$1.yellow(
          `Unable to rewrite Origin header as headers are already sent.`
        )
      );
      return;
    }
    if (proxyReq.getHeader("origin") && target) {
      const changedOrigin = typeof target === "object" ? `${target.protocol}//${target.host}` : target;
      proxyReq.setHeader("origin", changedOrigin);
    }
  }
};
function proxyMiddleware(httpServer, options, config) {
  const proxies = {};
  Object.keys(options).forEach((context) => {
    let opts = options[context];
    if (!opts) {
      return;
    }
    if (typeof opts === "string") {
      opts = { target: opts, changeOrigin: true };
    }
    const proxy = httpProxy$1.createProxyServer(opts);
    if (opts.configure) {
      opts.configure(proxy, opts);
    }
    proxy.on("error", (err, _req, originalRes) => {
      const res = originalRes;
      if (!res) {
        config.logger.error(
          `${colors$1.red(`http proxy error: ${err.message}`)}
${err.stack}`,
          {
            timestamp: true,
            error: err
          }
        );
      } else if ("req" in res) {
        config.logger.error(
          `${colors$1.red(`http proxy error: ${originalRes.req.url}`)}
${err.stack}`,
          {
            timestamp: true,
            error: err
          }
        );
        if (!res.headersSent && !res.writableEnded) {
          res.writeHead(500, {
            "Content-Type": "text/plain"
          }).end();
        }
      } else {
        config.logger.error(`${colors$1.red(`ws proxy error:`)}
${err.stack}`, {
          timestamp: true,
          error: err
        });
        res.end();
      }
    });
    proxy.on("proxyReqWs", (proxyReq, _req, socket, options2) => {
      rewriteOriginHeader(proxyReq, options2, config);
      socket.on("error", (err) => {
        config.logger.error(
          `${colors$1.red(`ws proxy socket error:`)}
${err.stack}`,
          {
            timestamp: true,
            error: err
          }
        );
      });
    });
    proxy.on("proxyRes", (proxyRes, _req, res) => {
      res.on("close", () => {
        if (!res.writableEnded) {
          debug$5?.("destroying proxyRes in proxyRes close event");
          proxyRes.destroy();
        }
      });
    });
    proxies[context] = [proxy, { ...opts }];
  });
  if (httpServer) {
    httpServer.on("upgrade", async (req, socket, head) => {
      const url = req.url;
      for (const context in proxies) {
        if (doesProxyContextMatchUrl(context, url)) {
          const [proxy, opts] = proxies[context];
          if (opts.ws || opts.target?.toString().startsWith("ws:") || opts.target?.toString().startsWith("wss:")) {
            if (opts.bypass) {
              try {
                const bypassResult = await opts.bypass(req, void 0, opts);
                if (typeof bypassResult === "string") {
                  debug$5?.(`bypass: ${req.url} -> ${bypassResult}`);
                  req.url = bypassResult;
                  return;
                }
                if (bypassResult === false) {
                  debug$5?.(`bypass: ${req.url} -> 404`);
                  socket.end("HTTP/1.1 404 Not Found\r\n\r\n", "");
                  return;
                }
              } catch (err) {
                config.logger.error(
                  `${colors$1.red(`ws proxy bypass error:`)}
${err.stack}`,
                  {
                    timestamp: true,
                    error: err
                  }
                );
                return;
              }
            }
            if (opts.rewrite) {
              req.url = opts.rewrite(url);
            }
            debug$5?.(`${req.url} -> ws ${opts.target}`);
            proxy.ws(req, socket, head);
            return;
          }
        }
      }
    });
  }
  return async function viteProxyMiddleware(req, res, next) {
    const url = req.url;
    for (const context in proxies) {
      if (doesProxyContextMatchUrl(context, url)) {
        const [proxy, opts] = proxies[context];
        const options2 = {};
        if (opts.bypass) {
          try {
            const bypassResult = await opts.bypass(req, res, opts);
            if (typeof bypassResult === "string") {
              debug$5?.(`bypass: ${req.url} -> ${bypassResult}`);
              req.url = bypassResult;
              if (res.writableEnded) {
                return;
              }
              return next();
            }
            if (bypassResult === false) {
              debug$5?.(`bypass: ${req.url} -> 404`);
              res.statusCode = 404;
              return res.end();
            }
          } catch (e) {
            debug$5?.(`bypass: ${req.url} -> ${e}`);
            return next(e);
          }
        }
        debug$5?.(`${req.url} -> ${opts.target || opts.forward}`);
        if (opts.rewrite) {
          req.url = opts.rewrite(req.url);
        }
        proxy.web(req, res, options2);
        return;
      }
    }
    next();
  };
}
function doesProxyContextMatchUrl(context, url) {
  return context[0] === "^" && new RegExp(context).test(url) || url.startsWith(context);
}

const debug$4 = createDebugger("vite:html-fallback");
function htmlFallbackMiddleware(root, spaFallback) {
  return function viteHtmlFallbackMiddleware(req, _res, next) {
    if (
      // Only accept GET or HEAD
      req.method !== "GET" && req.method !== "HEAD" || // Exclude default favicon requests
      req.url === "/favicon.ico" || // Require Accept: text/html or */*
      !(req.headers.accept === void 0 || // equivalent to `Accept: */*`
      req.headers.accept === "" || // equivalent to `Accept: */*`
      req.headers.accept.includes("text/html") || req.headers.accept.includes("*/*"))
    ) {
      return next();
    }
    const url = cleanUrl(req.url);
    const pathname = decodeURIComponent(url);
    if (pathname.endsWith(".html")) {
      const filePath = path$b.join(root, pathname);
      if (fs__default.existsSync(filePath)) {
        debug$4?.(`Rewriting ${req.method} ${req.url} to ${url}`);
        req.url = url;
        return next();
      }
    } else if (pathname.endsWith("/")) {
      const filePath = path$b.join(root, pathname, "index.html");
      if (fs__default.existsSync(filePath)) {
        const newUrl = url + "index.html";
        debug$4?.(`Rewriting ${req.method} ${req.url} to ${newUrl}`);
        req.url = newUrl;
        return next();
      }
    } else {
      const filePath = path$b.join(root, pathname + ".html");
      if (fs__default.existsSync(filePath)) {
        const newUrl = url + ".html";
        debug$4?.(`Rewriting ${req.method} ${req.url} to ${newUrl}`);
        req.url = newUrl;
        return next();
      }
    }
    if (spaFallback) {
      debug$4?.(`Rewriting ${req.method} ${req.url} to /index.html`);
      req.url = "/index.html";
    }
    next();
  };
}

/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var etag_1 = etag;

/**
 * Module dependencies.
 * @private
 */

var crypto = require$$3;
var Stats = require$$0$4.Stats;

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString;

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27);

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length;

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity);
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats;

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity);

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16);
  var size = stat.size.toString(16);

  return '"' + size + '-' + mtime + '"'
}

var getEtag = /*@__PURE__*/getDefaultExportFromCjs(etag_1);

const debug$3 = createDebugger("vite:send", {
  onlyWhenFocused: true
});
const alias = {
  js: "text/javascript",
  css: "text/css",
  html: "text/html",
  json: "application/json"
};
function send$1(req, res, content, type, options) {
  const {
    etag = getEtag(content, { weak: true }),
    cacheControl = "no-cache",
    headers,
    map
  } = options;
  if (res.writableEnded) {
    return;
  }
  if (req.headers["if-none-match"] === etag) {
    res.statusCode = 304;
    res.end();
    return;
  }
  res.setHeader("Content-Type", alias[type] || type);
  res.setHeader("Cache-Control", cacheControl);
  res.setHeader("Etag", etag);
  if (headers) {
    for (const name in headers) {
      res.setHeader(name, headers[name]);
    }
  }
  if (map && "version" in map && map.mappings) {
    if (type === "js" || type === "css") {
      content = getCodeWithSourcemap(type, content.toString(), map);
    }
  } else if (type === "js" && (!map || map.mappings !== "")) {
    const code = content.toString();
    if (convertSourceMap.mapFileCommentRegex.test(code)) {
      debug$3?.(`Skipped injecting fallback sourcemap for ${req.url}`);
    } else {
      const urlWithoutTimestamp = removeTimestampQuery(req.url);
      const ms = new MagicString(code);
      content = getCodeWithSourcemap(
        type,
        code,
        ms.generateMap({
          source: path$b.basename(urlWithoutTimestamp),
          hires: "boundary",
          includeContent: true
        })
      );
    }
  }
  res.statusCode = 200;
  res.end(content);
  return;
}

function totalist(dir, callback, pre='') {
	dir = resolve$3('.', dir);
	let arr = readdirSync(dir);
	let i=0, abs, stats;
	for (; i < arr.length; i++) {
		abs = join(dir, arr[i]);
		stats = statSync(abs);
		stats.isDirectory()
			? totalist(abs, callback, join(pre, arr[i]))
			: callback(join(pre, arr[i]), abs, stats);
	}
}

/**
 * @typedef ParsedURL
 * @type {import('.').ParsedURL}
 */

/**
 * @typedef Request
 * @property {string} url
 * @property {ParsedURL} _parsedUrl
 */

/**
 * @param {Request} req
 * @returns {ParsedURL|void}
 */
function parse(req) {
	let raw = req.url;
	if (raw == null) return;

	let prev = req._parsedUrl;
	if (prev && prev.raw === raw) return prev;

	let pathname=raw, search='', query;

	if (raw.length > 1) {
		let idx = raw.indexOf('?', 1);

		if (idx !== -1) {
			search = raw.substring(idx);
			pathname = raw.substring(0, idx);
			if (search.length > 1) {
				query = qs.parse(search.substring(1));
			}
		}
	}

	return req._parsedUrl = { pathname, search, query, raw };
}

const noop = () => {};

function isMatch(uri, arr) {
	for (let i=0; i < arr.length; i++) {
		if (arr[i].test(uri)) return true;
	}
}

function toAssume(uri, extns) {
	let i=0, x, len=uri.length - 1;
	if (uri.charCodeAt(len) === 47) {
		uri = uri.substring(0, len);
	}

	let arr=[], tmp=`${uri}/index`;
	for (; i < extns.length; i++) {
		x = extns[i] ? `.${extns[i]}` : '';
		if (uri) arr.push(uri + x);
		arr.push(tmp + x);
	}

	return arr;
}

function viaCache(cache, uri, extns) {
	let i=0, data, arr=toAssume(uri, extns);
	for (; i < arr.length; i++) {
		if (data = cache[arr[i]]) return data;
	}
}

function viaLocal(dir, isEtag, uri, extns, shouldServe) {
	let i=0, arr=toAssume(uri, extns);
	let abs, stats, name, headers;
	for (; i < arr.length; i++) {
		abs = normalize(
			join$1(dir, name=arr[i])
		);

		if (abs.startsWith(dir) && fs$8.existsSync(abs)) {
			stats = fs$8.statSync(abs);
			if (stats.isDirectory()) continue;
			if (shouldServe && !shouldServe(abs)) continue;
			headers = toHeaders(name, stats, isEtag);
			headers['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';
			return { abs, stats, headers };
		}
	}
}

function is404(req, res) {
	return (res.statusCode=404,res.end());
}

function send(req, res, file, stats, headers) {
	let code=200, tmp, opts={};
	headers = { ...headers };

	for (let key in headers) {
		tmp = res.getHeader(key);
		if (tmp) headers[key] = tmp;
	}

	if (tmp = res.getHeader('content-type')) {
		headers['Content-Type'] = tmp;
	}

	if (req.headers.range) {
		code = 206;
		let [x, y] = req.headers.range.replace('bytes=', '').split('-');
		let end = opts.end = parseInt(y, 10) || stats.size - 1;
		let start = opts.start = parseInt(x, 10) || 0;

		if (end >= stats.size) {
			end = stats.size - 1;
		}

		if (start >= stats.size) {
			res.setHeader('Content-Range', `bytes */${stats.size}`);
			res.statusCode = 416;
			return res.end();
		}

		headers['Content-Range'] = `bytes ${start}-${end}/${stats.size}`;
		headers['Content-Length'] = (end - start + 1);
		headers['Accept-Ranges'] = 'bytes';
	}

	res.writeHead(code, headers);
	fs$8.createReadStream(file, opts).pipe(res);
}

const ENCODING = {
	'.br': 'br',
	'.gz': 'gzip',
};

function toHeaders(name, stats, isEtag) {
	let enc = ENCODING[name.slice(-3)];

	let ctype = lookup(name.slice(0, enc && -3)) || '';
	if (ctype === 'text/html') ctype += ';charset=utf-8';

	let headers = {
		'Content-Length': stats.size,
		'Content-Type': ctype,
		'Last-Modified': stats.mtime.toUTCString(),
	};

	if (enc) headers['Content-Encoding'] = enc;
	if (isEtag) headers['ETag'] = `W/"${stats.size}-${stats.mtime.getTime()}"`;

	return headers;
}

function sirv (dir, opts={}) {
	dir = resolve$4(dir || '.');

	let isNotFound = opts.onNoMatch || is404;
	let setHeaders = opts.setHeaders || noop;

	let extensions = opts.extensions || ['html', 'htm'];
	let gzips = opts.gzip && extensions.map(x => `${x}.gz`).concat('gz');
	let brots = opts.brotli && extensions.map(x => `${x}.br`).concat('br');

	const FILES = {};

	let fallback = '/';
	let isEtag = !!opts.etag;
	let isSPA = !!opts.single;
	if (typeof opts.single === 'string') {
		let idx = opts.single.lastIndexOf('.');
		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
	}

	let ignores = [];
	if (opts.ignores !== false) {
		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/); // any extn
		if (opts.dotfiles) ignores.push(/\/\.\w/);
		else ignores.push(/\/\.well-known/);
		[].concat(opts.ignores || []).forEach(x => {
			ignores.push(new RegExp(x, 'i'));
		});
	}

	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
	if (cc && opts.immutable) cc += ',immutable';
	else if (cc && opts.maxAge === 0) cc += ',must-revalidate';

	if (!opts.dev) {
		totalist(dir, (name, abs, stats) => {
			if (/\.well-known[\\+\/]/.test(name)) ; // keep
			else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;

			let headers = toHeaders(name, stats, isEtag);
			if (cc) headers['Cache-Control'] = cc;

			FILES['/' + name.normalize().replace(/\\+/g, '/')] = { abs, stats, headers };
		});
	}

	let lookup = opts.dev ? viaLocal.bind(0, dir.endsWith(sep$1) ? dir : dir + sep$1, isEtag) : viaCache.bind(0, FILES);

	return function (req, res, next) {
		let extns = [''];
		let pathname = parse(req).pathname;
		let val = req.headers['accept-encoding'] || '';
		if (gzips && val.includes('gzip')) extns.unshift(...gzips);
		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
		extns.push(...extensions); // [...br, ...gz, orig, ...exts]

		if (pathname.indexOf('%') !== -1) {
			try { pathname = decodeURI(pathname); }
			catch (err) { /* malform uri */ }
		}

		let data = lookup(pathname, extns, opts.shouldServe) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns, opts.shouldServe);
		if (!data) return next ? next() : isNotFound(req, res);

		if (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {
			res.writeHead(304);
			return res.end();
		}

		if (gzips || brots) {
			res.setHeader('Vary', 'Accept-Encoding');
		}

		setHeaders(res, pathname, data.stats);
		send(req, res, data.abs, data.stats, data.headers);
	};
}

const knownJavascriptExtensionRE = /\.(?:[tj]sx?|[cm][tj]s)$/;
const ERR_DENIED_FILE = "ERR_DENIED_FILE";
const sirvOptions = ({
  config,
  getHeaders,
  disableFsServeCheck
}) => {
  return {
    dev: true,
    etag: true,
    extensions: [],
    setHeaders(res, pathname) {
      if (knownJavascriptExtensionRE.test(pathname)) {
        res.setHeader("Content-Type", "text/javascript");
      }
      const headers = getHeaders();
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]);
        }
      }
    },
    shouldServe: disableFsServeCheck ? void 0 : (filePath) => {
      const servingAccessResult = checkLoadingAccess(config, filePath);
      if (servingAccessResult === "denied") {
        const error = new Error("denied access");
        error.code = ERR_DENIED_FILE;
        error.path = filePath;
        throw error;
      }
      if (servingAccessResult === "fallback") {
        return false;
      }
      return true;
    }
  };
};
function servePublicMiddleware(server, publicFiles) {
  const dir = server.config.publicDir;
  const serve = sirv(
    dir,
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers,
      disableFsServeCheck: true
    })
  );
  const toFilePath = (url) => {
    let filePath = cleanUrl(url);
    if (filePath.indexOf("%") !== -1) {
      try {
        filePath = decodeURI(filePath);
      } catch {
      }
    }
    return normalizePath$3(filePath);
  };
  return function viteServePublicMiddleware(req, res, next) {
    if (publicFiles && !publicFiles.has(toFilePath(req.url)) || isImportRequest(req.url) || isInternalRequest(req.url) || // for `/public-file.js?url` to be transformed
    urlRE$1.test(req.url)) {
      return next();
    }
    serve(req, res, next);
  };
}
function serveStaticMiddleware(server) {
  const dir = server.config.root;
  const serve = sirv(
    dir,
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers
    })
  );
  return function viteServeStaticMiddleware(req, res, next) {
    const cleanedUrl = cleanUrl(req.url);
    if (cleanedUrl.endsWith("/") || path$b.extname(cleanedUrl) === ".html" || isInternalRequest(req.url) || // skip url starting with // as these will be interpreted as
    // scheme relative URLs by new URL() and will not be a valid file path
    req.url?.startsWith("//")) {
      return next();
    }
    const url = new URL(req.url, "http://example.com");
    const pathname = decodeURI(url.pathname);
    let redirectedPathname;
    for (const { find, replacement } of server.config.resolve.alias) {
      const matches = typeof find === "string" ? pathname.startsWith(find) : find.test(pathname);
      if (matches) {
        redirectedPathname = pathname.replace(find, replacement);
        break;
      }
    }
    if (redirectedPathname) {
      if (redirectedPathname.startsWith(withTrailingSlash(dir))) {
        redirectedPathname = redirectedPathname.slice(dir.length);
      }
    }
    const resolvedPathname = redirectedPathname || pathname;
    let fileUrl = path$b.resolve(dir, removeLeadingSlash(resolvedPathname));
    if (resolvedPathname.endsWith("/") && fileUrl[fileUrl.length - 1] !== "/") {
      fileUrl = withTrailingSlash(fileUrl);
    }
    if (redirectedPathname) {
      url.pathname = encodeURI(redirectedPathname);
      req.url = url.href.slice(url.origin.length);
    }
    try {
      serve(req, res, next);
    } catch (e) {
      if (e && "code" in e && e.code === ERR_DENIED_FILE) {
        respondWithAccessDenied(e.path, server, res);
        return;
      }
      throw e;
    }
  };
}
function serveRawFsMiddleware(server) {
  const serveFromRoot = sirv(
    "/",
    sirvOptions({
      config: server.config,
      getHeaders: () => server.config.server.headers
    })
  );
  return function viteServeRawFsMiddleware(req, res, next) {
    if (req.url.startsWith(FS_PREFIX)) {
      const url = new URL(req.url, "http://example.com");
      const pathname = decodeURI(url.pathname);
      let newPathname = pathname.slice(FS_PREFIX.length);
      if (isWindows$3) newPathname = newPathname.replace(/^[A-Z]:/i, "");
      url.pathname = encodeURI(newPathname);
      req.url = url.href.slice(url.origin.length);
      try {
        serveFromRoot(req, res, next);
      } catch (e) {
        if (e && "code" in e && e.code === ERR_DENIED_FILE) {
          respondWithAccessDenied(e.path, server, res);
          return;
        }
        throw e;
      }
    } else {
      next();
    }
  };
}
function isFileServingAllowed(configOrUrl, urlOrServer) {
  const config = typeof urlOrServer === "string" ? configOrUrl : urlOrServer.config;
  const url = typeof urlOrServer === "string" ? urlOrServer : configOrUrl;
  if (!config.server.fs.strict) return true;
  const filePath = fsPathFromUrl(url);
  return isFileLoadingAllowed(config, filePath);
}
function isUriInFilePath(uri, filePath) {
  return isSameFileUri(uri, filePath) || isParentDirectory(uri, filePath);
}
function isFileLoadingAllowed(config, filePath) {
  const { fs } = config.server;
  if (!fs.strict) return true;
  if (config.fsDenyGlob(filePath)) return false;
  if (config.safeModulePaths.has(filePath)) return true;
  if (fs.allow.some((uri) => isUriInFilePath(uri, filePath))) return true;
  return false;
}
function checkLoadingAccess(config, path2) {
  if (isFileLoadingAllowed(config, slash$1(path2))) {
    return "allowed";
  }
  if (isFileReadable(path2)) {
    return "denied";
  }
  return "fallback";
}
function checkServingAccess(url, server) {
  if (isFileServingAllowed(url, server)) {
    return "allowed";
  }
  if (isFileReadable(cleanUrl(url))) {
    return "denied";
  }
  return "fallback";
}
function respondWithAccessDenied(url, server, res) {
  const urlMessage = `The request url "${url}" is outside of Vite serving allow list.`;
  const hintMessage = `
${server.config.server.fs.allow.map((i) => `- ${i}`).join("\n")}

Refer to docs https://vite.dev/config/server-options.html#server-fs-allow for configurations and more details.`;
  server.config.logger.error(urlMessage);
  server.config.logger.warnOnce(hintMessage + "\n");
  res.statusCode = 403;
  res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
  res.end();
}
function renderRestrictedErrorHTML(msg) {
  const html = String.raw;
  return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${escapeHtml$2(msg).replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
}

const ERR_LOAD_URL = "ERR_LOAD_URL";
const ERR_LOAD_PUBLIC_URL = "ERR_LOAD_PUBLIC_URL";
const ERR_DENIED_ID = "ERR_DENIED_ID";
const debugLoad = createDebugger("vite:load");
const debugTransform = createDebugger("vite:transform");
const debugCache$1 = createDebugger("vite:cache");
function transformRequest(environment, url, options = {}) {
  if (!options.ssr) {
    options = { ...options, ssr: environment.config.consumer === "server" };
  }
  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError();
  const cacheKey = `${options.html ? "html:" : ""}${url}`;
  const timestamp = Date.now();
  const pending = environment._pendingRequests.get(cacheKey);
  if (pending) {
    return environment.moduleGraph.getModuleByUrl(removeTimestampQuery(url)).then((module) => {
      if (!module || pending.timestamp > module.lastInvalidationTimestamp) {
        return pending.request;
      } else {
        pending.abort();
        return transformRequest(environment, url, options);
      }
    });
  }
  const request = doTransform(environment, url, options, timestamp);
  let cleared = false;
  const clearCache = () => {
    if (!cleared) {
      environment._pendingRequests.delete(cacheKey);
      cleared = true;
    }
  };
  environment._pendingRequests.set(cacheKey, {
    request,
    timestamp,
    abort: clearCache
  });
  return request.finally(clearCache);
}
async function doTransform(environment, url, options, timestamp) {
  url = removeTimestampQuery(url);
  const { pluginContainer } = environment;
  let module = await environment.moduleGraph.getModuleByUrl(url);
  if (module) {
    const cached = await getCachedTransformResult(
      environment,
      url,
      module,
      timestamp
    );
    if (cached) return cached;
  }
  const resolved = module ? void 0 : await pluginContainer.resolveId(url, void 0) ?? void 0;
  const id = module?.id ?? resolved?.id ?? url;
  module ??= environment.moduleGraph.getModuleById(id);
  if (module) {
    await environment.moduleGraph._ensureEntryFromUrl(url, void 0, resolved);
    const cached = await getCachedTransformResult(
      environment,
      url,
      module,
      timestamp
    );
    if (cached) return cached;
  }
  const result = loadAndTransform(
    environment,
    id,
    url,
    options,
    timestamp,
    module,
    resolved
  );
  const { depsOptimizer } = environment;
  if (!depsOptimizer?.isOptimizedDepFile(id)) {
    environment._registerRequestProcessing(id, () => result);
  }
  return result;
}
async function getCachedTransformResult(environment, url, module, timestamp) {
  const prettyUrl = debugCache$1 ? prettifyUrl(url, environment.config.root) : "";
  const softInvalidatedTransformResult = await handleModuleSoftInvalidation(
    environment,
    module,
    timestamp
  );
  if (softInvalidatedTransformResult) {
    debugCache$1?.(`[memory-hmr] ${prettyUrl}`);
    return softInvalidatedTransformResult;
  }
  const cached = module.transformResult;
  if (cached) {
    debugCache$1?.(`[memory] ${prettyUrl}`);
    return cached;
  }
}
async function loadAndTransform(environment, id, url, options, timestamp, mod, resolved) {
  const { config, pluginContainer, logger } = environment;
  const prettyUrl = debugLoad || debugTransform ? prettifyUrl(url, config.root) : "";
  const moduleGraph = environment.moduleGraph;
  if (options.allowId && !options.allowId(id)) {
    const err = new Error(`Denied ID ${id}`);
    err.code = ERR_DENIED_ID;
    throw err;
  }
  let code = null;
  let map = null;
  const loadStart = debugLoad ? performance$1.now() : 0;
  const loadResult = await pluginContainer.load(id);
  if (loadResult == null) {
    const file = cleanUrl(id);
    if (options.html && !id.endsWith(".html")) {
      return null;
    }
    if (environment.config.consumer === "server" || isFileLoadingAllowed(environment.getTopLevelConfig(), file)) {
      try {
        code = await fsp.readFile(file, "utf-8");
        debugLoad?.(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
      } catch (e) {
        if (e.code !== "ENOENT") {
          if (e.code === "EISDIR") {
            e.message = `${e.message} ${file}`;
          }
          throw e;
        }
      }
      if (code != null && environment.pluginContainer.watcher) {
        ensureWatchedFile(
          environment.pluginContainer.watcher,
          file,
          config.root
        );
      }
    }
    if (code) {
      try {
        const extracted = await extractSourcemapFromFile(code, file);
        if (extracted) {
          code = extracted.code;
          map = extracted.map;
        }
      } catch (e) {
        logger.warn(`Failed to load source map for ${file}.
${e}`, {
          timestamp: true
        });
      }
    }
  } else {
    debugLoad?.(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
    if (isObject$1(loadResult)) {
      code = loadResult.code;
      map = loadResult.map;
    } else {
      code = loadResult;
    }
  }
  if (code == null) {
    const isPublicFile = checkPublicFile(url, environment.getTopLevelConfig());
    let publicDirName = path$b.relative(config.root, config.publicDir);
    if (publicDirName[0] !== ".") publicDirName = "/" + publicDirName;
    const msg = isPublicFile ? `This file is in ${publicDirName} and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.` : `Does the file exist?`;
    const importerMod = moduleGraph.idToModuleMap.get(id)?.importers.values().next().value;
    const importer = importerMod?.file || importerMod?.url;
    const err = new Error(
      `Failed to load url ${url} (resolved id: ${id})${importer ? ` in ${importer}` : ""}. ${msg}`
    );
    err.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL;
    throw err;
  }
  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError();
  mod ??= await moduleGraph._ensureEntryFromUrl(url, void 0, resolved);
  const transformStart = debugTransform ? performance$1.now() : 0;
  const transformResult = await pluginContainer.transform(code, id, {
    inMap: map
  });
  const originalCode = code;
  if (transformResult.code === originalCode) {
    debugTransform?.(
      timeFrom(transformStart) + colors$1.dim(` [skipped] ${prettyUrl}`)
    );
  } else {
    debugTransform?.(`${timeFrom(transformStart)} ${prettyUrl}`);
    code = transformResult.code;
    map = transformResult.map;
  }
  let normalizedMap;
  if (typeof map === "string") {
    normalizedMap = JSON.parse(map);
  } else if (map) {
    normalizedMap = map;
  } else {
    normalizedMap = null;
  }
  if (normalizedMap && "version" in normalizedMap && mod.file) {
    if (normalizedMap.mappings) {
      await injectSourcesContent(normalizedMap, mod.file, logger);
    }
    const sourcemapPath = `${mod.file}.map`;
    applySourcemapIgnoreList(
      normalizedMap,
      sourcemapPath,
      config.server.sourcemapIgnoreList,
      logger
    );
    if (path$b.isAbsolute(mod.file)) {
      let modDirname;
      for (let sourcesIndex = 0; sourcesIndex < normalizedMap.sources.length; ++sourcesIndex) {
        const sourcePath = normalizedMap.sources[sourcesIndex];
        if (sourcePath) {
          if (path$b.isAbsolute(sourcePath)) {
            modDirname ??= path$b.dirname(mod.file);
            normalizedMap.sources[sourcesIndex] = path$b.relative(
              modDirname,
              sourcePath
            );
          }
        }
      }
    }
  }
  if (environment._closing && environment.config.dev.recoverable)
    throwClosedServerError();
  const topLevelConfig = environment.getTopLevelConfig();
  const result = environment.config.dev.moduleRunnerTransform ? await ssrTransform(code, normalizedMap, url, originalCode, {
    json: {
      stringify: topLevelConfig.json.stringify === true && topLevelConfig.json.namedExports !== true
    }
  }) : {
    code,
    map: normalizedMap,
    etag: getEtag(code, { weak: true })
  };
  if (timestamp > mod.lastInvalidationTimestamp)
    moduleGraph.updateModuleTransformResult(mod, result);
  return result;
}
async function handleModuleSoftInvalidation(environment, mod, timestamp) {
  const transformResult = mod.invalidationState;
  mod.invalidationState = void 0;
  if (!transformResult || transformResult === "HARD_INVALIDATED") return;
  if (mod.transformResult) {
    throw new Error(
      `Internal server error: Soft-invalidated module "${mod.url}" should not have existing transform result`
    );
  }
  let result;
  if (transformResult.ssr) {
    result = transformResult;
  } else {
    await init;
    const source = transformResult.code;
    const s = new MagicString(source);
    const [imports] = parse$d(source, mod.id || void 0);
    for (const imp of imports) {
      let rawUrl = source.slice(imp.s, imp.e);
      if (rawUrl === "import.meta") continue;
      const hasQuotes = rawUrl[0] === '"' || rawUrl[0] === "'";
      if (hasQuotes) {
        rawUrl = rawUrl.slice(1, -1);
      }
      const urlWithoutTimestamp = removeTimestampQuery(rawUrl);
      const hmrUrl = unwrapId$1(
        stripBase(
          removeImportQuery(urlWithoutTimestamp),
          environment.config.base
        )
      );
      for (const importedMod of mod.importedModules) {
        if (importedMod.url !== hmrUrl) continue;
        if (importedMod.lastHMRTimestamp > 0) {
          const replacedUrl = injectQuery(
            urlWithoutTimestamp,
            `t=${importedMod.lastHMRTimestamp}`
          );
          const start = hasQuotes ? imp.s + 1 : imp.s;
          const end = hasQuotes ? imp.e - 1 : imp.e;
          s.overwrite(start, end, replacedUrl);
        }
        if (imp.d === -1 && environment.config.dev.preTransformRequests) {
          environment.warmupRequest(hmrUrl);
        }
        break;
      }
    }
    const code = s.toString();
    result = {
      ...transformResult,
      code,
      etag: getEtag(code, { weak: true })
    };
  }
  if (timestamp > mod.lastInvalidationTimestamp)
    environment.moduleGraph.updateModuleTransformResult(mod, result);
  return result;
}

const ALLOWED_META_NAME = [
  "msapplication-tileimage",
  "msapplication-square70x70logo",
  "msapplication-square150x150logo",
  "msapplication-wide310x150logo",
  "msapplication-square310x310logo",
  "msapplication-config",
  "twitter:image"
];
const ALLOWED_META_PROPERTY = [
  "og:image",
  "og:image:url",
  "og:image:secure_url",
  "og:audio",
  "og:audio:secure_url",
  "og:video",
  "og:video:secure_url"
];
const DEFAULT_HTML_ASSET_SOURCES = {
  audio: {
    srcAttributes: ["src"]
  },
  embed: {
    srcAttributes: ["src"]
  },
  img: {
    srcAttributes: ["src"],
    srcsetAttributes: ["srcset"]
  },
  image: {
    srcAttributes: ["href", "xlink:href"]
  },
  input: {
    srcAttributes: ["src"]
  },
  link: {
    srcAttributes: ["href"],
    srcsetAttributes: ["imagesrcset"]
  },
  object: {
    srcAttributes: ["data"]
  },
  source: {
    srcAttributes: ["src"],
    srcsetAttributes: ["srcset"]
  },
  track: {
    srcAttributes: ["src"]
  },
  use: {
    srcAttributes: ["href", "xlink:href"]
  },
  video: {
    srcAttributes: ["src", "poster"]
  },
  meta: {
    srcAttributes: ["content"],
    filter({ attributes }) {
      if (attributes.name && ALLOWED_META_NAME.includes(attributes.name.trim().toLowerCase())) {
        return true;
      }
      if (attributes.property && ALLOWED_META_PROPERTY.includes(attributes.property.trim().toLowerCase())) {
        return true;
      }
      return false;
    }
  }
};
function getNodeAssetAttributes(node) {
  const matched = DEFAULT_HTML_ASSET_SOURCES[node.nodeName];
  if (!matched) return [];
  const attributes = {};
  for (const attr of node.attrs) {
    attributes[getAttrKey(attr)] = attr.value;
  }
  if ("vite-ignore" in attributes) {
    return [
      {
        type: "remove",
        key: "vite-ignore",
        value: "",
        attributes,
        location: node.sourceCodeLocation.attrs["vite-ignore"]
      }
    ];
  }
  const actions = [];
  function handleAttributeKey(key, type) {
    const value = attributes[key];
    if (!value) return;
    if (matched.filter && !matched.filter({ key, value, attributes })) return;
    const location = node.sourceCodeLocation.attrs[key];
    actions.push({ type, key, value, attributes, location });
  }
  matched.srcAttributes?.forEach((key) => handleAttributeKey(key, "src"));
  matched.srcsetAttributes?.forEach((key) => handleAttributeKey(key, "srcset"));
  return actions;
}
function getAttrKey(attr) {
  return attr.prefix === void 0 ? attr.name : `${attr.prefix}:${attr.name}`;
}

const modulePreloadPolyfillId = "vite/modulepreload-polyfill";
const resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId + ".js";
function modulePreloadPolyfillPlugin(config) {
  let polyfillString;
  return {
    name: "vite:modulepreload-polyfill",
    resolveId: {
      handler(id) {
        if (id === modulePreloadPolyfillId) {
          return resolvedModulePreloadPolyfillId;
        }
      }
    },
    load: {
      handler(id) {
        if (id === resolvedModulePreloadPolyfillId) {
          if (config.command !== "build" || this.environment.config.consumer !== "client") {
            return "";
          }
          if (!polyfillString) {
            polyfillString = `${isModernFlag}&&(${polyfill.toString()}());`;
          }
          return { code: polyfillString, moduleSideEffects: true };
        }
      }
    }
  };
}
function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}

const htmlProxyRE$1 = /[?&]html-proxy=?(?:&inline-css)?(?:&style-attr)?&index=(\d+)\.(?:js|css)$/;
const isHtmlProxyRE = /[?&]html-proxy\b/;
const inlineCSSRE$1 = /__VITE_INLINE_CSS__([a-z\d]{8}_\d+)__/g;
const inlineImportRE = /(?<!(?<!\.\.)\.)\bimport\s*\(("(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*')\)/dg;
const htmlLangRE = /\.(?:html|htm)$/;
const spaceRe = /[\t\n\f\r ]/;
const importMapRE = /[ \t]*<script[^>]*type\s*=\s*(?:"importmap"|'importmap'|importmap)[^>]*>.*?<\/script>/is;
const moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
const modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
const importMapAppendRE = new RegExp(
  [moduleScriptRE, modulePreloadLinkRE].map((r) => r.source).join("|"),
  "i"
);
const isHTMLProxy = (id) => isHtmlProxyRE.test(id);
const isHTMLRequest = (request) => htmlLangRE.test(request);
const htmlProxyMap = /* @__PURE__ */ new WeakMap();
const htmlProxyResult = /* @__PURE__ */ new Map();
function htmlInlineProxyPlugin(config) {
  htmlProxyMap.set(config, /* @__PURE__ */ new Map());
  return {
    name: "vite:html-inline-proxy",
    resolveId: {
      handler(id) {
        if (isHTMLProxy(id)) {
          return id;
        }
      }
    },
    load: {
      handler(id) {
        const proxyMatch = htmlProxyRE$1.exec(id);
        if (proxyMatch) {
          const index = Number(proxyMatch[1]);
          const file = cleanUrl(id);
          const url = file.replace(normalizePath$3(config.root), "");
          const result = htmlProxyMap.get(config).get(url)?.[index];
          if (result) {
            return { ...result, moduleSideEffects: true };
          } else {
            throw new Error(`No matching HTML proxy module found from ${id}`);
          }
        }
      }
    }
  };
}
function addToHTMLProxyCache(config, filePath, index, result) {
  if (!htmlProxyMap.get(config)) {
    htmlProxyMap.set(config, /* @__PURE__ */ new Map());
  }
  if (!htmlProxyMap.get(config).get(filePath)) {
    htmlProxyMap.get(config).set(filePath, []);
  }
  htmlProxyMap.get(config).get(filePath)[index] = result;
}
function addToHTMLProxyTransformResult(hash, code) {
  htmlProxyResult.set(hash, code);
}
const noInlineLinkRels = /* @__PURE__ */ new Set([
  "icon",
  "apple-touch-icon",
  "apple-touch-startup-image",
  "manifest"
]);
const isAsyncScriptMap = /* @__PURE__ */ new WeakMap();
function nodeIsElement(node) {
  return node.nodeName[0] !== "#";
}
function traverseNodes(node, visitor) {
  if (node.nodeName === "template") {
    node = node.content;
  }
  visitor(node);
  if (nodeIsElement(node) || node.nodeName === "#document" || node.nodeName === "#document-fragment") {
    node.childNodes.forEach((childNode) => traverseNodes(childNode, visitor));
  }
}
async function traverseHtml(html, filePath, visitor) {
  const { parse } = await import('./dep-CvfTChi5.js');
  const ast = parse(html, {
    scriptingEnabled: false,
    // parse inside <noscript>
    sourceCodeLocationInfo: true,
    onParseError: (e) => {
      handleParseError(e, html, filePath);
    }
  });
  traverseNodes(ast, visitor);
}
function getScriptInfo(node) {
  let src;
  let srcSourceCodeLocation;
  let isModule = false;
  let isAsync = false;
  let isIgnored = false;
  for (const p of node.attrs) {
    if (p.prefix !== void 0) continue;
    if (p.name === "src") {
      if (!src) {
        src = p;
        srcSourceCodeLocation = node.sourceCodeLocation?.attrs["src"];
      }
    } else if (p.name === "type" && p.value === "module") {
      isModule = true;
    } else if (p.name === "async") {
      isAsync = true;
    } else if (p.name === "vite-ignore") {
      isIgnored = true;
    }
  }
  return { src, srcSourceCodeLocation, isModule, isAsync, isIgnored };
}
const attrValueStartRE = /=\s*(.)/;
function overwriteAttrValue(s, sourceCodeLocation, newValue) {
  const srcString = s.slice(
    sourceCodeLocation.startOffset,
    sourceCodeLocation.endOffset
  );
  const valueStart = attrValueStartRE.exec(srcString);
  if (!valueStart) {
    throw new Error(
      `[vite:html] internal error, failed to overwrite attribute value`
    );
  }
  const wrapOffset = valueStart[1] === '"' || valueStart[1] === "'" ? 1 : 0;
  const valueOffset = valueStart.index + valueStart[0].length - 1;
  s.update(
    sourceCodeLocation.startOffset + valueOffset + wrapOffset,
    sourceCodeLocation.endOffset - wrapOffset,
    newValue
  );
  return s;
}
function removeViteIgnoreAttr(s, sourceCodeLocation) {
  const loc = sourceCodeLocation.attrs?.["vite-ignore"];
  if (loc) {
    s.remove(loc.startOffset, loc.endOffset);
  }
  return s;
}
function formatParseError(parserError, id, html) {
  const formattedError = {
    code: parserError.code,
    message: `parse5 error code ${parserError.code}`,
    frame: generateCodeFrame(
      html,
      parserError.startOffset,
      parserError.endOffset
    ),
    loc: {
      file: id,
      line: parserError.startLine,
      column: parserError.startCol
    }
  };
  return formattedError;
}
function handleParseError(parserError, html, filePath) {
  switch (parserError.code) {
    case "missing-doctype":
      return;
    case "abandoned-head-element-child":
      return;
    case "duplicate-attribute":
      return;
    case "non-void-html-element-start-tag-with-trailing-solidus":
      return;
    case "unexpected-question-mark-instead-of-tag-name":
      return;
  }
  const parseError = formatParseError(parserError, filePath, html);
  throw new Error(
    `Unable to parse HTML; ${parseError.message}
 at ${parseError.loc.file}:${parseError.loc.line}:${parseError.loc.column}
${parseError.frame}`
  );
}
function buildHtmlPlugin(config) {
  const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(
    config.plugins,
    config.logger
  );
  preHooks.unshift(injectCspNonceMetaTagHook(config));
  preHooks.unshift(preImportMapHook(config));
  preHooks.push(htmlEnvHook(config));
  postHooks.push(injectNonceAttributeTagHook(config));
  postHooks.push(postImportMapHook());
  const processedHtml = perEnvironmentState(() => /* @__PURE__ */ new Map());
  const isExcludedUrl = (url) => url[0] === "#" || isExternalUrl(url) || isDataUrl(url);
  isAsyncScriptMap.set(config, /* @__PURE__ */ new Map());
  return {
    name: "vite:build-html",
    transform: {
      async handler(html, id) {
        if (id.endsWith(".html")) {
          id = normalizePath$3(id);
          const relativeUrlPath = normalizePath$3(path$b.relative(config.root, id));
          const publicPath = `/${relativeUrlPath}`;
          const publicBase = getBaseInHTML(relativeUrlPath, config);
          const publicToRelative = (filename) => publicBase + filename;
          const toOutputPublicFilePath = (url) => toOutputFilePathInHtml(
            url.slice(1),
            "public",
            relativeUrlPath,
            "html",
            config,
            publicToRelative
          );
          const nodeStartWithLeadingWhitespace = (node) => {
            const startOffset = node.sourceCodeLocation.startOffset;
            if (startOffset === 0) return 0;
            const lineStartOffset = startOffset - node.sourceCodeLocation.startCol;
            let isLineEmpty = false;
            try {
              const line = s.slice(Math.max(0, lineStartOffset), startOffset);
              isLineEmpty = !line.trim();
            } catch {
            }
            return isLineEmpty ? lineStartOffset : startOffset;
          };
          html = await applyHtmlTransforms(html, preHooks, {
            path: publicPath,
            filename: id
          });
          let js = "";
          const s = new MagicString(html);
          const scriptUrls = [];
          const styleUrls = [];
          let inlineModuleIndex = -1;
          let everyScriptIsAsync = true;
          let someScriptsAreAsync = false;
          let someScriptsAreDefer = false;
          const assetUrlsPromises = [];
          const namedOutput = Object.keys(
            config.build.rollupOptions.input || {}
          );
          const processAssetUrl = async (url, shouldInline) => {
            if (url !== "" && // Empty attribute
            !namedOutput.includes(url) && // Direct reference to named output
            !namedOutput.includes(removeLeadingSlash(url))) {
              try {
                return await urlToBuiltUrl(this, url, id, shouldInline);
              } catch (e) {
                if (e.code !== "ENOENT") {
                  throw e;
                }
              }
            }
            return url;
          };
          const setModuleSideEffectPromises = [];
          await traverseHtml(html, id, (node) => {
            if (!nodeIsElement(node)) {
              return;
            }
            let shouldRemove = false;
            if (node.nodeName === "script") {
              const {
                src,
                srcSourceCodeLocation,
                isModule,
                isAsync,
                isIgnored
              } = getScriptInfo(node);
              if (isIgnored) {
                removeViteIgnoreAttr(s, node.sourceCodeLocation);
              } else {
                const url = src && src.value;
                const isPublicFile = !!(url && checkPublicFile(url, config));
                if (isPublicFile) {
                  overwriteAttrValue(
                    s,
                    srcSourceCodeLocation,
                    partialEncodeURIPath(toOutputPublicFilePath(url))
                  );
                }
                if (isModule) {
                  inlineModuleIndex++;
                  if (url && !isExcludedUrl(url) && !isPublicFile) {
                    setModuleSideEffectPromises.push(
                      this.resolve(url, id).then((resolved) => {
                        if (!resolved) {
                          return Promise.reject(
                            new Error(`Failed to resolve ${url} from ${id}`)
                          );
                        }
                        const moduleInfo = this.getModuleInfo(resolved.id);
                        if (moduleInfo) {
                          moduleInfo.moduleSideEffects = true;
                        } else if (!resolved.external) {
                          return this.load(resolved).then((mod) => {
                            mod.moduleSideEffects = true;
                          });
                        }
                      })
                    );
                    js += `
import ${JSON.stringify(url)}`;
                    shouldRemove = true;
                  } else if (node.childNodes.length) {
                    const scriptNode = node.childNodes.pop();
                    const contents = scriptNode.value;
                    const filePath = id.replace(normalizePath$3(config.root), "");
                    addToHTMLProxyCache(config, filePath, inlineModuleIndex, {
                      code: contents
                    });
                    js += `
import "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                    shouldRemove = true;
                  }
                  everyScriptIsAsync &&= isAsync;
                  someScriptsAreAsync ||= isAsync;
                  someScriptsAreDefer ||= !isAsync;
                } else if (url && !isPublicFile) {
                  if (!isExcludedUrl(url)) {
                    config.logger.warn(
                      `<script src="${url}"> in "${publicPath}" can't be bundled without type="module" attribute`
                    );
                  }
                } else if (node.childNodes.length) {
                  const scriptNode = node.childNodes.pop();
                  scriptUrls.push(
                    ...extractImportExpressionFromClassicScript(scriptNode)
                  );
                }
              }
            }
            const assetAttributes = getNodeAssetAttributes(node);
            for (const attr of assetAttributes) {
              if (attr.type === "remove") {
                s.remove(attr.location.startOffset, attr.location.endOffset);
                continue;
              } else if (attr.type === "srcset") {
                assetUrlsPromises.push(
                  (async () => {
                    const processedEncodedUrl = await processSrcSet(
                      attr.value,
                      async ({ url }) => {
                        const decodedUrl = decodeURIIfPossible(url);
                        if (decodedUrl !== void 0 && !isExcludedUrl(decodedUrl)) {
                          const result = await processAssetUrl(url);
                          return result !== decodedUrl ? encodeURIPath(result) : url;
                        }
                        return url;
                      }
                    );
                    if (processedEncodedUrl !== attr.value) {
                      overwriteAttrValue(s, attr.location, processedEncodedUrl);
                    }
                  })()
                );
              } else if (attr.type === "src") {
                const url = decodeURIIfPossible(attr.value);
                if (url === void 0) ; else if (checkPublicFile(url, config)) {
                  overwriteAttrValue(
                    s,
                    attr.location,
                    partialEncodeURIPath(toOutputPublicFilePath(url))
                  );
                } else if (!isExcludedUrl(url)) {
                  if (node.nodeName === "link" && isCSSRequest(url) && // should not be converted if following attributes are present (#6748)
                  !("media" in attr.attributes || "disabled" in attr.attributes)) {
                    const importExpression = `
import ${JSON.stringify(url)}`;
                    styleUrls.push({
                      url,
                      start: nodeStartWithLeadingWhitespace(node),
                      end: node.sourceCodeLocation.endOffset
                    });
                    js += importExpression;
                  } else {
                    const isNoInlineLink = node.nodeName === "link" && attr.attributes.rel && parseRelAttr(attr.attributes.rel).some(
                      (v) => noInlineLinkRels.has(v)
                    );
                    const shouldInline = isNoInlineLink ? false : void 0;
                    assetUrlsPromises.push(
                      (async () => {
                        const processedUrl = await processAssetUrl(
                          url,
                          shouldInline
                        );
                        if (processedUrl !== url) {
                          overwriteAttrValue(
                            s,
                            attr.location,
                            partialEncodeURIPath(processedUrl)
                          );
                        }
                      })()
                    );
                  }
                }
              }
            }
            const inlineStyle = findNeedTransformStyleAttribute(node);
            if (inlineStyle) {
              inlineModuleIndex++;
              const code = inlineStyle.attr.value;
              const filePath = id.replace(normalizePath$3(config.root), "");
              addToHTMLProxyCache(config, filePath, inlineModuleIndex, { code });
              js += `
import "${id}?html-proxy&inline-css&style-attr&index=${inlineModuleIndex}.css"`;
              const hash = getHash(cleanUrl(id));
              overwriteAttrValue(
                s,
                inlineStyle.location,
                `__VITE_INLINE_CSS__${hash}_${inlineModuleIndex}__`
              );
            }
            if (node.nodeName === "style" && node.childNodes.length) {
              const styleNode = node.childNodes.pop();
              const filePath = id.replace(normalizePath$3(config.root), "");
              inlineModuleIndex++;
              addToHTMLProxyCache(config, filePath, inlineModuleIndex, {
                code: styleNode.value
              });
              js += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
              const hash = getHash(cleanUrl(id));
              s.update(
                styleNode.sourceCodeLocation.startOffset,
                styleNode.sourceCodeLocation.endOffset,
                `__VITE_INLINE_CSS__${hash}_${inlineModuleIndex}__`
              );
            }
            if (shouldRemove) {
              s.remove(
                nodeStartWithLeadingWhitespace(node),
                node.sourceCodeLocation.endOffset
              );
            }
          });
          isAsyncScriptMap.get(config).set(id, everyScriptIsAsync);
          if (someScriptsAreAsync && someScriptsAreDefer) {
            config.logger.warn(
              `
Mixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`
            );
          }
          await Promise.all(assetUrlsPromises);
          for (const { start, end, url } of scriptUrls) {
            if (checkPublicFile(url, config)) {
              s.update(
                start,
                end,
                partialEncodeURIPath(toOutputPublicFilePath(url))
              );
            } else if (!isExcludedUrl(url)) {
              s.update(
                start,
                end,
                partialEncodeURIPath(await urlToBuiltUrl(this, url, id))
              );
            }
          }
          const resolvedStyleUrls = await Promise.all(
            styleUrls.map(async (styleUrl) => ({
              ...styleUrl,
              resolved: await this.resolve(styleUrl.url, id)
            }))
          );
          for (const { start, end, url, resolved } of resolvedStyleUrls) {
            if (resolved == null) {
              config.logger.warnOnce(
                `
${url} doesn't exist at build time, it will remain unchanged to be resolved at runtime`
              );
              const importExpression = `
import ${JSON.stringify(url)}`;
              js = js.replace(importExpression, "");
            } else {
              s.remove(start, end);
            }
          }
          processedHtml(this).set(id, s.toString());
          const { modulePreload } = this.environment.config.build;
          if (modulePreload !== false && modulePreload.polyfill && (someScriptsAreAsync || someScriptsAreDefer)) {
            js = `import "${modulePreloadPolyfillId}";
${js}`;
          }
          await Promise.all(setModuleSideEffectPromises);
          return { code: js, moduleSideEffects: "no-treeshake" };
        }
      }
    },
    async generateBundle(options, bundle) {
      const analyzedImportedCssFiles = /* @__PURE__ */ new Map();
      const inlineEntryChunk = /* @__PURE__ */ new Set();
      const getImportedChunks = (chunk, seen = /* @__PURE__ */ new Set()) => {
        const chunks = [];
        chunk.imports.forEach((file) => {
          const importee = bundle[file];
          if (importee) {
            if (importee.type === "chunk" && !seen.has(file)) {
              seen.add(file);
              chunks.push(...getImportedChunks(importee, seen));
              chunks.push(importee);
            }
          } else {
            chunks.push(file);
          }
        });
        return chunks;
      };
      const toScriptTag = (chunkOrUrl, toOutputPath, isAsync) => ({
        tag: "script",
        attrs: {
          ...isAsync ? { async: true } : {},
          type: "module",
          // crossorigin must be set not only for serving assets in a different origin
          // but also to make it possible to preload the script using `<link rel="preload">`.
          // `<script type="module">` used to fetch the script with credential mode `omit`,
          // however `crossorigin` attribute cannot specify that value.
          // https://developer.chrome.com/blog/modulepreload/#ok-so-why-doesnt-link-relpreload-work-for-modules:~:text=For%20%3Cscript%3E,of%20other%20modules.
          // Now `<script type="module">` uses `same origin`: https://github.com/whatwg/html/pull/3656#:~:text=Module%20scripts%20are%20always%20fetched%20with%20credentials%20mode%20%22same%2Dorigin%22%20by%20default%20and%20can%20no%20longer%0Ause%20%22omit%22
          crossorigin: true,
          src: typeof chunkOrUrl === "string" ? chunkOrUrl : toOutputPath(chunkOrUrl.fileName)
        }
      });
      const toPreloadTag = (filename, toOutputPath) => ({
        tag: "link",
        attrs: {
          rel: "modulepreload",
          crossorigin: true,
          href: toOutputPath(filename)
        }
      });
      const toStyleSheetLinkTag = (file, toOutputPath) => ({
        tag: "link",
        attrs: {
          rel: "stylesheet",
          crossorigin: true,
          href: toOutputPath(file)
        }
      });
      const getCssFilesForChunk = (chunk, seenChunks = /* @__PURE__ */ new Set(), seenCss = /* @__PURE__ */ new Set()) => {
        if (seenChunks.has(chunk.fileName)) {
          return [];
        }
        seenChunks.add(chunk.fileName);
        if (analyzedImportedCssFiles.has(chunk)) {
          const files2 = analyzedImportedCssFiles.get(chunk);
          const additionals = files2.filter((file) => !seenCss.has(file));
          additionals.forEach((file) => seenCss.add(file));
          return additionals;
        }
        const files = [];
        chunk.imports.forEach((file) => {
          const importee = bundle[file];
          if (importee?.type === "chunk") {
            files.push(...getCssFilesForChunk(importee, seenChunks, seenCss));
          }
        });
        analyzedImportedCssFiles.set(chunk, files);
        chunk.viteMetadata.importedCss.forEach((file) => {
          if (!seenCss.has(file)) {
            seenCss.add(file);
            files.push(file);
          }
        });
        return files;
      };
      const getCssTagsForChunk = (chunk, toOutputPath) => getCssFilesForChunk(chunk).map(
        (file) => toStyleSheetLinkTag(file, toOutputPath)
      );
      for (const [normalizedId, html] of processedHtml(this)) {
        const relativeUrlPath = normalizePath$3(
          path$b.relative(config.root, normalizedId)
        );
        const assetsBase = getBaseInHTML(relativeUrlPath, config);
        const toOutputFilePath = (filename, type) => {
          if (isExternalUrl(filename)) {
            return filename;
          } else {
            return toOutputFilePathInHtml(
              filename,
              type,
              relativeUrlPath,
              "html",
              config,
              (filename2) => assetsBase + filename2
            );
          }
        };
        const toOutputAssetFilePath = (filename) => toOutputFilePath(filename, "asset");
        const toOutputPublicAssetFilePath = (filename) => toOutputFilePath(filename, "public");
        const isAsync = isAsyncScriptMap.get(config).get(normalizedId);
        let result = html;
        const chunk = Object.values(bundle).find(
          (chunk2) => chunk2.type === "chunk" && chunk2.isEntry && chunk2.facadeModuleId && normalizePath$3(chunk2.facadeModuleId) === normalizedId
        );
        let canInlineEntry = false;
        if (chunk) {
          if (options.format === "es" && isEntirelyImport(chunk.code)) {
            canInlineEntry = true;
          }
          const imports = getImportedChunks(chunk);
          let assetTags;
          if (canInlineEntry) {
            assetTags = imports.map(
              (chunk2) => toScriptTag(chunk2, toOutputAssetFilePath, isAsync)
            );
          } else {
            const { modulePreload } = this.environment.config.build;
            assetTags = [toScriptTag(chunk, toOutputAssetFilePath, isAsync)];
            if (modulePreload !== false) {
              const resolveDependencies = typeof modulePreload === "object" && modulePreload.resolveDependencies;
              const importsFileNames = imports.filter((chunkOrUrl) => typeof chunkOrUrl !== "string").map((chunk2) => chunk2.fileName);
              const resolvedDeps = resolveDependencies ? resolveDependencies(chunk.fileName, importsFileNames, {
                hostId: relativeUrlPath,
                hostType: "html"
              }) : importsFileNames;
              assetTags.push(
                ...resolvedDeps.map(
                  (i) => toPreloadTag(i, toOutputAssetFilePath)
                )
              );
            }
          }
          assetTags.push(...getCssTagsForChunk(chunk, toOutputAssetFilePath));
          result = injectToHead(result, assetTags);
        }
        if (!this.environment.config.build.cssCodeSplit) {
          const cssBundleName = cssBundleNameCache.get(config);
          const cssChunk = cssBundleName && Object.values(bundle).find(
            (chunk2) => chunk2.type === "asset" && chunk2.names.includes(cssBundleName)
          );
          if (cssChunk) {
            result = injectToHead(result, [
              {
                tag: "link",
                attrs: {
                  rel: "stylesheet",
                  crossorigin: true,
                  href: toOutputAssetFilePath(cssChunk.fileName)
                }
              }
            ]);
          }
        }
        let match;
        let s;
        inlineCSSRE$1.lastIndex = 0;
        while (match = inlineCSSRE$1.exec(result)) {
          s ||= new MagicString(result);
          const { 0: full, 1: scopedName } = match;
          const cssTransformedCode = htmlProxyResult.get(scopedName);
          s.update(match.index, match.index + full.length, cssTransformedCode);
        }
        if (s) {
          result = s.toString();
        }
        result = await applyHtmlTransforms(
          result,
          [...normalHooks, ...postHooks],
          {
            path: "/" + relativeUrlPath,
            filename: normalizedId,
            bundle,
            chunk
          }
        );
        result = result.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          const file = this.getFileName(fileHash);
          if (chunk) {
            chunk.viteMetadata.importedAssets.add(cleanUrl(file));
          }
          return encodeURIPath(toOutputAssetFilePath(file)) + postfix;
        });
        result = result.replace(publicAssetUrlRE, (_, fileHash) => {
          const publicAssetPath = toOutputPublicAssetFilePath(
            getPublicAssetFilename(fileHash, config)
          );
          return encodeURIPath(
            urlCanParse(publicAssetPath) ? publicAssetPath : normalizePath$3(publicAssetPath)
          );
        });
        if (chunk && canInlineEntry) {
          inlineEntryChunk.add(chunk.fileName);
        }
        const shortEmitName = normalizePath$3(
          path$b.relative(config.root, normalizedId)
        );
        this.emitFile({
          type: "asset",
          originalFileName: normalizedId,
          fileName: shortEmitName,
          source: result
        });
      }
      for (const fileName of inlineEntryChunk) {
        delete bundle[fileName];
      }
    }
  };
}
function parseRelAttr(attr) {
  return attr.split(spaceRe).map((v) => v.toLowerCase());
}
function findNeedTransformStyleAttribute(node) {
  const attr = node.attrs.find(
    (prop) => prop.prefix === void 0 && prop.name === "style" && // only url(...) or image-set(...) in css need to emit file
    (prop.value.includes("url(") || prop.value.includes("image-set("))
  );
  if (!attr) return void 0;
  const location = node.sourceCodeLocation?.attrs?.["style"];
  return { attr, location };
}
function extractImportExpressionFromClassicScript(scriptTextNode) {
  const startOffset = scriptTextNode.sourceCodeLocation.startOffset;
  const cleanCode = stripLiteral(scriptTextNode.value);
  const scriptUrls = [];
  let match;
  inlineImportRE.lastIndex = 0;
  while (match = inlineImportRE.exec(cleanCode)) {
    const [, [urlStart, urlEnd]] = match.indices;
    const start = urlStart + 1;
    const end = urlEnd - 1;
    scriptUrls.push({
      start: start + startOffset,
      end: end + startOffset,
      url: scriptTextNode.value.slice(start, end)
    });
  }
  return scriptUrls;
}
function preImportMapHook(config) {
  return (html, ctx) => {
    const importMapIndex = html.search(importMapRE);
    if (importMapIndex < 0) return;
    const importMapAppendIndex = html.search(importMapAppendRE);
    if (importMapAppendIndex < 0) return;
    if (importMapAppendIndex < importMapIndex) {
      const relativeHtml = normalizePath$3(
        path$b.relative(config.root, ctx.filename)
      );
      config.logger.warnOnce(
        colors$1.yellow(
          colors$1.bold(
            `(!) <script type="importmap"> should come before <script type="module"> and <link rel="modulepreload"> in /${relativeHtml}`
          )
        )
      );
    }
  };
}
function postImportMapHook() {
  return (html) => {
    if (!importMapAppendRE.test(html)) return;
    let importMap;
    html = html.replace(importMapRE, (match) => {
      importMap = match;
      return "";
    });
    if (importMap) {
      html = html.replace(
        importMapAppendRE,
        (match) => `${importMap}
${match}`
      );
    }
    return html;
  };
}
function injectCspNonceMetaTagHook(config) {
  return () => {
    if (!config.html?.cspNonce) return;
    return [
      {
        tag: "meta",
        injectTo: "head",
        // use nonce attribute so that it's hidden
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce#accessing_nonces_and_nonce_hiding
        attrs: { property: "csp-nonce", nonce: config.html.cspNonce }
      }
    ];
  };
}
function htmlEnvHook(config) {
  const pattern = /%(\S+?)%/g;
  const envPrefix = resolveEnvPrefix({ envPrefix: config.envPrefix });
  const env = { ...config.env };
  for (const key in config.define) {
    if (key.startsWith(`import.meta.env.`)) {
      const val = config.define[key];
      if (typeof val === "string") {
        try {
          const parsed = JSON.parse(val);
          env[key.slice(16)] = typeof parsed === "string" ? parsed : val;
        } catch {
          env[key.slice(16)] = val;
        }
      } else {
        env[key.slice(16)] = JSON.stringify(val);
      }
    }
  }
  return (html, ctx) => {
    return html.replace(pattern, (text, key) => {
      if (key in env) {
        return env[key];
      } else {
        if (envPrefix.some((prefix) => key.startsWith(prefix))) {
          const relativeHtml = normalizePath$3(
            path$b.relative(config.root, ctx.filename)
          );
          config.logger.warn(
            colors$1.yellow(
              colors$1.bold(
                `(!) ${text} is not defined in env variables found in /${relativeHtml}. Is the variable mistyped?`
              )
            )
          );
        }
        return text;
      }
    });
  };
}
function injectNonceAttributeTagHook(config) {
  const processRelType = /* @__PURE__ */ new Set(["stylesheet", "modulepreload", "preload"]);
  return async (html, { filename }) => {
    const nonce = config.html?.cspNonce;
    if (!nonce) return;
    const s = new MagicString(html);
    await traverseHtml(html, filename, (node) => {
      if (!nodeIsElement(node)) {
        return;
      }
      const { nodeName, attrs, sourceCodeLocation } = node;
      if (nodeName === "script" || nodeName === "style" || nodeName === "link" && attrs.some(
        (attr) => attr.name === "rel" && parseRelAttr(attr.value).some((a) => processRelType.has(a))
      )) {
        if (attrs.some(({ name }) => name === "nonce")) {
          return;
        }
        const startTagEndOffset = sourceCodeLocation.startTag.endOffset;
        const appendOffset = html[startTagEndOffset - 2] === "/" ? 2 : 1;
        s.appendRight(startTagEndOffset - appendOffset, ` nonce="${nonce}"`);
      }
    });
    return s.toString();
  };
}
function resolveHtmlTransforms(plugins, logger) {
  const preHooks = [];
  const normalHooks = [];
  const postHooks = [];
  for (const plugin of plugins) {
    const hook = plugin.transformIndexHtml;
    if (!hook) continue;
    if (typeof hook === "function") {
      normalHooks.push(hook);
    } else {
      if (!("order" in hook) && "enforce" in hook) {
        logger.warnOnce(
          colors$1.yellow(
            `plugin '${plugin.name}' uses deprecated 'enforce' option. Use 'order' option instead.`
          )
        );
      }
      if (!("handler" in hook) && "transform" in hook) {
        logger.warnOnce(
          colors$1.yellow(
            `plugin '${plugin.name}' uses deprecated 'transform' option. Use 'handler' option instead.`
          )
        );
      }
      const order = hook.order ?? (hook.enforce === "pre" ? "pre" : void 0);
      const handler = hook.handler ?? hook.transform;
      if (order === "pre") {
        preHooks.push(handler);
      } else if (order === "post") {
        postHooks.push(handler);
      } else {
        normalHooks.push(handler);
      }
    }
  }
  return [preHooks, normalHooks, postHooks];
}
const elementsAllowedInHead = /* @__PURE__ */ new Set([
  "title",
  "base",
  "link",
  "style",
  "meta",
  "script",
  "noscript",
  "template"
]);
function headTagInsertCheck(tags, ctx) {
  if (!tags.length) return;
  const { logger } = ctx.server?.config || {};
  const disallowedTags = tags.filter(
    (tagDescriptor) => !elementsAllowedInHead.has(tagDescriptor.tag)
  );
  if (disallowedTags.length) {
    const dedupedTags = unique(
      disallowedTags.map((tagDescriptor) => `<${tagDescriptor.tag}>`)
    );
    logger?.warn(
      colors$1.yellow(
        colors$1.bold(
          `[${dedupedTags.join(",")}] can not be used inside the <head> Element, please check the 'injectTo' value`
        )
      )
    );
  }
}
async function applyHtmlTransforms(html, hooks, ctx) {
  for (const hook of hooks) {
    const res = await hook(html, ctx);
    if (!res) {
      continue;
    }
    if (typeof res === "string") {
      html = res;
    } else {
      let tags;
      if (Array.isArray(res)) {
        tags = res;
      } else {
        html = res.html || html;
        tags = res.tags;
      }
      let headTags;
      let headPrependTags;
      let bodyTags;
      let bodyPrependTags;
      for (const tag of tags) {
        switch (tag.injectTo) {
          case "body":
            (bodyTags ??= []).push(tag);
            break;
          case "body-prepend":
            (bodyPrependTags ??= []).push(tag);
            break;
          case "head":
            (headTags ??= []).push(tag);
            break;
          default:
            (headPrependTags ??= []).push(tag);
        }
      }
      headTagInsertCheck([...headTags || [], ...headPrependTags || []], ctx);
      if (headPrependTags) html = injectToHead(html, headPrependTags, true);
      if (headTags) html = injectToHead(html, headTags);
      if (bodyPrependTags) html = injectToBody(html, bodyPrependTags, true);
      if (bodyTags) html = injectToBody(html, bodyTags);
    }
  }
  return html;
}
const importRE = /\bimport\s*(?:"[^"]*[^\\]"|'[^']*[^\\]');*/g;
const commentRE = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
function isEntirelyImport(code) {
  return !code.replace(importRE, "").replace(commentRE, "").trim().length;
}
function getBaseInHTML(urlRelativePath, config) {
  return config.base === "./" || config.base === "" ? path$b.posix.join(
    path$b.posix.relative(urlRelativePath, "").slice(0, -2),
    "./"
  ) : config.base;
}
const headInjectRE = /([ \t]*)<\/head>/i;
const headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
const htmlInjectRE = /<\/html>/i;
const htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
const bodyInjectRE = /([ \t]*)<\/body>/i;
const bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
const doctypePrependInjectRE = /<!doctype html>/i;
function injectToHead(html, tags, prepend = false) {
  if (tags.length === 0) return html;
  if (prepend) {
    if (headPrependInjectRE.test(html)) {
      return html.replace(
        headPrependInjectRE,
        (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`
      );
    }
  } else {
    if (headInjectRE.test(html)) {
      return html.replace(
        headInjectRE,
        (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`
      );
    }
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(
        bodyPrependInjectRE,
        (match, p1) => `${serializeTags(tags, p1)}
${match}`
      );
    }
  }
  return prependInjectFallback(html, tags);
}
function injectToBody(html, tags, prepend = false) {
  if (tags.length === 0) return html;
  if (prepend) {
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(
        bodyPrependInjectRE,
        (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`
      );
    }
    if (headInjectRE.test(html)) {
      return html.replace(
        headInjectRE,
        (match, p1) => `${match}
${serializeTags(tags, p1)}`
      );
    }
    return prependInjectFallback(html, tags);
  } else {
    if (bodyInjectRE.test(html)) {
      return html.replace(
        bodyInjectRE,
        (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`
      );
    }
    if (htmlInjectRE.test(html)) {
      return html.replace(htmlInjectRE, `${serializeTags(tags)}
$&`);
    }
    return html + `
` + serializeTags(tags);
  }
}
function prependInjectFallback(html, tags) {
  if (htmlPrependInjectRE.test(html)) {
    return html.replace(htmlPrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  if (doctypePrependInjectRE.test(html)) {
    return html.replace(doctypePrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  return serializeTags(tags) + html;
}
const unaryTags = /* @__PURE__ */ new Set(["link", "meta", "base"]);
function serializeTag({ tag, attrs, children }, indent = "") {
  if (unaryTags.has(tag)) {
    return `<${tag}${serializeAttrs(attrs)}>`;
  } else {
    return `<${tag}${serializeAttrs(attrs)}>${serializeTags(
      children,
      incrementIndent(indent)
    )}</${tag}>`;
  }
}
function serializeTags(tags, indent = "") {
  if (typeof tags === "string") {
    return tags;
  } else if (tags && tags.length) {
    return tags.map((tag) => `${indent}${serializeTag(tag, indent)}
`).join("");
  }
  return "";
}
function serializeAttrs(attrs) {
  let res = "";
  for (const key in attrs) {
    if (typeof attrs[key] === "boolean") {
      res += attrs[key] ? ` ${key}` : ``;
    } else {
      res += ` ${key}="${escapeHtml$2(attrs[key])}"`;
    }
  }
  return res;
}
function incrementIndent(indent = "") {
  return `${indent}${indent[0] === "	" ? "	" : "  "}`;
}
function decodeURIIfPossible(input) {
  try {
    return decodeURI(input);
  } catch {
    return;
  }
}

const debugCache = createDebugger("vite:cache");
const knownIgnoreList = /* @__PURE__ */ new Set(["/", "/favicon.ico"]);
const trailingQuerySeparatorsRE = /[?&]+$/;
const urlRE = /[?&]url\b/;
const rawRE = /[?&]raw\b/;
const inlineRE$2 = /[?&]inline\b/;
const svgRE = /\.svg\b/;
function deniedServingAccessForTransform(url, server, res, next) {
  if (rawRE.test(url) || urlRE.test(url) || inlineRE$2.test(url) || svgRE.test(url)) {
    const servingAccessResult = checkServingAccess(url, server);
    if (servingAccessResult === "denied") {
      respondWithAccessDenied(url, server, res);
      return true;
    }
    if (servingAccessResult === "fallback") {
      next();
      return true;
    }
  }
  return false;
}
function cachedTransformMiddleware(server) {
  return function viteCachedTransformMiddleware(req, res, next) {
    const environment = server.environments.client;
    const ifNoneMatch = req.headers["if-none-match"];
    if (ifNoneMatch) {
      const moduleByEtag = environment.moduleGraph.getModuleByEtag(ifNoneMatch);
      if (moduleByEtag?.transformResult?.etag === ifNoneMatch && moduleByEtag.url === req.url) {
        const maybeMixedEtag = isCSSRequest(req.url);
        if (!maybeMixedEtag) {
          debugCache?.(`[304] ${prettifyUrl(req.url, server.config.root)}`);
          res.statusCode = 304;
          return res.end();
        }
      }
    }
    next();
  };
}
function transformMiddleware(server) {
  const { root, publicDir } = server.config;
  const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root));
  const publicPath = `${publicDir.slice(root.length)}/`;
  return async function viteTransformMiddleware(req, res, next) {
    const environment = server.environments.client;
    if (req.method !== "GET" || knownIgnoreList.has(req.url)) {
      return next();
    }
    let url;
    try {
      url = decodeURI(removeTimestampQuery(req.url)).replace(
        NULL_BYTE_PLACEHOLDER,
        "\0"
      );
    } catch (e) {
      if (e instanceof URIError) {
        server.config.logger.warn(
          colors$1.yellow("Malformed URI sequence in request URL")
        );
        return next();
      }
      return next(e);
    }
    const withoutQuery = cleanUrl(url);
    try {
      const isSourceMap = withoutQuery.endsWith(".map");
      if (isSourceMap) {
        const depsOptimizer = environment.depsOptimizer;
        if (depsOptimizer?.isOptimizedDepUrl(url)) {
          const sourcemapPath = url.startsWith(FS_PREFIX) ? fsPathFromId(url) : normalizePath$3(path$b.resolve(server.config.root, url.slice(1)));
          try {
            const map = JSON.parse(
              await fsp.readFile(sourcemapPath, "utf-8")
            );
            applySourcemapIgnoreList(
              map,
              sourcemapPath,
              server.config.server.sourcemapIgnoreList,
              server.config.logger
            );
            return send$1(req, res, JSON.stringify(map), "json", {
              headers: server.config.server.headers
            });
          } catch {
            const dummySourceMap = {
              version: 3,
              file: sourcemapPath.replace(/\.map$/, ""),
              sources: [],
              sourcesContent: [],
              names: [],
              mappings: ";;;;;;;;;"
            };
            return send$1(req, res, JSON.stringify(dummySourceMap), "json", {
              cacheControl: "no-cache",
              headers: server.config.server.headers
            });
          }
        } else {
          const originalUrl = url.replace(/\.map($|\?)/, "$1");
          const map = (await environment.moduleGraph.getModuleByUrl(originalUrl))?.transformResult?.map;
          if (map) {
            return send$1(req, res, JSON.stringify(map), "json", {
              headers: server.config.server.headers
            });
          } else {
            return next();
          }
        }
      }
      if (publicDirInRoot && url.startsWith(publicPath)) {
        warnAboutExplicitPublicPathInUrl(url);
      }
      const urlWithoutTrailingQuerySeparators = url.replace(
        trailingQuerySeparatorsRE,
        ""
      );
      if (deniedServingAccessForTransform(
        urlWithoutTrailingQuerySeparators,
        server,
        res,
        next
      )) {
        return;
      }
      if (req.headers["sec-fetch-dest"] === "script" || isJSRequest(url) || isImportRequest(url) || isCSSRequest(url) || isHTMLProxy(url)) {
        url = removeImportQuery(url);
        url = unwrapId$1(url);
        if (isCSSRequest(url)) {
          if (req.headers.accept?.includes("text/css") && !isDirectRequest(url)) {
            url = injectQuery(url, "direct");
          }
          const ifNoneMatch = req.headers["if-none-match"];
          if (ifNoneMatch && (await environment.moduleGraph.getModuleByUrl(url))?.transformResult?.etag === ifNoneMatch) {
            debugCache?.(`[304] ${prettifyUrl(url, server.config.root)}`);
            res.statusCode = 304;
            return res.end();
          }
        }
        const result = await transformRequest(environment, url, {
          html: req.headers.accept?.includes("text/html"),
          allowId(id) {
            return !deniedServingAccessForTransform(id, server, res, next);
          }
        });
        if (result) {
          const depsOptimizer = environment.depsOptimizer;
          const type = isDirectCSSRequest(url) ? "css" : "js";
          const isDep = DEP_VERSION_RE.test(url) || depsOptimizer?.isOptimizedDepUrl(url);
          return send$1(req, res, result.code, type, {
            etag: result.etag,
            // allow browser to cache npm deps!
            cacheControl: isDep ? "max-age=31536000,immutable" : "no-cache",
            headers: server.config.server.headers,
            map: result.map
          });
        }
      }
    } catch (e) {
      if (e?.code === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.statusMessage = "Optimize Deps Processing Error";
          res.end();
        }
        server.config.logger.error(e.message);
        return;
      }
      if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.statusMessage = "Outdated Optimize Dep";
          res.end();
        }
        return;
      }
      if (e?.code === ERR_CLOSED_SERVER) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.statusMessage = "Outdated Request";
          res.end();
        }
        return;
      }
      if (e?.code === ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR) {
        if (!res.writableEnded) {
          res.statusCode = 404;
          res.end();
        }
        server.config.logger.warn(colors$1.yellow(e.message));
        return;
      }
      if (e?.code === ERR_LOAD_URL) {
        return next();
      }
      if (e?.code === ERR_DENIED_ID) {
        return;
      }
      return next(e);
    }
    next();
  };
  function warnAboutExplicitPublicPathInUrl(url) {
    let warning;
    if (isImportRequest(url)) {
      const rawUrl = removeImportQuery(url);
      if (urlRE.test(url)) {
        warning = `Assets in the public directory are served at the root path.
Instead of ${colors$1.cyan(rawUrl)}, use ${colors$1.cyan(
          rawUrl.replace(publicPath, "/")
        )}.`;
      } else {
        warning = `Assets in public directory cannot be imported from JavaScript.
If you intend to import that asset, put the file in the src directory, and use ${colors$1.cyan(
          rawUrl.replace(publicPath, "/src/")
        )} instead of ${colors$1.cyan(rawUrl)}.
If you intend to use the URL of that asset, use ${colors$1.cyan(
          injectQuery(rawUrl.replace(publicPath, "/"), "url")
        )}.`;
      }
    } else {
      warning = `Files in the public directory are served at the root path.
Instead of ${colors$1.cyan(url)}, use ${colors$1.cyan(
        url.replace(publicPath, "/")
      )}.`;
    }
    server.config.logger.warn(colors$1.yellow(warning));
  }
}

function createDevHtmlTransformFn(config) {
  const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(
    config.plugins,
    config.logger
  );
  const transformHooks = [
    preImportMapHook(config),
    injectCspNonceMetaTagHook(config),
    ...preHooks,
    htmlEnvHook(config),
    devHtmlHook,
    ...normalHooks,
    ...postHooks,
    injectNonceAttributeTagHook(config),
    postImportMapHook()
  ];
  return (server, url, html, originalUrl) => {
    return applyHtmlTransforms(html, transformHooks, {
      path: url,
      filename: getHtmlFilename(url, server),
      server,
      originalUrl
    });
  };
}
function getHtmlFilename(url, server) {
  if (url.startsWith(FS_PREFIX)) {
    return decodeURIComponent(fsPathFromId(url));
  } else {
    return decodeURIComponent(
      normalizePath$3(path$b.join(server.config.root, url.slice(1)))
    );
  }
}
function shouldPreTransform(url, config) {
  return !checkPublicFile(url, config) && (isJSRequest(url) || isCSSRequest(url));
}
const wordCharRE = /\w/;
function isBareRelative(url) {
  return wordCharRE.test(url[0]) && !url.includes(":");
}
const processNodeUrl = (url, useSrcSetReplacer, config, htmlPath, originalUrl, server, isClassicScriptLink) => {
  const replacer = (url2) => {
    if (url2[0] === "/" && url2[1] !== "/" || // #3230 if some request url (localhost:3000/a/b) return to fallback html, the relative assets
    // path will add `/a/` prefix, it will caused 404.
    //
    // skip if url contains `:` as it implies a url protocol or Windows path that we don't want to replace.
    //
    // rewrite `./index.js` -> `localhost:5173/a/index.js`.
    // rewrite `../index.js` -> `localhost:5173/index.js`.
    // rewrite `relative/index.js` -> `localhost:5173/a/relative/index.js`.
    (url2[0] === "." || isBareRelative(url2)) && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") {
      url2 = path$b.posix.join(config.base, url2);
    }
    let preTransformUrl;
    if (!isClassicScriptLink && shouldPreTransform(url2, config)) {
      if (url2[0] === "/" && url2[1] !== "/") {
        preTransformUrl = url2;
      } else if (url2[0] === "." || isBareRelative(url2)) {
        preTransformUrl = path$b.posix.join(
          config.base,
          path$b.posix.dirname(htmlPath),
          url2
        );
      }
    }
    if (server) {
      const mod = server.environments.client.moduleGraph.urlToModuleMap.get(
        preTransformUrl || url2
      );
      if (mod && mod.lastHMRTimestamp > 0) {
        url2 = injectQuery(url2, `t=${mod.lastHMRTimestamp}`);
      }
    }
    if (server && preTransformUrl) {
      try {
        preTransformUrl = decodeURI(preTransformUrl);
      } catch {
        return url2;
      }
      preTransformRequest(server, preTransformUrl, config.decodedBase);
    }
    return url2;
  };
  const processedUrl = useSrcSetReplacer ? processSrcSetSync(url, ({ url: url2 }) => replacer(url2)) : replacer(url);
  return processedUrl;
};
const devHtmlHook = async (html, { path: htmlPath, filename, server, originalUrl }) => {
  const { config, watcher } = server;
  const base = config.base || "/";
  const decodedBase = config.decodedBase || "/";
  let proxyModulePath;
  let proxyModuleUrl;
  const trailingSlash = htmlPath.endsWith("/");
  if (!trailingSlash && fs__default.existsSync(filename)) {
    proxyModulePath = htmlPath;
    proxyModuleUrl = proxyModulePath;
  } else {
    const validPath = `${htmlPath}${trailingSlash ? "index.html" : ""}`;
    proxyModulePath = `\0${validPath}`;
    proxyModuleUrl = wrapId$1(proxyModulePath);
  }
  proxyModuleUrl = joinUrlSegments(decodedBase, proxyModuleUrl);
  const s = new MagicString(html);
  let inlineModuleIndex = -1;
  const proxyCacheUrl = decodeURI(
    cleanUrl(proxyModulePath).replace(normalizePath$3(config.root), "")
  );
  const styleUrl = [];
  const inlineStyles = [];
  const inlineModulePaths = [];
  const addInlineModule = (node, ext) => {
    inlineModuleIndex++;
    const contentNode = node.childNodes[0];
    const code = contentNode.value;
    let map;
    if (proxyModulePath[0] !== "\0") {
      map = new MagicString(html).snip(
        contentNode.sourceCodeLocation.startOffset,
        contentNode.sourceCodeLocation.endOffset
      ).generateMap({ hires: "boundary" });
      map.sources = [filename];
      map.file = filename;
    }
    addToHTMLProxyCache(config, proxyCacheUrl, inlineModuleIndex, { code, map });
    const modulePath = `${proxyModuleUrl}?html-proxy&index=${inlineModuleIndex}.${ext}`;
    inlineModulePaths.push(modulePath);
    s.update(
      node.sourceCodeLocation.startOffset,
      node.sourceCodeLocation.endOffset,
      `<script type="module" src="${modulePath}"><\/script>`
    );
    preTransformRequest(server, modulePath, decodedBase);
  };
  await traverseHtml(html, filename, (node) => {
    if (!nodeIsElement(node)) {
      return;
    }
    if (node.nodeName === "script") {
      const { src, srcSourceCodeLocation, isModule, isIgnored } = getScriptInfo(node);
      if (isIgnored) {
        removeViteIgnoreAttr(s, node.sourceCodeLocation);
      } else if (src) {
        const processedUrl = processNodeUrl(
          src.value,
          /* useSrcSetReplacer */
          false,
          config,
          htmlPath,
          originalUrl,
          server,
          !isModule
        );
        if (processedUrl !== src.value) {
          overwriteAttrValue(s, srcSourceCodeLocation, processedUrl);
        }
      } else if (isModule && node.childNodes.length) {
        addInlineModule(node, "js");
      } else if (node.childNodes.length) {
        const scriptNode = node.childNodes[node.childNodes.length - 1];
        for (const {
          url,
          start,
          end
        } of extractImportExpressionFromClassicScript(scriptNode)) {
          const processedUrl = processNodeUrl(
            url,
            false,
            config,
            htmlPath,
            originalUrl
          );
          if (processedUrl !== url) {
            s.update(start, end, processedUrl);
          }
        }
      }
    }
    const inlineStyle = findNeedTransformStyleAttribute(node);
    if (inlineStyle) {
      inlineModuleIndex++;
      inlineStyles.push({
        index: inlineModuleIndex,
        location: inlineStyle.location,
        code: inlineStyle.attr.value
      });
    }
    if (node.nodeName === "style" && node.childNodes.length) {
      const children = node.childNodes[0];
      styleUrl.push({
        start: children.sourceCodeLocation.startOffset,
        end: children.sourceCodeLocation.endOffset,
        code: children.value
      });
    }
    const assetAttributes = getNodeAssetAttributes(node);
    for (const attr of assetAttributes) {
      if (attr.type === "remove") {
        s.remove(attr.location.startOffset, attr.location.endOffset);
      } else {
        const processedUrl = processNodeUrl(
          attr.value,
          attr.type === "srcset",
          config,
          htmlPath,
          originalUrl
        );
        if (processedUrl !== attr.value) {
          overwriteAttrValue(s, attr.location, processedUrl);
        }
      }
    }
  });
  const clientModuelGraph = server?.environments.client.moduleGraph;
  if (clientModuelGraph) {
    await Promise.all(
      inlineModulePaths.map(async (url) => {
        const module = await clientModuelGraph.getModuleByUrl(url);
        if (module) {
          clientModuelGraph.invalidateModule(module);
        }
      })
    );
  }
  await Promise.all([
    ...styleUrl.map(async ({ start, end, code }, index) => {
      const url = `${proxyModulePath}?html-proxy&direct&index=${index}.css`;
      const mod = await server.environments.client.moduleGraph.ensureEntryFromUrl(
        url,
        false
      );
      ensureWatchedFile(watcher, mod.file, config.root);
      const result = await server.pluginContainer.transform(code, mod.id, {
        environment: server.environments.client
      });
      let content = "";
      if (result.map && "version" in result.map) {
        if (result.map.mappings) {
          await injectSourcesContent(result.map, proxyModulePath, config.logger);
        }
        content = getCodeWithSourcemap("css", result.code, result.map);
      } else {
        content = result.code;
      }
      s.overwrite(start, end, content);
    }),
    ...inlineStyles.map(async ({ index, location, code }) => {
      const url = `${proxyModulePath}?html-proxy&inline-css&style-attr&index=${index}.css`;
      const mod = await server.environments.client.moduleGraph.ensureEntryFromUrl(
        url,
        false
      );
      ensureWatchedFile(watcher, mod.file, config.root);
      await server?.pluginContainer.transform(code, mod.id, {
        environment: server.environments.client
      });
      const hash = getHash(cleanUrl(mod.id));
      const result = htmlProxyResult.get(`${hash}_${index}`);
      overwriteAttrValue(s, location, result ?? "");
    })
  ]);
  html = s.toString();
  return {
    html,
    tags: [
      {
        tag: "script",
        attrs: {
          type: "module",
          src: path$b.posix.join(base, CLIENT_PUBLIC_PATH)
        },
        injectTo: "head-prepend"
      }
    ]
  };
};
function indexHtmlMiddleware(root, server) {
  const isDev = isDevServer(server);
  return async function viteIndexHtmlMiddleware(req, res, next) {
    if (res.writableEnded) {
      return next();
    }
    const url = req.url && cleanUrl(req.url);
    if (url?.endsWith(".html") && req.headers["sec-fetch-dest"] !== "script") {
      let filePath;
      if (isDev && url.startsWith(FS_PREFIX)) {
        filePath = decodeURIComponent(fsPathFromId(url));
      } else {
        filePath = normalizePath$3(
          path$b.resolve(path$b.join(root, decodeURIComponent(url)))
        );
      }
      if (isDev) {
        const servingAccessResult = checkLoadingAccess(server.config, filePath);
        if (servingAccessResult === "denied") {
          return respondWithAccessDenied(filePath, server, res);
        }
        if (servingAccessResult === "fallback") {
          return next();
        }
      } else {
        if (!isParentDirectory(root, filePath)) {
          return next();
        }
      }
      if (fs__default.existsSync(filePath)) {
        const headers = isDev ? server.config.server.headers : server.config.preview.headers;
        try {
          let html = await fsp.readFile(filePath, "utf-8");
          if (isDev) {
            html = await server.transformIndexHtml(url, html, req.originalUrl);
          }
          return send$1(req, res, html, "html", { headers });
        } catch (e) {
          return next(e);
        }
      }
    }
    next();
  };
}
function preTransformRequest(server, decodedUrl, decodedBase) {
  if (!server.config.server.preTransformRequests) return;
  decodedUrl = unwrapId$1(stripBase(decodedUrl, decodedBase));
  server.warmupRequest(decodedUrl);
}

const logTime = createDebugger("vite:time");
function timeMiddleware(root) {
  return function viteTimeMiddleware(req, res, next) {
    const start = performance$1.now();
    const end = res.end;
    res.end = (...args) => {
      logTime?.(`${timeFrom(start)} ${prettifyUrl(req.url, root)}`);
      return end.call(res, ...args);
    };
    next();
  };
}

const EMPTY_OBJECT$1 = Object.freeze({});
class ModuleNode {
  _moduleGraph;
  _clientModule;
  _ssrModule;
  constructor(moduleGraph, clientModule, ssrModule) {
    this._moduleGraph = moduleGraph;
    this._clientModule = clientModule;
    this._ssrModule = ssrModule;
  }
  _get(prop) {
    return this._clientModule?.[prop] ?? this._ssrModule?.[prop];
  }
  _set(prop, value) {
    if (this._clientModule) {
      this._clientModule[prop] = value;
    }
    if (this._ssrModule) {
      this._ssrModule[prop] = value;
    }
  }
  _wrapModuleSet(prop, module) {
    if (!module) {
      return /* @__PURE__ */ new Set();
    }
    return createBackwardCompatibleModuleSet(this._moduleGraph, prop, module);
  }
  _getModuleSetUnion(prop) {
    const importedModules = /* @__PURE__ */ new Set();
    const ids = /* @__PURE__ */ new Set();
    if (this._clientModule) {
      for (const mod of this._clientModule[prop]) {
        if (mod.id) ids.add(mod.id);
        importedModules.add(
          this._moduleGraph.getBackwardCompatibleModuleNode(mod)
        );
      }
    }
    if (this._ssrModule) {
      for (const mod of this._ssrModule[prop]) {
        if (mod.id && !ids.has(mod.id)) {
          importedModules.add(
            this._moduleGraph.getBackwardCompatibleModuleNode(mod)
          );
        }
      }
    }
    return importedModules;
  }
  _getModuleInfoUnion(prop) {
    const _clientValue = this._clientModule?.[prop];
    const _ssrValue = this._ssrModule?.[prop];
    if (_clientValue == null && _ssrValue == null) return void 0;
    return new Proxy({}, {
      get: (_, key) => {
        if (key === "meta") {
          return this.meta || EMPTY_OBJECT$1;
        }
        if (_clientValue) {
          if (key in _clientValue) {
            return _clientValue[key];
          }
        }
        if (_ssrValue) {
          if (key in _ssrValue) {
            return _ssrValue[key];
          }
        }
      }
    });
  }
  _getModuleObjectUnion(prop) {
    const _clientValue = this._clientModule?.[prop];
    const _ssrValue = this._ssrModule?.[prop];
    if (_clientValue == null && _ssrValue == null) return void 0;
    const info = {};
    if (_ssrValue) {
      Object.assign(info, _ssrValue);
    }
    if (_clientValue) {
      Object.assign(info, _clientValue);
    }
    return info;
  }
  get url() {
    return this._get("url");
  }
  set url(value) {
    this._set("url", value);
  }
  get id() {
    return this._get("id");
  }
  set id(value) {
    this._set("id", value);
  }
  get file() {
    return this._get("file");
  }
  set file(value) {
    this._set("file", value);
  }
  get type() {
    return this._get("type");
  }
  // `info` needs special care as it's defined as a proxy in `pluginContainer`,
  // so we also merge it as a proxy too
  get info() {
    return this._getModuleInfoUnion("info");
  }
  get meta() {
    return this._getModuleObjectUnion("meta");
  }
  get importers() {
    return this._getModuleSetUnion("importers");
  }
  get clientImportedModules() {
    return this._wrapModuleSet("importedModules", this._clientModule);
  }
  get ssrImportedModules() {
    return this._wrapModuleSet("importedModules", this._ssrModule);
  }
  get importedModules() {
    return this._getModuleSetUnion("importedModules");
  }
  get acceptedHmrDeps() {
    return this._wrapModuleSet("acceptedHmrDeps", this._clientModule);
  }
  get acceptedHmrExports() {
    return this._clientModule?.acceptedHmrExports ?? null;
  }
  get importedBindings() {
    return this._clientModule?.importedBindings ?? null;
  }
  get isSelfAccepting() {
    return this._clientModule?.isSelfAccepting;
  }
  get transformResult() {
    return this._clientModule?.transformResult ?? null;
  }
  set transformResult(value) {
    if (this._clientModule) {
      this._clientModule.transformResult = value;
    }
  }
  get ssrTransformResult() {
    return this._ssrModule?.transformResult ?? null;
  }
  set ssrTransformResult(value) {
    if (this._ssrModule) {
      this._ssrModule.transformResult = value;
    }
  }
  get ssrModule() {
    return this._ssrModule?.ssrModule ?? null;
  }
  get ssrError() {
    return this._ssrModule?.ssrError ?? null;
  }
  get lastHMRTimestamp() {
    return Math.max(
      this._clientModule?.lastHMRTimestamp ?? 0,
      this._ssrModule?.lastHMRTimestamp ?? 0
    );
  }
  set lastHMRTimestamp(value) {
    if (this._clientModule) {
      this._clientModule.lastHMRTimestamp = value;
    }
    if (this._ssrModule) {
      this._ssrModule.lastHMRTimestamp = value;
    }
  }
  get lastInvalidationTimestamp() {
    return Math.max(
      this._clientModule?.lastInvalidationTimestamp ?? 0,
      this._ssrModule?.lastInvalidationTimestamp ?? 0
    );
  }
  get invalidationState() {
    return this._clientModule?.invalidationState;
  }
  get ssrInvalidationState() {
    return this._ssrModule?.invalidationState;
  }
}
function mapIterator(iterable, transform) {
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      const r = iterable.next();
      return r.done ? r : {
        value: transform(r.value),
        done: false
      };
    }
  };
}
class ModuleGraph {
  /** @internal */
  _moduleGraphs;
  /** @internal */
  get _client() {
    return this._moduleGraphs.client();
  }
  /** @internal */
  get _ssr() {
    return this._moduleGraphs.ssr();
  }
  urlToModuleMap;
  idToModuleMap;
  etagToModuleMap;
  fileToModulesMap;
  moduleNodeCache = new DualWeakMap();
  constructor(moduleGraphs) {
    this._moduleGraphs = moduleGraphs;
    const getModuleMapUnion = (prop) => () => {
      if (this._ssr[prop].size === 0) {
        return this._client[prop];
      }
      const map = new Map(this._client[prop]);
      for (const [key, module] of this._ssr[prop]) {
        if (!map.has(key)) {
          map.set(key, module);
        }
      }
      return map;
    };
    this.urlToModuleMap = createBackwardCompatibleModuleMap(
      this,
      "urlToModuleMap",
      getModuleMapUnion("urlToModuleMap")
    );
    this.idToModuleMap = createBackwardCompatibleModuleMap(
      this,
      "idToModuleMap",
      getModuleMapUnion("idToModuleMap")
    );
    this.etagToModuleMap = createBackwardCompatibleModuleMap(
      this,
      "etagToModuleMap",
      () => this._client.etagToModuleMap
    );
    this.fileToModulesMap = createBackwardCompatibleFileToModulesMap(this);
  }
  getModuleById(id) {
    const clientModule = this._client.getModuleById(id);
    const ssrModule = this._ssr.getModuleById(id);
    if (!clientModule && !ssrModule) {
      return;
    }
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
  }
  async getModuleByUrl(url, _ssr) {
    const [clientModule, ssrModule] = await Promise.all([
      this._client.getModuleByUrl(url),
      this._ssr.getModuleByUrl(url)
    ]);
    if (!clientModule && !ssrModule) {
      return;
    }
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
  }
  getModulesByFile(file) {
    const clientModules = this._client.getModulesByFile(file);
    const ssrModules = this._ssr.getModulesByFile(file);
    if (!clientModules && !ssrModules) {
      return void 0;
    }
    const result = /* @__PURE__ */ new Set();
    if (clientModules) {
      for (const mod of clientModules) {
        result.add(this.getBackwardCompatibleBrowserModuleNode(mod));
      }
    }
    if (ssrModules) {
      for (const mod of ssrModules) {
        if (mod.id == null || !this._client.getModuleById(mod.id)) {
          result.add(this.getBackwardCompatibleServerModuleNode(mod));
        }
      }
    }
    return result;
  }
  onFileChange(file) {
    this._client.onFileChange(file);
    this._ssr.onFileChange(file);
  }
  onFileDelete(file) {
    this._client.onFileDelete(file);
    this._ssr.onFileDelete(file);
  }
  /** @internal */
  _getModuleGraph(environment) {
    switch (environment) {
      case "client":
        return this._client;
      case "ssr":
        return this._ssr;
      default:
        throw new Error(`Invalid module node environment ${environment}`);
    }
  }
  invalidateModule(mod, seen = /* @__PURE__ */ new Set(), timestamp = Date.now(), isHmr = false, softInvalidate = false) {
    if (mod._clientModule) {
      this._client.invalidateModule(
        mod._clientModule,
        new Set(
          [...seen].map((mod2) => mod2._clientModule).filter(Boolean)
        ),
        timestamp,
        isHmr,
        softInvalidate
      );
    }
    if (mod._ssrModule) {
      this._ssr.invalidateModule(
        mod._ssrModule,
        new Set(
          [...seen].map((mod2) => mod2._ssrModule).filter(Boolean)
        ),
        timestamp,
        isHmr,
        softInvalidate
      );
    }
  }
  invalidateAll() {
    this._client.invalidateAll();
    this._ssr.invalidateAll();
  }
  /* TODO: It seems there isn't usage of this method in the ecosystem
     Waiting to check if we really need this for backwards compatibility
  async updateModuleInfo(
    module: ModuleNode,
    importedModules: Set<string | ModuleNode>,
    importedBindings: Map<string, Set<string>> | null,
    acceptedModules: Set<string | ModuleNode>,
    acceptedExports: Set<string> | null,
    isSelfAccepting: boolean,
    ssr?: boolean,
    staticImportedUrls?: Set<string>, // internal
  ): Promise<Set<ModuleNode> | undefined> {
    // Not implemented
  }
  */
  async ensureEntryFromUrl(rawUrl, ssr, setIsSelfAccepting = true) {
    const module = await (ssr ? this._ssr : this._client).ensureEntryFromUrl(
      rawUrl,
      setIsSelfAccepting
    );
    return this.getBackwardCompatibleModuleNode(module);
  }
  createFileOnlyEntry(file) {
    const clientModule = this._client.createFileOnlyEntry(file);
    const ssrModule = this._ssr.createFileOnlyEntry(file);
    return this.getBackwardCompatibleModuleNodeDual(clientModule, ssrModule);
  }
  async resolveUrl(url, ssr) {
    return ssr ? this._ssr.resolveUrl(url) : this._client.resolveUrl(url);
  }
  updateModuleTransformResult(mod, result, ssr) {
    const environment = ssr ? "ssr" : "client";
    this._getModuleGraph(environment).updateModuleTransformResult(
      environment === "client" ? mod._clientModule : mod._ssrModule,
      result
    );
  }
  getModuleByEtag(etag) {
    const mod = this._client.etagToModuleMap.get(etag);
    return mod && this.getBackwardCompatibleBrowserModuleNode(mod);
  }
  getBackwardCompatibleBrowserModuleNode(clientModule) {
    return this.getBackwardCompatibleModuleNodeDual(
      clientModule,
      clientModule.id ? this._ssr.getModuleById(clientModule.id) : void 0
    );
  }
  getBackwardCompatibleServerModuleNode(ssrModule) {
    return this.getBackwardCompatibleModuleNodeDual(
      ssrModule.id ? this._client.getModuleById(ssrModule.id) : void 0,
      ssrModule
    );
  }
  getBackwardCompatibleModuleNode(mod) {
    return mod.environment === "client" ? this.getBackwardCompatibleBrowserModuleNode(mod) : this.getBackwardCompatibleServerModuleNode(mod);
  }
  getBackwardCompatibleModuleNodeDual(clientModule, ssrModule) {
    const cached = this.moduleNodeCache.get(clientModule, ssrModule);
    if (cached) {
      return cached;
    }
    const moduleNode = new ModuleNode(this, clientModule, ssrModule);
    this.moduleNodeCache.set(clientModule, ssrModule, moduleNode);
    return moduleNode;
  }
}
class DualWeakMap {
  map = /* @__PURE__ */ new WeakMap();
  undefinedKey = {};
  get(key1, key2) {
    const k1 = key1 ?? this.undefinedKey;
    const k2 = key2 ?? this.undefinedKey;
    return this.map.get(k1)?.get(k2);
  }
  set(key1, key2, value) {
    const k1 = key1 ?? this.undefinedKey;
    const k2 = key2 ?? this.undefinedKey;
    if (!this.map.has(k1)) {
      this.map.set(k1, /* @__PURE__ */ new Map());
    }
    const m = this.map.get(k1);
    m.set(k2, value);
  }
}
function createBackwardCompatibleModuleSet(moduleGraph, prop, module) {
  return {
    [Symbol.iterator]() {
      return this.keys();
    },
    has(key) {
      if (!key.id) {
        return false;
      }
      const keyModule = moduleGraph._getModuleGraph(module.environment).getModuleById(key.id);
      return keyModule !== void 0 && module[prop].has(keyModule);
    },
    values() {
      return this.keys();
    },
    keys() {
      return mapIterator(
        module[prop].keys(),
        (mod) => moduleGraph.getBackwardCompatibleModuleNode(mod)
      );
    },
    get size() {
      return module[prop].size;
    },
    forEach(callback, thisArg) {
      return module[prop].forEach((mod) => {
        const backwardCompatibleMod = moduleGraph.getBackwardCompatibleModuleNode(mod);
        callback.call(
          thisArg,
          backwardCompatibleMod,
          backwardCompatibleMod,
          this
        );
      });
    }
    // There are several methods missing. We can implement them if downstream
    // projects are relying on them: add, clear, delete, difference, intersection,
    // sDisjointFrom, isSubsetOf, isSupersetOf, symmetricDifference, union
  };
}
function createBackwardCompatibleModuleMap(moduleGraph, prop, getModuleMap) {
  return {
    [Symbol.iterator]() {
      return this.entries();
    },
    get(key) {
      const clientModule = moduleGraph._client[prop].get(key);
      const ssrModule = moduleGraph._ssr[prop].get(key);
      if (!clientModule && !ssrModule) {
        return;
      }
      return moduleGraph.getBackwardCompatibleModuleNodeDual(
        clientModule,
        ssrModule
      );
    },
    set(key, mod) {
      const clientModule = mod._clientModule;
      if (clientModule) {
        moduleGraph._client[prop].set(key, clientModule);
      }
      const ssrModule = mod._ssrModule;
      if (ssrModule) {
        moduleGraph._ssr[prop].set(key, ssrModule);
      }
    },
    keys() {
      return getModuleMap().keys();
    },
    values() {
      return mapIterator(
        getModuleMap().values(),
        (mod) => moduleGraph.getBackwardCompatibleModuleNode(mod)
      );
    },
    entries() {
      return mapIterator(getModuleMap().entries(), ([key, mod]) => [
        key,
        moduleGraph.getBackwardCompatibleModuleNode(mod)
      ]);
    },
    get size() {
      return getModuleMap().size;
    },
    forEach(callback, thisArg) {
      return getModuleMap().forEach((mod, key) => {
        const backwardCompatibleMod = moduleGraph.getBackwardCompatibleModuleNode(mod);
        callback.call(thisArg, backwardCompatibleMod, key, this);
      });
    }
  };
}
function createBackwardCompatibleFileToModulesMap(moduleGraph) {
  const getFileToModulesMap = () => {
    if (!moduleGraph._ssr.fileToModulesMap.size) {
      return moduleGraph._client.fileToModulesMap;
    }
    const map = new Map(moduleGraph._client.fileToModulesMap);
    for (const [key, modules] of moduleGraph._ssr.fileToModulesMap) {
      const modulesSet = map.get(key);
      if (!modulesSet) {
        map.set(key, modules);
      } else {
        for (const ssrModule of modules) {
          let hasModule = false;
          for (const clientModule of modulesSet) {
            hasModule ||= clientModule.id === ssrModule.id;
            if (hasModule) {
              break;
            }
          }
          if (!hasModule) {
            modulesSet.add(ssrModule);
          }
        }
      }
    }
    return map;
  };
  const getBackwardCompatibleModules = (modules) => new Set(
    [...modules].map(
      (mod) => moduleGraph.getBackwardCompatibleModuleNode(mod)
    )
  );
  return {
    [Symbol.iterator]() {
      return this.entries();
    },
    get(key) {
      const clientModules = moduleGraph._client.fileToModulesMap.get(key);
      const ssrModules = moduleGraph._ssr.fileToModulesMap.get(key);
      if (!clientModules && !ssrModules) {
        return;
      }
      const modules = clientModules ?? /* @__PURE__ */ new Set();
      if (ssrModules) {
        for (const ssrModule of ssrModules) {
          if (ssrModule.id) {
            let found = false;
            for (const mod of modules) {
              found ||= mod.id === ssrModule.id;
              if (found) {
                break;
              }
            }
            if (!found) {
              modules.add(ssrModule);
            }
          }
        }
      }
      return getBackwardCompatibleModules(modules);
    },
    keys() {
      return getFileToModulesMap().keys();
    },
    values() {
      return mapIterator(
        getFileToModulesMap().values(),
        getBackwardCompatibleModules
      );
    },
    entries() {
      return mapIterator(getFileToModulesMap().entries(), ([key, modules]) => [
        key,
        getBackwardCompatibleModules(modules)
      ]);
    },
    get size() {
      return getFileToModulesMap().size;
    },
    forEach(callback, thisArg) {
      return getFileToModulesMap().forEach((modules, key) => {
        callback.call(thisArg, getBackwardCompatibleModules(modules), key, this);
      });
    }
  };
}

function notFoundMiddleware() {
  return function vite404Middleware(_, res) {
    res.statusCode = 404;
    res.end();
  };
}

const ROOT_FILES = [
  // '.git',
  // https://pnpm.io/workspaces/
  "pnpm-workspace.yaml",
  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',
  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json',
  // https://github.com/lerna/lerna#lernajson
  "lerna.json"
];
function hasWorkspacePackageJSON(root) {
  const path = join$1(root, "package.json");
  if (!isFileReadable(path)) {
    return false;
  }
  try {
    const content = JSON.parse(fs__default.readFileSync(path, "utf-8")) || {};
    return !!content.workspaces;
  } catch {
    return false;
  }
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => fs__default.existsSync(join$1(root, file)));
}
function hasPackageJSON(root) {
  const path = join$1(root, "package.json");
  return fs__default.existsSync(path);
}
function searchForPackageRoot(current, root = current) {
  if (hasPackageJSON(current)) return current;
  const dir = dirname$2(current);
  if (!dir || dir === current) return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
  if (hasRootFile(current)) return current;
  if (hasWorkspacePackageJSON(current)) return current;
  const dir = dirname$2(current);
  if (!dir || dir === current) return root;
  return searchForWorkspaceRoot(dir, root);
}

function rejectInvalidRequestMiddleware() {
  return function viteRejectInvalidRequestMiddleware(req, res, next) {
    if (req.url?.includes("#")) {
      res.writeHead(400);
      res.end();
      return;
    }
    return next();
  };
}

function createServer(inlineConfig = {}) {
  return _createServer(inlineConfig, { listen: true });
}
async function _createServer(inlineConfig = {}, options) {
  const config = await resolveConfig(inlineConfig, "serve");
  const initPublicFilesPromise = initPublicFiles(config);
  const { root, server: serverConfig } = config;
  const httpsOptions = await resolveHttpsConfig(config.server.https);
  const { middlewareMode } = serverConfig;
  const resolvedOutDirs = getResolvedOutDirs(
    config.root,
    config.build.outDir,
    config.build.rollupOptions.output
  );
  const emptyOutDir = resolveEmptyOutDir(
    config.build.emptyOutDir,
    config.root,
    resolvedOutDirs
  );
  const resolvedWatchOptions = resolveChokidarOptions(
    {
      disableGlobbing: true,
      ...serverConfig.watch
    },
    resolvedOutDirs,
    emptyOutDir,
    config.cacheDir
  );
  const middlewares = connect$1();
  const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
  const ws = createWebSocketServer(httpServer, config, httpsOptions);
  const publicFiles = await initPublicFilesPromise;
  const { publicDir } = config;
  if (httpServer) {
    setClientErrorHandler(httpServer, config.logger);
  }
  const watchEnabled = serverConfig.watch !== null;
  const watcher = watchEnabled ? chokidar.watch(
    // config file dependencies and env file might be outside of root
    [
      root,
      ...config.configFileDependencies,
      ...getEnvFilesForMode(config.mode, config.envDir),
      // Watch the public directory explicitly because it might be outside
      // of the root directory.
      ...publicDir && publicFiles ? [publicDir] : []
    ],
    resolvedWatchOptions
  ) : createNoopWatcher(resolvedWatchOptions);
  const environments = {};
  for (const [name, environmentOptions] of Object.entries(
    config.environments
  )) {
    environments[name] = await environmentOptions.dev.createEnvironment(
      name,
      config,
      {
        ws
      }
    );
  }
  for (const environment of Object.values(environments)) {
    const previousInstance = options.previousEnvironments?.[environment.name];
    await environment.init({ watcher, previousInstance });
  }
  let moduleGraph = new ModuleGraph({
    client: () => environments.client.moduleGraph,
    ssr: () => environments.ssr.moduleGraph
  });
  const pluginContainer = createPluginContainer(environments);
  const closeHttpServer = createServerCloseFn(httpServer);
  const devHtmlTransformFn = createDevHtmlTransformFn(config);
  let closeServerPromise;
  const closeServer = async () => {
    if (!middlewareMode) {
      teardownSIGTERMListener(closeServerAndExit);
    }
    await Promise.allSettled([
      watcher.close(),
      ws.close(),
      Promise.allSettled(
        Object.values(server.environments).map(
          (environment) => environment.close()
        )
      ),
      closeHttpServer(),
      server._ssrCompatModuleRunner?.close()
    ]);
    server.resolvedUrls = null;
    server._ssrCompatModuleRunner = void 0;
  };
  let server = {
    config,
    middlewares,
    httpServer,
    watcher,
    ws,
    hot: createDeprecatedHotBroadcaster(ws),
    environments,
    pluginContainer,
    get moduleGraph() {
      warnFutureDeprecation(config, "removeServerModuleGraph");
      return moduleGraph;
    },
    set moduleGraph(graph) {
      moduleGraph = graph;
    },
    resolvedUrls: null,
    // will be set on listen
    ssrTransform(code, inMap, url, originalCode = code) {
      return ssrTransform(code, inMap, url, originalCode, {
        json: {
          stringify: config.json.stringify === true && config.json.namedExports !== true
        }
      });
    },
    // environment.transformRequest and .warmupRequest don't take an options param for now,
    // so the logic and error handling needs to be duplicated here.
    // The only param in options that could be important is `html`, but we may remove it as
    // that is part of the internal control flow for the vite dev server to be able to bail
    // out and do the html fallback
    transformRequest(url, options2) {
      warnFutureDeprecation(
        config,
        "removeServerTransformRequest",
        "server.transformRequest() is deprecated. Use environment.transformRequest() instead."
      );
      const environment = server.environments[options2?.ssr ? "ssr" : "client"];
      return transformRequest(environment, url, options2);
    },
    async warmupRequest(url, options2) {
      try {
        const environment = server.environments[options2?.ssr ? "ssr" : "client"];
        await transformRequest(environment, url, options2);
      } catch (e) {
        if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP || e?.code === ERR_CLOSED_SERVER) {
          return;
        }
        server.config.logger.error(
          buildErrorMessage(e, [`Pre-transform error: ${e.message}`], false),
          {
            error: e,
            timestamp: true
          }
        );
      }
    },
    transformIndexHtml(url, html, originalUrl) {
      return devHtmlTransformFn(server, url, html, originalUrl);
    },
    async ssrLoadModule(url, opts) {
      warnFutureDeprecation(config, "removeSsrLoadModule");
      return ssrLoadModule(url, server, opts?.fixStacktrace);
    },
    ssrFixStacktrace(e) {
      ssrFixStacktrace(e, server.environments.ssr.moduleGraph);
    },
    ssrRewriteStacktrace(stack) {
      return ssrRewriteStacktrace(stack, server.environments.ssr.moduleGraph);
    },
    async reloadModule(module) {
      if (serverConfig.hmr !== false && module.file) {
        const environmentModule = module._clientModule ?? module._ssrModule;
        updateModules(
          environments[environmentModule.environment],
          module.file,
          [environmentModule],
          Date.now()
        );
      }
    },
    async listen(port, isRestart) {
      await startServer(server, port);
      if (httpServer) {
        server.resolvedUrls = await resolveServerUrls(
          httpServer,
          config.server,
          httpsOptions,
          config
        );
        if (!isRestart && config.server.open) server.openBrowser();
      }
      return server;
    },
    openBrowser() {
      const options2 = server.config.server;
      const url = getServerUrlByHost(server.resolvedUrls, options2.host);
      if (url) {
        const path2 = typeof options2.open === "string" ? new URL(options2.open, url).href : url;
        if (server.config.server.preTransformRequests) {
          setTimeout(() => {
            const getMethod = path2.startsWith("https:") ? get$1 : get$2;
            getMethod(
              path2,
              {
                headers: {
                  // Allow the history middleware to redirect to /index.html
                  Accept: "text/html"
                }
              },
              (res) => {
                res.on("end", () => {
                });
              }
            ).on("error", () => {
            }).end();
          }, 0);
        }
        openBrowser(path2, true, server.config.logger);
      } else {
        server.config.logger.warn("No URL available to open in browser");
      }
    },
    async close() {
      if (!closeServerPromise) {
        closeServerPromise = closeServer();
      }
      return closeServerPromise;
    },
    printUrls() {
      if (server.resolvedUrls) {
        printServerUrls(
          server.resolvedUrls,
          serverConfig.host,
          config.logger.info
        );
      } else if (middlewareMode) {
        throw new Error("cannot print server URLs in middleware mode.");
      } else {
        throw new Error(
          "cannot print server URLs before server.listen is called."
        );
      }
    },
    bindCLIShortcuts(options2) {
      bindCLIShortcuts(server, options2);
    },
    async restart(forceOptimize) {
      if (!server._restartPromise) {
        server._forceOptimizeOnRestart = !!forceOptimize;
        server._restartPromise = restartServer(server).finally(() => {
          server._restartPromise = null;
          server._forceOptimizeOnRestart = false;
        });
      }
      return server._restartPromise;
    },
    waitForRequestsIdle(ignoredId) {
      return environments.client.waitForRequestsIdle(ignoredId);
    },
    _setInternalServer(_server) {
      server = _server;
    },
    _importGlobMap: /* @__PURE__ */ new Map(),
    _restartPromise: null,
    _forceOptimizeOnRestart: false,
    _shortcutsOptions: void 0
  };
  const reflexServer = new Proxy(server, {
    get: (_, property) => {
      return server[property];
    },
    set: (_, property, value) => {
      server[property] = value;
      return true;
    }
  });
  const closeServerAndExit = async (_, exitCode) => {
    try {
      await server.close();
    } finally {
      process.exitCode ??= exitCode ? 128 + exitCode : void 0;
      process.exit();
    }
  };
  if (!middlewareMode) {
    setupSIGTERMListener(closeServerAndExit);
  }
  const onHMRUpdate = async (type, file) => {
    if (serverConfig.hmr !== false) {
      await handleHMRUpdate(type, file, server);
    }
  };
  const onFileAddUnlink = async (file, isUnlink) => {
    file = normalizePath$3(file);
    reloadOnTsconfigChange(server, file);
    await pluginContainer.watchChange(file, {
      event: isUnlink ? "delete" : "create"
    });
    if (publicDir && publicFiles) {
      if (file.startsWith(publicDir)) {
        const path2 = file.slice(publicDir.length);
        publicFiles[isUnlink ? "delete" : "add"](path2);
        if (!isUnlink) {
          const clientModuleGraph = server.environments.client.moduleGraph;
          const moduleWithSamePath = await clientModuleGraph.getModuleByUrl(path2);
          const etag = moduleWithSamePath?.transformResult?.etag;
          if (etag) {
            clientModuleGraph.etagToModuleMap.delete(etag);
          }
        }
      }
    }
    if (isUnlink) {
      for (const environment of Object.values(server.environments)) {
        environment.moduleGraph.onFileDelete(file);
      }
    }
    await onHMRUpdate(isUnlink ? "delete" : "create", file);
  };
  watcher.on("change", async (file) => {
    file = normalizePath$3(file);
    reloadOnTsconfigChange(server, file);
    await pluginContainer.watchChange(file, { event: "update" });
    for (const environment of Object.values(server.environments)) {
      environment.moduleGraph.onFileChange(file);
    }
    await onHMRUpdate("update", file);
  });
  watcher.on("add", (file) => {
    onFileAddUnlink(file, false);
  });
  watcher.on("unlink", (file) => {
    onFileAddUnlink(file, true);
  });
  if (!middlewareMode && httpServer) {
    httpServer.once("listening", () => {
      serverConfig.port = httpServer.address().port;
    });
  }
  const postHooks = [];
  for (const hook of config.getSortedPluginHooks("configureServer")) {
    postHooks.push(await hook(reflexServer));
  }
  if (process.env.DEBUG) {
    middlewares.use(timeMiddleware(root));
  }
  middlewares.use(rejectInvalidRequestMiddleware());
  const { cors } = serverConfig;
  if (cors !== false) {
    middlewares.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
  }
  const { allowedHosts } = serverConfig;
  if (allowedHosts !== true && !serverConfig.https) {
    middlewares.use(hostCheckMiddleware(config, false));
  }
  middlewares.use(cachedTransformMiddleware(server));
  const { proxy } = serverConfig;
  if (proxy) {
    const middlewareServer = (isObject$1(middlewareMode) ? middlewareMode.server : null) || httpServer;
    middlewares.use(proxyMiddleware(middlewareServer, proxy, config));
  }
  if (config.base !== "/") {
    middlewares.use(baseMiddleware(config.rawBase, !!middlewareMode));
  }
  middlewares.use("/__open-in-editor", launchEditorMiddleware$1());
  middlewares.use(function viteHMRPingMiddleware(req, res, next) {
    if (req.headers["accept"] === "text/x-vite-ping") {
      res.writeHead(204).end();
    } else {
      next();
    }
  });
  if (publicDir) {
    middlewares.use(servePublicMiddleware(server, publicFiles));
  }
  middlewares.use(transformMiddleware(server));
  middlewares.use(serveRawFsMiddleware(server));
  middlewares.use(serveStaticMiddleware(server));
  if (config.appType === "spa" || config.appType === "mpa") {
    middlewares.use(htmlFallbackMiddleware(root, config.appType === "spa"));
  }
  postHooks.forEach((fn) => fn && fn());
  if (config.appType === "spa" || config.appType === "mpa") {
    middlewares.use(indexHtmlMiddleware(root, server));
    middlewares.use(notFoundMiddleware());
  }
  middlewares.use(errorMiddleware(server, !!middlewareMode));
  let initingServer;
  let serverInited = false;
  const initServer = async (onListen) => {
    if (serverInited) return;
    if (initingServer) return initingServer;
    initingServer = async function() {
      await environments.client.pluginContainer.buildStart();
      if (onListen || options.listen) {
        await Promise.all(
          Object.values(environments).map((e) => e.listen(server))
        );
      }
      initingServer = void 0;
      serverInited = true;
    }();
    return initingServer;
  };
  if (!middlewareMode && httpServer) {
    const listen = httpServer.listen.bind(httpServer);
    httpServer.listen = async (port, ...args) => {
      try {
        await initServer(true);
      } catch (e) {
        httpServer.emit("error", e);
        return;
      }
      return listen(port, ...args);
    };
  } else {
    await initServer(false);
  }
  return server;
}
async function startServer(server, inlinePort) {
  const httpServer = server.httpServer;
  if (!httpServer) {
    throw new Error("Cannot call server.listen in middleware mode.");
  }
  const options = server.config.server;
  const hostname = await resolveHostname(options.host);
  const configPort = inlinePort ?? options.port;
  const port = (!configPort || configPort === server._configServerPort ? server._currentServerPort : configPort) ?? DEFAULT_DEV_PORT;
  server._configServerPort = configPort;
  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options.strictPort,
    host: hostname.host,
    logger: server.config.logger
  });
  server._currentServerPort = serverPort;
}
function createServerCloseFn(server) {
  if (!server) {
    return () => Promise.resolve();
  }
  let hasListened = false;
  const openSockets = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    openSockets.add(socket);
    socket.on("close", () => {
      openSockets.delete(socket);
    });
  });
  server.once("listening", () => {
    hasListened = true;
  });
  return () => new Promise((resolve, reject) => {
    openSockets.forEach((s) => s.destroy());
    if (hasListened) {
      server.close((err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    } else {
      resolve();
    }
  });
}
function resolvedAllowDir(root, dir) {
  return normalizePath$3(path$b.resolve(root, dir));
}
const serverConfigDefaults = Object.freeze({
  port: DEFAULT_DEV_PORT,
  strictPort: false,
  host: "localhost",
  allowedHosts: [],
  https: void 0,
  open: false,
  proxy: void 0,
  cors: { origin: defaultAllowedOrigins },
  headers: {},
  // hmr
  // ws
  warmup: {
    clientFiles: [],
    ssrFiles: []
  },
  // watch
  middlewareMode: false,
  fs: {
    strict: true,
    // allow
    deny: [".env", ".env.*", "*.{crt,pem}", "**/.git/**"]
  },
  // origin
  preTransformRequests: true,
  // sourcemapIgnoreList
  perEnvironmentStartEndDuringDev: false
  // hotUpdateEnvironments
});
function resolveServerOptions(root, raw, logger) {
  const _server = mergeWithDefaults(
    {
      ...serverConfigDefaults,
      host: void 0,
      // do not set here to detect whether host is set or not
      sourcemapIgnoreList: isInNodeModules$1
    },
    raw ?? {}
  );
  const server = {
    ..._server,
    fs: {
      ..._server.fs,
      // run searchForWorkspaceRoot only if needed
      allow: raw?.fs?.allow ?? [searchForWorkspaceRoot(root)]
    },
    sourcemapIgnoreList: _server.sourcemapIgnoreList === false ? () => false : _server.sourcemapIgnoreList
  };
  let allowDirs = server.fs.allow;
  if (process.versions.pnp) {
    const cwd = searchForPackageRoot(root);
    try {
      const enableGlobalCache = execSync("yarn config get enableGlobalCache", { cwd }).toString().trim() === "true";
      const yarnCacheDir = execSync(
        `yarn config get ${enableGlobalCache ? "globalFolder" : "cacheFolder"}`,
        { cwd }
      ).toString().trim();
      allowDirs.push(yarnCacheDir);
    } catch (e) {
      logger.warn(`Get yarn cache dir error: ${e.message}`, {
        timestamp: true
      });
    }
  }
  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i));
  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR);
  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
    allowDirs.push(resolvedClientDir);
  }
  server.fs.allow = allowDirs;
  if (server.origin?.endsWith("/")) {
    server.origin = server.origin.slice(0, -1);
    logger.warn(
      colors$1.yellow(
        `${colors$1.bold("(!)")} server.origin should not end with "/". Using "${server.origin}" instead.`
      )
    );
  }
  if (process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS && Array.isArray(server.allowedHosts)) {
    const additionalHost = process.env.__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS;
    server.allowedHosts = [...server.allowedHosts, additionalHost];
  }
  return server;
}
async function restartServer(server) {
  global.__vite_start_time = performance$1.now();
  const shortcutsOptions = server._shortcutsOptions;
  let inlineConfig = server.config.inlineConfig;
  if (server._forceOptimizeOnRestart) {
    inlineConfig = mergeConfig(inlineConfig, {
      forceOptimizeDeps: true
    });
  }
  {
    let newServer = null;
    try {
      newServer = await _createServer(inlineConfig, {
        listen: false,
        previousEnvironments: server.environments
      });
    } catch (err) {
      server.config.logger.error(err.message, {
        timestamp: true
      });
      server.config.logger.error("server restart failed", { timestamp: true });
      return;
    }
    await server.close();
    const middlewares = server.middlewares;
    newServer._configServerPort = server._configServerPort;
    newServer._currentServerPort = server._currentServerPort;
    Object.assign(server, newServer);
    middlewares.stack = newServer.middlewares.stack;
    server.middlewares = middlewares;
    newServer._setInternalServer(server);
  }
  const {
    logger,
    server: { port, middlewareMode }
  } = server.config;
  if (!middlewareMode) {
    await server.listen(port, true);
  } else {
    await Promise.all(
      Object.values(server.environments).map((e) => e.listen(server))
    );
  }
  logger.info("server restarted.", { timestamp: true });
  if (shortcutsOptions) {
    shortcutsOptions.print = false;
    bindCLIShortcuts(server, shortcutsOptions);
  }
}
async function restartServerWithUrls(server) {
  if (server.config.server.middlewareMode) {
    await server.restart();
    return;
  }
  const { port: prevPort, host: prevHost } = server.config.server;
  const prevUrls = server.resolvedUrls;
  await server.restart();
  const {
    logger,
    server: { port, host }
  } = server.config;
  if ((port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) || host !== prevHost || diffDnsOrderChange(prevUrls, server.resolvedUrls)) {
    logger.info("");
    server.printUrls();
  }
}

var index = {
	__proto__: null,
	_createServer: _createServer,
	createServer: createServer,
	createServerCloseFn: createServerCloseFn,
	resolveServerOptions: resolveServerOptions,
	restartServerWithUrls: restartServerWithUrls,
	serverConfigDefaults: serverConfigDefaults
};

const debugHmr = createDebugger("vite:hmr");
const whitespaceRE = /\s/;
const normalizedClientDir = normalizePath$3(CLIENT_DIR);
function getShortName(file, root) {
  return file.startsWith(withTrailingSlash(root)) ? path$b.posix.relative(root, file) : file;
}
const normalizeHotChannel = (channel, enableHmr, normalizeClient = true) => {
  const normalizedListenerMap = /* @__PURE__ */ new WeakMap();
  const listenersForEvents = /* @__PURE__ */ new Map();
  let invokeHandlers;
  let listenerForInvokeHandler;
  const handleInvoke = async (payload) => {
    if (!invokeHandlers) {
      return {
        error: {
          name: "TransportError",
          message: "invokeHandlers is not set",
          stack: new Error().stack
        }
      };
    }
    const data = payload.data;
    const { name, data: args } = data;
    try {
      const invokeHandler = invokeHandlers[name];
      const result = await invokeHandler(...args);
      return { result };
    } catch (error2) {
      return {
        error: {
          name: error2.name,
          message: error2.message,
          stack: error2.stack,
          ...error2
          // preserve enumerable properties such as RollupError.loc, frame, plugin
        }
      };
    }
  };
  return {
    ...channel,
    on: (event, fn) => {
      if (event === "connection" || !normalizeClient) {
        channel.on?.(event, fn);
        return;
      }
      const listenerWithNormalizedClient = (data, client) => {
        const normalizedClient = {
          send: (...args) => {
            let payload;
            if (typeof args[0] === "string") {
              payload = {
                type: "custom",
                event: args[0],
                data: args[1]
              };
            } else {
              payload = args[0];
            }
            client.send(payload);
          }
        };
        fn(data, normalizedClient);
      };
      normalizedListenerMap.set(fn, listenerWithNormalizedClient);
      channel.on?.(event, listenerWithNormalizedClient);
      if (!listenersForEvents.has(event)) {
        listenersForEvents.set(event, /* @__PURE__ */ new Set());
      }
      listenersForEvents.get(event).add(listenerWithNormalizedClient);
    },
    off: (event, fn) => {
      if (event === "connection" || !normalizeClient) {
        channel.off?.(event, fn);
        return;
      }
      const normalizedListener = normalizedListenerMap.get(fn);
      if (normalizedListener) {
        channel.off?.(event, normalizedListener);
        listenersForEvents.get(event)?.delete(normalizedListener);
      }
    },
    setInvokeHandler(_invokeHandlers) {
      invokeHandlers = _invokeHandlers;
      if (!_invokeHandlers) {
        if (listenerForInvokeHandler) {
          channel.off?.("vite:invoke", listenerForInvokeHandler);
        }
        return;
      }
      listenerForInvokeHandler = async (payload, client) => {
        const responseInvoke = payload.id.replace("send", "response");
        client.send({
          type: "custom",
          event: "vite:invoke",
          data: {
            name: payload.name,
            id: responseInvoke,
            data: await handleInvoke({
              data: payload
            })
          }
        });
      };
      channel.on?.("vite:invoke", listenerForInvokeHandler);
    },
    handleInvoke,
    send: (...args) => {
      let payload;
      if (typeof args[0] === "string") {
        payload = {
          type: "custom",
          event: args[0],
          data: args[1]
        };
      } else {
        payload = args[0];
      }
      if (enableHmr || payload.type === "connected" || payload.type === "ping" || payload.type === "custom" || payload.type === "error") {
        channel.send?.(payload);
      }
    },
    listen() {
      return channel.listen?.();
    },
    close() {
      return channel.close?.();
    }
  };
};
function getSortedPluginsByHotUpdateHook(plugins) {
  const sortedPlugins = [];
  let pre = 0, normal = 0, post = 0;
  for (const plugin of plugins) {
    const hook = plugin["hotUpdate"] ?? plugin["handleHotUpdate"];
    if (hook) {
      if (typeof hook === "object") {
        if (hook.order === "pre") {
          sortedPlugins.splice(pre++, 0, plugin);
          continue;
        }
        if (hook.order === "post") {
          sortedPlugins.splice(pre + normal + post++, 0, plugin);
          continue;
        }
      }
      sortedPlugins.splice(pre + normal++, 0, plugin);
    }
  }
  return sortedPlugins;
}
const sortedHotUpdatePluginsCache = /* @__PURE__ */ new WeakMap();
function getSortedHotUpdatePlugins(environment) {
  let sortedPlugins = sortedHotUpdatePluginsCache.get(environment);
  if (!sortedPlugins) {
    sortedPlugins = getSortedPluginsByHotUpdateHook(environment.plugins);
    sortedHotUpdatePluginsCache.set(environment, sortedPlugins);
  }
  return sortedPlugins;
}
async function handleHMRUpdate(type, file, server) {
  const { config } = server;
  const mixedModuleGraph = ignoreDeprecationWarnings(() => server.moduleGraph);
  const environments = Object.values(server.environments);
  const shortFile = getShortName(file, config.root);
  const isConfig = file === config.configFile;
  const isConfigDependency = config.configFileDependencies.some(
    (name) => file === name
  );
  const isEnv = config.envDir !== false && getEnvFilesForMode(config.mode, config.envDir).includes(file);
  if (isConfig || isConfigDependency || isEnv) {
    debugHmr?.(`[config change] ${colors$1.dim(shortFile)}`);
    config.logger.info(
      colors$1.green(
        `${normalizePath$3(
          path$b.relative(process.cwd(), file)
        )} changed, restarting server...`
      ),
      { clear: true, timestamp: true }
    );
    try {
      await restartServerWithUrls(server);
    } catch (e) {
      config.logger.error(colors$1.red(e));
    }
    return;
  }
  debugHmr?.(`[file change] ${colors$1.dim(shortFile)}`);
  if (file.startsWith(withTrailingSlash(normalizedClientDir))) {
    environments.forEach(
      ({ hot }) => hot.send({
        type: "full-reload",
        path: "*",
        triggeredBy: path$b.resolve(config.root, file)
      })
    );
    return;
  }
  const timestamp = Date.now();
  const contextMeta = {
    type,
    file,
    timestamp,
    read: () => readModifiedFile(file),
    server
  };
  const hotMap = /* @__PURE__ */ new Map();
  for (const environment of Object.values(server.environments)) {
    const mods = new Set(environment.moduleGraph.getModulesByFile(file));
    if (type === "create") {
      for (const mod of environment.moduleGraph._hasResolveFailedErrorModules) {
        mods.add(mod);
      }
    }
    const options = {
      ...contextMeta,
      modules: [...mods],
      // later on hotUpdate will be called for each runtime with a new HotUpdateOptions
      environment
    };
    hotMap.set(environment, { options });
  }
  const mixedMods = new Set(mixedModuleGraph.getModulesByFile(file));
  const mixedHmrContext = {
    ...contextMeta,
    modules: [...mixedMods]
  };
  const clientEnvironment = server.environments.client;
  const ssrEnvironment = server.environments.ssr;
  const clientContext = { environment: clientEnvironment };
  const clientHotUpdateOptions = hotMap.get(clientEnvironment).options;
  const ssrHotUpdateOptions = hotMap.get(ssrEnvironment)?.options;
  try {
    for (const plugin of getSortedHotUpdatePlugins(
      server.environments.client
    )) {
      if (plugin.hotUpdate) {
        const filteredModules = await getHookHandler(plugin.hotUpdate).call(
          clientContext,
          clientHotUpdateOptions
        );
        if (filteredModules) {
          clientHotUpdateOptions.modules = filteredModules;
          mixedHmrContext.modules = mixedHmrContext.modules.filter(
            (mixedMod) => filteredModules.some((mod) => mixedMod.id === mod.id) || ssrHotUpdateOptions?.modules.some(
              (ssrMod) => ssrMod.id === mixedMod.id
            )
          );
          mixedHmrContext.modules.push(
            ...filteredModules.filter(
              (mod) => !mixedHmrContext.modules.some(
                (mixedMod) => mixedMod.id === mod.id
              )
            ).map(
              (mod) => mixedModuleGraph.getBackwardCompatibleModuleNode(mod)
            )
          );
        }
      } else if (type === "update") {
        warnFutureDeprecation(
          config,
          "removePluginHookHandleHotUpdate",
          `Used in plugin "${plugin.name}".`,
          false
        );
        const filteredModules = await getHookHandler(plugin.handleHotUpdate)(
          mixedHmrContext
        );
        if (filteredModules) {
          mixedHmrContext.modules = filteredModules;
          clientHotUpdateOptions.modules = clientHotUpdateOptions.modules.filter(
            (mod) => filteredModules.some((mixedMod) => mod.id === mixedMod.id)
          );
          clientHotUpdateOptions.modules.push(
            ...filteredModules.filter(
              (mixedMod) => !clientHotUpdateOptions.modules.some(
                (mod) => mod.id === mixedMod.id
              )
            ).map((mixedMod) => mixedMod._clientModule).filter(Boolean)
          );
          if (ssrHotUpdateOptions) {
            ssrHotUpdateOptions.modules = ssrHotUpdateOptions.modules.filter(
              (mod) => filteredModules.some((mixedMod) => mod.id === mixedMod.id)
            );
            ssrHotUpdateOptions.modules.push(
              ...filteredModules.filter(
                (mixedMod) => !ssrHotUpdateOptions.modules.some(
                  (mod) => mod.id === mixedMod.id
                )
              ).map((mixedMod) => mixedMod._ssrModule).filter(Boolean)
            );
          }
        }
      }
    }
  } catch (error2) {
    hotMap.get(server.environments.client).error = error2;
  }
  for (const environment of Object.values(server.environments)) {
    if (environment.name === "client") continue;
    const hot = hotMap.get(environment);
    const environmentThis = { environment };
    try {
      for (const plugin of getSortedHotUpdatePlugins(environment)) {
        if (plugin.hotUpdate) {
          const filteredModules = await getHookHandler(plugin.hotUpdate).call(
            environmentThis,
            hot.options
          );
          if (filteredModules) {
            hot.options.modules = filteredModules;
          }
        }
      }
    } catch (error2) {
      hot.error = error2;
    }
  }
  async function hmr(environment) {
    try {
      const { options, error: error2 } = hotMap.get(environment);
      if (error2) {
        throw error2;
      }
      if (!options.modules.length) {
        if (file.endsWith(".html") && environment.name === "client") {
          environment.logger.info(
            colors$1.green(`page reload `) + colors$1.dim(shortFile),
            {
              clear: true,
              timestamp: true
            }
          );
          environment.hot.send({
            type: "full-reload",
            path: config.server.middlewareMode ? "*" : "/" + normalizePath$3(path$b.relative(config.root, file))
          });
        } else {
          debugHmr?.(
            `(${environment.name}) [no modules matched] ${colors$1.dim(shortFile)}`
          );
        }
        return;
      }
      updateModules(environment, shortFile, options.modules, timestamp);
    } catch (err) {
      environment.hot.send({
        type: "error",
        err: prepareError(err)
      });
    }
  }
  const hotUpdateEnvironments = server.config.server.hotUpdateEnvironments ?? ((server2, hmr2) => {
    return Promise.all(
      Object.values(server2.environments).map(
        (environment) => hmr2(environment)
      )
    );
  });
  await hotUpdateEnvironments(server, hmr);
}
function updateModules(environment, file, modules, timestamp, firstInvalidatedBy) {
  const { hot } = environment;
  const updates = [];
  const invalidatedModules = /* @__PURE__ */ new Set();
  const traversedModules = /* @__PURE__ */ new Set();
  let needFullReload = modules.length === 0;
  for (const mod of modules) {
    const boundaries = [];
    const hasDeadEnd = propagateUpdate(mod, traversedModules, boundaries);
    environment.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    );
    if (needFullReload) {
      continue;
    }
    if (hasDeadEnd) {
      needFullReload = hasDeadEnd;
      continue;
    }
    if (firstInvalidatedBy && boundaries.some(
      ({ acceptedVia }) => normalizeHmrUrl(acceptedVia.url) === firstInvalidatedBy
    )) {
      needFullReload = "circular import invalidate";
      continue;
    }
    updates.push(
      ...boundaries.map(
        ({ boundary, acceptedVia, isWithinCircularImport }) => ({
          type: `${boundary.type}-update`,
          timestamp,
          path: normalizeHmrUrl(boundary.url),
          acceptedPath: normalizeHmrUrl(acceptedVia.url),
          explicitImportRequired: boundary.type === "js" ? isExplicitImportRequired(acceptedVia.url) : false,
          isWithinCircularImport,
          firstInvalidatedBy
        })
      )
    );
  }
  if (needFullReload) {
    const reason = typeof needFullReload === "string" ? colors$1.dim(` (${needFullReload})`) : "";
    environment.logger.info(
      colors$1.green(`page reload `) + colors$1.dim(file) + reason,
      { clear: !firstInvalidatedBy, timestamp: true }
    );
    hot.send({
      type: "full-reload",
      triggeredBy: path$b.resolve(environment.config.root, file)
    });
    return;
  }
  if (updates.length === 0) {
    debugHmr?.(colors$1.yellow(`no update happened `) + colors$1.dim(file));
    return;
  }
  environment.logger.info(
    colors$1.green(`hmr update `) + colors$1.dim([...new Set(updates.map((u) => u.path))].join(", ")),
    { clear: !firstInvalidatedBy, timestamp: true }
  );
  hot.send({
    type: "update",
    updates
  });
}
function areAllImportsAccepted(importedBindings, acceptedExports) {
  for (const binding of importedBindings) {
    if (!acceptedExports.has(binding)) {
      return false;
    }
  }
  return true;
}
function propagateUpdate(node, traversedModules, boundaries, currentChain = [node]) {
  if (traversedModules.has(node)) {
    return false;
  }
  traversedModules.add(node);
  if (node.id && node.isSelfAccepting === void 0) {
    debugHmr?.(
      `[propagate update] stop propagation because not analyzed: ${colors$1.dim(
        node.id
      )}`
    );
    return false;
  }
  if (node.isSelfAccepting) {
    boundaries.push({
      boundary: node,
      acceptedVia: node,
      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain)
    });
    for (const importer of node.importers) {
      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
        propagateUpdate(
          importer,
          traversedModules,
          boundaries,
          currentChain.concat(importer)
        );
      }
    }
    return false;
  }
  if (node.acceptedHmrExports) {
    boundaries.push({
      boundary: node,
      acceptedVia: node,
      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain)
    });
  } else {
    if (!node.importers.size) {
      return true;
    }
    if (!isCSSRequest(node.url) && // we assume .svg is never an entrypoint and does not need a full reload
    // to avoid frequent full reloads when an SVG file is referenced in CSS files (#18979)
    !node.file?.endsWith(".svg") && [...node.importers].every((i) => isCSSRequest(i.url))) {
      return true;
    }
  }
  for (const importer of node.importers) {
    const subChain = currentChain.concat(importer);
    if (importer.acceptedHmrDeps.has(node)) {
      boundaries.push({
        boundary: importer,
        acceptedVia: node,
        isWithinCircularImport: isNodeWithinCircularImports(importer, subChain)
      });
      continue;
    }
    if (node.id && node.acceptedHmrExports && importer.importedBindings) {
      const importedBindingsFromNode = importer.importedBindings.get(node.id);
      if (importedBindingsFromNode && areAllImportsAccepted(importedBindingsFromNode, node.acceptedHmrExports)) {
        continue;
      }
    }
    if (!currentChain.includes(importer) && propagateUpdate(importer, traversedModules, boundaries, subChain)) {
      return true;
    }
  }
  return false;
}
function isNodeWithinCircularImports(node, nodeChain, currentChain = [node], traversedModules = /* @__PURE__ */ new Set()) {
  if (traversedModules.has(node)) {
    return false;
  }
  traversedModules.add(node);
  for (const importer of node.importers) {
    if (importer === node) continue;
    if (isCSSRequest(importer.url)) continue;
    const importerIndex = nodeChain.indexOf(importer);
    if (importerIndex > -1) {
      if (debugHmr) {
        const importChain = [
          importer,
          ...[...currentChain].reverse(),
          ...nodeChain.slice(importerIndex, -1).reverse()
        ];
        debugHmr(
          colors$1.yellow(`circular imports detected: `) + importChain.map((m) => colors$1.dim(m.url)).join(" -> ")
        );
      }
      return true;
    }
    if (!currentChain.includes(importer)) {
      const result = isNodeWithinCircularImports(
        importer,
        nodeChain,
        currentChain.concat(importer),
        traversedModules
      );
      if (result) return result;
    }
  }
  return false;
}
function handlePrunedModules(mods, { hot }) {
  const t = Date.now();
  mods.forEach((mod) => {
    mod.lastHMRTimestamp = t;
    mod.lastHMRInvalidationReceived = false;
    debugHmr?.(`[dispose] ${colors$1.dim(mod.file)}`);
  });
  hot.send({
    type: "prune",
    paths: [...mods].map((m) => m.url)
  });
}
function lexAcceptedHmrDeps(code, start, urls) {
  let state = 0 /* inCall */;
  let prevState = 0 /* inCall */;
  let currentDep = "";
  function addDep(index) {
    urls.add({
      url: currentDep,
      start: index - currentDep.length - 1,
      end: index + 1
    });
    currentDep = "";
  }
  for (let i = start; i < code.length; i++) {
    const char = code.charAt(i);
    switch (state) {
      case 0 /* inCall */:
      case 4 /* inArray */:
        if (char === `'`) {
          prevState = state;
          state = 1 /* inSingleQuoteString */;
        } else if (char === `"`) {
          prevState = state;
          state = 2 /* inDoubleQuoteString */;
        } else if (char === "`") {
          prevState = state;
          state = 3 /* inTemplateString */;
        } else if (whitespaceRE.test(char)) {
          continue;
        } else {
          if (state === 0 /* inCall */) {
            if (char === `[`) {
              state = 4 /* inArray */;
            } else {
              return true;
            }
          } else {
            if (char === `]`) {
              return false;
            } else if (char === ",") {
              continue;
            } else {
              error(i);
            }
          }
        }
        break;
      case 1 /* inSingleQuoteString */:
        if (char === `'`) {
          addDep(i);
          if (prevState === 0 /* inCall */) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 2 /* inDoubleQuoteString */:
        if (char === `"`) {
          addDep(i);
          if (prevState === 0 /* inCall */) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 3 /* inTemplateString */:
        if (char === "`") {
          addDep(i);
          if (prevState === 0 /* inCall */) {
            return false;
          } else {
            state = prevState;
          }
        } else if (char === "$" && code.charAt(i + 1) === "{") {
          error(i);
        } else {
          currentDep += char;
        }
        break;
      default:
        throw new Error("unknown import.meta.hot lexer state");
    }
  }
  return false;
}
function lexAcceptedHmrExports(code, start, exportNames) {
  const urls = /* @__PURE__ */ new Set();
  lexAcceptedHmrDeps(code, start, urls);
  for (const { url } of urls) {
    exportNames.add(url);
  }
  return urls.size > 0;
}
function normalizeHmrUrl(url) {
  if (url[0] !== "." && url[0] !== "/") {
    url = wrapId$1(url);
  }
  return url;
}
function error(pos) {
  const err = new Error(
    `import.meta.hot.accept() can only accept string literals or an Array of string literals.`
  );
  err.pos = pos;
  throw err;
}
async function readModifiedFile(file) {
  const content = await fsp.readFile(file, "utf-8");
  if (!content) {
    const mtime = (await fsp.stat(file)).mtimeMs;
    for (let n = 0; n < 10; n++) {
      await new Promise((r) => setTimeout(r, 10));
      const newMtime = (await fsp.stat(file)).mtimeMs;
      if (newMtime !== mtime) {
        break;
      }
    }
    return await fsp.readFile(file, "utf-8");
  } else {
    return content;
  }
}
function createServerHotChannel() {
  const innerEmitter = new EventEmitter$4();
  const outsideEmitter = new EventEmitter$4();
  return {
    send(payload) {
      outsideEmitter.emit("send", payload);
    },
    off(event, listener) {
      innerEmitter.off(event, listener);
    },
    on: (event, listener) => {
      innerEmitter.on(event, listener);
    },
    close() {
      innerEmitter.removeAllListeners();
      outsideEmitter.removeAllListeners();
    },
    listen() {
      innerEmitter.emit("connection");
    },
    api: {
      innerEmitter,
      outsideEmitter
    }
  };
}
function createDeprecatedHotBroadcaster(ws) {
  const broadcaster = {
    on: ws.on,
    off: ws.off,
    listen: ws.listen,
    send: ws.send,
    setInvokeHandler: ws.setInvokeHandler,
    handleInvoke: async () => ({
      error: {
        name: "TransportError",
        message: "handleInvoke not implemented",
        stack: new Error().stack
      }
    }),
    get channels() {
      return [ws];
    },
    addChannel() {
      return broadcaster;
    },
    close() {
      return Promise.all(broadcaster.channels.map((channel) => channel.close()));
    }
  };
  return broadcaster;
}

const nonJsRe = /\.json(?:$|\?)/;
const isNonJsRequest = (request) => nonJsRe.test(request);
const importMetaEnvMarker = "__vite_import_meta_env__";
const importMetaEnvKeyReCache = /* @__PURE__ */ new Map();
function definePlugin(config) {
  const isBuild = config.command === "build";
  const isBuildLib = isBuild && config.build.lib;
  const processEnv = {};
  if (!isBuildLib) {
    const nodeEnv = process.env.NODE_ENV || config.mode;
    Object.assign(processEnv, {
      "process.env": `{}`,
      "global.process.env": `{}`,
      "globalThis.process.env": `{}`,
      "process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
    });
  }
  const importMetaKeys = {};
  const importMetaEnvKeys = {};
  const importMetaFallbackKeys = {};
  if (isBuild) {
    importMetaKeys["import.meta.hot"] = `undefined`;
    for (const key in config.env) {
      const val = JSON.stringify(config.env[key]);
      importMetaKeys[`import.meta.env.${key}`] = val;
      importMetaEnvKeys[key] = val;
    }
    importMetaKeys["import.meta.env.SSR"] = `undefined`;
    importMetaFallbackKeys["import.meta.env"] = `undefined`;
  }
  function generatePattern(environment) {
    const keepProcessEnv = environment.config.keepProcessEnv;
    const userDefine = {};
    const userDefineEnv = {};
    for (const key in environment.config.define) {
      userDefine[key] = handleDefineValue(environment.config.define[key]);
      if (isBuild && key.startsWith("import.meta.env.")) {
        userDefineEnv[key.slice(16)] = environment.config.define[key];
      }
    }
    const define = {
      ...keepProcessEnv ? {} : processEnv,
      ...importMetaKeys,
      ...userDefine,
      ...importMetaFallbackKeys
    };
    const ssr = environment.config.consumer === "server";
    if ("import.meta.env.SSR" in define) {
      define["import.meta.env.SSR"] = ssr + "";
    }
    if ("import.meta.env" in define) {
      define["import.meta.env"] = importMetaEnvMarker;
    }
    const importMetaEnvVal = serializeDefine({
      ...importMetaEnvKeys,
      SSR: ssr + "",
      ...userDefineEnv
    });
    const patternKeys = Object.keys(userDefine);
    if (!keepProcessEnv && Object.keys(processEnv).length) {
      patternKeys.push("process.env");
    }
    if (Object.keys(importMetaKeys).length) {
      patternKeys.push("import.meta.env", "import.meta.hot");
    }
    const pattern = patternKeys.length ? new RegExp(patternKeys.map(escapeRegex).join("|")) : null;
    return [define, pattern, importMetaEnvVal];
  }
  const patternsCache = /* @__PURE__ */ new WeakMap();
  function getPattern(environment) {
    let pattern = patternsCache.get(environment);
    if (!pattern) {
      pattern = generatePattern(environment);
      patternsCache.set(environment, pattern);
    }
    return pattern;
  }
  return {
    name: "vite:define",
    transform: {
      async handler(code, id) {
        if (this.environment.config.consumer === "client" && !isBuild) {
          return;
        }
        if (
          // exclude html, css and static assets for performance
          isHTMLRequest(id) || isCSSRequest(id) || isNonJsRequest(id) || config.assetsInclude(id)
        ) {
          return;
        }
        let [define, pattern, importMetaEnvVal] = getPattern(this.environment);
        if (!pattern) return;
        pattern.lastIndex = 0;
        if (!pattern.test(code)) return;
        const hasDefineImportMetaEnv = "import.meta.env" in define;
        let marker = importMetaEnvMarker;
        if (hasDefineImportMetaEnv && code.includes(marker)) {
          let i = 1;
          do {
            marker = importMetaEnvMarker + i++;
          } while (code.includes(marker));
          if (marker !== importMetaEnvMarker) {
            define = { ...define, "import.meta.env": marker };
          }
        }
        const result = await replaceDefine(this.environment, code, id, define);
        if (hasDefineImportMetaEnv) {
          result.code = result.code.replaceAll(
            getImportMetaEnvKeyRe(marker),
            (m) => "undefined".padEnd(m.length)
          );
          if (result.code.includes(marker)) {
            result.code = `const ${marker} = ${importMetaEnvVal};
` + result.code;
            if (result.map) {
              const map = JSON.parse(result.map);
              map.mappings = ";" + map.mappings;
              result.map = map;
            }
          }
        }
        return result;
      }
    }
  };
}
async function replaceDefine(environment, code, id, define) {
  const esbuildOptions = environment.config.esbuild || {};
  const result = await transform$1(code, {
    loader: "js",
    charset: esbuildOptions.charset ?? "utf8",
    platform: "neutral",
    define,
    sourcefile: id,
    sourcemap: environment.config.command === "build" ? !!environment.config.build.sourcemap : true
  });
  if (result.map.includes("<define:")) {
    const originalMap = new TraceMap(result.map);
    if (originalMap.sources.length >= 2) {
      const sourceIndex = originalMap.sources.indexOf(id);
      const decoded = decodedMap(originalMap);
      decoded.sources = [id];
      decoded.mappings = decoded.mappings.map(
        (segments) => segments.filter((segment) => {
          const index = segment[1];
          segment[1] = 0;
          return index === sourceIndex;
        })
      );
      result.map = JSON.stringify(encodedMap(new TraceMap(decoded)));
    }
  }
  return {
    code: result.code,
    map: result.map || null
  };
}
function serializeDefine(define) {
  let res = `{`;
  const keys = Object.keys(define).sort();
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const val = define[key];
    res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
    if (i !== keys.length - 1) {
      res += `, `;
    }
  }
  return res + `}`;
}
function handleDefineValue(value) {
  if (typeof value === "undefined") return "undefined";
  if (typeof value === "string") return value;
  return JSON.stringify(value);
}
function getImportMetaEnvKeyRe(marker) {
  let re = importMetaEnvKeyReCache.get(marker);
  if (!re) {
    re = new RegExp(`${marker}\\..+?\\b`, "g");
    importMetaEnvKeyReCache.set(marker, re);
  }
  return re;
}

const workerOrSharedWorkerRE = /(?:\?|&)(worker|sharedworker)(?:&|$)/;
const workerFileRE = /(?:\?|&)worker_file&type=(\w+)(?:&|$)/;
const inlineRE$1 = /[?&]inline\b/;
const WORKER_FILE_ID = "worker_file";
const workerCache = /* @__PURE__ */ new WeakMap();
function saveEmitWorkerAsset(config, asset) {
  const workerMap = workerCache.get(config.mainConfig || config);
  const duplicateAsset = workerMap.assets.get(asset.fileName);
  if (duplicateAsset) {
    if (!isSameContent(duplicateAsset.source, asset.source)) {
      config.logger.warn(
        `
` + colors$1.yellow(
          `The emitted file ${JSON.stringify(asset.fileName)} overwrites a previously emitted file of the same name.`
        )
      );
    }
  }
  workerMap.assets.set(asset.fileName, asset);
}
async function bundleWorkerEntry(config, id) {
  const input = cleanUrl(id);
  const newBundleChain = [...config.bundleChain, input];
  if (config.bundleChain.includes(input)) {
    throw new Error(
      `Circular worker imports detected. Vite does not support it. Import chain: ${newBundleChain.map((id2) => prettifyUrl(id2, config.root)).join(" -> ")}`
    );
  }
  const { rollup } = await import('rollup');
  const { plugins, rollupOptions, format } = config.worker;
  const workerConfig = await plugins(newBundleChain);
  const workerEnvironment = new BuildEnvironment("client", workerConfig);
  await workerEnvironment.init();
  const bundle = await rollup({
    ...rollupOptions,
    input,
    plugins: workerEnvironment.plugins.map(
      (p) => injectEnvironmentAndFilterToHooks(workerEnvironment, p)
    ),
    onLog(level, log) {
      onRollupLog(level, log, workerEnvironment);
    },
    preserveEntrySignatures: false
  });
  let chunk;
  try {
    const workerOutputConfig = config.worker.rollupOptions.output;
    const workerConfig2 = workerOutputConfig ? Array.isArray(workerOutputConfig) ? workerOutputConfig[0] || {} : workerOutputConfig : {};
    const {
      output: [outputChunk, ...outputChunks]
    } = await bundle.generate({
      entryFileNames: path$b.posix.join(
        config.build.assetsDir,
        "[name]-[hash].js"
      ),
      chunkFileNames: path$b.posix.join(
        config.build.assetsDir,
        "[name]-[hash].js"
      ),
      assetFileNames: path$b.posix.join(
        config.build.assetsDir,
        "[name]-[hash].[ext]"
      ),
      ...workerConfig2,
      format,
      sourcemap: config.build.sourcemap
    });
    chunk = outputChunk;
    outputChunks.forEach((outputChunk2) => {
      if (outputChunk2.type === "asset") {
        saveEmitWorkerAsset(config, outputChunk2);
      } else if (outputChunk2.type === "chunk") {
        saveEmitWorkerAsset(config, {
          fileName: outputChunk2.fileName,
          originalFileName: null,
          originalFileNames: [],
          source: outputChunk2.code
        });
      }
    });
  } catch (e) {
    if (e instanceof Error && e.name === "RollupError" && e.code === "INVALID_OPTION" && e.message.includes('"output.format"')) {
      e.message = e.message.replace("output.format", "worker.format");
    }
    throw e;
  } finally {
    await bundle.close();
  }
  return emitSourcemapForWorkerEntry(config, chunk);
}
function emitSourcemapForWorkerEntry(config, chunk) {
  const { map: sourcemap } = chunk;
  if (sourcemap) {
    if (config.build.sourcemap === "hidden" || config.build.sourcemap === true) {
      const data = sourcemap.toString();
      const mapFileName = chunk.fileName + ".map";
      saveEmitWorkerAsset(config, {
        fileName: mapFileName,
        originalFileName: null,
        originalFileNames: [],
        source: data
      });
    }
  }
  return chunk;
}
const workerAssetUrlRE = /__VITE_WORKER_ASSET__([a-z\d]{8})__/g;
function encodeWorkerAssetFileName(fileName, workerCache2) {
  const { fileNameHash } = workerCache2;
  const hash = getHash(fileName);
  if (!fileNameHash.get(hash)) {
    fileNameHash.set(hash, fileName);
  }
  return `__VITE_WORKER_ASSET__${hash}__`;
}
async function workerFileToUrl(config, id) {
  const workerMap = workerCache.get(config.mainConfig || config);
  let fileName = workerMap.bundle.get(id);
  if (!fileName) {
    const outputChunk = await bundleWorkerEntry(config, id);
    fileName = outputChunk.fileName;
    saveEmitWorkerAsset(config, {
      fileName,
      originalFileName: null,
      originalFileNames: [],
      source: outputChunk.code
    });
    workerMap.bundle.set(id, fileName);
  }
  return encodeWorkerAssetFileName(fileName, workerMap);
}
function webWorkerPostPlugin() {
  return {
    name: "vite:worker-post",
    resolveImportMeta(property, { format }) {
      if (format === "iife") {
        if (!property) {
          return `{
            url: self.location.href
          }`;
        }
        if (property === "url") {
          return "self.location.href";
        }
      }
      return null;
    }
  };
}
function webWorkerPlugin(config) {
  const isBuild = config.command === "build";
  const isWorker = config.isWorker;
  return {
    name: "vite:worker",
    buildStart() {
      if (isWorker) {
        return;
      }
      workerCache.set(config, {
        assets: /* @__PURE__ */ new Map(),
        bundle: /* @__PURE__ */ new Map(),
        fileNameHash: /* @__PURE__ */ new Map()
      });
    },
    load: {
      handler(id) {
        if (isBuild && workerOrSharedWorkerRE.test(id)) {
          return "";
        }
      }
    },
    shouldTransformCachedModule({ id }) {
      if (isBuild && config.build.watch && workerOrSharedWorkerRE.test(id)) {
        return true;
      }
    },
    transform: {
      async handler(raw, id) {
        const workerFileMatch = workerFileRE.exec(id);
        if (workerFileMatch) {
          const workerType2 = workerFileMatch[1];
          let injectEnv = "";
          const scriptPath = JSON.stringify(
            path$b.posix.join(config.base, ENV_PUBLIC_PATH)
          );
          if (workerType2 === "classic") {
            injectEnv = `importScripts(${scriptPath})
`;
          } else if (workerType2 === "module") {
            injectEnv = `import ${scriptPath}
`;
          } else if (workerType2 === "ignore") {
            if (isBuild) {
              injectEnv = "";
            } else {
              const environment = this.environment;
              const moduleGraph = environment.mode === "dev" ? environment.moduleGraph : void 0;
              const module = moduleGraph?.getModuleById(ENV_ENTRY);
              injectEnv = module?.transformResult?.code || "";
            }
          }
          if (injectEnv) {
            const s = new MagicString(raw);
            s.prepend(injectEnv + ";\n");
            return {
              code: s.toString(),
              map: s.generateMap({ hires: "boundary" })
            };
          }
          return;
        }
        const workerMatch = workerOrSharedWorkerRE.exec(id);
        if (!workerMatch) return;
        const { format } = config.worker;
        const workerConstructor = workerMatch[1] === "sharedworker" ? "SharedWorker" : "Worker";
        const workerType = isBuild ? format === "es" ? "module" : "classic" : "module";
        const workerTypeOption = `{
          ${workerType === "module" ? `type: "module",` : ""}
          name: options?.name
        }`;
        let urlCode;
        if (isBuild) {
          if (isWorker && config.bundleChain.at(-1) === cleanUrl(id)) {
            urlCode = "self.location.href";
          } else if (inlineRE$1.test(id)) {
            const chunk = await bundleWorkerEntry(config, id);
            const jsContent = `const jsContent = ${JSON.stringify(chunk.code)};`;
            const code = (
              // Using blob URL for SharedWorker results in multiple instances of a same worker
              workerConstructor === "Worker" ? `${jsContent}
            const blob = typeof self !== "undefined" && self.Blob && new Blob([${workerType === "classic" ? "" : (
                // `URL` is always available, in `Worker[type="module"]`
                `'URL.revokeObjectURL(import.meta.url);',`
              )}jsContent], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper(options) {
              let objURL;
              try {
                objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
                if (!objURL) throw ''
                const worker = new ${workerConstructor}(objURL, ${workerTypeOption});
                worker.addEventListener("error", () => {
                  (self.URL || self.webkitURL).revokeObjectURL(objURL);
                });
                return worker;
              } catch(e) {
                return new ${workerConstructor}(
                  'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                  ${workerTypeOption}
                );
              }${// For module workers, we should not revoke the URL until the worker runs,
              // otherwise the worker fails to run
              workerType === "classic" ? ` finally {
                      objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);
                    }` : ""}
            }` : `${jsContent}
            export default function WorkerWrapper(options) {
              return new ${workerConstructor}(
                'data:text/javascript;charset=utf-8,' + encodeURIComponent(jsContent),
                ${workerTypeOption}
              );
            }
            `
            );
            return {
              code,
              // Empty sourcemap to suppress Rollup warning
              map: { mappings: "" }
            };
          } else {
            urlCode = JSON.stringify(await workerFileToUrl(config, id));
          }
        } else {
          let url = await fileToUrl$1(this, cleanUrl(id));
          url = injectQuery(url, `${WORKER_FILE_ID}&type=${workerType}`);
          urlCode = JSON.stringify(url);
        }
        if (urlRE$1.test(id)) {
          return {
            code: `export default ${urlCode}`,
            map: { mappings: "" }
            // Empty sourcemap to suppress Rollup warning
          };
        }
        return {
          code: `export default function WorkerWrapper(options) {
            return new ${workerConstructor}(
              ${urlCode},
              ${workerTypeOption}
            );
          }`,
          map: { mappings: "" }
          // Empty sourcemap to suppress Rollup warning
        };
      }
    },
    renderChunk(code, chunk, outputOptions) {
      let s;
      const result = () => {
        return s && {
          code: s.toString(),
          map: this.environment.config.build.sourcemap ? s.generateMap({ hires: "boundary" }) : null
        };
      };
      workerAssetUrlRE.lastIndex = 0;
      if (workerAssetUrlRE.test(code)) {
        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
          outputOptions.format,
          this.environment.config.isWorker
        );
        let match;
        s = new MagicString(code);
        workerAssetUrlRE.lastIndex = 0;
        const workerMap = workerCache.get(config.mainConfig || config);
        const { fileNameHash } = workerMap;
        while (match = workerAssetUrlRE.exec(code)) {
          const [full, hash] = match;
          const filename = fileNameHash.get(hash);
          const replacement = toOutputFilePathInJS(
            this.environment,
            filename,
            "asset",
            chunk.fileName,
            "js",
            toRelativeRuntime
          );
          const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
          s.update(match.index, match.index + full.length, replacementString);
        }
      }
      return result();
    },
    generateBundle(opts, bundle) {
      if (opts.__vite_skip_asset_emit__ || isWorker) {
        return;
      }
      const workerMap = workerCache.get(config);
      workerMap.assets.forEach((asset) => {
        const duplicateAsset = bundle[asset.fileName];
        if (duplicateAsset) {
          const content = duplicateAsset.type === "asset" ? duplicateAsset.source : duplicateAsset.code;
          if (isSameContent(content, asset.source)) {
            return;
          }
        }
        this.emitFile({
          type: "asset",
          fileName: asset.fileName,
          source: asset.source
          // NOTE: fileName is already generated when bundling the worker
          //       so no need to pass originalFileNames/names
        });
      });
      workerMap.assets.clear();
    }
  };
}
function isSameContent(a, b) {
  if (typeof a === "string") {
    if (typeof b === "string") {
      return a === b;
    }
    return Buffer.from(a).equals(b);
  }
  return Buffer.from(b).equals(a);
}

function preAliasPlugin(config) {
  const findPatterns = getAliasPatterns(config.resolve.alias);
  return {
    name: "vite:pre-alias",
    applyToEnvironment(environment) {
      return !isDepOptimizationDisabled(environment.config.optimizeDeps);
    },
    async resolveId(id, importer, options) {
      const environment = this.environment;
      const ssr = environment.config.consumer === "server";
      const depsOptimizer = environment.depsOptimizer;
      if (importer && depsOptimizer && bareImportRE.test(id) && !options.scan && id !== "@vite/client" && id !== "@vite/env") {
        if (findPatterns.find((pattern) => matches(pattern, id))) {
          const optimizedId = await tryOptimizedResolve(
            depsOptimizer,
            id,
            importer,
            config.resolve.preserveSymlinks,
            config.packageCache
          );
          if (optimizedId) {
            return optimizedId;
          }
          if (depsOptimizer.options.noDiscovery) {
            return;
          }
          const resolved = await this.resolve(id, importer, options);
          if (resolved && !depsOptimizer.isOptimizedDepFile(resolved.id)) {
            const optimizeDeps = depsOptimizer.options;
            const resolvedId = cleanUrl(resolved.id);
            const isVirtual = resolvedId === id || resolvedId.includes("\0");
            if (!isVirtual && fs__default.existsSync(resolvedId) && !moduleListContains(optimizeDeps.exclude, id) && path$b.isAbsolute(resolvedId) && (isInNodeModules$1(resolvedId) || optimizeDeps.include?.includes(id)) && isOptimizable(resolvedId, optimizeDeps) && (!ssr || optimizeAliasReplacementForSSR(resolvedId, optimizeDeps))) {
              const optimizedInfo = depsOptimizer.registerMissingImport(
                id,
                resolvedId
              );
              return { id: depsOptimizer.getOptimizedDepId(optimizedInfo) };
            }
          }
          return resolved;
        }
      }
    }
  };
}
function optimizeAliasReplacementForSSR(id, optimizeDeps) {
  if (optimizeDeps.include?.includes(id)) {
    return true;
  }
  return false;
}
function matches(pattern, importee) {
  if (pattern instanceof RegExp) {
    return pattern.test(importee);
  }
  if (importee.length < pattern.length) {
    return false;
  }
  if (importee === pattern) {
    return true;
  }
  return importee.startsWith(withTrailingSlash(pattern));
}
function getAliasPatterns(entries) {
  if (Array.isArray(entries)) {
    return entries.map((entry) => entry.find);
  }
  return Object.entries(entries).map(([find]) => find);
}
function getAliasPatternMatcher(entries) {
  const patterns = getAliasPatterns(entries);
  return (importee) => patterns.some((pattern) => matches(pattern, importee));
}

const debug$2 = createDebugger("vite:import-analysis");
const clientDir = normalizePath$3(CLIENT_DIR);
const skipRE = /\.(?:map|json)(?:$|\?)/;
const canSkipImportAnalysis = (id) => skipRE.test(id) || isDirectCSSRequest(id);
const optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/;
const optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/;
const hasViteIgnoreRE = /\/\*\s*@vite-ignore\s*\*\//;
const urlIsStringRE = /^(?:'.*'|".*"|`.*`)$/;
const templateLiteralRE = /^\s*`(.*)`\s*$/;
function isExplicitImportRequired(url) {
  return !isJSRequest(url) && !isCSSRequest(url);
}
function normalizeResolvedIdToUrl(environment, url, resolved) {
  const root = environment.config.root;
  const depsOptimizer = environment.depsOptimizer;
  if (resolved.id.startsWith(withTrailingSlash(root))) {
    url = resolved.id.slice(root.length);
  } else if (depsOptimizer?.isOptimizedDepFile(resolved.id) || // vite-plugin-react isn't following the leading \0 virtual module convention.
  // This is a temporary hack to avoid expensive fs checks for React apps.
  // We'll remove this as soon we're able to fix the react plugins.
  resolved.id !== "/@react-refresh" && path$b.isAbsolute(resolved.id) && fs__default.existsSync(cleanUrl(resolved.id))) {
    url = path$b.posix.join(FS_PREFIX, resolved.id);
  } else {
    url = resolved.id;
  }
  if (url[0] !== "." && url[0] !== "/") {
    url = wrapId$1(resolved.id);
  }
  return url;
}
function extractImportedBindings(id, source, importSpec, importedBindings) {
  let bindings = importedBindings.get(id);
  if (!bindings) {
    bindings = /* @__PURE__ */ new Set();
    importedBindings.set(id, bindings);
  }
  const isDynamic = importSpec.d > -1;
  const isMeta = importSpec.d === -2;
  if (isDynamic || isMeta) {
    bindings.add("*");
    return;
  }
  const exp = source.slice(importSpec.ss, importSpec.se);
  ESM_STATIC_IMPORT_RE.lastIndex = 0;
  const match = ESM_STATIC_IMPORT_RE.exec(exp);
  if (!match) {
    return;
  }
  const staticImport = {
    type: "static",
    code: match[0],
    start: match.index,
    end: match.index + match[0].length,
    imports: match.groups.imports,
    specifier: match.groups.specifier
  };
  const parsed = parseStaticImport(staticImport);
  if (parsed.namespacedImport) {
    bindings.add("*");
  }
  if (parsed.defaultImport) {
    bindings.add("default");
  }
  if (parsed.namedImports) {
    for (const name of Object.keys(parsed.namedImports)) {
      bindings.add(name);
    }
  }
}
function importAnalysisPlugin(config) {
  const { root, base } = config;
  const clientPublicPath = path$b.posix.join(base, CLIENT_PUBLIC_PATH);
  const enablePartialAccept = config.experimental.hmrPartialAccept;
  const matchAlias = getAliasPatternMatcher(config.resolve.alias);
  let _env;
  let _ssrEnv;
  function getEnv(ssr) {
    if (!_ssrEnv || !_env) {
      const importMetaEnvKeys = {};
      const userDefineEnv = {};
      for (const key in config.env) {
        importMetaEnvKeys[key] = JSON.stringify(config.env[key]);
      }
      for (const key in config.define) {
        if (key.startsWith("import.meta.env.")) {
          userDefineEnv[key.slice(16)] = config.define[key];
        }
      }
      const env = `import.meta.env = ${serializeDefine({
        ...importMetaEnvKeys,
        SSR: "__vite_ssr__",
        ...userDefineEnv
      })};`;
      _ssrEnv = env.replace("__vite_ssr__", "true");
      _env = env.replace("__vite_ssr__", "false");
    }
    return ssr ? _ssrEnv : _env;
  }
  return {
    name: "vite:import-analysis",
    async transform(source, importer) {
      const environment = this.environment;
      const ssr = environment.config.consumer === "server";
      const moduleGraph = environment.moduleGraph;
      if (canSkipImportAnalysis(importer)) {
        debug$2?.(colors$1.dim(`[skipped] ${prettifyUrl(importer, root)}`));
        return null;
      }
      const msAtStart = debug$2 ? performance$1.now() : 0;
      await init;
      let imports;
      let exports;
      source = stripBomTag(source);
      try {
        [imports, exports] = parse$d(source);
      } catch (_e) {
        const e = _e;
        const { message, showCodeFrame } = createParseErrorInfo(
          importer,
          source
        );
        this.error(message, showCodeFrame ? e.idx : void 0);
      }
      const depsOptimizer = environment.depsOptimizer;
      const importerModule = moduleGraph.getModuleById(importer);
      if (!importerModule) {
        throwOutdatedRequest(importer);
      }
      if (!imports.length && !this._addedImports) {
        importerModule.isSelfAccepting = false;
        debug$2?.(
          `${timeFrom(msAtStart)} ${colors$1.dim(
            `[no imports] ${prettifyUrl(importer, root)}`
          )}`
        );
        return source;
      }
      let hasHMR = false;
      let isSelfAccepting = false;
      let hasEnv = false;
      let needQueryInjectHelper = false;
      let s;
      const str = () => s || (s = new MagicString(source));
      let isPartiallySelfAccepting = false;
      const importedBindings = enablePartialAccept ? /* @__PURE__ */ new Map() : null;
      const toAbsoluteUrl = (url) => path$b.posix.resolve(path$b.posix.dirname(importerModule.url), url);
      const normalizeUrl = async (url, pos, forceSkipImportAnalysis = false) => {
        url = stripBase(url, base);
        let importerFile = importer;
        if (depsOptimizer && moduleListContains(depsOptimizer.options.exclude, url)) {
          await depsOptimizer.scanProcessing;
          for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
            if (!optimizedModule.src) continue;
            if (optimizedModule.file === importerModule.file) {
              importerFile = optimizedModule.src;
            }
          }
        }
        const resolved = await this.resolve(url, importerFile).catch((e) => {
          if (e instanceof Error) {
            e.pos ??= pos;
          }
          throw e;
        });
        if (!resolved || resolved.meta?.["vite:alias"]?.noResolved) {
          if (ssr) {
            return [url, null];
          }
          importerModule.isSelfAccepting = false;
          moduleGraph._hasResolveFailedErrorModules.add(importerModule);
          return this.error(
            `Failed to resolve import "${url}" from "${normalizePath$3(
              path$b.relative(process.cwd(), importerFile)
            )}". Does the file exist?`,
            pos
          );
        }
        if (isExternalUrl(resolved.id)) {
          return [resolved.id, resolved.id];
        }
        const isRelative = url[0] === ".";
        const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer);
        url = normalizeResolvedIdToUrl(environment, url, resolved);
        if (environment.config.consumer === "client") {
          if (isExplicitImportRequired(url)) {
            url = injectQuery(url, "import");
          } else if ((isRelative || isSelfImport) && !DEP_VERSION_RE.test(url)) {
            const versionMatch = DEP_VERSION_RE.exec(importer);
            if (versionMatch) {
              url = injectQuery(url, versionMatch[1]);
            }
          }
        }
        try {
          const depModule = await moduleGraph._ensureEntryFromUrl(
            unwrapId$1(url),
            canSkipImportAnalysis(url) || forceSkipImportAnalysis,
            resolved
          );
          if (environment.config.consumer === "client" && depModule.lastHMRTimestamp > 0) {
            url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`);
          }
        } catch (e) {
          e.pos = pos;
          throw e;
        }
        if (!ssr) url = joinUrlSegments(base, url);
        return [url, resolved.id];
      };
      const orderedImportedUrls = new Array(imports.length);
      const orderedAcceptedUrls = new Array(
        imports.length
      );
      const orderedAcceptedExports = new Array(
        imports.length
      );
      await Promise.all(
        imports.map(async (importSpecifier, index) => {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex,
            a: attributeIndex
          } = importSpecifier;
          let specifier = importSpecifier.n;
          const rawUrl = source.slice(start, end);
          if (rawUrl === "import.meta") {
            const prop = source.slice(end, end + 4);
            if (prop === ".hot") {
              hasHMR = true;
              const endHot = end + 4 + (source[end + 4] === "?" ? 1 : 0);
              if (source.slice(endHot, endHot + 7) === ".accept") {
                if (source.slice(endHot, endHot + 14) === ".acceptExports") {
                  const importAcceptedExports = orderedAcceptedExports[index] = /* @__PURE__ */ new Set();
                  lexAcceptedHmrExports(
                    source,
                    source.indexOf("(", endHot + 14) + 1,
                    importAcceptedExports
                  );
                  isPartiallySelfAccepting = true;
                } else {
                  const importAcceptedUrls = orderedAcceptedUrls[index] = /* @__PURE__ */ new Set();
                  if (lexAcceptedHmrDeps(
                    source,
                    source.indexOf("(", endHot + 7) + 1,
                    importAcceptedUrls
                  )) {
                    isSelfAccepting = true;
                  }
                }
              }
            } else if (prop === ".env") {
              hasEnv = true;
            }
            return;
          } else if (templateLiteralRE.test(rawUrl)) {
            if (!(rawUrl.includes("${") && rawUrl.includes("}"))) {
              specifier = rawUrl.replace(templateLiteralRE, "$1");
            }
          }
          const isDynamicImport = dynamicIndex > -1;
          if (!isDynamicImport && attributeIndex > -1) {
            str().remove(end + 1, expEnd);
          }
          if (specifier !== void 0) {
            if (isExternalUrl(specifier) && !specifier.startsWith("file://") || isDataUrl(specifier)) {
              return;
            }
            if (ssr && !matchAlias(specifier)) {
              if (shouldExternalize(environment, specifier, importer)) {
                return;
              }
              if (isBuiltin(environment.config.resolve.builtins, specifier)) {
                return;
              }
            }
            if (specifier === clientPublicPath) {
              return;
            }
            if (specifier[0] === "/" && !(config.assetsInclude(cleanUrl(specifier)) || urlRE$1.test(specifier)) && checkPublicFile(specifier, config)) {
              throw new Error(
                `Cannot import non-asset file ${specifier} which is inside /public. JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html. If you want to get the URL of that file, use ${injectQuery(
                  specifier,
                  "url"
                )} instead.`
              );
            }
            let [url, resolvedId] = await normalizeUrl(specifier, start);
            resolvedId = resolvedId || url;
            config.safeModulePaths.add(fsPathFromUrl(stripBase(url, base)));
            if (url !== specifier) {
              let rewriteDone = false;
              if (depsOptimizer?.isOptimizedDepFile(resolvedId) && !optimizedDepChunkRE.test(resolvedId)) {
                const file = cleanUrl(resolvedId);
                const needsInterop = await optimizedDepNeedsInterop(
                  environment,
                  depsOptimizer.metadata,
                  file
                );
                if (needsInterop === void 0) {
                  if (!optimizedDepDynamicRE.test(file)) {
                    config.logger.error(
                      colors$1.red(
                        `Vite Error, ${url} optimized info should be defined`
                      )
                    );
                  }
                } else if (needsInterop) {
                  debug$2?.(`${url} needs interop`);
                  interopNamedImports(
                    str(),
                    importSpecifier,
                    url,
                    index,
                    importer,
                    config
                  );
                  rewriteDone = true;
                }
              } else if (url.includes(browserExternalId) && source.slice(expStart, start).includes("{")) {
                interopNamedImports(
                  str(),
                  importSpecifier,
                  url,
                  index,
                  importer,
                  config
                );
                rewriteDone = true;
              }
              if (!rewriteDone) {
                const rewrittenUrl = JSON.stringify(url);
                const s2 = isDynamicImport ? start : start - 1;
                const e = isDynamicImport ? end : end + 1;
                str().overwrite(s2, e, rewrittenUrl, {
                  contentOnly: true
                });
              }
            }
            const hmrUrl = unwrapId$1(stripBase(url, base));
            const isLocalImport = !isExternalUrl(hmrUrl) && !isDataUrl(hmrUrl);
            if (isLocalImport) {
              orderedImportedUrls[index] = hmrUrl;
            }
            if (enablePartialAccept && importedBindings) {
              extractImportedBindings(
                resolvedId,
                source,
                importSpecifier,
                importedBindings
              );
            }
            if (!isDynamicImport && isLocalImport && environment.config.dev.preTransformRequests) {
              const url2 = removeImportQuery(hmrUrl);
              environment.warmupRequest(url2);
            }
          } else if (!importer.startsWith(withTrailingSlash(clientDir))) {
            if (!isInNodeModules$1(importer)) {
              const hasViteIgnore = hasViteIgnoreRE.test(
                // complete expression inside parens
                source.slice(dynamicIndex + 1, end)
              );
              if (!hasViteIgnore) {
                this.warn(
                  `
` + colors$1.cyan(importerModule.file) + `
` + colors$1.reset(generateCodeFrame(source, start, end)) + colors$1.yellow(
                    `
The above dynamic import cannot be analyzed by Vite.
See ${colors$1.blue(
                      `https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`
                    )} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.
`
                  )
                );
              }
            }
            if (!ssr) {
              if (!urlIsStringRE.test(rawUrl) || isExplicitImportRequired(rawUrl.slice(1, -1))) {
                needQueryInjectHelper = true;
                str().overwrite(
                  start,
                  end,
                  `__vite__injectQuery(${rawUrl}, 'import')`,
                  { contentOnly: true }
                );
              }
            }
          }
        })
      );
      const _orderedImportedUrls = orderedImportedUrls.filter(isDefined);
      const importedUrls = new Set(_orderedImportedUrls);
      const staticImportedUrls = new Set(
        _orderedImportedUrls.map((url) => removeTimestampQuery(url))
      );
      const acceptedUrls = mergeAcceptedUrls(orderedAcceptedUrls);
      const acceptedExports = mergeAcceptedUrls(orderedAcceptedExports);
      const isClassicWorker = importer.includes(WORKER_FILE_ID) && importer.includes("type=classic");
      if (hasEnv && !isClassicWorker) {
        str().prepend(getEnv(ssr));
      }
      if (hasHMR && !ssr && !isClassicWorker) {
        debugHmr?.(
          `${isSelfAccepting ? `[self-accepts]` : isPartiallySelfAccepting ? `[accepts-exports]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettifyUrl(importer, root)}`
        );
        str().prepend(
          `import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(
            normalizeHmrUrl(importerModule.url)
          )});`
        );
      }
      if (needQueryInjectHelper) {
        if (isClassicWorker) {
          str().append("\n" + __vite__injectQuery.toString());
        } else {
          str().prepend(
            `import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`
          );
        }
      }
      const normalizedAcceptedUrls = /* @__PURE__ */ new Set();
      for (const { url, start, end } of acceptedUrls) {
        let [normalized, resolvedId] = await normalizeUrl(url, start).catch(
          () => []
        );
        if (resolvedId) {
          const mod = moduleGraph.getModuleById(resolvedId);
          if (!mod) {
            this.error(
              `module was not found for ${JSON.stringify(resolvedId)}`,
              start
            );
            return;
          }
          normalized = mod.url;
        } else {
          try {
            const [resolved] = await moduleGraph.resolveUrl(toAbsoluteUrl(url));
            normalized = resolved;
            if (resolved) {
              this.warn({
                message: `Failed to resolve ${JSON.stringify(url)} from ${importer}. An id should be written. Did you pass a URL?`,
                pos: start
              });
            }
          } catch {
            this.error(`Failed to resolve ${JSON.stringify(url)}`, start);
            return;
          }
        }
        normalizedAcceptedUrls.add(normalized);
        const hmrAccept = normalizeHmrUrl(normalized);
        str().overwrite(start, end, JSON.stringify(hmrAccept), {
          contentOnly: true
        });
      }
      if (!isCSSRequest(importer) || SPECIAL_QUERY_RE.test(importer)) {
        const pluginImports = this._addedImports;
        if (pluginImports) {
          (await Promise.all(
            [...pluginImports].map((id) => normalizeUrl(id, 0, true))
          )).forEach(([url]) => importedUrls.add(stripBase(url, base)));
        }
        if (ssr && importerModule.isSelfAccepting) {
          isSelfAccepting = true;
        }
        if (!isSelfAccepting && isPartiallySelfAccepting && acceptedExports.size >= exports.length && exports.every((e) => acceptedExports.has(e.n))) {
          isSelfAccepting = true;
        }
        const prunedImports = await moduleGraph.updateModuleInfo(
          importerModule,
          importedUrls,
          importedBindings,
          normalizedAcceptedUrls,
          isPartiallySelfAccepting ? acceptedExports : null,
          isSelfAccepting,
          staticImportedUrls
        );
        if (hasHMR && prunedImports) {
          handlePrunedModules(prunedImports, environment);
        }
      }
      debug$2?.(
        `${timeFrom(msAtStart)} ${colors$1.dim(
          `[${importedUrls.size} imports rewritten] ${prettifyUrl(
            importer,
            root
          )}`
        )}`
      );
      if (s) {
        return transformStableResult(s, importer, config);
      } else {
        return source;
      }
    }
  };
}
function mergeAcceptedUrls(orderedUrls) {
  const acceptedUrls = /* @__PURE__ */ new Set();
  for (const urls of orderedUrls) {
    if (!urls) continue;
    for (const url of urls) acceptedUrls.add(url);
  }
  return acceptedUrls;
}
function createParseErrorInfo(importer, source) {
  const isVue = importer.endsWith(".vue");
  const isJsx = importer.endsWith(".jsx") || importer.endsWith(".tsx");
  const maybeJSX = !isVue && isJSRequest(importer);
  const probablyBinary = source.includes(
    "\uFFFD"
  );
  const msg = isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? isJsx ? `If you use tsconfig.json, make sure to not set jsx to preserve.` : `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${path$b.extname(
    importer
  )} file format, or if it's an asset, add "**/*${path$b.extname(
    importer
  )}" to \`assetsInclude\` in your configuration.`;
  return {
    message: `Failed to parse source for import analysis because the content contains invalid JS syntax. ` + msg,
    showCodeFrame: !probablyBinary
  };
}
const interopHelper = (m) => m?.__esModule ? m : { ...typeof m === "object" && !Array.isArray(m) || typeof m === "function" ? m : {}, default: m };
function interopNamedImports(str, importSpecifier, rewrittenUrl, importIndex, importer, config) {
  const source = str.original;
  const {
    s: start,
    e: end,
    ss: expStart,
    se: expEnd,
    d: dynamicIndex
  } = importSpecifier;
  const exp = source.slice(expStart, expEnd);
  if (dynamicIndex > -1) {
    str.overwrite(
      expStart,
      expEnd,
      `import('${rewrittenUrl}').then(m => (${interopHelper.toString()})(m.default))` + getLineBreaks(exp),
      { contentOnly: true }
    );
  } else {
    const rawUrl = source.slice(start, end);
    const rewritten = transformCjsImport(
      exp,
      rewrittenUrl,
      rawUrl,
      importIndex,
      importer,
      config
    );
    if (rewritten) {
      str.overwrite(expStart, expEnd, rewritten + getLineBreaks(exp), {
        contentOnly: true
      });
    } else {
      str.overwrite(
        start,
        end,
        rewrittenUrl + getLineBreaks(source.slice(start, end)),
        {
          contentOnly: true
        }
      );
    }
  }
}
function getLineBreaks(str) {
  return str.includes("\n") ? "\n".repeat(str.split("\n").length - 1) : "";
}
function transformCjsImport(importExp, url, rawUrl, importIndex, importer, config) {
  const node = parseAst(importExp).body[0];
  if (config.command === "serve" && node.type === "ExportAllDeclaration" && !node.exported) {
    config.logger.warn(
      colors$1.yellow(
        `
Unable to interop \`${importExp}\` in ${importer}, this may lose module exports. Please export "${rawUrl}" as ESM or use named exports instead, e.g. \`export { A, B } from "${rawUrl}"\``
      )
    );
  } else if (node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") {
    if (!node.specifiers.length) {
      return `import "${url}"`;
    }
    const importNames = [];
    const exportNames = [];
    let defaultExports = "";
    for (const spec of node.specifiers) {
      if (spec.type === "ImportSpecifier") {
        const importedName = getIdentifierNameOrLiteralValue(
          spec.imported
        );
        const localName = spec.local.name;
        importNames.push({ importedName, localName });
      } else if (spec.type === "ImportDefaultSpecifier") {
        importNames.push({
          importedName: "default",
          localName: spec.local.name
        });
      } else if (spec.type === "ImportNamespaceSpecifier") {
        importNames.push({ importedName: "*", localName: spec.local.name });
      } else if (spec.type === "ExportSpecifier") {
        const importedName = getIdentifierNameOrLiteralValue(
          spec.local
        );
        const exportedName = getIdentifierNameOrLiteralValue(
          spec.exported
        );
        if (exportedName === "default") {
          defaultExports = makeLegalIdentifier(
            `__vite__cjsExportDefault_${importIndex}`
          );
          importNames.push({ importedName, localName: defaultExports });
        } else {
          const localName = `__vite__cjsExport${spec.exported.type === "Literal" ? `L_${getHash(spec.exported.value)}` : "I_" + spec.exported.name}`;
          importNames.push({ importedName, localName });
          exportNames.push(
            `${localName} as ${spec.exported.type === "Literal" ? JSON.stringify(exportedName) : exportedName}`
          );
        }
      }
    }
    const cjsModuleName = makeLegalIdentifier(
      `__vite__cjsImport${importIndex}_${rawUrl}`
    );
    const lines = [`import ${cjsModuleName} from "${url}"`];
    importNames.forEach(({ importedName, localName }) => {
      if (importedName === "*") {
        lines.push(
          `const ${localName} = (${interopHelper.toString()})(${cjsModuleName})`
        );
      } else if (importedName === "default") {
        lines.push(
          `const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`
        );
      } else {
        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
      }
    });
    if (defaultExports) {
      lines.push(`export default ${defaultExports}`);
    }
    if (exportNames.length) {
      lines.push(`export { ${exportNames.join(", ")} }`);
    }
    return lines.join("; ");
  }
}
function getIdentifierNameOrLiteralValue(node) {
  return node.type === "Identifier" ? node.name : node.value;
}
function __vite__injectQuery(url, queryToInject) {
  if (url[0] !== "." && url[0] !== "/") {
    return url;
  }
  const pathname = url.replace(/[?#].*$/, "");
  const { search, hash } = new URL(url, "http://vite.dev");
  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash || ""}`;
}

const normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
const normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
function clientInjectionsPlugin(config) {
  let injectConfigValues;
  const getDefineReplacer = perEnvironmentState((environment) => {
    const userDefine = {};
    for (const key in environment.config.define) {
      if (!key.startsWith("import.meta.env.")) {
        userDefine[key] = environment.config.define[key];
      }
    }
    const serializedDefines = serializeDefine(userDefine);
    const definesReplacement = () => serializedDefines;
    return (code) => code.replace(`__DEFINES__`, definesReplacement);
  });
  return {
    name: "vite:client-inject",
    async buildStart() {
      const resolvedServerHostname = (await resolveHostname(config.server.host)).name;
      const resolvedServerPort = config.server.port;
      const devBase = config.base;
      const serverHost = `${resolvedServerHostname}:${resolvedServerPort}${devBase}`;
      let hmrConfig = config.server.hmr;
      hmrConfig = isObject$1(hmrConfig) ? hmrConfig : void 0;
      const host = hmrConfig?.host || null;
      const protocol = hmrConfig?.protocol || null;
      const timeout = hmrConfig?.timeout || 3e4;
      const overlay = hmrConfig?.overlay !== false;
      const isHmrServerSpecified = !!hmrConfig?.server;
      const hmrConfigName = path$b.basename(config.configFile || "vite.config.js");
      let port = hmrConfig?.clientPort || hmrConfig?.port || null;
      if (config.server.middlewareMode && !isHmrServerSpecified) {
        port ||= 24678;
      }
      let directTarget = hmrConfig?.host || resolvedServerHostname;
      directTarget += `:${hmrConfig?.port || resolvedServerPort}`;
      directTarget += devBase;
      let hmrBase = devBase;
      if (hmrConfig?.path) {
        hmrBase = path$b.posix.join(hmrBase, hmrConfig.path);
      }
      const modeReplacement = escapeReplacement(config.mode);
      const baseReplacement = escapeReplacement(devBase);
      const serverHostReplacement = escapeReplacement(serverHost);
      const hmrProtocolReplacement = escapeReplacement(protocol);
      const hmrHostnameReplacement = escapeReplacement(host);
      const hmrPortReplacement = escapeReplacement(port);
      const hmrDirectTargetReplacement = escapeReplacement(directTarget);
      const hmrBaseReplacement = escapeReplacement(hmrBase);
      const hmrTimeoutReplacement = escapeReplacement(timeout);
      const hmrEnableOverlayReplacement = escapeReplacement(overlay);
      const hmrConfigNameReplacement = escapeReplacement(hmrConfigName);
      const wsTokenReplacement = escapeReplacement(config.webSocketToken);
      injectConfigValues = (code) => {
        return code.replace(`__MODE__`, modeReplacement).replace(/__BASE__/g, baseReplacement).replace(`__SERVER_HOST__`, serverHostReplacement).replace(`__HMR_PROTOCOL__`, hmrProtocolReplacement).replace(`__HMR_HOSTNAME__`, hmrHostnameReplacement).replace(`__HMR_PORT__`, hmrPortReplacement).replace(`__HMR_DIRECT_TARGET__`, hmrDirectTargetReplacement).replace(`__HMR_BASE__`, hmrBaseReplacement).replace(`__HMR_TIMEOUT__`, hmrTimeoutReplacement).replace(`__HMR_ENABLE_OVERLAY__`, hmrEnableOverlayReplacement).replace(`__HMR_CONFIG_NAME__`, hmrConfigNameReplacement).replace(`__WS_TOKEN__`, wsTokenReplacement);
      };
    },
    async transform(code, id, options) {
      const ssr = options?.ssr ?? this.environment.config.consumer === "server";
      if (id === normalizedClientEntry || id === normalizedEnvEntry) {
        const defineReplacer = getDefineReplacer(this);
        return defineReplacer(injectConfigValues(code));
      } else if (!ssr && code.includes("process.env.NODE_ENV")) {
        const nodeEnv = this.environment.config.define?.["process.env.NODE_ENV"] || JSON.stringify(process.env.NODE_ENV || config.mode);
        return await replaceDefine(this.environment, code, id, {
          "process.env.NODE_ENV": nodeEnv,
          "global.process.env.NODE_ENV": nodeEnv,
          "globalThis.process.env.NODE_ENV": nodeEnv
        });
      }
    }
  };
}
function escapeReplacement(value) {
  const jsonValue = JSON.stringify(value);
  return () => jsonValue;
}

const wasmHelperId = "\0vite/wasm-helper.js";
const wasmInitRE = /(?<![?#].*)\.wasm\?init/;
const wasmHelper = async (opts = {}, url) => {
  let result;
  if (url.startsWith("data:")) {
    const urlContent = url.replace(/^data:.*?base64,/, "");
    let bytes;
    if (typeof Buffer === "function" && typeof Buffer.from === "function") {
      bytes = Buffer.from(urlContent, "base64");
    } else if (typeof atob === "function") {
      const binaryString = atob(urlContent);
      bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
    } else {
      throw new Error(
        "Failed to decode base64-encoded data URL, Buffer and atob are not supported"
      );
    }
    result = await WebAssembly.instantiate(bytes, opts);
  } else {
    const response = await fetch(url);
    const contentType = response.headers.get("Content-Type") || "";
    if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
      result = await WebAssembly.instantiateStreaming(response, opts);
    } else {
      const buffer = await response.arrayBuffer();
      result = await WebAssembly.instantiate(buffer, opts);
    }
  }
  return result.instance;
};
const wasmHelperCode = wasmHelper.toString();
const wasmHelperPlugin = () => {
  return {
    name: "vite:wasm-helper",
    resolveId: {
      handler(id) {
        if (id === wasmHelperId) {
          return id;
        }
      }
    },
    load: {
      async handler(id) {
        if (id === wasmHelperId) {
          return `export default ${wasmHelperCode}`;
        }
        if (!wasmInitRE.test(id)) {
          return;
        }
        const url = await fileToUrl$1(this, id);
        return `
  import initWasm from "${wasmHelperId}"
  export default opts => initWasm(opts, ${JSON.stringify(url)})
  `;
      }
    }
  };
};
const wasmFallbackPlugin = () => {
  return {
    name: "vite:wasm-fallback",
    load: {
      handler(id) {
        if (!id.endsWith(".wasm")) {
          return;
        }
        throw new Error(
          '"ESM integration proposal for Wasm" is not supported currently. Use vite-plugin-wasm or other community plugins to handle this. Alternatively, you can use `.wasm?init` or `.wasm?url`. See https://vite.dev/guide/features.html#webassembly for more details.'
        );
      }
    }
  };
};

function err(e, pos) {
  const error = new Error(e);
  error.pos = pos;
  return error;
}
function findClosingParen(input, fromIndex) {
  let count = 1;
  for (let i = fromIndex; i < input.length; i++) {
    if (input[i] === "(") count++;
    if (input[i] === ")") count--;
    if (count === 0) return i;
  }
  return -1;
}
function extractWorkerTypeFromAst(expression, optsStartIndex) {
  if (expression.type !== "ObjectExpression") {
    return;
  }
  let lastSpreadElementIndex = -1;
  let typeProperty = null;
  let typePropertyIndex = -1;
  for (let i = 0; i < expression.properties.length; i++) {
    const property = expression.properties[i];
    if (property.type === "SpreadElement") {
      lastSpreadElementIndex = i;
      continue;
    }
    if (property.type === "Property" && (property.key.type === "Identifier" && property.key.name === "type" || property.key.type === "Literal" && property.key.value === "type")) {
      typeProperty = property;
      typePropertyIndex = i;
    }
  }
  if (typePropertyIndex === -1 && lastSpreadElementIndex === -1) {
    return "classic";
  }
  if (typePropertyIndex < lastSpreadElementIndex) {
    throw err(
      "Expected object spread to be used before the definition of the type property. Vite needs a static value for the type property to correctly infer it.",
      optsStartIndex
    );
  }
  if (typeProperty?.value.type !== "Literal") {
    throw err(
      "Expected worker options type property to be a literal value.",
      optsStartIndex
    );
  }
  return typeProperty?.value.value === "module" ? "module" : "classic";
}
async function parseWorkerOptions(rawOpts, optsStartIndex) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    const optsNode = (await parseAstAsync(`(${rawOpts})`)).body[0].expression;
    const type = extractWorkerTypeFromAst(optsNode, optsStartIndex);
    if (type) {
      return { type };
    }
    throw err(
      "Vite is unable to parse the worker options as the value is not static. To ignore this error, please use /* @vite-ignore */ in the worker options.",
      optsStartIndex
    );
  }
  if (opts == null) {
    return {};
  }
  if (typeof opts !== "object") {
    throw err(
      `Expected worker options to be an object, got ${typeof opts}`,
      optsStartIndex
    );
  }
  return opts;
}
async function getWorkerType(raw, clean, i) {
  const commaIndex = clean.indexOf(",", i);
  if (commaIndex === -1) {
    return "classic";
  }
  const endIndex = findClosingParen(clean, i);
  if (commaIndex > endIndex) {
    return "classic";
  }
  let workerOptString = raw.substring(commaIndex + 1, endIndex);
  const hasViteIgnore = hasViteIgnoreRE.test(workerOptString);
  if (hasViteIgnore) {
    return "ignore";
  }
  const cleanWorkerOptString = clean.substring(commaIndex + 1, endIndex);
  const trimmedCleanWorkerOptString = cleanWorkerOptString.trim();
  if (!trimmedCleanWorkerOptString.length) {
    return "classic";
  }
  if (trimmedCleanWorkerOptString.endsWith(",")) {
    workerOptString = workerOptString.slice(
      0,
      cleanWorkerOptString.lastIndexOf(",")
    );
  }
  const workerOpts = await parseWorkerOptions(workerOptString, commaIndex + 1);
  if (workerOpts.type && (workerOpts.type === "module" || workerOpts.type === "classic")) {
    return workerOpts.type;
  }
  return "classic";
}
function isIncludeWorkerImportMetaUrl(code) {
  if ((code.includes("new Worker") || code.includes("new SharedWorker")) && code.includes("new URL") && code.includes(`import.meta.url`)) {
    return true;
  }
  return false;
}
function workerImportMetaUrlPlugin(config) {
  const isBuild = config.command === "build";
  let workerResolver;
  const fsResolveOptions = {
    ...config.resolve,
    root: config.root,
    isProduction: config.isProduction,
    isBuild: config.command === "build",
    packageCache: config.packageCache,
    asSrc: true
  };
  return {
    name: "vite:worker-import-meta-url",
    applyToEnvironment(environment) {
      return environment.config.consumer === "client";
    },
    shouldTransformCachedModule({ code }) {
      if (isBuild && config.build.watch && isIncludeWorkerImportMetaUrl(code)) {
        return true;
      }
    },
    transform: {
      async handler(code, id) {
        if (isIncludeWorkerImportMetaUrl(code)) {
          let s;
          const cleanString = stripLiteral(code);
          const workerImportMetaUrlRE = /\bnew\s+(?:Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/dg;
          let match;
          while (match = workerImportMetaUrlRE.exec(cleanString)) {
            const [[, endIndex], [expStart, expEnd], [urlStart, urlEnd]] = match.indices;
            const rawUrl = code.slice(urlStart, urlEnd);
            if (rawUrl[0] === "`" && rawUrl.includes("${")) {
              this.error(
                `\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`,
                expStart
              );
            }
            s ||= new MagicString(code);
            const workerType = await getWorkerType(code, cleanString, endIndex);
            const url = rawUrl.slice(1, -1);
            let file;
            if (url[0] === ".") {
              file = path$b.resolve(path$b.dirname(id), url);
              file = slash$1(tryFsResolve(file, fsResolveOptions) ?? file);
            } else {
              workerResolver ??= createBackCompatIdResolver(config, {
                extensions: [],
                tryIndex: false,
                preferRelative: true
              });
              file = await workerResolver(this.environment, url, id);
              file ??= url[0] === "/" ? slash$1(path$b.join(config.publicDir, url)) : slash$1(path$b.resolve(path$b.dirname(id), url));
            }
            if (isBuild && config.isWorker && config.bundleChain.at(-1) === cleanUrl(file)) {
              s.update(expStart, expEnd, "self.location.href");
            } else {
              let builtUrl;
              if (isBuild) {
                builtUrl = await workerFileToUrl(config, file);
              } else {
                builtUrl = await fileToUrl$1(this, cleanUrl(file));
                builtUrl = injectQuery(
                  builtUrl,
                  `${WORKER_FILE_ID}&type=${workerType}`
                );
              }
              s.update(
                expStart,
                expEnd,
                `new URL(/* @vite-ignore */ ${JSON.stringify(builtUrl)}, import.meta.url)`
              );
            }
          }
          if (s) {
            return transformStableResult(s, id, config);
          }
          return null;
        }
      }
    }
  };
}

function assetImportMetaUrlPlugin(config) {
  const { publicDir } = config;
  let assetResolver;
  const fsResolveOptions = {
    ...config.resolve,
    root: config.root,
    isProduction: config.isProduction,
    isBuild: config.command === "build",
    packageCache: config.packageCache,
    asSrc: true
  };
  return {
    name: "vite:asset-import-meta-url",
    applyToEnvironment(environment) {
      return environment.config.consumer === "client";
    },
    transform: {
      async handler(code, id) {
        if (id !== preloadHelperId && id !== CLIENT_ENTRY && code.includes("new URL") && code.includes(`import.meta.url`)) {
          let s;
          const assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*(?:,\s*)?\)/dg;
          const cleanString = stripLiteral(code);
          let match;
          while (match = assetImportMetaUrlRE.exec(cleanString)) {
            const [[startIndex, endIndex], [urlStart, urlEnd]] = match.indices;
            if (hasViteIgnoreRE.test(code.slice(startIndex, urlStart))) continue;
            const rawUrl = code.slice(urlStart, urlEnd);
            if (!s) s = new MagicString(code);
            if (rawUrl[0] === "`" && rawUrl.includes("${")) {
              const queryDelimiterIndex = getQueryDelimiterIndex(rawUrl);
              const hasQueryDelimiter = queryDelimiterIndex !== -1;
              const pureUrl = hasQueryDelimiter ? rawUrl.slice(0, queryDelimiterIndex) + "`" : rawUrl;
              const queryString = hasQueryDelimiter ? rawUrl.slice(queryDelimiterIndex, -1) : "";
              const ast = this.parse(pureUrl);
              const templateLiteral = ast.body[0].expression;
              if (templateLiteral.expressions.length) {
                const pattern = buildGlobPattern(templateLiteral);
                if (pattern.startsWith("*")) {
                  continue;
                }
                const globOptions = {
                  eager: true,
                  import: "default",
                  // A hack to allow 'as' & 'query' exist at the same time
                  query: injectQuery(queryString, "url")
                };
                s.update(
                  startIndex,
                  endIndex,
                  `new URL((import.meta.glob(${JSON.stringify(
                    pattern
                  )}, ${JSON.stringify(
                    globOptions
                  )}))[${pureUrl}], import.meta.url)`
                );
                continue;
              }
            }
            const url = rawUrl.slice(1, -1);
            if (isDataUrl(url)) {
              continue;
            }
            let file;
            if (url[0] === ".") {
              file = slash$1(path$b.resolve(path$b.dirname(id), url));
              file = tryFsResolve(file, fsResolveOptions) ?? file;
            } else {
              assetResolver ??= createBackCompatIdResolver(config, {
                extensions: [],
                mainFields: [],
                tryIndex: false,
                preferRelative: true
              });
              file = await assetResolver(this.environment, url, id);
              file ??= url[0] === "/" ? slash$1(path$b.join(publicDir, url)) : slash$1(path$b.resolve(path$b.dirname(id), url));
            }
            let builtUrl;
            if (file) {
              try {
                if (publicDir && isParentDirectory(publicDir, file)) {
                  const publicPath = "/" + path$b.posix.relative(publicDir, file);
                  builtUrl = await fileToUrl$1(this, publicPath);
                } else {
                  builtUrl = await fileToUrl$1(this, file);
                }
              } catch {
              }
            }
            if (!builtUrl) {
              const rawExp = code.slice(startIndex, endIndex);
              config.logger.warnOnce(
                `
${rawExp} doesn't exist at build time, it will remain unchanged to be resolved at runtime. If this is intended, you can use the /* @vite-ignore */ comment to suppress this warning.`
              );
              builtUrl = url;
            }
            s.update(
              startIndex,
              endIndex,
              `new URL(${JSON.stringify(builtUrl)}, import.meta.url)`
            );
          }
          if (s) {
            return transformStableResult(s, id, config);
          }
        }
        return null;
      }
    }
  };
}
function buildGlobPattern(ast) {
  let pattern = "";
  let lastIsGlob = false;
  for (let i = 0; i < ast.quasis.length; i++) {
    const str = ast.quasis[i].value.raw;
    if (str) {
      pattern += str;
      lastIsGlob = false;
    }
    if (ast.expressions[i] && !lastIsGlob) {
      pattern += "*";
      lastIsGlob = true;
    }
  }
  return pattern;
}
function getQueryDelimiterIndex(rawUrl) {
  let bracketsStack = 0;
  for (let i = 0; i < rawUrl.length; i++) {
    if (rawUrl[i] === "{") {
      bracketsStack++;
    } else if (rawUrl[i] === "}") {
      bracketsStack--;
    } else if (rawUrl[i] === "?" && bracketsStack === 0) {
      return i;
    }
  }
  return -1;
}

function metadataPlugin() {
  return {
    name: "vite:build-metadata",
    async renderChunk(_code, chunk) {
      chunk.viteMetadata = {
        importedAssets: /* @__PURE__ */ new Set(),
        importedCss: /* @__PURE__ */ new Set()
      };
      return null;
    }
  };
}

class VariableDynamicImportError extends Error {}

/* eslint-disable-next-line no-template-curly-in-string */
const example = 'For example: import(`./foo/${bar}.js`).';

function sanitizeString(str) {
  if (str === '') return str;
  if (str.includes('*')) {
    throw new VariableDynamicImportError('A dynamic import cannot contain * characters.');
  }
  return escapePath(str);
}

function templateLiteralToGlob(node) {
  let glob = '';

  for (let i = 0; i < node.quasis.length; i += 1) {
    glob += sanitizeString(node.quasis[i].value.raw);
    if (node.expressions[i]) {
      glob += expressionToGlob(node.expressions[i]);
    }
  }

  return glob;
}

function callExpressionToGlob(node) {
  const { callee } = node;
  if (
    callee.type === 'MemberExpression' &&
    callee.property.type === 'Identifier' &&
    callee.property.name === 'concat'
  ) {
    return `${expressionToGlob(callee.object)}${node.arguments.map(expressionToGlob).join('')}`;
  }
  return '*';
}

function binaryExpressionToGlob(node) {
  if (node.operator !== '+') {
    throw new VariableDynamicImportError(`${node.operator} operator is not supported.`);
  }

  return `${expressionToGlob(node.left)}${expressionToGlob(node.right)}`;
}

function expressionToGlob(node) {
  switch (node.type) {
    case 'TemplateLiteral':
      return templateLiteralToGlob(node);
    case 'CallExpression':
      return callExpressionToGlob(node);
    case 'BinaryExpression':
      return binaryExpressionToGlob(node);
    case 'Literal': {
      return sanitizeString(node.value);
    }
    default:
      return '*';
  }
}

const defaultProtocol = 'file:';
const ignoredProtocols = ['data:', 'http:', 'https:'];

function shouldIgnore(glob) {
  const containsAsterisk = glob.includes('*');

  const globURL = new URL(glob, defaultProtocol);

  const containsIgnoredProtocol = ignoredProtocols.some(
    (ignoredProtocol) => ignoredProtocol === globURL.protocol
  );

  return !containsAsterisk || containsIgnoredProtocol;
}

function dynamicImportToGlob(node, sourceString) {
  let glob = expressionToGlob(node);

  if (shouldIgnore(glob)) {
    return null;
  }

  glob = glob.replace(/\*\*/g, '*');

  if (glob.startsWith('*')) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`
    );
  }

  if (glob.startsWith('/')) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }

  if (!glob.startsWith('./') && !glob.startsWith('../')) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }

  // Disallow ./*.ext
  const ownDirectoryStarExtension = /^\.\/\*\.\w+$/;
  if (ownDirectoryStarExtension.test(glob)) {
    throw new VariableDynamicImportError(
      `${
        `invalid import "${sourceString}". Variable imports cannot import their own directory, ` +
        'place imports in a separate directory or make the import filename more specific. '
      }${example}`
    );
  }

  if (require$$0$2.extname(glob) === '') {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`
    );
  }

  return glob;
}

const dynamicImportHelperId = "\0vite/dynamic-import-helper.js";
const relativePathRE = /^\.{1,2}\//;
const hasDynamicImportRE = /\bimport\s*[(/]/;
const dynamicImportHelper = (glob, path, segs) => {
  const v = glob[path];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
      reject.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
function parseDynamicImportPattern(strings) {
  const filename = strings.slice(1, -1);
  const ast = parseAst(strings).body[0].expression;
  const userPatternQuery = dynamicImportToGlob(ast, filename);
  if (!userPatternQuery) {
    return null;
  }
  const [userPattern] = userPatternQuery.split(
    // ? is escaped on posix OS
    requestQueryMaybeEscapedSplitRE,
    2
  );
  let [rawPattern, search] = filename.split(requestQuerySplitRE, 2);
  let globParams = null;
  if (search) {
    search = "?" + search;
    if (workerOrSharedWorkerRE.test(search) || urlRE$1.test(search) || rawRE$1.test(search)) {
      globParams = {
        query: search,
        import: "*"
      };
    } else {
      globParams = {
        query: search
      };
    }
  }
  return {
    globParams,
    userPattern,
    rawPattern
  };
}
async function transformDynamicImport(importSource, importer, resolve, root) {
  if (importSource[1] !== "." && importSource[1] !== "/") {
    const resolvedFileName = await resolve(importSource.slice(1, -1), importer);
    if (!resolvedFileName) {
      return null;
    }
    const relativeFileName = normalizePath$3(
      posix$1.relative(
        posix$1.dirname(normalizePath$3(importer)),
        normalizePath$3(resolvedFileName)
      )
    );
    importSource = "`" + (relativeFileName[0] === "." ? "" : "./") + relativeFileName + "`";
  }
  const dynamicImportPattern = parseDynamicImportPattern(importSource);
  if (!dynamicImportPattern) {
    return null;
  }
  const { globParams, rawPattern, userPattern } = dynamicImportPattern;
  const params = globParams ? `, ${JSON.stringify(globParams)}` : "";
  const dir = importer ? posix$1.dirname(importer) : root;
  const normalized = rawPattern[0] === "/" ? posix$1.join(root, rawPattern.slice(1)) : posix$1.join(dir, rawPattern);
  let newRawPattern = posix$1.relative(posix$1.dirname(importer), normalized);
  if (!relativePathRE.test(newRawPattern)) {
    newRawPattern = `./${newRawPattern}`;
  }
  const exp = `(import.meta.glob(${JSON.stringify(userPattern)}${params}))`;
  return {
    rawPattern: newRawPattern,
    pattern: userPattern,
    glob: exp
  };
}
function dynamicImportVarsPlugin(config) {
  const resolve = createBackCompatIdResolver(config, {
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  const getFilter = perEnvironmentState((environment) => {
    const { include, exclude } = environment.config.build.dynamicImportVarsOptions;
    return createFilter$1(include, exclude);
  });
  return {
    name: "vite:dynamic-import-vars",
    resolveId: {
      handler(id) {
        if (id === dynamicImportHelperId) {
          return id;
        }
      }
    },
    load: {
      handler(id) {
        if (id === dynamicImportHelperId) {
          return `export default ${dynamicImportHelper.toString()}`;
        }
      }
    },
    transform: {
      async handler(source, importer) {
        const { environment } = this;
        if (!getFilter(this)(importer) || importer === CLIENT_ENTRY || !hasDynamicImportRE.test(source)) {
          return;
        }
        await init;
        let imports = [];
        try {
          imports = parse$d(source)[0];
        } catch {
          return null;
        }
        if (!imports.length) {
          return null;
        }
        let s;
        let needDynamicImportHelper = false;
        for (let index = 0; index < imports.length; index++) {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex
          } = imports[index];
          if (dynamicIndex === -1 || source[start] !== "`") {
            continue;
          }
          if (hasViteIgnoreRE.test(source.slice(expStart, expEnd))) {
            continue;
          }
          s ||= new MagicString(source);
          let result;
          try {
            result = await transformDynamicImport(
              source.slice(start, end),
              importer,
              (id, importer2) => resolve(environment, id, importer2),
              config.root
            );
          } catch (error) {
            if (environment.config.build.dynamicImportVarsOptions.warnOnError) {
              this.warn(error);
            } else {
              this.error(error);
            }
          }
          if (!result) {
            continue;
          }
          const { rawPattern, glob } = result;
          needDynamicImportHelper = true;
          s.overwrite(
            expStart,
            expEnd,
            `__variableDynamicImportRuntimeHelper(${glob}, \`${rawPattern}\`, ${rawPattern.split("/").length})`
          );
        }
        if (s) {
          if (needDynamicImportHelper) {
            s.prepend(
              `import __variableDynamicImportRuntimeHelper from "${dynamicImportHelperId}";`
            );
          }
          return transformStableResult(s, importer, config);
        }
      }
    }
  };
}

function getMatcherString(glob, cwd) {
  if (glob.startsWith("**") || path$b.isAbsolute(glob)) {
    return slash$1(glob);
  }
  const resolved = path$b.join(cwd, glob);
  return slash$1(resolved);
}
function patternToIdFilter(pattern, cwd) {
  if (pattern instanceof RegExp) {
    return (id) => {
      const normalizedId = slash$1(id);
      const result = pattern.test(normalizedId);
      pattern.lastIndex = 0;
      return result;
    };
  }
  const glob = getMatcherString(pattern, cwd);
  const matcher = picomatch$2(glob, { dot: true });
  return (id) => {
    const normalizedId = slash$1(id);
    return matcher(normalizedId);
  };
}
function patternToCodeFilter(pattern) {
  if (pattern instanceof RegExp) {
    return (code) => {
      const result = pattern.test(code);
      pattern.lastIndex = 0;
      return result;
    };
  }
  return (code) => code.includes(pattern);
}
function createFilter(exclude, include) {
  if (!exclude && !include) {
    return;
  }
  return (input) => {
    if (exclude?.some((filter) => filter(input))) {
      return false;
    }
    if (include?.some((filter) => filter(input))) {
      return true;
    }
    return !(include && include.length > 0);
  };
}
function normalizeFilter(filter) {
  if (typeof filter === "string" || filter instanceof RegExp) {
    return {
      include: [filter]
    };
  }
  if (Array.isArray(filter)) {
    return {
      include: filter
    };
  }
  return {
    include: filter.include ? arraify(filter.include) : void 0,
    exclude: filter.exclude ? arraify(filter.exclude) : void 0
  };
}
function createIdFilter(filter, cwd = process.cwd()) {
  if (!filter) return;
  const { exclude, include } = normalizeFilter(filter);
  const excludeFilter = exclude?.map((p) => patternToIdFilter(p, cwd));
  const includeFilter = include?.map((p) => patternToIdFilter(p, cwd));
  return createFilter(excludeFilter, includeFilter);
}
function createCodeFilter(filter) {
  if (!filter) return;
  const { exclude, include } = normalizeFilter(filter);
  const excludeFilter = exclude?.map(patternToCodeFilter);
  const includeFilter = include?.map(patternToCodeFilter);
  return createFilter(excludeFilter, includeFilter);
}
function createFilterForTransform(idFilter, codeFilter, cwd) {
  if (!idFilter && !codeFilter) return;
  const idFilterFn = createIdFilter(idFilter, cwd);
  const codeFilterFn = createCodeFilter(codeFilter);
  return (id, code) => {
    let fallback = true;
    if (idFilterFn) {
      fallback &&= idFilterFn(id);
    }
    if (!fallback) {
      return false;
    }
    if (codeFilterFn) {
      fallback &&= codeFilterFn(code);
    }
    return fallback;
  };
}

async function resolvePlugins(config, prePlugins, normalPlugins, postPlugins) {
  const isBuild = config.command === "build";
  const isWorker = config.isWorker;
  const buildPlugins = isBuild ? await (await Promise.resolve().then(function () { return build$1; })).resolveBuildPlugins(config) : { pre: [], post: [] };
  const { modulePreload } = config.build;
  return [
    !isBuild ? optimizedDepsPlugin() : null,
    isBuild ? metadataPlugin() : null,
    !isWorker ? watchPackageDataPlugin(config.packageCache) : null,
    !isBuild ? preAliasPlugin(config) : null,
    alias$1({
      entries: config.resolve.alias,
      customResolver: viteAliasCustomResolver
    }),
    ...prePlugins,
    modulePreload !== false && modulePreload.polyfill ? modulePreloadPolyfillPlugin(config) : null,
    resolvePlugin({
      root: config.root,
      isProduction: config.isProduction,
      isBuild,
      packageCache: config.packageCache,
      asSrc: true,
      optimizeDeps: true,
      externalize: true
    }),
    htmlInlineProxyPlugin(config),
    cssPlugin(config),
    config.esbuild !== false ? esbuildPlugin(config) : null,
    jsonPlugin(config.json, isBuild),
    wasmHelperPlugin(),
    webWorkerPlugin(config),
    assetPlugin(config),
    ...normalPlugins,
    wasmFallbackPlugin(),
    definePlugin(config),
    cssPostPlugin(config),
    isBuild && buildHtmlPlugin(config),
    workerImportMetaUrlPlugin(config),
    assetImportMetaUrlPlugin(config),
    ...buildPlugins.pre,
    dynamicImportVarsPlugin(config),
    importGlobPlugin(config),
    ...postPlugins,
    ...buildPlugins.post,
    // internal server-only plugins are always applied after everything else
    ...isBuild ? [] : [
      clientInjectionsPlugin(config),
      cssAnalysisPlugin(config),
      importAnalysisPlugin(config)
    ]
  ].filter(Boolean);
}
function createPluginHookUtils(plugins) {
  const sortedPluginsCache = /* @__PURE__ */ new Map();
  function getSortedPlugins(hookName) {
    if (sortedPluginsCache.has(hookName))
      return sortedPluginsCache.get(hookName);
    const sorted = getSortedPluginsByHook(hookName, plugins);
    sortedPluginsCache.set(hookName, sorted);
    return sorted;
  }
  function getSortedPluginHooks(hookName) {
    const plugins2 = getSortedPlugins(hookName);
    return plugins2.map((p) => getHookHandler(p[hookName])).filter(Boolean);
  }
  return {
    getSortedPlugins,
    getSortedPluginHooks
  };
}
function getSortedPluginsByHook(hookName, plugins) {
  const sortedPlugins = [];
  let pre = 0, normal = 0, post = 0;
  for (const plugin of plugins) {
    const hook = plugin[hookName];
    if (hook) {
      if (typeof hook === "object") {
        if (hook.order === "pre") {
          sortedPlugins.splice(pre++, 0, plugin);
          continue;
        }
        if (hook.order === "post") {
          sortedPlugins.splice(pre + normal + post++, 0, plugin);
          continue;
        }
      }
      sortedPlugins.splice(pre + normal++, 0, plugin);
    }
  }
  return sortedPlugins;
}
function getHookHandler(hook) {
  return typeof hook === "object" ? hook.handler : hook;
}
const filterForPlugin = /* @__PURE__ */ new WeakMap();
function getCachedFilterForPlugin(plugin, hookName) {
  let filters = filterForPlugin.get(plugin);
  if (filters && hookName in filters) {
    return filters[hookName];
  }
  if (!filters) {
    filters = {};
    filterForPlugin.set(plugin, filters);
  }
  let filter;
  switch (hookName) {
    case "resolveId": {
      const rawFilter = typeof plugin.resolveId === "object" ? plugin.resolveId.filter?.id : void 0;
      filters.resolveId = createIdFilter(rawFilter);
      filter = filters.resolveId;
      break;
    }
    case "load": {
      const rawFilter = typeof plugin.load === "object" ? plugin.load.filter?.id : void 0;
      filters.load = createIdFilter(rawFilter);
      filter = filters.load;
      break;
    }
    case "transform": {
      const rawFilters = typeof plugin.transform === "object" ? plugin.transform.filter : void 0;
      filters.transform = createFilterForTransform(
        rawFilters?.id,
        rawFilters?.code
      );
      filter = filters.transform;
      break;
    }
  }
  return filter;
}
const viteAliasCustomResolver = async function(id, importer, options) {
  const resolved = await this.resolve(id, importer, options);
  return resolved || { id, meta: { "vite:alias": { noResolved: true } } };
};

const EMPTY_OBJECT = Object.freeze({});
const debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
const debugSourcemapCombine = createDebugger("vite:sourcemap-combine", {
  onlyWhenFocused: true
});
const debugResolve = createDebugger("vite:resolve");
const debugPluginResolve = createDebugger("vite:plugin-resolve", {
  onlyWhenFocused: "vite:plugin"
});
const debugPluginTransform = createDebugger("vite:plugin-transform", {
  onlyWhenFocused: "vite:plugin"
});
const debugPluginContainerContext = createDebugger(
  "vite:plugin-container-context"
);
const ERR_CLOSED_SERVER = "ERR_CLOSED_SERVER";
function throwClosedServerError() {
  const err = new Error(
    "The server is being restarted or closed. Request is outdated"
  );
  err.code = ERR_CLOSED_SERVER;
  throw err;
}
async function createEnvironmentPluginContainer(environment, plugins, watcher, autoStart = true) {
  const container = new EnvironmentPluginContainer(
    environment,
    plugins,
    watcher,
    autoStart
  );
  await container.resolveRollupOptions();
  return container;
}
class EnvironmentPluginContainer {
  /**
   * @internal use `createEnvironmentPluginContainer` instead
   */
  constructor(environment, plugins, watcher, autoStart = true) {
    this.environment = environment;
    this.plugins = plugins;
    this.watcher = watcher;
    this._started = !autoStart;
    this.minimalContext = new MinimalPluginContext(
      { rollupVersion, watchMode: true },
      environment
    );
    const utils = createPluginHookUtils(plugins);
    this.getSortedPlugins = utils.getSortedPlugins;
    this.getSortedPluginHooks = utils.getSortedPluginHooks;
    this.moduleGraph = environment.mode === "dev" ? environment.moduleGraph : void 0;
  }
  _pluginContextMap = /* @__PURE__ */ new Map();
  _resolvedRollupOptions;
  _processesing = /* @__PURE__ */ new Set();
  _seenResolves = {};
  // _addedFiles from the `load()` hook gets saved here so it can be reused in the `transform()` hook
  _moduleNodeToLoadAddedImports = /* @__PURE__ */ new WeakMap();
  getSortedPluginHooks;
  getSortedPlugins;
  moduleGraph;
  watchFiles = /* @__PURE__ */ new Set();
  minimalContext;
  _started = false;
  _buildStartPromise;
  _closed = false;
  _updateModuleLoadAddedImports(id, addedImports) {
    const module = this.moduleGraph?.getModuleById(id);
    if (module) {
      this._moduleNodeToLoadAddedImports.set(module, addedImports);
    }
  }
  _getAddedImports(id) {
    const module = this.moduleGraph?.getModuleById(id);
    return module ? this._moduleNodeToLoadAddedImports.get(module) || null : null;
  }
  getModuleInfo(id) {
    const module = this.moduleGraph?.getModuleById(id);
    if (!module) {
      return null;
    }
    if (!module.info) {
      module.info = new Proxy(
        { id, meta: module.meta || EMPTY_OBJECT },
        // throw when an unsupported ModuleInfo property is accessed,
        // so that incompatible plugins fail in a non-cryptic way.
        {
          get(info, key) {
            if (key in info) {
              return info[key];
            }
            if (key === "then") {
              return void 0;
            }
            throw Error(
              `[vite] The "${key}" property of ModuleInfo is not supported.`
            );
          }
        }
      );
    }
    return module.info ?? null;
  }
  // keeps track of hook promises so that we can wait for them all to finish upon closing the server
  handleHookPromise(maybePromise) {
    if (!maybePromise?.then) {
      return maybePromise;
    }
    const promise = maybePromise;
    this._processesing.add(promise);
    return promise.finally(() => this._processesing.delete(promise));
  }
  get options() {
    return this._resolvedRollupOptions;
  }
  async resolveRollupOptions() {
    if (!this._resolvedRollupOptions) {
      let options = this.environment.config.build.rollupOptions;
      for (const optionsHook of this.getSortedPluginHooks("options")) {
        if (this._closed) {
          throwClosedServerError();
        }
        options = await this.handleHookPromise(
          optionsHook.call(this.minimalContext, options)
        ) || options;
      }
      this._resolvedRollupOptions = options;
    }
    return this._resolvedRollupOptions;
  }
  _getPluginContext(plugin) {
    if (!this._pluginContextMap.has(plugin)) {
      this._pluginContextMap.set(plugin, new PluginContext(plugin, this));
    }
    return this._pluginContextMap.get(plugin);
  }
  // parallel, ignores returns
  async hookParallel(hookName, context, args, condition) {
    const parallelPromises = [];
    for (const plugin of this.getSortedPlugins(hookName)) {
      if (condition && !condition(plugin)) continue;
      const hook = plugin[hookName];
      const handler = getHookHandler(hook);
      if (hook.sequential) {
        await Promise.all(parallelPromises);
        parallelPromises.length = 0;
        await handler.apply(context(plugin), args(plugin));
      } else {
        parallelPromises.push(handler.apply(context(plugin), args(plugin)));
      }
    }
    await Promise.all(parallelPromises);
  }
  async buildStart(_options) {
    if (this._started) {
      if (this._buildStartPromise) {
        await this._buildStartPromise;
      }
      return;
    }
    this._started = true;
    const config = this.environment.getTopLevelConfig();
    this._buildStartPromise = this.handleHookPromise(
      this.hookParallel(
        "buildStart",
        (plugin) => this._getPluginContext(plugin),
        () => [this.options],
        (plugin) => this.environment.name === "client" || config.server.perEnvironmentStartEndDuringDev || plugin.perEnvironmentStartEndDuringDev
      )
    );
    await this._buildStartPromise;
    this._buildStartPromise = void 0;
  }
  async resolveId(rawId, importer = join$1(
    this.environment.config.root,
    "index.html"
  ), options) {
    if (!this._started) {
      this.buildStart();
      await this._buildStartPromise;
    }
    const skip = options?.skip;
    const skipCalls = options?.skipCalls;
    const scan = !!options?.scan;
    const ssr = this.environment.config.consumer === "server";
    const ctx = new ResolveIdContext(this, skip, skipCalls, scan);
    const mergedSkip = new Set(skip);
    for (const call of skipCalls ?? []) {
      if (call.called || call.id === rawId && call.importer === importer) {
        mergedSkip.add(call.plugin);
      }
    }
    const resolveStart = debugResolve ? performance$1.now() : 0;
    let id = null;
    const partial = {};
    for (const plugin of this.getSortedPlugins("resolveId")) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError();
      if (mergedSkip?.has(plugin)) continue;
      const filter = getCachedFilterForPlugin(plugin, "resolveId");
      if (filter && !filter(rawId)) continue;
      ctx._plugin = plugin;
      const pluginResolveStart = debugPluginResolve ? performance$1.now() : 0;
      const handler = getHookHandler(plugin.resolveId);
      const result = await this.handleHookPromise(
        handler.call(ctx, rawId, importer, {
          attributes: options?.attributes ?? {},
          custom: options?.custom,
          isEntry: !!options?.isEntry,
          ssr,
          scan
        })
      );
      if (!result) continue;
      if (typeof result === "string") {
        id = result;
      } else {
        id = result.id;
        Object.assign(partial, result);
      }
      debugPluginResolve?.(
        timeFrom(pluginResolveStart),
        plugin.name,
        prettifyUrl(id, this.environment.config.root)
      );
      break;
    }
    if (debugResolve && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
      const key = rawId + id;
      if (!this._seenResolves[key]) {
        this._seenResolves[key] = true;
        debugResolve(
          `${timeFrom(resolveStart)} ${colors$1.cyan(rawId)} -> ${colors$1.dim(
            id
          )}`
        );
      }
    }
    if (id) {
      partial.id = isExternalUrl(id) ? id : normalizePath$3(id);
      return partial;
    } else {
      return null;
    }
  }
  async load(id) {
    const ssr = this.environment.config.consumer === "server";
    const options = { ssr };
    const ctx = new LoadPluginContext(this);
    for (const plugin of this.getSortedPlugins("load")) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError();
      const filter = getCachedFilterForPlugin(plugin, "load");
      if (filter && !filter(id)) continue;
      ctx._plugin = plugin;
      const handler = getHookHandler(plugin.load);
      const result = await this.handleHookPromise(
        handler.call(ctx, id, options)
      );
      if (result != null) {
        if (isObject$1(result)) {
          ctx._updateModuleInfo(id, result);
        }
        this._updateModuleLoadAddedImports(id, ctx._addedImports);
        return result;
      }
    }
    this._updateModuleLoadAddedImports(id, ctx._addedImports);
    return null;
  }
  async transform(code, id, options) {
    const ssr = this.environment.config.consumer === "server";
    const optionsWithSSR = options ? { ...options, ssr } : { ssr };
    const inMap = options?.inMap;
    const ctx = new TransformPluginContext(this, id, code, inMap);
    ctx._addedImports = this._getAddedImports(id);
    for (const plugin of this.getSortedPlugins("transform")) {
      if (this._closed && this.environment.config.dev.recoverable)
        throwClosedServerError();
      const filter = getCachedFilterForPlugin(plugin, "transform");
      if (filter && !filter(id, code)) continue;
      ctx._updateActiveInfo(plugin, id, code);
      const start = debugPluginTransform ? performance$1.now() : 0;
      let result;
      const handler = getHookHandler(plugin.transform);
      try {
        result = await this.handleHookPromise(
          handler.call(ctx, code, id, optionsWithSSR)
        );
      } catch (e) {
        ctx.error(e);
      }
      if (!result) continue;
      debugPluginTransform?.(
        timeFrom(start),
        plugin.name,
        prettifyUrl(id, this.environment.config.root)
      );
      if (isObject$1(result)) {
        if (result.code !== void 0) {
          code = result.code;
          if (result.map) {
            if (debugSourcemapCombine) {
              result.map.name = plugin.name;
            }
            ctx.sourcemapChain.push(result.map);
          }
        }
        ctx._updateModuleInfo(id, result);
      } else {
        code = result;
      }
    }
    return {
      code,
      map: ctx._getCombinedSourcemap()
    };
  }
  async watchChange(id, change) {
    await this.hookParallel(
      "watchChange",
      (plugin) => this._getPluginContext(plugin),
      () => [id, change]
    );
  }
  async close() {
    if (this._closed) return;
    this._closed = true;
    await Promise.allSettled(Array.from(this._processesing));
    const config = this.environment.getTopLevelConfig();
    await this.hookParallel(
      "buildEnd",
      (plugin) => this._getPluginContext(plugin),
      () => [],
      (plugin) => this.environment.name === "client" || config.server.perEnvironmentStartEndDuringDev || plugin.perEnvironmentStartEndDuringDev
    );
    await this.hookParallel(
      "closeBundle",
      (plugin) => this._getPluginContext(plugin),
      () => []
    );
  }
}
class MinimalPluginContext {
  constructor(meta, environment) {
    this.meta = meta;
    this.environment = environment;
  }
  debug(rawLog) {
    const log = this._normalizeRawLog(rawLog);
    const msg = buildErrorMessage(log, [`debug: ${log.message}`], false);
    debugPluginContainerContext?.(msg);
  }
  info(rawLog) {
    const log = this._normalizeRawLog(rawLog);
    const msg = buildErrorMessage(log, [`info: ${log.message}`], false);
    this.environment.logger.info(msg, { clear: true, timestamp: true });
  }
  warn(rawLog) {
    const log = this._normalizeRawLog(rawLog);
    const msg = buildErrorMessage(
      log,
      [colors$1.yellow(`warning: ${log.message}`)],
      false
    );
    this.environment.logger.warn(msg, { clear: true, timestamp: true });
  }
  error(e) {
    const err = typeof e === "string" ? new Error(e) : e;
    throw err;
  }
  _normalizeRawLog(rawLog) {
    const logValue = typeof rawLog === "function" ? rawLog() : rawLog;
    return typeof logValue === "string" ? new Error(logValue) : logValue;
  }
}
class PluginContext extends MinimalPluginContext {
  constructor(_plugin, _container) {
    super(_container.minimalContext.meta, _container.environment);
    this._plugin = _plugin;
    this._container = _container;
  }
  ssr = false;
  _scan = false;
  _activeId = null;
  _activeCode = null;
  _resolveSkips;
  _resolveSkipCalls;
  parse(code, opts) {
    return parseAst(code, opts);
  }
  async resolve(id, importer, options) {
    let skipCalls;
    if (options?.skipSelf === false) {
      skipCalls = this._resolveSkipCalls;
    } else if (this._resolveSkipCalls) {
      const skipCallsTemp = [...this._resolveSkipCalls];
      const sameCallIndex = this._resolveSkipCalls.findIndex(
        (c) => c.id === id && c.importer === importer && c.plugin === this._plugin
      );
      if (sameCallIndex !== -1) {
        skipCallsTemp[sameCallIndex] = {
          ...skipCallsTemp[sameCallIndex],
          called: true
        };
      } else {
        skipCallsTemp.push({ id, importer, plugin: this._plugin });
      }
      skipCalls = skipCallsTemp;
    } else {
      skipCalls = [{ id, importer, plugin: this._plugin }];
    }
    let out = await this._container.resolveId(id, importer, {
      attributes: options?.attributes,
      custom: options?.custom,
      isEntry: !!options?.isEntry,
      skip: this._resolveSkips,
      skipCalls,
      scan: this._scan
    });
    if (typeof out === "string") out = { id: out };
    return out;
  }
  async load(options) {
    await this._container.moduleGraph?.ensureEntryFromUrl(unwrapId$1(options.id));
    this._updateModuleInfo(options.id, options);
    const loadResult = await this._container.load(options.id);
    const code = typeof loadResult === "object" ? loadResult?.code : loadResult;
    if (code != null) {
      await this._container.transform(code, options.id);
    }
    const moduleInfo = this.getModuleInfo(options.id);
    if (!moduleInfo) throw Error(`Failed to load module with id ${options.id}`);
    return moduleInfo;
  }
  getModuleInfo(id) {
    return this._container.getModuleInfo(id);
  }
  _updateModuleInfo(id, { meta }) {
    if (meta) {
      const moduleInfo = this.getModuleInfo(id);
      if (moduleInfo) {
        moduleInfo.meta = { ...moduleInfo.meta, ...meta };
      }
    }
  }
  getModuleIds() {
    return this._container.moduleGraph ? this._container.moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
  }
  addWatchFile(id) {
    this._container.watchFiles.add(id);
    if (this._container.watcher)
      ensureWatchedFile(
        this._container.watcher,
        id,
        this.environment.config.root
      );
  }
  getWatchFiles() {
    return [...this._container.watchFiles];
  }
  emitFile(_assetOrFile) {
    this._warnIncompatibleMethod(`emitFile`);
    return "";
  }
  setAssetSource() {
    this._warnIncompatibleMethod(`setAssetSource`);
  }
  getFileName() {
    this._warnIncompatibleMethod(`getFileName`);
    return "";
  }
  debug(log) {
    const err = this._formatLog(typeof log === "function" ? log() : log);
    super.debug(err);
  }
  info(log) {
    const err = this._formatLog(typeof log === "function" ? log() : log);
    super.info(err);
  }
  warn(log, position) {
    const err = this._formatLog(
      typeof log === "function" ? log() : log,
      position
    );
    super.warn(err);
  }
  error(e, position) {
    throw this._formatLog(e, position);
  }
  _formatLog(e, position) {
    const err = typeof e === "string" ? new Error(e) : e;
    if (err.pluginCode) {
      return err;
    }
    err.plugin = this._plugin.name;
    if (this._activeId && !err.id) err.id = this._activeId;
    if (this._activeCode) {
      err.pluginCode = this._activeCode;
      const pos = position ?? err.pos ?? err.position;
      if (pos != null) {
        let errLocation;
        try {
          errLocation = numberToPos(this._activeCode, pos);
        } catch (err2) {
          this.environment.logger.error(
            colors$1.red(
              `Error in error handler:
${err2.stack || err2.message}
`
            ),
            // print extra newline to separate the two errors
            { error: err2 }
          );
          throw err;
        }
        err.loc = err.loc || {
          file: err.id,
          ...errLocation
        };
        err.frame = err.frame || generateCodeFrame(this._activeCode, pos);
      } else if (err.loc) {
        if (!err.frame) {
          let code = this._activeCode;
          if (err.loc.file) {
            err.id = normalizePath$3(err.loc.file);
            try {
              code = fs__default.readFileSync(err.loc.file, "utf-8");
            } catch {
            }
          }
          err.frame = generateCodeFrame(code, err.loc);
        }
      } else if (err.line && err.column) {
        err.loc = {
          file: err.id,
          line: err.line,
          column: err.column
        };
        err.frame = err.frame || generateCodeFrame(this._activeCode, err.loc);
      }
      if (this instanceof TransformPluginContext && typeof err.loc?.line === "number" && typeof err.loc.column === "number") {
        const rawSourceMap = this._getCombinedSourcemap();
        if (rawSourceMap && "version" in rawSourceMap) {
          const traced = new TraceMap(rawSourceMap);
          const { source, line, column } = originalPositionFor$1(traced, {
            line: Number(err.loc.line),
            column: Number(err.loc.column)
          });
          if (source) {
            err.loc = { file: source, line, column };
          }
        }
      }
    } else if (err.loc) {
      if (!err.frame) {
        let code = err.pluginCode;
        if (err.loc.file) {
          err.id = normalizePath$3(err.loc.file);
          if (!code) {
            try {
              code = fs__default.readFileSync(err.loc.file, "utf-8");
            } catch {
            }
          }
        }
        if (code) {
          err.frame = generateCodeFrame(`${code}`, err.loc);
        }
      }
    }
    if (typeof err.loc?.column !== "number" && typeof err.loc?.line !== "number" && !err.loc?.file) {
      delete err.loc;
    }
    return err;
  }
  _warnIncompatibleMethod(method) {
    this.environment.logger.warn(
      colors$1.cyan(`[plugin:${this._plugin.name}] `) + colors$1.yellow(
        `context method ${colors$1.bold(
          `${method}()`
        )} is not supported in serve mode. This plugin is likely not vite-compatible.`
      )
    );
  }
}
class ResolveIdContext extends PluginContext {
  constructor(container, skip, skipCalls, scan) {
    super(null, container);
    this._resolveSkips = skip;
    this._resolveSkipCalls = skipCalls;
    this._scan = scan;
  }
}
class LoadPluginContext extends PluginContext {
  _addedImports = null;
  constructor(container) {
    super(null, container);
  }
  addWatchFile(id) {
    if (!this._addedImports) {
      this._addedImports = /* @__PURE__ */ new Set();
    }
    this._addedImports.add(id);
    super.addWatchFile(id);
  }
}
class TransformPluginContext extends LoadPluginContext {
  filename;
  originalCode;
  originalSourcemap = null;
  sourcemapChain = [];
  combinedMap = null;
  constructor(container, id, code, inMap) {
    super(container);
    this.filename = id;
    this.originalCode = code;
    if (inMap) {
      if (debugSourcemapCombine) {
        inMap.name = "$inMap";
      }
      this.sourcemapChain.push(inMap);
    }
  }
  _getCombinedSourcemap() {
    if (debugSourcemapCombine && debugSourcemapCombineFilter && this.filename.includes(debugSourcemapCombineFilter)) {
      debugSourcemapCombine("----------", this.filename);
      debugSourcemapCombine(this.combinedMap);
      debugSourcemapCombine(this.sourcemapChain);
      debugSourcemapCombine("----------");
    }
    let combinedMap = this.combinedMap;
    if (combinedMap && !("version" in combinedMap) && combinedMap.mappings === "") {
      this.sourcemapChain.length = 0;
      return combinedMap;
    }
    for (let m of this.sourcemapChain) {
      if (typeof m === "string") m = JSON.parse(m);
      if (!("version" in m)) {
        if (m.mappings === "") {
          combinedMap = { mappings: "" };
          break;
        }
        combinedMap = null;
        break;
      }
      if (!combinedMap) {
        const sm = m;
        if (sm.sources.length === 1 && !sm.sources[0]) {
          combinedMap = {
            ...sm,
            sources: [this.filename],
            sourcesContent: [this.originalCode]
          };
        } else {
          combinedMap = sm;
        }
      } else {
        combinedMap = combineSourcemaps(cleanUrl(this.filename), [
          m,
          combinedMap
        ]);
      }
    }
    if (combinedMap !== this.combinedMap) {
      this.combinedMap = combinedMap;
      this.sourcemapChain.length = 0;
    }
    return this.combinedMap;
  }
  getCombinedSourcemap() {
    const map = this._getCombinedSourcemap();
    if (!map || !("version" in map) && map.mappings === "") {
      return new MagicString(this.originalCode).generateMap({
        includeContent: true,
        hires: "boundary",
        source: cleanUrl(this.filename)
      });
    }
    return map;
  }
  _updateActiveInfo(plugin, id, code) {
    this._plugin = plugin;
    this._activeId = id;
    this._activeCode = code;
  }
}
class PluginContainer {
  constructor(environments) {
    this.environments = environments;
  }
  // Backward compatibility
  // Users should call pluginContainer.resolveId (and load/transform) passing the environment they want to work with
  // But there is code that is going to call it without passing an environment, or with the ssr flag to get the ssr environment
  _getEnvironment(options) {
    return options?.environment ? options.environment : this.environments[options?.ssr ? "ssr" : "client"];
  }
  _getPluginContainer(options) {
    return this._getEnvironment(options).pluginContainer;
  }
  getModuleInfo(id) {
    const clientModuleInfo = this.environments.client.pluginContainer.getModuleInfo(id);
    const ssrModuleInfo = this.environments.ssr.pluginContainer.getModuleInfo(id);
    if (clientModuleInfo == null && ssrModuleInfo == null) return null;
    return new Proxy({}, {
      get: (_, key) => {
        if (key === "meta") {
          const meta = {};
          if (ssrModuleInfo) {
            Object.assign(meta, ssrModuleInfo.meta);
          }
          if (clientModuleInfo) {
            Object.assign(meta, clientModuleInfo.meta);
          }
          return meta;
        }
        if (clientModuleInfo) {
          if (key in clientModuleInfo) {
            return clientModuleInfo[key];
          }
        }
        if (ssrModuleInfo) {
          if (key in ssrModuleInfo) {
            return ssrModuleInfo[key];
          }
        }
      }
    });
  }
  get options() {
    return this.environments.client.pluginContainer.options;
  }
  // For backward compatibility, buildStart and watchChange are called only for the client environment
  // buildStart is called per environment for a plugin with the perEnvironmentStartEndDuring dev flag
  async buildStart(_options) {
    return this.environments.client.pluginContainer.buildStart(_options);
  }
  async watchChange(id, change) {
    return this.environments.client.pluginContainer.watchChange(id, change);
  }
  async resolveId(rawId, importer, options) {
    return this._getPluginContainer(options).resolveId(rawId, importer, options);
  }
  async load(id, options) {
    return this._getPluginContainer(options).load(id);
  }
  async transform(code, id, options) {
    return this._getPluginContainer(options).transform(code, id, options);
  }
  async close() {
  }
}
function createPluginContainer(environments) {
  return new PluginContainer(environments);
}

function createBackCompatIdResolver(config, options) {
  const compatResolve = config.createResolver(options);
  let resolve;
  return async (environment, id, importer, aliasOnly) => {
    if (environment.name === "client" || environment.name === "ssr") {
      return compatResolve(id, importer, aliasOnly, environment.name === "ssr");
    }
    resolve ??= createIdResolver(config, options);
    return resolve(environment, id, importer, aliasOnly);
  };
}
function createIdResolver(config, options) {
  const scan = options?.scan;
  const pluginContainerMap = /* @__PURE__ */ new Map();
  async function resolve(environment, id, importer) {
    let pluginContainer = pluginContainerMap.get(environment);
    if (!pluginContainer) {
      pluginContainer = await createEnvironmentPluginContainer(
        environment,
        [
          alias$1({ entries: environment.config.resolve.alias }),
          resolvePlugin({
            root: config.root,
            isProduction: config.isProduction,
            isBuild: config.command === "build",
            asSrc: true,
            preferRelative: false,
            tryIndex: true,
            ...options,
            // Ignore sideEffects and other computations as we only need the id
            idOnly: true
          })
        ],
        void 0,
        false
      );
      pluginContainerMap.set(environment, pluginContainer);
    }
    return await pluginContainer.resolveId(id, importer, { scan });
  }
  const aliasOnlyPluginContainerMap = /* @__PURE__ */ new Map();
  async function resolveAlias(environment, id, importer) {
    let pluginContainer = aliasOnlyPluginContainerMap.get(environment);
    if (!pluginContainer) {
      pluginContainer = await createEnvironmentPluginContainer(
        environment,
        [alias$1({ entries: environment.config.resolve.alias })],
        void 0,
        false
      );
      aliasOnlyPluginContainerMap.set(environment, pluginContainer);
    }
    return await pluginContainer.resolveId(id, importer, { scan });
  }
  return async (environment, id, importer, aliasOnly) => {
    const resolveFn = aliasOnly ? resolveAlias : resolve;
    const resolved = await resolveFn(environment, id, importer);
    return resolved?.id;
  };
}

const decoder = new TextDecoder();
const cssConfigDefaults = Object.freeze({
  /** @experimental */
  transformer: "postcss",
  // modules
  // preprocessorOptions
  /** @experimental */
  preprocessorMaxWorkers: 0,
  // postcss
  /** @experimental */
  devSourcemap: false
  // lightningcss
});
function resolveCSSOptions(options) {
  const resolved = mergeWithDefaults(cssConfigDefaults, options ?? {});
  if (resolved.transformer === "lightningcss") {
    resolved.lightningcss ??= {};
    resolved.lightningcss.targets ??= convertTargets(ESBUILD_MODULES_TARGET);
  }
  return resolved;
}
const cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`);
const directRequestRE = /[?&]direct\b/;
const htmlProxyRE = /[?&]html-proxy\b/;
const htmlProxyIndexRE = /&index=(\d+)/;
const commonjsProxyRE = /[?&]commonjs-proxy/;
const inlineRE = /[?&]inline\b/;
const inlineCSSRE = /[?&]inline-css\b/;
const styleAttrRE = /[?&]style-attr\b/;
const functionCallRE = /^[A-Z_][.\w-]*\(/i;
const transformOnlyRE = /[?&]transform-only\b/;
const nonEscapedDoubleQuoteRe = /(?<!\\)"/g;
const defaultCssBundleName = "style.css";
const isCSSRequest = (request) => CSS_LANGS_RE.test(request);
const isModuleCSSRequest = (request) => cssModuleRE.test(request);
const isDirectCSSRequest = (request) => CSS_LANGS_RE.test(request) && directRequestRE.test(request);
const isDirectRequest = (request) => directRequestRE.test(request);
const cssModulesCache = /* @__PURE__ */ new WeakMap();
const removedPureCssFilesCache = /* @__PURE__ */ new WeakMap();
const cssBundleNameCache = /* @__PURE__ */ new WeakMap();
const postcssConfigCache = /* @__PURE__ */ new WeakMap();
function encodePublicUrlsInCSS(config) {
  return config.command === "build";
}
const cssUrlAssetRE = /__VITE_CSS_URL__([\da-f]+)__/g;
function cssPlugin(config) {
  const isBuild = config.command === "build";
  let moduleCache;
  const idResolver = createBackCompatIdResolver(config, {
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  let preprocessorWorkerController;
  if (config.css.transformer !== "lightningcss") {
    resolvePostcssConfig(config).catch(() => {
    });
  }
  const plugin = {
    name: "vite:css",
    buildStart() {
      moduleCache = /* @__PURE__ */ new Map();
      cssModulesCache.set(config, moduleCache);
      removedPureCssFilesCache.set(config, /* @__PURE__ */ new Map());
      preprocessorWorkerController = createPreprocessorWorkerController(
        normalizeMaxWorkers(config.css.preprocessorMaxWorkers)
      );
      preprocessorWorkerControllerCache.set(
        config,
        preprocessorWorkerController
      );
    },
    buildEnd() {
      preprocessorWorkerController?.close();
    },
    load: {
      async handler(id) {
        if (!isCSSRequest(id)) return;
        if (urlRE$1.test(id)) {
          if (isModuleCSSRequest(id)) {
            throw new Error(
              `?url is not supported with CSS modules. (tried to import ${JSON.stringify(
                id
              )})`
            );
          }
          if (isBuild) {
            id = injectQuery(removeUrlQuery(id), "transform-only");
            return `import ${JSON.stringify(id)};export default "__VITE_CSS_URL__${Buffer.from(id).toString(
              "hex"
            )}__"`;
          }
        }
      }
    }
  };
  const transformHook = {
    async handler(raw, id) {
      if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
        return;
      }
      const { environment } = this;
      const resolveUrl = (url, importer) => idResolver(environment, url, importer);
      const urlResolver = async (url, importer) => {
        const decodedUrl = decodeURI(url);
        if (checkPublicFile(decodedUrl, config)) {
          if (encodePublicUrlsInCSS(config)) {
            return [publicFileToBuiltUrl(decodedUrl, config), void 0];
          } else {
            return [joinUrlSegments(config.base, decodedUrl), void 0];
          }
        }
        const [id2, fragment] = decodedUrl.split("#");
        let resolved = await resolveUrl(id2, importer);
        if (resolved) {
          if (fragment) resolved += "#" + fragment;
          return [await fileToUrl$1(this, resolved), resolved];
        }
        if (config.command === "build") {
          const isExternal = config.build.rollupOptions.external ? resolveUserExternal(
            config.build.rollupOptions.external,
            decodedUrl,
            // use URL as id since id could not be resolved
            id2,
            false
          ) : false;
          if (!isExternal) {
            config.logger.warnOnce(
              `
${decodedUrl} referenced in ${id2} didn't resolve at build time, it will remain unchanged to be resolved at runtime`
            );
          }
        }
        return [url, void 0];
      };
      const {
        code: css,
        modules,
        deps,
        map: map2
      } = await compileCSS(
        environment,
        id,
        raw,
        preprocessorWorkerController,
        urlResolver
      );
      if (modules) {
        moduleCache.set(id, modules);
      }
      if (deps) {
        for (const file of deps) {
          this.addWatchFile(file);
        }
      }
      return {
        code: css,
        map: map2
      };
    }
  };
  plugin.transform = transformHook.handler;
  plugin.transform.handler = transformHook.handler;
  return plugin;
}
function cssPostPlugin(config) {
  const styles = /* @__PURE__ */ new Map();
  let codeSplitEmitQueue = createSerialPromiseQueue();
  const urlEmitQueue = createSerialPromiseQueue();
  let pureCssChunks;
  let hasEmitted = false;
  let chunkCSSMap;
  const rollupOptionsOutput = config.build.rollupOptions.output;
  const assetFileNames = (Array.isArray(rollupOptionsOutput) ? rollupOptionsOutput[0] : rollupOptionsOutput)?.assetFileNames;
  const getCssAssetDirname = (cssAssetName) => {
    const cssAssetNameDir = path$b.dirname(cssAssetName);
    if (!assetFileNames) {
      return path$b.join(config.build.assetsDir, cssAssetNameDir);
    } else if (typeof assetFileNames === "string") {
      return path$b.join(path$b.dirname(assetFileNames), cssAssetNameDir);
    } else {
      return path$b.dirname(
        assetFileNames({
          type: "asset",
          name: cssAssetName,
          names: [cssAssetName],
          originalFileName: null,
          originalFileNames: [],
          source: "/* vite internal call, ignore */"
        })
      );
    }
  };
  function getCssBundleName() {
    const cached = cssBundleNameCache.get(config);
    if (cached) return cached;
    const cssBundleName = config.build.lib ? resolveLibCssFilename(
      config.build.lib,
      config.root,
      config.packageCache
    ) : defaultCssBundleName;
    cssBundleNameCache.set(config, cssBundleName);
    return cssBundleName;
  }
  const plugin = {
    name: "vite:css-post",
    renderStart() {
      pureCssChunks = /* @__PURE__ */ new Set();
      hasEmitted = false;
      chunkCSSMap = /* @__PURE__ */ new Map();
      codeSplitEmitQueue = createSerialPromiseQueue();
    },
    transform: {
      async handler(css, id) {
        if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
          return;
        }
        css = stripBomTag(css);
        const inlineCSS = inlineCSSRE.test(id);
        const isHTMLProxy = htmlProxyRE.test(id);
        if (inlineCSS && isHTMLProxy) {
          if (styleAttrRE.test(id)) {
            css = css.replace(/"/g, "&quot;");
          }
          const index = htmlProxyIndexRE.exec(id)?.[1];
          if (index == null) {
            throw new Error(`HTML proxy index in "${id}" not found`);
          }
          addToHTMLProxyTransformResult(
            `${getHash(cleanUrl(id))}_${Number.parseInt(index)}`,
            css
          );
          return `export default ''`;
        }
        const inlined = inlineRE.test(id);
        const modules = cssModulesCache.get(config).get(id);
        const modulesCode = modules && !inlined && dataToEsm(modules, { namedExports: true, preferConst: true });
        if (config.command === "serve") {
          const getContentWithSourcemap = async (content) => {
            if (config.css.devSourcemap) {
              const sourcemap = this.getCombinedSourcemap();
              if (sourcemap.mappings) {
                await injectSourcesContent(
                  sourcemap,
                  cleanUrl(id),
                  config.logger
                );
              }
              return getCodeWithSourcemap("css", content, sourcemap);
            }
            return content;
          };
          if (isDirectCSSRequest(id)) {
            return null;
          }
          if (inlined) {
            return `export default ${JSON.stringify(css)}`;
          }
          if (this.environment.config.consumer === "server") {
            return modulesCode || "export {}";
          }
          const cssContent = await getContentWithSourcemap(css);
          const code2 = [
            `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(
              path$b.posix.join(config.base, CLIENT_PUBLIC_PATH)
            )}`,
            `const __vite__id = ${JSON.stringify(id)}`,
            `const __vite__css = ${JSON.stringify(cssContent)}`,
            `__vite__updateStyle(__vite__id, __vite__css)`,
            // css modules exports change on edit so it can't self accept
            `${modulesCode || "import.meta.hot.accept()"}`,
            `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
          ].join("\n");
          return { code: code2, map: { mappings: "" } };
        }
        if (!inlined) {
          styles.set(id, css);
        }
        let code;
        if (modulesCode) {
          code = modulesCode;
        } else if (inlined) {
          let content = css;
          if (config.build.cssMinify) {
            content = await minifyCSS(content, config, true);
          }
          code = `export default ${JSON.stringify(content)}`;
        } else {
          code = "";
        }
        return {
          code,
          map: { mappings: "" },
          // avoid the css module from being tree-shaken so that we can retrieve
          // it in renderChunk()
          moduleSideEffects: modulesCode || inlined ? false : "no-treeshake"
        };
      }
    },
    async renderChunk(code, chunk, opts, meta) {
      let chunkCSS = "";
      const renderedModules = new Proxy(
        {},
        {
          get(_target, p) {
            for (const name in meta.chunks) {
              const modules = meta.chunks[name].modules;
              const module = modules[p];
              if (module) {
                return module;
              }
            }
          }
        }
      );
      const isJsChunkEmpty = code === "" && !chunk.isEntry;
      let isPureCssChunk = chunk.exports.length === 0;
      const ids = Object.keys(chunk.modules);
      for (const id of ids) {
        if (styles.has(id)) {
          if (transformOnlyRE.test(id)) {
            continue;
          }
          const cssScopeTo = this.getModuleInfo(id)?.meta?.vite?.cssScopeTo;
          if (cssScopeTo && !isCssScopeToRendered(cssScopeTo, renderedModules)) {
            continue;
          }
          if (cssModuleRE.test(id)) {
            isPureCssChunk = false;
          }
          chunkCSS += styles.get(id);
        } else if (!isJsChunkEmpty) {
          isPureCssChunk = false;
        }
      }
      const publicAssetUrlMap = publicAssetUrlCache.get(config);
      const resolveAssetUrlsInCss = (chunkCSS2, cssAssetName) => {
        const encodedPublicUrls = encodePublicUrlsInCSS(config);
        const relative = config.base === "./" || config.base === "";
        const cssAssetDirname = encodedPublicUrls || relative ? slash$1(getCssAssetDirname(cssAssetName)) : void 0;
        const toRelative = (filename) => {
          const relativePath = normalizePath$3(
            path$b.relative(cssAssetDirname, filename)
          );
          return relativePath[0] === "." ? relativePath : "./" + relativePath;
        };
        chunkCSS2 = chunkCSS2.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          const filename = this.getFileName(fileHash) + postfix;
          chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
          return encodeURIPath(
            toOutputFilePathInCss(
              filename,
              "asset",
              cssAssetName,
              "css",
              config,
              toRelative
            )
          );
        });
        if (encodedPublicUrls) {
          const relativePathToPublicFromCSS = normalizePath$3(
            path$b.relative(cssAssetDirname, "")
          );
          chunkCSS2 = chunkCSS2.replace(publicAssetUrlRE, (_, hash) => {
            const publicUrl = publicAssetUrlMap.get(hash).slice(1);
            return encodeURIPath(
              toOutputFilePathInCss(
                publicUrl,
                "public",
                cssAssetName,
                "css",
                config,
                () => `${relativePathToPublicFromCSS}/${publicUrl}`
              )
            );
          });
        }
        return chunkCSS2;
      };
      function ensureFileExt(name, ext) {
        return normalizePath$3(
          path$b.format({ ...path$b.parse(name), base: void 0, ext })
        );
      }
      let s;
      const urlEmitTasks = [];
      if (code.includes("__VITE_CSS_URL__")) {
        let match;
        cssUrlAssetRE.lastIndex = 0;
        while (match = cssUrlAssetRE.exec(code)) {
          const [full, idHex] = match;
          const id = Buffer.from(idHex, "hex").toString();
          const originalFileName = cleanUrl(id);
          const cssAssetName = ensureFileExt(
            path$b.basename(originalFileName),
            ".css"
          );
          if (!styles.has(id)) {
            throw new Error(
              `css content for ${JSON.stringify(id)} was not found`
            );
          }
          let cssContent = styles.get(id);
          cssContent = resolveAssetUrlsInCss(cssContent, cssAssetName);
          urlEmitTasks.push({
            cssAssetName,
            originalFileName,
            content: cssContent,
            start: match.index,
            end: match.index + full.length
          });
        }
      }
      await urlEmitQueue.run(
        async () => Promise.all(
          urlEmitTasks.map(async (info) => {
            info.content = await finalizeCss(info.content, true, config);
          })
        )
      );
      if (urlEmitTasks.length > 0) {
        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
          opts.format,
          config.isWorker
        );
        s ||= new MagicString(code);
        for (const {
          cssAssetName,
          originalFileName,
          content,
          start,
          end
        } of urlEmitTasks) {
          const referenceId = this.emitFile({
            type: "asset",
            name: cssAssetName,
            originalFileName,
            source: content
          });
          const filename = this.getFileName(referenceId);
          chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
          const replacement = toOutputFilePathInJS(
            this.environment,
            filename,
            "asset",
            chunk.fileName,
            "js",
            toRelativeRuntime
          );
          const replacementString = typeof replacement === "string" ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1) : `"+${replacement.runtime}+"`;
          s.update(start, end, replacementString);
        }
      }
      if (chunkCSS) {
        if (isPureCssChunk && (opts.format === "es" || opts.format === "cjs")) {
          pureCssChunks.add(chunk);
        }
        if (this.environment.config.build.cssCodeSplit) {
          if (opts.format === "es" || opts.format === "cjs") {
            const isEntry = chunk.isEntry && isPureCssChunk;
            const cssFullAssetName = ensureFileExt(chunk.name, ".css");
            const cssAssetName = chunk.isEntry && (!chunk.facadeModuleId || !isCSSRequest(chunk.facadeModuleId)) ? path$b.basename(cssFullAssetName) : cssFullAssetName;
            const originalFileName = getChunkOriginalFileName(
              chunk,
              config.root,
              opts.format
            );
            chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName);
            chunkCSS = await codeSplitEmitQueue.run(async () => {
              return finalizeCss(chunkCSS, true, config);
            });
            const referenceId = this.emitFile({
              type: "asset",
              name: cssAssetName,
              originalFileName,
              source: chunkCSS
            });
            if (isEntry) {
              cssEntriesMap.get(this.environment).add(referenceId);
            }
            chunk.viteMetadata.importedCss.add(this.getFileName(referenceId));
          } else if (this.environment.config.consumer === "client") {
            chunkCSS = await finalizeCss(chunkCSS, true, config);
            let cssString = JSON.stringify(chunkCSS);
            cssString = renderAssetUrlInJS(this, chunk, opts, cssString)?.toString() || cssString;
            const style = `__vite_style__`;
            const injectCode = `var ${style} = document.createElement('style');${style}.textContent = ${cssString};document.head.appendChild(${style});`;
            let injectionPoint;
            const wrapIdx = code.indexOf("System.register");
            const singleQuoteUseStrict = `'use strict';`;
            const doubleQuoteUseStrict = `"use strict";`;
            if (wrapIdx >= 0) {
              const executeFnStart = code.indexOf("execute:", wrapIdx);
              injectionPoint = code.indexOf("{", executeFnStart) + 1;
            } else if (code.includes(singleQuoteUseStrict)) {
              injectionPoint = code.indexOf(singleQuoteUseStrict) + singleQuoteUseStrict.length;
            } else if (code.includes(doubleQuoteUseStrict)) {
              injectionPoint = code.indexOf(doubleQuoteUseStrict) + doubleQuoteUseStrict.length;
            } else {
              throw new Error("Injection point for inlined CSS not found");
            }
            s ||= new MagicString(code);
            s.appendRight(injectionPoint, injectCode);
          }
        } else {
          chunkCSS = resolveAssetUrlsInCss(chunkCSS, getCssBundleName());
          chunkCSSMap.set(chunk.fileName, chunkCSS);
        }
      }
      if (s) {
        if (config.build.sourcemap) {
          return {
            code: s.toString(),
            map: s.generateMap({ hires: "boundary" })
          };
        } else {
          return { code: s.toString() };
        }
      }
      return null;
    },
    augmentChunkHash(chunk) {
      if (chunk.viteMetadata?.importedCss.size) {
        let hash = "";
        for (const id of chunk.viteMetadata.importedCss) {
          hash += id;
        }
        return hash;
      }
    },
    async generateBundle(opts, bundle) {
      if (opts.__vite_skip_asset_emit__) {
        return;
      }
      if (!this.environment.config.build.cssCodeSplit && !hasEmitted) {
        let collect2 = function(chunk) {
          if (!chunk || chunk.type !== "chunk" || collected.has(chunk)) return;
          collected.add(chunk);
          chunk.imports.forEach((importName) => collect2(bundle[importName]));
          chunk.dynamicImports.forEach(
            (importName) => dynamicImports.add(importName)
          );
          extractedCss += chunkCSSMap.get(chunk.preliminaryFileName) ?? "";
        };
        let extractedCss = "";
        const collected = /* @__PURE__ */ new Set();
        const dynamicImports = /* @__PURE__ */ new Set();
        for (const chunk of Object.values(bundle)) {
          if (chunk.type === "chunk" && chunk.isEntry) {
            collect2(chunk);
          }
        }
        for (const chunkName of dynamicImports) {
          collect2(bundle[chunkName]);
        }
        if (extractedCss) {
          hasEmitted = true;
          extractedCss = await finalizeCss(extractedCss, true, config);
          this.emitFile({
            name: getCssBundleName(),
            type: "asset",
            source: extractedCss,
            // this file is an implicit entry point, use `style.css` as the original file name
            // this name is also used as a key in the manifest
            originalFileName: "style.css"
          });
        }
      }
      if (pureCssChunks.size) {
        const prelimaryNameToChunkMap = Object.fromEntries(
          Object.values(bundle).filter((chunk) => chunk.type === "chunk").map((chunk) => [chunk.preliminaryFileName, chunk.fileName])
        );
        const pureCssChunkNames = [...pureCssChunks].map((pureCssChunk) => prelimaryNameToChunkMap[pureCssChunk.fileName]).filter(Boolean);
        const replaceEmptyChunk = getEmptyChunkReplacer(
          pureCssChunkNames,
          opts.format
        );
        for (const file in bundle) {
          const chunk = bundle[file];
          if (chunk.type === "chunk") {
            let chunkImportsPureCssChunk = false;
            chunk.imports = chunk.imports.filter((file2) => {
              if (pureCssChunkNames.includes(file2)) {
                const { importedCss, importedAssets } = bundle[file2].viteMetadata;
                importedCss.forEach(
                  (file3) => chunk.viteMetadata.importedCss.add(file3)
                );
                importedAssets.forEach(
                  (file3) => chunk.viteMetadata.importedAssets.add(file3)
                );
                chunkImportsPureCssChunk = true;
                return false;
              }
              return true;
            });
            if (chunkImportsPureCssChunk) {
              chunk.code = replaceEmptyChunk(chunk.code);
            }
          }
        }
        const removedPureCssFiles = removedPureCssFilesCache.get(config);
        pureCssChunkNames.forEach((fileName) => {
          removedPureCssFiles.set(fileName, bundle[fileName]);
          delete bundle[fileName];
          delete bundle[`${fileName}.map`];
        });
      }
      const cssAssets = Object.values(bundle).filter(
        (asset) => asset.type === "asset" && asset.fileName.endsWith(".css")
      );
      for (const cssAsset of cssAssets) {
        if (typeof cssAsset.source === "string") {
          cssAsset.source = cssAsset.source.replace(viteHashUpdateMarkerRE, "");
        }
      }
    }
  };
  const handler = plugin.transform.handler;
  plugin.transform = handler;
  plugin.transform.handler = handler;
  return plugin;
}
function cssAnalysisPlugin(config) {
  return {
    name: "vite:css-analysis",
    transform: {
      async handler(_, id) {
        if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
          return;
        }
        const { moduleGraph } = this.environment;
        const thisModule = moduleGraph.getModuleById(id);
        if (thisModule) {
          const isSelfAccepting = !cssModulesCache.get(config)?.get(id) && !inlineRE.test(id) && !htmlProxyRE.test(id);
          const pluginImports = this._addedImports;
          if (pluginImports) {
            const depModules = /* @__PURE__ */ new Set();
            for (const file of pluginImports) {
              if (isCSSRequest(file)) {
                depModules.add(moduleGraph.createFileOnlyEntry(file));
              } else {
                const url = await fileToDevUrl(
                  this.environment,
                  file,
                  /* skipBase */
                  true
                );
                if (url.startsWith("data:")) {
                  depModules.add(moduleGraph.createFileOnlyEntry(file));
                } else {
                  depModules.add(await moduleGraph.ensureEntryFromUrl(url));
                }
              }
            }
            moduleGraph.updateModuleInfo(
              thisModule,
              depModules,
              null,
              // The root CSS proxy module is self-accepting and should not
              // have an explicit accept list
              /* @__PURE__ */ new Set(),
              null,
              isSelfAccepting
            );
          } else {
            thisModule.isSelfAccepting = isSelfAccepting;
          }
        }
      }
    }
  };
}
function isCssScopeToRendered(cssScopeTo, renderedModules) {
  const [importerId, exp] = cssScopeTo;
  const importer = renderedModules[importerId];
  return importer && (exp === void 0 || importer.renderedExports.includes(exp));
}
function getEmptyChunkReplacer(pureCssChunkNames, outputFormat) {
  const emptyChunkFiles = pureCssChunkNames.map((file) => escapeRegex(path$b.basename(file))).join("|");
  const emptyChunkRE = new RegExp(
    outputFormat === "es" ? `\\bimport\\s*["'][^"']*(?:${emptyChunkFiles})["'];` : `(\\b|,\\s*)require\\(\\s*["'][^"']*(?:${emptyChunkFiles})["']\\)(;|,)`,
    "g"
  );
  return (code) => code.replace(
    emptyChunkRE,
    // remove css import while preserving source map location
    (m, p1, p2) => {
      if (outputFormat === "es") {
        return `/* empty css ${"".padEnd(m.length - 15)}*/`;
      }
      if (p2 === ";") {
        return `${p2}/* empty css ${"".padEnd(m.length - 16)}*/`;
      }
      return `${p1}/* empty css ${"".padEnd(m.length - 15 - p1.length)}*/`;
    }
  );
}
const fileURLWithWindowsDriveRE = /^file:\/\/\/[a-zA-Z]:\//;
function createCSSResolvers(config) {
  let cssResolve;
  let sassResolve;
  let lessResolve;
  return {
    get css() {
      return cssResolve ??= createBackCompatIdResolver(config, {
        extensions: [".css"],
        mainFields: ["style"],
        conditions: ["style", DEV_PROD_CONDITION],
        tryIndex: false,
        preferRelative: true
      });
    },
    get sass() {
      if (!sassResolve) {
        const resolver = createBackCompatIdResolver(config, {
          extensions: [".scss", ".sass", ".css"],
          mainFields: ["sass", "style"],
          conditions: ["sass", "style", DEV_PROD_CONDITION],
          tryIndex: true,
          tryPrefix: "_",
          preferRelative: true
        });
        sassResolve = async (...args) => {
          if (args[1].startsWith("file://")) {
            args[1] = fileURLToPath$1(args[1], {
              windows: (
                // file:///foo cannot be converted to path with windows mode
                isWindows$3 && !fileURLWithWindowsDriveRE.test(args[1]) ? false : void 0
              )
            });
          }
          return resolver(...args);
        };
      }
      return sassResolve;
    },
    get less() {
      return lessResolve ??= createBackCompatIdResolver(config, {
        extensions: [".less", ".css"],
        mainFields: ["less", "style"],
        conditions: ["less", "style", DEV_PROD_CONDITION],
        tryIndex: false,
        preferRelative: true
      });
    }
  };
}
function getCssResolversKeys(resolvers) {
  return Object.keys(resolvers);
}
async function compileCSSPreprocessors(environment, id, lang, code, workerController) {
  const { config } = environment;
  const { preprocessorOptions, devSourcemap } = config.css;
  const atImportResolvers = getAtImportResolvers(
    environment.getTopLevelConfig()
  );
  const opts = {
    ...preprocessorOptions && preprocessorOptions[lang] || {},
    alias: config.resolve.alias,
    // important: set this for relative import resolving
    filename: cleanUrl(id),
    enableSourcemap: devSourcemap ?? false
  };
  const preProcessor = workerController[lang];
  const preprocessResult = await preProcessor(
    environment,
    code,
    config.root,
    opts,
    atImportResolvers
  );
  if (preprocessResult.error) {
    throw preprocessResult.error;
  }
  let deps;
  if (preprocessResult.deps.length > 0) {
    const normalizedFilename = normalizePath$3(opts.filename);
    deps = new Set(
      [...preprocessResult.deps].filter(
        (dep) => normalizePath$3(dep) !== normalizedFilename
      )
    );
  }
  return {
    code: preprocessResult.code,
    map: combineSourcemapsIfExists(
      opts.filename,
      preprocessResult.map,
      preprocessResult.additionalMap
    ),
    deps
  };
}
const configToAtImportResolvers = /* @__PURE__ */ new WeakMap();
function getAtImportResolvers(config) {
  let atImportResolvers = configToAtImportResolvers.get(config);
  if (!atImportResolvers) {
    atImportResolvers = createCSSResolvers(config);
    configToAtImportResolvers.set(config, atImportResolvers);
  }
  return atImportResolvers;
}
async function compileCSS(environment, id, code, workerController, urlResolver) {
  const { config } = environment;
  const lang = CSS_LANGS_RE.exec(id)?.[1];
  const deps = /* @__PURE__ */ new Set();
  let preprocessorMap;
  if (isPreProcessor(lang)) {
    const preprocessorResult = await compileCSSPreprocessors(
      environment,
      id,
      lang,
      code,
      workerController
    );
    code = preprocessorResult.code;
    preprocessorMap = preprocessorResult.map;
    preprocessorResult.deps?.forEach((dep) => deps.add(dep));
  } else if (lang === "sss" && config.css.transformer === "lightningcss") {
    const sssResult = await transformSugarSS(environment, id, code);
    code = sssResult.code;
    preprocessorMap = sssResult.map;
  }
  const transformResult = await (config.css.transformer === "lightningcss" ? compileLightningCSS(
    environment,
    id,
    code,
    deps,
    workerController,
    urlResolver
  ) : compilePostCSS(
    environment,
    id,
    code,
    deps,
    lang,
    workerController,
    urlResolver
  ));
  if (!transformResult) {
    return {
      code,
      map: config.css.devSourcemap ? preprocessorMap : { mappings: "" },
      deps
    };
  }
  return {
    ...transformResult,
    map: config.css.devSourcemap ? combineSourcemapsIfExists(
      cleanUrl(id),
      typeof transformResult.map === "string" ? JSON.parse(transformResult.map) : transformResult.map,
      preprocessorMap
    ) : { mappings: "" },
    deps
  };
}
async function compilePostCSS(environment, id, code, deps, lang, workerController, urlResolver) {
  const { config } = environment;
  const { modules: modulesOptions, devSourcemap } = config.css;
  const isModule = modulesOptions !== false && cssModuleRE.test(id);
  const needInlineImport = code.includes("@import");
  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
  const postcssConfig = await resolvePostcssConfig(
    environment.getTopLevelConfig()
  );
  if (lang !== "sss" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) {
    return;
  }
  const atImportResolvers = getAtImportResolvers(
    environment.getTopLevelConfig()
  );
  const postcssPlugins = postcssConfig?.plugins.slice() ?? [];
  if (needInlineImport) {
    postcssPlugins.unshift(
      (await importPostcssImport()).default({
        async resolve(id2, basedir) {
          const publicFile = checkPublicFile(
            id2,
            environment.getTopLevelConfig()
          );
          if (publicFile) {
            return publicFile;
          }
          const resolved = await atImportResolvers.css(
            environment,
            id2,
            path$b.join(basedir, "*")
          );
          if (resolved) {
            return path$b.resolve(resolved);
          }
          if (!path$b.isAbsolute(id2)) {
            environment.logger.error(
              colors$1.red(
                `Unable to resolve \`@import "${id2}"\` from ${basedir}`
              )
            );
          }
          return id2;
        },
        async load(id2) {
          const code2 = await fs__default.promises.readFile(id2, "utf-8");
          const lang2 = CSS_LANGS_RE.exec(id2)?.[1];
          if (isPreProcessor(lang2)) {
            const result2 = await compileCSSPreprocessors(
              environment,
              id2,
              lang2,
              code2,
              workerController
            );
            result2.deps?.forEach((dep) => deps.add(dep));
            return result2.code;
          }
          return code2;
        },
        nameLayer(index) {
          return `vite--anon-layer-${getHash(id)}-${index}`;
        }
      })
    );
  }
  if (urlResolver && // when a postcss plugin is used (including the internal postcss plugins),
  // we need to add this plugin regardless of whether
  // this file contains url() or image-set(),
  // because we don't know the content injected by those plugins
  (postcssPlugins.length > 0 || isModule || hasUrl)) {
    postcssPlugins.push(
      UrlRewritePostcssPlugin({
        resolver: urlResolver,
        deps,
        logger: environment.logger
      })
    );
  }
  let modules;
  if (isModule) {
    postcssPlugins.unshift(
      (await importPostcssModules()).default({
        ...modulesOptions,
        localsConvention: modulesOptions?.localsConvention,
        getJSON(cssFileName, _modules, outputFileName) {
          modules = _modules;
          if (modulesOptions && typeof modulesOptions.getJSON === "function") {
            modulesOptions.getJSON(cssFileName, _modules, outputFileName);
          }
        },
        async resolve(id2, importer) {
          for (const key of getCssResolversKeys(atImportResolvers)) {
            const resolved = await atImportResolvers[key](
              environment,
              id2,
              importer
            );
            if (resolved) {
              return path$b.resolve(resolved);
            }
          }
          return id2;
        }
      })
    );
  }
  const postcssOptions = postcssConfig?.options ?? {};
  const postcssParser = lang === "sss" ? loadSss(config.root) : postcssOptions.parser;
  if (!postcssPlugins.length && !postcssParser) {
    return;
  }
  const result = await runPostCSS(
    id,
    code,
    postcssPlugins,
    { ...postcssOptions, parser: postcssParser },
    deps,
    environment.logger,
    devSourcemap
  );
  return { ...result, modules };
}
async function transformSugarSS(environment, id, code) {
  const { config } = environment;
  const { devSourcemap } = config.css;
  const result = await runPostCSS(
    id,
    code,
    [],
    { parser: loadSss(config.root) },
    void 0,
    environment.logger,
    devSourcemap
  );
  return result;
}
async function runPostCSS(id, code, plugins, options, deps, logger, enableSourcemap) {
  let postcssResult;
  try {
    const source = removeDirectQuery(id);
    const postcss = await importPostcss();
    postcssResult = await postcss.default(plugins).process(code, {
      ...options,
      to: source,
      from: source,
      ...enableSourcemap ? {
        map: {
          inline: false,
          annotation: false,
          // postcss may return virtual files
          // we cannot obtain content of them, so this needs to be enabled
          sourcesContent: true
          // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
          // prev: preprocessorMap,
        }
      } : {}
    });
    for (const message of postcssResult.messages) {
      if (message.type === "dependency") {
        deps?.add(normalizePath$3(message.file));
      } else if (message.type === "dir-dependency") {
        const { dir, glob: globPattern = "**" } = message;
        const files = globSync(globPattern, {
          absolute: true,
          cwd: path$b.resolve(path$b.dirname(id), dir),
          expandDirectories: false,
          ignore: ["**/node_modules/**"]
        });
        for (let i = 0; i < files.length; i++) {
          deps?.add(files[i]);
        }
      } else if (message.type === "warning") {
        const warning = message;
        let msg = `[vite:css][postcss] ${warning.text}`;
        msg += `
${generateCodeFrame(
          code,
          {
            line: warning.line,
            column: warning.column - 1
            // 1-based
          },
          warning.endLine !== void 0 && warning.endColumn !== void 0 ? {
            line: warning.endLine,
            column: warning.endColumn - 1
            // 1-based
          } : void 0
        )}`;
        logger.warn(colors$1.yellow(msg));
      }
    }
  } catch (e) {
    e.message = `[postcss] ${e.message}`;
    e.code = code;
    e.loc = {
      file: e.file,
      line: e.line,
      column: e.column - 1
      // 1-based
    };
    throw e;
  }
  if (!enableSourcemap) {
    return {
      code: postcssResult.css,
      map: { mappings: "" }
    };
  }
  const rawPostcssMap = postcssResult.map.toJSON();
  const postcssMap = await formatPostcssSourceMap(
    // version property of rawPostcssMap is declared as string
    // but actually it is a number
    rawPostcssMap,
    cleanUrl(id)
  );
  return {
    code: postcssResult.css,
    map: postcssMap
  };
}
function createCachedImport(imp) {
  let cached;
  return () => {
    if (!cached) {
      cached = imp().then((module) => {
        cached = module;
        return module;
      });
    }
    return cached;
  };
}
const importPostcssImport = createCachedImport(() => import('./dep-D67CHC8_.js').then(function (n) { return n.i; }));
const importPostcssModules = createCachedImport(() => import('./dep-B63J_9ss.js').then(function (n) { return n.i; }));
const importPostcss = createCachedImport(() => import('postcss'));
const preprocessorWorkerControllerCache = /* @__PURE__ */ new WeakMap();
let alwaysFakeWorkerWorkerControllerCache;
async function preprocessCSS(code, filename, config) {
  let workerController = preprocessorWorkerControllerCache.get(config);
  if (!workerController) {
    alwaysFakeWorkerWorkerControllerCache ||= createPreprocessorWorkerController(0);
    workerController = alwaysFakeWorkerWorkerControllerCache;
  }
  const environment = new PartialEnvironment(
    "client",
    config
  );
  return await compileCSS(environment, filename, code, workerController);
}
async function formatPostcssSourceMap(rawMap, file) {
  const inputFileDir = path$b.dirname(file);
  const sources = rawMap.sources.map((source) => {
    const cleanSource = cleanUrl(decodeURIComponent(source));
    if (cleanSource[0] === "<" && cleanSource.endsWith(">")) {
      return `\0${cleanSource}`;
    }
    return normalizePath$3(path$b.resolve(inputFileDir, cleanSource));
  });
  return {
    file,
    mappings: rawMap.mappings,
    names: rawMap.names,
    sources,
    sourcesContent: rawMap.sourcesContent,
    version: rawMap.version
  };
}
function combineSourcemapsIfExists(filename, map1, map2) {
  if (!map1 || !map2) {
    return map1;
  }
  if (map1.mappings === "" || map2.mappings === "") {
    return { mappings: "" };
  }
  return combineSourcemaps(filename, [
    // type of version property of ExistingRawSourceMap is number
    // but it is always 3
    map1,
    map2
  ]);
}
const viteHashUpdateMarker = "/*$vite$:1*/";
const viteHashUpdateMarkerRE = /\/\*\$vite\$:\d+\*\//;
async function finalizeCss(css, minify, config) {
  if (css.includes("@import") || css.includes("@charset")) {
    css = await hoistAtRules(css);
  }
  if (config.build.cssMinify) {
    css = await minifyCSS(css, config, false);
  }
  css += viteHashUpdateMarker;
  return css;
}
async function resolvePostcssConfig(config) {
  let result = postcssConfigCache.get(config);
  if (result !== void 0) {
    return await result;
  }
  const inlineOptions = config.css.postcss;
  if (isObject$1(inlineOptions)) {
    const options = { ...inlineOptions };
    delete options.plugins;
    result = {
      options,
      plugins: inlineOptions.plugins || []
    };
  } else {
    const searchPath = typeof inlineOptions === "string" ? inlineOptions : config.root;
    const stopDir = searchForWorkspaceRoot(config.root);
    result = postcssrc({}, searchPath, { stopDir }).catch((e) => {
      if (!e.message.includes("No PostCSS Config found")) {
        if (e instanceof Error) {
          const { name, message, stack } = e;
          e.name = "Failed to load PostCSS config";
          e.message = `Failed to load PostCSS config (searchPath: ${searchPath}): [${name}] ${message}
${stack}`;
          e.stack = "";
          throw e;
        } else {
          throw new Error(`Failed to load PostCSS config: ${e}`);
        }
      }
      return null;
    });
    result.then(
      (resolved) => {
        postcssConfigCache.set(config, resolved);
      },
      () => {
      }
    );
  }
  postcssConfigCache.set(config, result);
  return result;
}
const cssUrlRE = /(?<!@import\s+)(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
const cssDataUriRE = /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
const importCssRE = /@import\s+(?:url\()?('[^']+\.css'|"[^"]+\.css"|[^'"\s)]+\.css)/;
const cssImageSetRE = /(?<=image-set\()((?:[\w-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
const UrlRewritePostcssPlugin = (opts) => {
  if (!opts) {
    throw new Error("base or replace is required");
  }
  return {
    postcssPlugin: "vite-url-rewrite",
    Once(root) {
      const promises = [];
      root.walkDecls((declaration) => {
        const importer = declaration.source?.input.file;
        if (!importer) {
          opts.logger.warnOnce(
            "\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue."
          );
        }
        const isCssUrl = cssUrlRE.test(declaration.value);
        const isCssImageSet = cssImageSetRE.test(declaration.value);
        if (isCssUrl || isCssImageSet) {
          const replacerForDeclaration = async (rawUrl) => {
            const [newUrl, resolvedId] = await opts.resolver(rawUrl, importer);
            if (newUrl.startsWith("data:") && resolvedId) {
              opts.deps.add(resolvedId);
            }
            return newUrl;
          };
          if (isCssUrl && isCssImageSet) {
            promises.push(
              rewriteCssUrls(declaration.value, replacerForDeclaration).then((url) => rewriteCssImageSet(url, replacerForDeclaration)).then((url) => {
                declaration.value = url;
              })
            );
          } else {
            const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
            promises.push(
              rewriterToUse(declaration.value, replacerForDeclaration).then(
                (url) => {
                  declaration.value = url;
                }
              )
            );
          }
        }
      });
      if (promises.length) {
        return Promise.all(promises);
      }
    }
  };
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer);
  });
}
function rewriteCssDataUris(css, replacer) {
  return asyncReplace(css, cssDataUriRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer, "data-uri");
  });
}
function rewriteImportCss(css, replacer) {
  return asyncReplace(css, importCssRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doImportCSSReplace(rawUrl, matched, replacer);
  });
}
const cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match) => {
    const [, rawUrl] = match;
    const url = await processSrcSet(rawUrl, async ({ url: url2 }) => {
      if (cssUrlRE.test(url2)) {
        return await rewriteCssUrls(url2, replacer);
      }
      if (!cssNotProcessedRE.test(url2)) {
        return await doUrlReplace(url2, url2, replacer);
      }
      return url2;
    });
    return url;
  });
}
function skipUrlReplacer(rawUrl) {
  return isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === "#" || functionCallRE.test(rawUrl);
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap = "";
  const first = rawUrl[0];
  if (first === `"` || first === `'`) {
    wrap = first;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (skipUrlReplacer(rawUrl)) {
    return matched;
  }
  let newUrl = await replacer(rawUrl);
  if (wrap === "" && newUrl !== encodeURI(newUrl)) {
    wrap = '"';
  }
  if (wrap === "'" && newUrl.includes("'")) {
    wrap = '"';
  }
  if (wrap === '"' && newUrl.includes('"')) {
    newUrl = newUrl.replace(nonEscapedDoubleQuoteRe, '\\"');
  }
  return `${funcName}(${wrap}${newUrl}${wrap})`;
}
async function doImportCSSReplace(rawUrl, matched, replacer) {
  let wrap = "";
  const first = rawUrl[0];
  if (first === `"` || first === `'`) {
    wrap = first;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === "#") {
    return matched;
  }
  const prefix = matched.includes("url(") ? "url(" : "";
  return `@import ${prefix}${wrap}${await replacer(rawUrl)}${wrap}`;
}
async function minifyCSS(css, config, inlined) {
  if (config.build.cssMinify === "lightningcss") {
    try {
      const { code, warnings } = (await importLightningCSS()).transform({
        ...config.css.lightningcss,
        targets: convertTargets(config.build.cssTarget),
        cssModules: void 0,
        // TODO: Pass actual filename here, which can also be passed to esbuild's
        // `sourcefile` option below to improve error messages
        filename: defaultCssBundleName,
        code: Buffer.from(css),
        minify: true
      });
      for (const warning of warnings) {
        let msg = `[lightningcss minify] ${warning.message}`;
        msg += `
${generateCodeFrame(css, {
          line: warning.loc.line,
          column: warning.loc.column - 1
          // 1-based
        })}`;
        config.logger.warn(colors$1.yellow(msg));
      }
      return decoder.decode(code) + (inlined ? "" : "\n");
    } catch (e) {
      e.message = `[lightningcss minify] ${e.message}`;
      const friendlyMessage = getLightningCssErrorMessageForIeSyntaxes(css);
      if (friendlyMessage) {
        e.message += friendlyMessage;
      }
      if (e.loc) {
        e.loc = {
          line: e.loc.line,
          column: e.loc.column - 1
          // 1-based
        };
        e.frame = generateCodeFrame(css, e.loc);
      }
      throw e;
    }
  }
  try {
    const { code, warnings } = await transform$1(css, {
      loader: "css",
      target: config.build.cssTarget || void 0,
      ...resolveMinifyCssEsbuildOptions(config.esbuild || {})
    });
    if (warnings.length) {
      const msgs = await formatMessages(warnings, { kind: "warning" });
      config.logger.warn(
        colors$1.yellow(`[esbuild css minify]
${msgs.join("\n")}`)
      );
    }
    return inlined ? code.trimEnd() : code;
  } catch (e) {
    if (e.errors) {
      e.message = "[esbuild css minify] " + e.message;
      const msgs = await formatMessages(e.errors, { kind: "error" });
      e.frame = "\n" + msgs.join("\n");
      e.loc = e.errors[0].location;
    }
    throw e;
  }
}
function resolveMinifyCssEsbuildOptions(options) {
  const base = {
    charset: options.charset ?? "utf8",
    logLevel: options.logLevel,
    logLimit: options.logLimit,
    logOverride: options.logOverride,
    legalComments: options.legalComments
  };
  if (options.minifyIdentifiers != null || options.minifySyntax != null || options.minifyWhitespace != null) {
    return {
      ...base,
      minifyIdentifiers: options.minifyIdentifiers ?? true,
      minifySyntax: options.minifySyntax ?? true,
      minifyWhitespace: options.minifyWhitespace ?? true
    };
  } else {
    return { ...base, minify: true };
  }
}
const atImportRE = /@import(?:\s*(?:url\([^)]*\)|"(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*').*?|[^;]*);/g;
const atCharsetRE = /@charset(?:\s*(?:"(?:[^"]|(?<=\\)")*"|'(?:[^']|(?<=\\)')*').*?|[^;]*);/g;
async function hoistAtRules(css) {
  const s = new MagicString(css);
  const cleanCss = emptyCssComments(css);
  let match;
  atImportRE.lastIndex = 0;
  while (match = atImportRE.exec(cleanCss)) {
    s.remove(match.index, match.index + match[0].length);
    s.appendLeft(0, match[0]);
  }
  atCharsetRE.lastIndex = 0;
  let foundCharset = false;
  while (match = atCharsetRE.exec(cleanCss)) {
    s.remove(match.index, match.index + match[0].length);
    if (!foundCharset) {
      s.prepend(match[0]);
      foundCharset = true;
    }
  }
  return s.toString();
}
const loadedPreprocessorPath = {};
function loadPreprocessorPath(lang, root) {
  const cached = loadedPreprocessorPath[lang];
  if (cached) {
    return cached;
  }
  try {
    const resolved = requireResolveFromRootWithFallback(root, lang);
    return loadedPreprocessorPath[lang] = resolved;
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      const installCommand = getPackageManagerCommand("install");
      throw new Error(
        `Preprocessor dependency "${lang}" not found. Did you install it? Try \`${installCommand} -D ${lang}\`.`
      );
    } else {
      const message = new Error(
        `Preprocessor dependency "${lang}" failed to load:
${e.message}`
      );
      message.stack = e.stack + "\n" + message.stack;
      throw message;
    }
  }
}
function loadSassPackage(root) {
  try {
    const path2 = loadPreprocessorPath("sass-embedded", root);
    return { name: "sass-embedded", path: path2 };
  } catch (e1) {
    try {
      const path2 = loadPreprocessorPath("sass" /* sass */, root);
      return { name: "sass", path: path2 };
    } catch {
      throw e1;
    }
  }
}
let cachedSss;
function loadSss(root) {
  if (cachedSss) return cachedSss;
  const sssPath = loadPreprocessorPath("sugarss" /* sss */, root);
  cachedSss = createRequire$1(import.meta.url)(sssPath);
  return cachedSss;
}
function cleanScssBugUrl(url) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined" && typeof location.href === "string"
  ) {
    const prefix = location.href.replace(/\/$/, "");
    return url.replace(prefix, "");
  } else {
    return url;
  }
}
function fixScssBugImportValue(data) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined" && data && "file" in data && (!("contents" in data) || data.contents == null)
  ) {
    data.contents = fs__default.readFileSync(data.file, "utf-8");
  }
  return data;
}
const makeScssWorker = (environment, resolvers, alias, maxWorkers, packageName) => {
  const internalImporter = async (url, importer, filename) => {
    importer = cleanScssBugUrl(importer);
    const resolved = await resolvers.sass(environment, url, importer);
    if (resolved) {
      try {
        const data = await rebaseUrls(
          environment,
          resolved,
          filename,
          alias,
          "$",
          resolvers.sass
        );
        if (packageName === "sass-embedded") {
          return data;
        }
        return fixScssBugImportValue(data);
      } catch (data) {
        return data;
      }
    } else {
      return null;
    }
  };
  const worker = new WorkerWithFallback(
    () => async (sassPath, data, options) => {
      const sass = require(sassPath);
      const path2 = require("node:path");
      const _internalImporter = (url, importer2, done) => {
        internalImporter(url, importer2, options.filename).then(
          (data2) => done(data2)
        );
      };
      const importer = [_internalImporter];
      if (options.importer) {
        if (Array.isArray(options.importer)) {
          importer.unshift(...options.importer);
        } else {
          importer.unshift(options.importer);
        }
      }
      const finalOptions = {
        // support @import from node dependencies by default
        includePaths: ["node_modules"],
        ...options,
        data,
        file: options.filename,
        outFile: options.filename,
        importer,
        ...options.enableSourcemap ? {
          sourceMap: true,
          omitSourceMapUrl: true,
          sourceMapRoot: path2.dirname(options.filename)
        } : {}
      };
      return new Promise((resolve, reject) => {
        sass.render(finalOptions, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve({
              css: res.css.toString(),
              map: res.map?.toString(),
              stats: res.stats
            });
          }
        });
      });
    },
    {
      parentFunctions: { internalImporter },
      shouldUseFake(_sassPath, _data, options) {
        return !!(options.functions && Object.keys(options.functions).length > 0 || options.importer && (!Array.isArray(options.importer) || options.importer.length > 0) || options.logger || options.pkgImporter);
      },
      max: maxWorkers
    }
  );
  return worker;
};
const makeModernScssWorker = (environment, resolvers, alias, maxWorkers) => {
  const internalCanonicalize = async (url, importer) => {
    importer = cleanScssBugUrl(importer);
    const resolved = await resolvers.sass(environment, url, importer);
    return resolved ?? null;
  };
  const internalLoad = async (file, rootFile) => {
    const result = await rebaseUrls(
      environment,
      file,
      rootFile,
      alias,
      "$",
      resolvers.sass
    );
    if (result.contents) {
      return result.contents;
    }
    return await fsp.readFile(result.file, "utf-8");
  };
  const worker = new WorkerWithFallback(
    () => async (sassPath, data, options) => {
      const sass = require(sassPath);
      const path2 = require("node:path");
      const { fileURLToPath: fileURLToPath2, pathToFileURL: pathToFileURL2 } = (
        // eslint-disable-next-line no-restricted-globals
        require("node:url")
      );
      const sassOptions = { ...options };
      sassOptions.url = pathToFileURL2(options.filename);
      sassOptions.sourceMap = options.enableSourcemap;
      const internalImporter = {
        async canonicalize(url, context) {
          const importer = context.containingUrl ? fileURLToPath2(context.containingUrl) : options.filename;
          const resolved = await internalCanonicalize(url, importer);
          if (resolved && // only limit to these extensions because:
          // - for the `@import`/`@use`s written in file loaded by `load` function,
          //   the `canonicalize` function of that `importer` is called first
          // - the `load` function of an importer is only called for the importer
          //   that returned a non-null result from its `canonicalize` function
          (resolved.endsWith(".css") || resolved.endsWith(".scss") || resolved.endsWith(".sass"))) {
            return pathToFileURL2(resolved);
          }
          return null;
        },
        async load(canonicalUrl) {
          const ext = path2.extname(canonicalUrl.pathname);
          let syntax = "scss";
          if (ext === ".sass") {
            syntax = "indented";
          } else if (ext === ".css") {
            syntax = "css";
          }
          const contents = await internalLoad(
            fileURLToPath2(canonicalUrl),
            options.filename
          );
          return { contents, syntax, sourceMapUrl: canonicalUrl };
        }
      };
      sassOptions.importers = [
        ...sassOptions.importers ?? [],
        internalImporter
      ];
      const result = await sass.compileStringAsync(data, sassOptions);
      return {
        css: result.css,
        map: result.sourceMap ? JSON.stringify(result.sourceMap) : void 0,
        stats: {
          includedFiles: result.loadedUrls.filter((url) => url.protocol === "file:").map((url) => fileURLToPath2(url))
        }
      };
    },
    {
      parentFunctions: {
        internalCanonicalize,
        internalLoad
      },
      shouldUseFake(_sassPath, _data, options) {
        return !!(options.functions && Object.keys(options.functions).length > 0 || options.importers && (!Array.isArray(options.importers) || options.importers.length > 0) || options.logger);
      },
      max: maxWorkers
    }
  );
  return worker;
};
const makeModernCompilerScssWorker = (environment, resolvers, alias, _maxWorkers) => {
  let compilerPromise;
  const worker = {
    async run(sassPath, data, options) {
      const sass = (await import(pathToFileURL$1(sassPath).href)).default;
      compilerPromise ??= sass.initAsyncCompiler();
      const compiler = await compilerPromise;
      const sassOptions = { ...options };
      sassOptions.url = pathToFileURL$1(options.filename);
      sassOptions.sourceMap = options.enableSourcemap;
      const internalImporter = {
        async canonicalize(url, context) {
          const importer = context.containingUrl ? fileURLToPath$1(context.containingUrl) : options.filename;
          const resolved = await resolvers.sass(
            environment,
            url,
            cleanScssBugUrl(importer)
          );
          if (resolved && (resolved.endsWith(".css") || resolved.endsWith(".scss") || resolved.endsWith(".sass"))) {
            return pathToFileURL$1(resolved);
          }
          return null;
        },
        async load(canonicalUrl) {
          const ext = path$b.extname(canonicalUrl.pathname);
          let syntax = "scss";
          if (ext === ".sass") {
            syntax = "indented";
          } else if (ext === ".css") {
            syntax = "css";
          }
          const result2 = await rebaseUrls(
            environment,
            fileURLToPath$1(canonicalUrl),
            options.filename,
            alias,
            "$",
            resolvers.sass
          );
          const contents = result2.contents ?? await fsp.readFile(result2.file, "utf-8");
          return { contents, syntax, sourceMapUrl: canonicalUrl };
        }
      };
      sassOptions.importers = [
        ...sassOptions.importers ?? [],
        internalImporter
      ];
      const result = await compiler.compileStringAsync(data, sassOptions);
      return {
        css: result.css,
        map: result.sourceMap ? JSON.stringify(result.sourceMap) : void 0,
        stats: {
          includedFiles: result.loadedUrls.filter((url) => url.protocol === "file:").map((url) => fileURLToPath$1(url))
        }
      };
    },
    async stop() {
      (await compilerPromise)?.dispose();
      compilerPromise = void 0;
    }
  };
  return worker;
};
const scssProcessor = (maxWorkers) => {
  const workerMap = /* @__PURE__ */ new Map();
  return {
    close() {
      for (const worker of workerMap.values()) {
        worker.stop();
      }
    },
    async process(environment, source, root, options, resolvers) {
      const sassPackage = loadSassPackage(root);
      const api = options.api ?? (sassPackage.name === "sass-embedded" ? "modern-compiler" : "modern");
      if (!workerMap.has(options.alias)) {
        workerMap.set(
          options.alias,
          api === "modern-compiler" ? makeModernCompilerScssWorker(
            environment,
            resolvers,
            options.alias) : api === "modern" ? makeModernScssWorker(
            environment,
            resolvers,
            options.alias,
            maxWorkers
          ) : makeScssWorker(
            environment,
            resolvers,
            options.alias,
            maxWorkers,
            sassPackage.name
          )
        );
      }
      const worker = workerMap.get(options.alias);
      const { content: data, map: additionalMap } = await getSource(
        source,
        options.filename,
        options.additionalData,
        options.enableSourcemap
      );
      const optionsWithoutAdditionalData = {
        ...options,
        additionalData: void 0
      };
      try {
        const result = await worker.run(
          sassPackage.path,
          data,
          // @ts-expect-error the correct worker is selected for `options.type`
          optionsWithoutAdditionalData
        );
        const deps = result.stats.includedFiles.map((f) => cleanScssBugUrl(f));
        const map2 = result.map ? JSON.parse(result.map.toString()) : void 0;
        if (map2) {
          map2.sources = map2.sources.map(
            (url) => url.startsWith("file://") ? normalizePath$3(fileURLToPath$1(url)) : url
          );
        }
        return {
          code: result.css.toString(),
          map: map2,
          additionalMap,
          deps
        };
      } catch (e) {
        e.message = `[sass] ${e.message}`;
        e.id = e.file;
        e.frame = e.formatted;
        if (e.span?.start) {
          e.line = e.span.start.line + 1;
          e.column = e.span.start.column + 1;
          e.frame = e.message;
        }
        return { code: "", error: e, deps: [] };
      }
    }
  };
};
async function rebaseUrls(environment, file, rootFile, alias, variablePrefix, resolver) {
  file = path$b.resolve(file);
  const fileDir = path$b.dirname(file);
  const rootDir = path$b.dirname(rootFile);
  if (fileDir === rootDir) {
    return { file };
  }
  const content = await fsp.readFile(file, "utf-8");
  const hasUrls = cssUrlRE.test(content);
  const hasDataUris = cssDataUriRE.test(content);
  const hasImportCss = importCssRE.test(content);
  if (!hasUrls && !hasDataUris && !hasImportCss) {
    return { file };
  }
  let rebased;
  const rebaseFn = async (url) => {
    if (url[0] === "/") return url;
    if (url.startsWith(variablePrefix)) return url;
    for (const { find } of alias) {
      const matches = typeof find === "string" ? url.startsWith(find) : find.test(url);
      if (matches) {
        return url;
      }
    }
    const absolute = await resolver(environment, url, file) || path$b.resolve(fileDir, url);
    const relative = path$b.relative(rootDir, absolute);
    return normalizePath$3(relative);
  };
  if (hasImportCss) {
    rebased = await rewriteImportCss(content, rebaseFn);
  }
  if (hasUrls) {
    rebased = await rewriteCssUrls(rebased || content, rebaseFn);
  }
  if (hasDataUris) {
    rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
  }
  return {
    file,
    contents: rebased
  };
}
const makeLessWorker = (environment, resolvers, alias, maxWorkers) => {
  const viteLessResolve = async (filename, dir, rootFile, mime) => {
    const resolved = await resolvers.less(
      environment,
      filename,
      path$b.join(dir, "*")
    );
    if (!resolved) return void 0;
    if (mime === "application/javascript") {
      const file = path$b.resolve(resolved);
      return { resolved: file };
    }
    const result = await rebaseUrls(
      environment,
      resolved,
      rootFile,
      alias,
      "@",
      resolvers.less
    );
    return {
      resolved,
      contents: "contents" in result ? result.contents : void 0
    };
  };
  const worker = new WorkerWithFallback(
    () => {
      const fsp2 = require("node:fs/promises");
      const path2 = require("node:path");
      let ViteLessManager;
      const createViteLessPlugin = (less, rootFile) => {
        const { FileManager } = less;
        ViteLessManager ??= class ViteManager extends FileManager {
          rootFile;
          constructor(rootFile2) {
            super();
            this.rootFile = rootFile2;
          }
          supports(filename) {
            return !/^(?:https?:)?\/\//.test(filename);
          }
          supportsSync() {
            return false;
          }
          async loadFile(filename, dir, opts, env) {
            const result = await viteLessResolve(
              filename,
              dir,
              this.rootFile,
              opts.mime
            );
            if (result) {
              return {
                filename: path2.resolve(result.resolved),
                contents: result.contents ?? await fsp2.readFile(result.resolved, "utf-8")
              };
            } else {
              return super.loadFile(filename, dir, opts, env);
            }
          }
        };
        return {
          install(_, pluginManager) {
            pluginManager.addFileManager(new ViteLessManager(rootFile));
          },
          minVersion: [3, 0, 0]
        };
      };
      return async (lessPath, content, options) => {
        const nodeLess = require(lessPath);
        const viteResolverPlugin = createViteLessPlugin(
          nodeLess,
          options.filename
        );
        const result = await nodeLess.render(content, {
          // support @import from node dependencies by default
          paths: ["node_modules"],
          ...options,
          plugins: [viteResolverPlugin, ...options.plugins || []],
          ...options.enableSourcemap ? {
            sourceMap: {
              outputSourceFiles: true,
              sourceMapFileInline: false
            }
          } : {}
        });
        return result;
      };
    },
    {
      parentFunctions: { viteLessResolve },
      shouldUseFake(_lessPath, _content, options) {
        return !!options.plugins && options.plugins.length > 0;
      },
      max: maxWorkers
    }
  );
  return worker;
};
const lessProcessor = (maxWorkers) => {
  const workerMap = /* @__PURE__ */ new Map();
  return {
    close() {
      for (const worker of workerMap.values()) {
        worker.stop();
      }
    },
    async process(environment, source, root, options, resolvers) {
      const lessPath = loadPreprocessorPath("less" /* less */, root);
      if (!workerMap.has(options.alias)) {
        workerMap.set(
          options.alias,
          makeLessWorker(environment, resolvers, options.alias, maxWorkers)
        );
      }
      const worker = workerMap.get(options.alias);
      const { content, map: additionalMap } = await getSource(
        source,
        options.filename,
        options.additionalData,
        options.enableSourcemap
      );
      let result;
      const optionsWithoutAdditionalData = {
        ...options,
        additionalData: void 0
      };
      try {
        result = await worker.run(
          lessPath,
          content,
          optionsWithoutAdditionalData
        );
      } catch (e) {
        const error = e;
        const normalizedError = new Error(
          `[less] ${error.message || error.type}`
        );
        normalizedError.loc = {
          file: error.filename || options.filename,
          line: error.line,
          column: error.column
        };
        return { code: "", error: normalizedError, deps: [] };
      }
      const map2 = result.map && JSON.parse(result.map);
      if (map2) {
        delete map2.sourcesContent;
      }
      return {
        code: result.css.toString(),
        map: map2,
        additionalMap,
        deps: result.imports
      };
    }
  };
};
const makeStylWorker = (maxWorkers) => {
  const worker = new WorkerWithFallback(
    () => {
      return async (stylusPath, content, root, options) => {
        const nodeStylus = require(stylusPath);
        const ref = nodeStylus(content, {
          // support @import from node dependencies by default
          paths: ["node_modules"],
          ...options
        });
        if (options.define) {
          for (const key in options.define) {
            ref.define(key, options.define[key]);
          }
        }
        if (options.enableSourcemap) {
          ref.set("sourcemap", {
            comment: false,
            inline: false,
            basePath: root
          });
        }
        return {
          code: ref.render(),
          // @ts-expect-error sourcemap exists
          map: ref.sourcemap,
          deps: ref.deps()
        };
      };
    },
    {
      shouldUseFake(_stylusPath, _content, _root, options) {
        return !!(options.define && Object.values(options.define).some((d) => typeof d === "function"));
      },
      max: maxWorkers
    }
  );
  return worker;
};
const stylProcessor = (maxWorkers) => {
  const workerMap = /* @__PURE__ */ new Map();
  return {
    close() {
      for (const worker of workerMap.values()) {
        worker.stop();
      }
    },
    async process(_environment, source, root, options, _resolvers) {
      const stylusPath = loadPreprocessorPath("stylus" /* stylus */, root);
      if (!workerMap.has(options.alias)) {
        workerMap.set(options.alias, makeStylWorker(maxWorkers));
      }
      const worker = workerMap.get(options.alias);
      const { content, map: additionalMap } = await getSource(
        source,
        options.filename,
        options.additionalData,
        options.enableSourcemap,
        "\n"
      );
      const importsDeps = (options.imports ?? []).map(
        (dep) => path$b.resolve(dep)
      );
      const optionsWithoutAdditionalData = {
        ...options,
        additionalData: void 0
      };
      try {
        const { code, map: map2, deps } = await worker.run(
          stylusPath,
          content,
          root,
          optionsWithoutAdditionalData
        );
        return {
          code,
          map: formatStylusSourceMap(map2, root),
          additionalMap,
          // Concat imports deps with computed deps
          deps: [...deps, ...importsDeps]
        };
      } catch (e) {
        const wrapped = new Error(`[stylus] ${e.message}`);
        wrapped.name = e.name;
        wrapped.stack = e.stack;
        return { code: "", error: wrapped, deps: [] };
      }
    }
  };
};
function formatStylusSourceMap(mapBefore, root) {
  if (!mapBefore) return void 0;
  const map2 = { ...mapBefore };
  const resolveFromRoot = (p) => normalizePath$3(path$b.resolve(root, p));
  if (map2.file) {
    map2.file = resolveFromRoot(map2.file);
  }
  map2.sources = map2.sources.map(resolveFromRoot);
  return map2;
}
async function getSource(source, filename, additionalData, enableSourcemap, sep = "") {
  if (!additionalData) return { content: source };
  if (typeof additionalData === "function") {
    const newContent = await additionalData(source, filename);
    if (typeof newContent === "string") {
      return { content: newContent };
    }
    return newContent;
  }
  if (!enableSourcemap) {
    return { content: additionalData + sep + source };
  }
  const ms = new MagicString(source);
  ms.appendLeft(0, sep);
  ms.appendLeft(0, additionalData);
  const map2 = ms.generateMap({ hires: "boundary" });
  map2.file = filename;
  map2.sources = [filename];
  return {
    content: ms.toString(),
    map: map2
  };
}
const createPreprocessorWorkerController = (maxWorkers) => {
  const scss = scssProcessor(maxWorkers);
  const less = lessProcessor(maxWorkers);
  const styl = stylProcessor(maxWorkers);
  const sassProcess = (environment, source, root, options, resolvers) => {
    const opts = { ...options };
    if (opts.api === "legacy") {
      opts.indentedSyntax = true;
    } else {
      opts.syntax = "indented";
    }
    return scss.process(environment, source, root, opts, resolvers);
  };
  const close = () => {
    less.close();
    scss.close();
    styl.close();
  };
  return {
    ["less" /* less */]: less.process,
    ["scss" /* scss */]: scss.process,
    ["sass" /* sass */]: sassProcess,
    ["styl" /* styl */]: styl.process,
    ["stylus" /* stylus */]: styl.process,
    close
  };
};
const normalizeMaxWorkers = (maxWorker) => {
  if (maxWorker === void 0) return 0;
  if (maxWorker === true) return void 0;
  return maxWorker;
};
const preprocessorSet = /* @__PURE__ */ new Set([
  "less" /* less */,
  "sass" /* sass */,
  "scss" /* scss */,
  "styl" /* styl */,
  "stylus" /* stylus */
]);
function isPreProcessor(lang) {
  return lang && preprocessorSet.has(lang);
}
const importLightningCSS = createCachedImport(() => import('lightningcss'));
async function compileLightningCSS(environment, id, src, deps, workerController, urlResolver) {
  const { config } = environment;
  const filename = removeDirectQuery(id).replace("\0", NULL_BYTE_PLACEHOLDER);
  let res;
  try {
    res = styleAttrRE.test(id) ? (await importLightningCSS()).transformStyleAttribute({
      filename,
      code: Buffer.from(src),
      targets: config.css.lightningcss?.targets,
      minify: config.isProduction && !!config.build.cssMinify,
      analyzeDependencies: true
    }) : await (await importLightningCSS()).bundleAsync({
      ...config.css.lightningcss,
      filename,
      // projectRoot is needed to get stable hash when using CSS modules
      projectRoot: config.root,
      resolver: {
        async read(filePath) {
          if (filePath === filename) {
            return src;
          }
          const code = fs__default.readFileSync(filePath, "utf-8");
          const lang = CSS_LANGS_RE.exec(filePath)?.[1];
          if (isPreProcessor(lang)) {
            const result = await compileCSSPreprocessors(
              environment,
              id,
              lang,
              code,
              workerController
            );
            result.deps?.forEach((dep) => deps.add(dep));
            return result.code;
          } else if (lang === "sss") {
            const sssResult = await transformSugarSS(environment, id, code);
            return sssResult.code;
          }
          return code;
        },
        async resolve(id2, from) {
          const publicFile = checkPublicFile(
            id2,
            environment.getTopLevelConfig()
          );
          if (publicFile) {
            return publicFile;
          }
          const atImportResolvers = getAtImportResolvers(
            environment.getTopLevelConfig()
          );
          const lang = CSS_LANGS_RE.exec(from)?.[1];
          let resolver;
          switch (lang) {
            case "css":
            case "sss":
            case "styl":
            case "stylus":
            case void 0:
              resolver = atImportResolvers.css;
              break;
            case "sass":
            case "scss":
              resolver = atImportResolvers.sass;
              break;
            case "less":
              resolver = atImportResolvers.less;
              break;
            default:
              throw new Error(`Unknown lang: ${lang}`);
          }
          const resolved = await resolver(environment, id2, from);
          if (resolved) {
            deps.add(resolved);
            return resolved;
          }
          return id2;
        }
      },
      minify: config.isProduction && !!config.build.cssMinify,
      sourceMap: config.command === "build" ? !!config.build.sourcemap : config.css.devSourcemap,
      analyzeDependencies: true,
      cssModules: cssModuleRE.test(id) ? config.css.lightningcss?.cssModules ?? true : void 0
    });
  } catch (e) {
    e.message = `[lightningcss] ${e.message}`;
    if (e.loc) {
      e.loc = {
        file: e.fileName.replace(NULL_BYTE_PLACEHOLDER, "\0"),
        line: e.loc.line,
        column: e.loc.column - 1
        // 1-based
      };
      try {
        const code = fs__default.readFileSync(e.fileName, "utf-8");
        const friendlyMessage = getLightningCssErrorMessageForIeSyntaxes(code);
        if (friendlyMessage) {
          e.message += friendlyMessage;
        }
      } catch {
      }
    }
    throw e;
  }
  for (const warning of res.warnings) {
    let msg = `[vite:css][lightningcss] ${warning.message}`;
    msg += `
${generateCodeFrame(src, {
      line: warning.loc.line,
      column: warning.loc.column - 1
      // 1-based
    })}`;
    environment.logger.warn(colors$1.yellow(msg));
  }
  let css = decoder.decode(res.code);
  for (const dep of res.dependencies) {
    switch (dep.type) {
      case "url": {
        let replaceUrl;
        if (skipUrlReplacer(dep.url)) {
          replaceUrl = dep.url;
        } else if (urlResolver) {
          const [newUrl, resolvedId] = await urlResolver(
            dep.url,
            dep.loc.filePath.replace(NULL_BYTE_PLACEHOLDER, "\0")
          );
          if (newUrl.startsWith("data:") && resolvedId) {
            deps.add(resolvedId);
          }
          replaceUrl = newUrl;
        } else {
          replaceUrl = dep.url;
        }
        css = css.replace(
          dep.placeholder,
          // lightningcss always generates `url("placeholder")`
          // (`url('placeholder')`, `url(placeholder)` is not generated)
          // so escape double quotes
          () => replaceUrl.replaceAll('"', '\\"')
        );
        break;
      }
      default:
        throw new Error(`Unsupported dependency type: ${dep.type}`);
    }
  }
  let modules;
  if ("exports" in res && res.exports) {
    modules = {};
    const sortedEntries = Object.entries(res.exports).sort(
      (a, b) => a[0].localeCompare(b[0])
    );
    for (const [key, value] of sortedEntries) {
      modules[key] = value.name;
      for (const c of value.composes) {
        modules[key] += " " + c.name;
      }
    }
  }
  return {
    code: css,
    map: "map" in res ? res.map?.toString() : void 0,
    modules
  };
}
function getLightningCssErrorMessageForIeSyntaxes(code) {
  const commonIeMessage = ", which was used in the past to support old Internet Explorer versions. This is not a valid CSS syntax and will be ignored by modern browsers. \nWhile this is not supported by LightningCSS, you can set `css.lightningcss.errorRecovery: true` to strip these codes.";
  if (/[\s;{]\*[a-zA-Z-][\w-]+\s*:/.test(code)) {
    return ".\nThis file contains star property hack (e.g. `*zoom`)" + commonIeMessage;
  }
  if (/min-width:\s*0\\0/.test(code)) {
    return ".\nThis file contains @media zero hack (e.g. `@media (min-width: 0\\0)`)" + commonIeMessage;
  }
  return void 0;
}
const map = {
  chrome: "chrome",
  edge: "edge",
  firefox: "firefox",
  hermes: false,
  ie: "ie",
  ios: "ios_saf",
  node: false,
  opera: "opera",
  rhino: false,
  safari: "safari"
};
const esMap = {
  // https://caniuse.com/?search=es2015
  2015: ["chrome49", "edge13", "safari10", "firefox44", "opera36"],
  // https://caniuse.com/?search=es2016
  2016: ["chrome50", "edge13", "safari10", "firefox43", "opera37"],
  // https://caniuse.com/?search=es2017
  2017: ["chrome58", "edge15", "safari11", "firefox52", "opera45"],
  // https://caniuse.com/?search=es2018
  2018: ["chrome63", "edge79", "safari12", "firefox58", "opera50"],
  // https://caniuse.com/?search=es2019
  2019: ["chrome73", "edge79", "safari12.1", "firefox64", "opera60"],
  // https://caniuse.com/?search=es2020
  2020: ["chrome80", "edge80", "safari14.1", "firefox80", "opera67"],
  // https://caniuse.com/?search=es2021
  2021: ["chrome85", "edge85", "safari14.1", "firefox80", "opera71"],
  // https://caniuse.com/?search=es2022
  2022: ["chrome94", "edge94", "safari16.4", "firefox93", "opera80"],
  // https://caniuse.com/?search=es2023
  2023: ["chrome110", "edge110", "safari16.4", "opera96"]
};
const esRE = /es(\d{4})/;
const versionRE = /\d/;
const convertTargetsCache = /* @__PURE__ */ new Map();
const convertTargets = (esbuildTarget) => {
  if (!esbuildTarget) return {};
  const cached = convertTargetsCache.get(esbuildTarget);
  if (cached) return cached;
  const targets = {};
  const entriesWithoutES = arraify(esbuildTarget).flatMap((e) => {
    const match = esRE.exec(e);
    if (!match) return e;
    const year = Number(match[1]);
    if (!esMap[year]) throw new Error(`Unsupported target "${e}"`);
    return esMap[year];
  });
  for (const entry of entriesWithoutES) {
    if (entry === "esnext") continue;
    const index = entry.search(versionRE);
    if (index >= 0) {
      const browser = map[entry.slice(0, index)];
      if (browser === false) continue;
      if (browser) {
        const [major, minor = 0] = entry.slice(index).split(".").map((v) => parseInt(v, 10));
        if (!isNaN(major) && !isNaN(minor)) {
          const version = major << 16 | minor << 8;
          if (!targets[browser] || version < targets[browser]) {
            targets[browser] = version;
          }
          continue;
        }
      }
    }
    throw new Error(`Unsupported target "${entry}"`);
  }
  convertTargetsCache.set(esbuildTarget, targets);
  return targets;
};
function resolveLibCssFilename(libOptions, root, packageCache) {
  if (typeof libOptions.cssFileName === "string") {
    return `${libOptions.cssFileName}.css`;
  } else if (typeof libOptions.fileName === "string") {
    return `${libOptions.fileName}.css`;
  }
  const packageJson = findNearestMainPackageData(root, packageCache)?.data;
  const name = packageJson ? getPkgName(packageJson.name) : void 0;
  if (!name)
    throw new Error(
      'Name in package.json is required if option "build.lib.cssFileName" is not provided.'
    );
  return `${name}.css`;
}

const isModernFlag = `__VITE_IS_MODERN__`;
const preloadMethod = `__vitePreload`;
const preloadMarker = `__VITE_PRELOAD__`;
const preloadHelperId = "\0vite/preload-helper.js";
const preloadMarkerRE = new RegExp(preloadMarker, "g");
const dynamicImportPrefixRE = /import\s*\(/;
const dynamicImportTreeshakenRE = /((?:\bconst\s+|\blet\s+|\bvar\s+|,\s*)(\{[^{}.=]+\})\s*=\s*await\s+import\([^)]+\))|(\(\s*await\s+import\([^)]+\)\s*\)(\??\.[\w$]+))|\bimport\([^)]+\)(\s*\.then\(\s*(?:function\s*)?\(\s*\{([^{}.=]+)\}\))/g;
function toRelativePath(filename, importer) {
  const relPath = path$b.posix.relative(path$b.posix.dirname(importer), filename);
  return relPath[0] === "." ? relPath : `./${relPath}`;
}
function indexOfMatchInSlice(str, reg, pos = 0) {
  reg.lastIndex = pos;
  const result = reg.exec(str);
  return result?.index ?? -1;
}
function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}
function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (__VITE_IS_MODERN__ && deps && deps.length > 0) {
    let allSettled2 = function(promises) {
      return Promise.all(
        promises.map(
          (p) => Promise.resolve(p).then(
            (value) => ({ status: "fulfilled", value }),
            (reason) => ({ status: "rejected", reason })
          )
        )
      );
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled2(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link2 = links[i];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
}
function buildImportAnalysisPlugin(config) {
  const getInsertPreload = (environment) => environment.config.consumer === "client" && !config.isWorker && !config.build.lib;
  const renderBuiltUrl = config.experimental.renderBuiltUrl;
  const isRelativeBase = config.base === "./" || config.base === "";
  return {
    name: "vite:build-import-analysis",
    resolveId: {
      handler(id) {
        if (id === preloadHelperId) {
          return id;
        }
      }
    },
    load: {
      handler(id) {
        if (id === preloadHelperId) {
          const { modulePreload } = this.environment.config.build;
          const scriptRel2 = modulePreload && modulePreload.polyfill ? `'modulepreload'` : `/* @__PURE__ */ (${detectScriptRel.toString()})()`;
          const assetsURL2 = renderBuiltUrl || isRelativeBase ? (
            // If `experimental.renderBuiltUrl` is used, the dependencies might be relative to the current chunk.
            // If relative base is used, the dependencies are relative to the current chunk.
            // The importerUrl is passed as third parameter to __vitePreload in this case
            `function(dep, importerUrl) { return new URL(dep, importerUrl).href }`
          ) : (
            // If the base isn't relative, then the deps are relative to the projects `outDir` and the base
            // is appended inside __vitePreload too.
            `function(dep) { return ${JSON.stringify(config.base)}+dep }`
          );
          const preloadCode = `const scriptRel = ${scriptRel2};const assetsURL = ${assetsURL2};const seen = {};export const ${preloadMethod} = ${preload.toString()}`;
          return { code: preloadCode, moduleSideEffects: false };
        }
      }
    },
    transform: {
      async handler(source, importer) {
        if (isInNodeModules$1(importer) && !dynamicImportPrefixRE.test(source)) {
          return;
        }
        await init;
        let imports = [];
        try {
          imports = parse$d(source)[0];
        } catch (_e) {
          const e = _e;
          const { message, showCodeFrame } = createParseErrorInfo(
            importer,
            source
          );
          this.error(message, showCodeFrame ? e.idx : void 0);
        }
        if (!imports.length) {
          return null;
        }
        const insertPreload = getInsertPreload(this.environment);
        const dynamicImports = {};
        if (insertPreload) {
          let match;
          while (match = dynamicImportTreeshakenRE.exec(source)) {
            if (match[1]) {
              dynamicImports[dynamicImportTreeshakenRE.lastIndex] = {
                declaration: `const ${match[2]}`,
                names: match[2]?.trim()
              };
              continue;
            }
            if (match[3]) {
              let names2 = /\.([^.?]+)/.exec(match[4])?.[1] || "";
              if (names2 === "default") {
                names2 = "default: __vite_default__";
              }
              dynamicImports[dynamicImportTreeshakenRE.lastIndex - match[4]?.length - 1] = { declaration: `const {${names2}}`, names: `{ ${names2} }` };
              continue;
            }
            const names = match[6]?.trim();
            dynamicImports[dynamicImportTreeshakenRE.lastIndex - match[5]?.length] = { declaration: `const {${names}}`, names: `{ ${names} }` };
          }
        }
        let s;
        const str = () => s || (s = new MagicString(source));
        let needPreloadHelper = false;
        for (let index = 0; index < imports.length; index++) {
          const {
            s: start,
            e: end,
            ss: expStart,
            se: expEnd,
            d: dynamicIndex,
            a: attributeIndex
          } = imports[index];
          const isDynamicImport = dynamicIndex > -1;
          if (!isDynamicImport && attributeIndex > -1) {
            str().remove(end + 1, expEnd);
          }
          if (isDynamicImport && insertPreload && // Only preload static urls
          (source[start] === '"' || source[start] === "'" || source[start] === "`")) {
            needPreloadHelper = true;
            const { declaration, names } = dynamicImports[expEnd] || {};
            if (names) {
              str().prependLeft(
                expStart,
                `${preloadMethod}(async () => { ${declaration} = await `
              );
              str().appendRight(expEnd, `;return ${names}}`);
            } else {
              str().prependLeft(expStart, `${preloadMethod}(() => `);
            }
            str().appendRight(
              expEnd,
              `,${isModernFlag}?${preloadMarker}:void 0${renderBuiltUrl || isRelativeBase ? ",import.meta.url" : ""})`
            );
          }
        }
        if (needPreloadHelper && insertPreload && !source.includes(`const ${preloadMethod} =`)) {
          str().prepend(
            `import { ${preloadMethod} } from "${preloadHelperId}";`
          );
        }
        if (s) {
          return {
            code: s.toString(),
            map: this.environment.config.build.sourcemap ? s.generateMap({ hires: "boundary" }) : null
          };
        }
      }
    },
    renderChunk(code, _, { format }) {
      if (code.indexOf(isModernFlag) > -1) {
        const re = new RegExp(isModernFlag, "g");
        const isModern = String(format === "es");
        const isModernWithPadding = isModern + " ".repeat(isModernFlag.length - isModern.length);
        return {
          code: code.replace(re, isModernWithPadding),
          map: null
        };
      }
      return null;
    },
    generateBundle({ format }, bundle) {
      if (format !== "es") {
        return;
      }
      if (!getInsertPreload(this.environment)) {
        const removedPureCssFiles = removedPureCssFilesCache.get(config);
        if (removedPureCssFiles && removedPureCssFiles.size > 0) {
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk" && chunk.code.includes("import")) {
              const code = chunk.code;
              let imports;
              try {
                imports = parse$d(code)[0].filter((i) => i.d > -1);
              } catch (e) {
                const loc = numberToPos(code, e.idx);
                this.error({
                  name: e.name,
                  message: e.message,
                  stack: e.stack,
                  cause: e.cause,
                  pos: e.idx,
                  loc: { ...loc, file: chunk.fileName },
                  frame: generateCodeFrame(code, loc)
                });
              }
              for (const imp of imports) {
                const {
                  n: name,
                  s: start,
                  e: end,
                  ss: expStart,
                  se: expEnd
                } = imp;
                let url = name;
                if (!url) {
                  const rawUrl = code.slice(start, end);
                  if (rawUrl[0] === `"` && rawUrl.endsWith(`"`))
                    url = rawUrl.slice(1, -1);
                }
                if (!url) continue;
                const normalizedFile = path$b.posix.join(
                  path$b.posix.dirname(chunk.fileName),
                  url
                );
                if (removedPureCssFiles.has(normalizedFile)) {
                  chunk.code = chunk.code.slice(0, expStart) + `Promise.resolve({${"".padEnd(expEnd - expStart - 19, " ")}})` + chunk.code.slice(expEnd);
                }
              }
            }
          }
        }
        return;
      }
      const buildSourcemap = this.environment.config.build.sourcemap;
      const { modulePreload } = this.environment.config.build;
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
          const code = chunk.code;
          let imports;
          try {
            imports = parse$d(code)[0].filter((i) => i.d > -1);
          } catch (e) {
            const loc = numberToPos(code, e.idx);
            this.error({
              name: e.name,
              message: e.message,
              stack: e.stack,
              cause: e.cause,
              pos: e.idx,
              loc: { ...loc, file: chunk.fileName },
              frame: generateCodeFrame(code, loc)
            });
          }
          const s = new MagicString(code);
          const rewroteMarkerStartPos = /* @__PURE__ */ new Set();
          const fileDeps = [];
          const addFileDep = (url, runtime = false) => {
            const index = fileDeps.findIndex((dep) => dep.url === url);
            if (index === -1) {
              return fileDeps.push({ url, runtime }) - 1;
            } else {
              return index;
            }
          };
          if (imports.length) {
            for (let index = 0; index < imports.length; index++) {
              const {
                n: name,
                s: start,
                e: end,
                ss: expStart,
                se: expEnd
              } = imports[index];
              let url = name;
              if (!url) {
                const rawUrl = code.slice(start, end);
                if (rawUrl[0] === `"` && rawUrl.endsWith(`"`))
                  url = rawUrl.slice(1, -1);
              }
              const deps = /* @__PURE__ */ new Set();
              let hasRemovedPureCssChunk = false;
              let normalizedFile = void 0;
              if (url) {
                normalizedFile = path$b.posix.join(
                  path$b.posix.dirname(chunk.fileName),
                  url
                );
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename) return;
                  if (analyzed.has(filename)) return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    deps.add(chunk2.fileName);
                    if (chunk2.type === "chunk") {
                      chunk2.imports.forEach(addDeps);
                      chunk2.viteMetadata.importedCss.forEach((file2) => {
                        deps.add(file2);
                      });
                    }
                  } else {
                    const removedPureCssFiles = removedPureCssFilesCache.get(config);
                    const chunk3 = removedPureCssFiles.get(filename);
                    if (chunk3) {
                      if (chunk3.viteMetadata.importedCss.size) {
                        chunk3.viteMetadata.importedCss.forEach((file2) => {
                          deps.add(file2);
                        });
                        hasRemovedPureCssChunk = true;
                      }
                      s.update(expStart, expEnd, "Promise.resolve({})");
                    }
                  }
                };
                addDeps(normalizedFile);
              }
              let markerStartPos2 = indexOfMatchInSlice(
                code,
                preloadMarkerRE,
                end
              );
              if (markerStartPos2 === -1 && imports.length === 1) {
                markerStartPos2 = indexOfMatchInSlice(code, preloadMarkerRE);
              }
              if (markerStartPos2 > 0) {
                let depsArray = deps.size > 1 || // main chunk is removed
                hasRemovedPureCssChunk && deps.size > 0 ? modulePreload === false ? (
                  // CSS deps use the same mechanism as module preloads, so even if disabled,
                  // we still need to pass these deps to the preload helper in dynamic imports.
                  [...deps].filter((d) => d.endsWith(".css"))
                ) : [...deps] : [];
                const resolveDependencies = modulePreload ? modulePreload.resolveDependencies : void 0;
                if (resolveDependencies && normalizedFile) {
                  const cssDeps = [];
                  const otherDeps = [];
                  for (const dep of depsArray) {
                    (dep.endsWith(".css") ? cssDeps : otherDeps).push(dep);
                  }
                  depsArray = [
                    ...resolveDependencies(normalizedFile, otherDeps, {
                      hostId: file,
                      hostType: "js"
                    }),
                    ...cssDeps
                  ];
                }
                let renderedDeps;
                if (renderBuiltUrl) {
                  renderedDeps = depsArray.map((dep) => {
                    const replacement = toOutputFilePathInJS(
                      this.environment,
                      dep,
                      "asset",
                      chunk.fileName,
                      "js",
                      toRelativePath
                    );
                    if (typeof replacement === "string") {
                      return addFileDep(replacement);
                    }
                    return addFileDep(replacement.runtime, true);
                  });
                } else {
                  renderedDeps = depsArray.map(
                    (d) => (
                      // Don't include the assets dir if the default asset file names
                      // are used, the path will be reconstructed by the import preload helper
                      isRelativeBase ? addFileDep(toRelativePath(d, file)) : addFileDep(d)
                    )
                  );
                }
                s.update(
                  markerStartPos2,
                  markerStartPos2 + preloadMarker.length,
                  renderedDeps.length > 0 ? `__vite__mapDeps([${renderedDeps.join(",")}])` : `[]`
                );
                rewroteMarkerStartPos.add(markerStartPos2);
              }
            }
          }
          if (fileDeps.length > 0) {
            const fileDepsCode = `[${fileDeps.map(
              (fileDep) => fileDep.runtime ? fileDep.url : JSON.stringify(fileDep.url)
            ).join(",")}]`;
            const mapDepsCode = `const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=${fileDepsCode})))=>i.map(i=>d[i]);
`;
            if (code.startsWith("#!")) {
              s.prependLeft(code.indexOf("\n") + 1, mapDepsCode);
            } else {
              s.prepend(mapDepsCode);
            }
          }
          let markerStartPos = indexOfMatchInSlice(code, preloadMarkerRE);
          while (markerStartPos >= 0) {
            if (!rewroteMarkerStartPos.has(markerStartPos)) {
              s.update(
                markerStartPos,
                markerStartPos + preloadMarker.length,
                "void 0"
              );
            }
            markerStartPos = indexOfMatchInSlice(
              code,
              preloadMarkerRE,
              markerStartPos + preloadMarker.length
            );
          }
          if (s.hasChanged()) {
            chunk.code = s.toString();
            if (buildSourcemap && chunk.map) {
              const nextMap = s.generateMap({
                source: chunk.fileName,
                hires: "boundary"
              });
              const map = combineSourcemaps(chunk.fileName, [
                nextMap,
                chunk.map
              ]);
              map.toUrl = () => genSourceMapUrl(map);
              const originalDebugId = chunk.map.debugId;
              chunk.map = map;
              if (buildSourcemap === "inline") {
                chunk.code = chunk.code.replace(
                  convertSourceMap.mapFileCommentRegex,
                  ""
                );
                chunk.code += `
//# sourceMappingURL=${genSourceMapUrl(map)}`;
              } else {
                if (originalDebugId) {
                  map.debugId = originalDebugId;
                }
                const mapAsset = bundle[chunk.fileName + ".map"];
                if (mapAsset && mapAsset.type === "asset") {
                  mapAsset.source = map.toString();
                }
              }
            }
          }
        }
      }
    }
  };
}

function ssrManifestPlugin() {
  const getSsrManifest = perEnvironmentState(() => {
    return {};
  });
  return {
    name: "vite:ssr-manifest",
    applyToEnvironment(environment) {
      return !!environment.config.build.ssrManifest;
    },
    generateBundle(_options, bundle) {
      const config = this.environment.config;
      const ssrManifest = getSsrManifest(this);
      const { base } = config;
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          for (const id in chunk.modules) {
            const normalizedId = normalizePath$3(relative$2(config.root, id));
            const mappedChunks = ssrManifest[normalizedId] ?? (ssrManifest[normalizedId] = []);
            if (!chunk.isEntry) {
              mappedChunks.push(joinUrlSegments(base, chunk.fileName));
              chunk.viteMetadata.importedCss.forEach((file2) => {
                mappedChunks.push(joinUrlSegments(base, file2));
              });
            }
            chunk.viteMetadata.importedAssets.forEach((file2) => {
              mappedChunks.push(joinUrlSegments(base, file2));
            });
          }
          if (chunk.code.includes(preloadMethod)) {
            const code = chunk.code;
            let imports = [];
            try {
              imports = parse$d(code)[0].filter((i) => i.n && i.d > -1);
            } catch (_e) {
              const e = _e;
              const loc = numberToPos(code, e.idx);
              this.error({
                name: e.name,
                message: e.message,
                stack: e.stack,
                cause: e.cause,
                pos: e.idx,
                loc: { ...loc, file: chunk.fileName },
                frame: generateCodeFrame(code, loc)
              });
            }
            if (imports.length) {
              for (let index = 0; index < imports.length; index++) {
                const { s: start, e: end, n: name } = imports[index];
                const url = code.slice(start, end);
                const deps = [];
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename) return;
                  if (analyzed.has(filename)) return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    chunk2.viteMetadata.importedCss.forEach((file2) => {
                      deps.push(joinUrlSegments(base, file2));
                    });
                    chunk2.imports.forEach(addDeps);
                  }
                };
                const normalizedFile = normalizePath$3(
                  join$1(dirname$2(chunk.fileName), url.slice(1, -1))
                );
                addDeps(normalizedFile);
                ssrManifest[basename$2(name)] = deps;
              }
            }
          }
        }
      }
      this.emitFile({
        fileName: typeof config.build.ssrManifest === "string" ? config.build.ssrManifest : ".vite/ssr-manifest.json",
        type: "asset",
        source: JSON.stringify(sortObjectKeys(ssrManifest), void 0, 2)
      });
    }
  };
}

function buildLoadFallbackPlugin() {
  return {
    name: "vite:load-fallback",
    load: {
      async handler(id) {
        try {
          const cleanedId = cleanUrl(id);
          const content = await fsp.readFile(cleanedId, "utf-8");
          this.addWatchFile(cleanedId);
          return content;
        } catch {
          const content = await fsp.readFile(id, "utf-8");
          this.addWatchFile(id);
          return content;
        }
      }
    }
  };
}

function completeSystemWrapPlugin() {
  const SystemJSWrapRE = /System.register\(.*?(\(exports\)|\(\))/g;
  return {
    name: "vite:force-systemjs-wrap-complete",
    renderChunk(code, _chunk, opts) {
      if (opts.format === "system") {
        return {
          code: code.replace(
            SystemJSWrapRE,
            (s, s1) => s.replace(s1, "(exports, module)")
          ),
          map: null
        };
      }
    }
  };
}

const buildEnvironmentOptionsDefaults = Object.freeze({
  target: "modules",
  /** @deprecated */
  polyfillModulePreload: true,
  modulePreload: true,
  outDir: "dist",
  assetsDir: "assets",
  assetsInlineLimit: DEFAULT_ASSETS_INLINE_LIMIT,
  // cssCodeSplit
  // cssTarget
  // cssMinify
  sourcemap: false,
  // minify
  terserOptions: {},
  rollupOptions: {},
  commonjsOptions: {
    include: [/node_modules/],
    extensions: [".js", ".cjs"]
  },
  dynamicImportVarsOptions: {
    warnOnError: true,
    exclude: [/node_modules/]
  },
  write: true,
  emptyOutDir: null,
  copyPublicDir: true,
  manifest: false,
  lib: false,
  // ssr
  ssrManifest: false,
  ssrEmitAssets: false,
  // emitAssets
  reportCompressedSize: true,
  chunkSizeWarningLimit: 500,
  watch: null
  // createEnvironment
});
function resolveBuildEnvironmentOptions(raw, logger, consumer) {
  const deprecatedPolyfillModulePreload = raw.polyfillModulePreload;
  const { polyfillModulePreload, ...rest } = raw;
  raw = rest;
  if (deprecatedPolyfillModulePreload !== void 0) {
    logger.warn(
      "polyfillModulePreload is deprecated. Use modulePreload.polyfill instead."
    );
  }
  if (deprecatedPolyfillModulePreload === false && raw.modulePreload === void 0) {
    raw.modulePreload = { polyfill: false };
  }
  const merged = mergeWithDefaults(
    {
      ...buildEnvironmentOptionsDefaults,
      cssCodeSplit: !raw.lib,
      minify: consumer === "server" ? false : "esbuild",
      ssr: consumer === "server",
      emitAssets: consumer === "client",
      createEnvironment: (name, config) => new BuildEnvironment(name, config)
    },
    raw
  );
  if (merged.target === "modules") {
    merged.target = ESBUILD_MODULES_TARGET;
  }
  if (merged.minify === "false") {
    merged.minify = false;
  } else if (merged.minify === true) {
    merged.minify = "esbuild";
  }
  const defaultModulePreload = {
    polyfill: true
  };
  const resolved = {
    ...merged,
    cssTarget: merged.cssTarget ?? merged.target,
    cssMinify: merged.cssMinify ?? (consumer === "server" ? "esbuild" : !!merged.minify),
    // Resolve to false | object
    modulePreload: merged.modulePreload === false ? false : merged.modulePreload === true ? defaultModulePreload : {
      ...defaultModulePreload,
      ...merged.modulePreload
    }
  };
  return resolved;
}
async function resolveBuildPlugins(config) {
  return {
    pre: [
      completeSystemWrapPlugin(),
      perEnvironmentPlugin("commonjs", (environment) => {
        const { commonjsOptions } = environment.config.build;
        const usePluginCommonjs = !Array.isArray(commonjsOptions.include) || commonjsOptions.include.length !== 0;
        return usePluginCommonjs ? commonjs(commonjsOptions) : false;
      }),
      dataURIPlugin(),
      perEnvironmentPlugin(
        "vite:rollup-options-plugins",
        async (environment) => (await asyncFlatten(
          arraify(environment.config.build.rollupOptions.plugins)
        )).filter(Boolean)
      ),
      ...config.isWorker ? [webWorkerPostPlugin()] : []
    ],
    post: [
      buildImportAnalysisPlugin(config),
      buildEsbuildPlugin(),
      terserPlugin(config),
      ...!config.isWorker ? [manifestPlugin(), ssrManifestPlugin(), buildReporterPlugin(config)] : [],
      buildLoadFallbackPlugin()
    ]
  };
}
async function build(inlineConfig = {}) {
  const builder = await createBuilder(inlineConfig, true);
  const environment = Object.values(builder.environments)[0];
  if (!environment) throw new Error("No environment found");
  return builder.build(environment);
}
function resolveConfigToBuild(inlineConfig = {}, patchConfig, patchPlugins) {
  return resolveConfig(
    inlineConfig,
    "build",
    "production",
    "production",
    false,
    patchConfig,
    patchPlugins
  );
}
async function buildEnvironment(environment) {
  const { root, packageCache } = environment.config;
  const options = environment.config.build;
  const libOptions = options.lib;
  const { logger } = environment;
  const ssr = environment.config.consumer === "server";
  logger.info(
    colors$1.cyan(
      `vite v${VERSION} ${colors$1.green(
        `building ${ssr ? `SSR bundle ` : ``}for ${environment.config.mode}...`
      )}`
    )
  );
  const resolve = (p) => path$b.resolve(root, p);
  const input = libOptions ? options.rollupOptions.input || (typeof libOptions.entry === "string" ? resolve(libOptions.entry) : Array.isArray(libOptions.entry) ? libOptions.entry.map(resolve) : Object.fromEntries(
    Object.entries(libOptions.entry).map(([alias, file]) => [
      alias,
      resolve(file)
    ])
  )) : typeof options.ssr === "string" ? resolve(options.ssr) : options.rollupOptions.input || resolve("index.html");
  if (ssr && typeof input === "string" && input.endsWith(".html")) {
    throw new Error(
      `rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.`
    );
  }
  if (options.cssCodeSplit === false) {
    const inputs = typeof input === "string" ? [input] : Array.isArray(input) ? input : Object.values(input);
    if (inputs.some((input2) => input2.endsWith(".css"))) {
      throw new Error(
        `When "build.cssCodeSplit: false" is set, "rollupOptions.input" should not include CSS files.`
      );
    }
  }
  const outDir = resolve(options.outDir);
  const plugins = environment.plugins.map(
    (p) => injectEnvironmentAndFilterToHooks(environment, p)
  );
  const rollupOptions = {
    preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false,
    cache: options.watch ? void 0 : false,
    ...options.rollupOptions,
    output: options.rollupOptions.output,
    input,
    plugins,
    external: options.rollupOptions.external,
    onLog(level, log) {
      onRollupLog(level, log, environment);
    }
  };
  function extractStack(e) {
    const { stack, name = "Error", message } = e;
    if (!stack) {
      return stack;
    }
    const expectedPrefix = `${name}: ${message}
`;
    if (stack.startsWith(expectedPrefix)) {
      return stack.slice(expectedPrefix.length);
    }
    return stack;
  }
  const normalizeCodeFrame = (frame) => {
    const trimmedPadding = frame.replace(/^\n|\n$/g, "");
    return `
${trimmedPadding}
`;
  };
  const enhanceRollupError = (e) => {
    const stackOnly = extractStack(e);
    let msg = colors$1.red((e.plugin ? `[${e.plugin}] ` : "") + e.message);
    if (e.loc && e.loc.file && e.loc.file !== e.id) {
      msg += `
file: ${colors$1.cyan(
        `${e.loc.file}:${e.loc.line}:${e.loc.column}` + (e.id ? ` (${e.id})` : "")
      )}`;
    } else if (e.id) {
      msg += `
file: ${colors$1.cyan(
        e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : "")
      )}`;
    }
    if (e.frame) {
      msg += `
` + colors$1.yellow(normalizeCodeFrame(e.frame));
    }
    e.message = msg;
    if (stackOnly !== void 0) {
      e.stack = `${e.message}
${stackOnly}`;
    }
  };
  const outputBuildError = (e) => {
    enhanceRollupError(e);
    clearLine();
    logger.error(e.message, { error: e });
  };
  const isSsrTargetWebworkerEnvironment = environment.name === "ssr" && environment.getTopLevelConfig().ssr?.target === "webworker";
  let bundle;
  let startTime;
  try {
    const buildOutputOptions = (output = {}) => {
      if (output.output) {
        logger.warn(
          `You've set "rollupOptions.output.output" in your config. This is deprecated and will override all Vite.js default output options. Please use "rollupOptions.output" instead.`
        );
      }
      if (output.file) {
        throw new Error(
          `Vite does not support "rollupOptions.output.file". Please use "rollupOptions.output.dir" and "rollupOptions.output.entryFileNames" instead.`
        );
      }
      if (output.sourcemap) {
        logger.warnOnce(
          colors$1.yellow(
            `Vite does not support "rollupOptions.output.sourcemap". Please use "build.sourcemap" instead.`
          )
        );
      }
      const format = output.format || "es";
      const jsExt = ssr && !isSsrTargetWebworkerEnvironment || libOptions ? resolveOutputJsExtension(
        format,
        findNearestPackageData(root, packageCache)?.data.type
      ) : "js";
      return {
        dir: outDir,
        // Default format is 'es' for regular and for SSR builds
        format,
        exports: "auto",
        sourcemap: options.sourcemap,
        name: libOptions ? libOptions.name : void 0,
        hoistTransitiveImports: libOptions ? false : void 0,
        // es2015 enables `generatedCode.symbols`
        // - #764 add `Symbol.toStringTag` when build es module into cjs chunk
        // - #1048 add `Symbol.toStringTag` for module default export
        generatedCode: "es2015",
        entryFileNames: ssr ? `[name].${jsExt}` : libOptions ? ({ name }) => resolveLibFilename(
          libOptions,
          format,
          name,
          root,
          jsExt,
          packageCache
        ) : path$b.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
        chunkFileNames: libOptions ? `[name]-[hash].${jsExt}` : path$b.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
        assetFileNames: libOptions ? `[name].[ext]` : path$b.posix.join(options.assetsDir, `[name]-[hash].[ext]`),
        inlineDynamicImports: output.format === "umd" || output.format === "iife" || isSsrTargetWebworkerEnvironment && (typeof input === "string" || Object.keys(input).length === 1),
        ...output
      };
    };
    const outputs = resolveBuildOutputs(
      options.rollupOptions.output,
      libOptions,
      logger
    );
    const normalizedOutputs = [];
    if (Array.isArray(outputs)) {
      for (const resolvedOutput of outputs) {
        normalizedOutputs.push(buildOutputOptions(resolvedOutput));
      }
    } else {
      normalizedOutputs.push(buildOutputOptions(outputs));
    }
    const resolvedOutDirs = getResolvedOutDirs(
      root,
      options.outDir,
      options.rollupOptions.output
    );
    const emptyOutDir = resolveEmptyOutDir(
      options.emptyOutDir,
      root,
      resolvedOutDirs,
      logger
    );
    if (options.watch) {
      logger.info(colors$1.cyan(`
watching for file changes...`));
      const resolvedChokidarOptions = resolveChokidarOptions(
        options.watch.chokidar,
        resolvedOutDirs,
        emptyOutDir,
        environment.config.cacheDir
      );
      const { watch } = await import('rollup');
      const watcher = watch({
        ...rollupOptions,
        output: normalizedOutputs,
        watch: {
          ...options.watch,
          chokidar: resolvedChokidarOptions
        }
      });
      watcher.on("event", (event) => {
        if (event.code === "BUNDLE_START") {
          logger.info(colors$1.cyan(`
build started...`));
          if (options.write) {
            prepareOutDir(resolvedOutDirs, emptyOutDir, environment);
          }
        } else if (event.code === "BUNDLE_END") {
          event.result.close();
          logger.info(colors$1.cyan(`built in ${event.duration}ms.`));
        } else if (event.code === "ERROR") {
          outputBuildError(event.error);
        }
      });
      return watcher;
    }
    const { rollup } = await import('rollup');
    startTime = Date.now();
    bundle = await rollup(rollupOptions);
    if (options.write) {
      prepareOutDir(resolvedOutDirs, emptyOutDir, environment);
    }
    const res = [];
    for (const output of normalizedOutputs) {
      res.push(await bundle[options.write ? "write" : "generate"](output));
    }
    logger.info(
      `${colors$1.green(`\u2713 built in ${displayTime(Date.now() - startTime)}`)}`
    );
    return Array.isArray(outputs) ? res : res[0];
  } catch (e) {
    enhanceRollupError(e);
    clearLine();
    if (startTime) {
      logger.error(
        `${colors$1.red("\u2717")} Build failed in ${displayTime(Date.now() - startTime)}`
      );
      startTime = void 0;
    }
    throw e;
  } finally {
    if (bundle) await bundle.close();
  }
}
function prepareOutDir(outDirs, emptyOutDir, environment) {
  const { publicDir } = environment.config;
  const outDirsArray = [...outDirs];
  for (const outDir of outDirs) {
    if (emptyOutDir !== false && fs__default.existsSync(outDir)) {
      const skipDirs = outDirsArray.map((dir) => {
        const relative = path$b.relative(outDir, dir);
        if (relative && !relative.startsWith("..") && !path$b.isAbsolute(relative)) {
          return relative;
        }
        return "";
      }).filter(Boolean);
      emptyDir(outDir, [...skipDirs, ".git"]);
    }
    if (environment.config.build.copyPublicDir && publicDir && fs__default.existsSync(publicDir)) {
      if (!areSeparateFolders(outDir, publicDir)) {
        environment.logger.warn(
          colors$1.yellow(
            `
${colors$1.bold(
              `(!)`
            )} The public directory feature may not work correctly. outDir ${colors$1.white(
              colors$1.dim(outDir)
            )} and publicDir ${colors$1.white(
              colors$1.dim(publicDir)
            )} are not separate folders.
`
          )
        );
      }
      copyDir(publicDir, outDir);
    }
  }
}
function resolveOutputJsExtension(format, type = "commonjs") {
  if (type === "module") {
    return format === "cjs" || format === "umd" ? "cjs" : "js";
  } else {
    return format === "es" ? "mjs" : "js";
  }
}
function resolveLibFilename(libOptions, format, entryName, root, extension, packageCache) {
  if (typeof libOptions.fileName === "function") {
    return libOptions.fileName(format, entryName);
  }
  const packageJson = findNearestMainPackageData(root, packageCache)?.data;
  const name = libOptions.fileName || (packageJson && typeof libOptions.entry === "string" ? getPkgName(packageJson.name) : entryName);
  if (!name)
    throw new Error(
      'Name in package.json is required if option "build.lib.fileName" is not provided.'
    );
  extension ??= resolveOutputJsExtension(format, packageJson?.type);
  if (format === "cjs" || format === "es") {
    return `${name}.${extension}`;
  }
  return `${name}.${format}.${extension}`;
}
function resolveBuildOutputs(outputs, libOptions, logger) {
  if (libOptions) {
    const libHasMultipleEntries = typeof libOptions.entry !== "string" && Object.values(libOptions.entry).length > 1;
    const libFormats = libOptions.formats || (libHasMultipleEntries ? ["es", "cjs"] : ["es", "umd"]);
    if (!Array.isArray(outputs)) {
      if (libFormats.includes("umd") || libFormats.includes("iife")) {
        if (libHasMultipleEntries) {
          throw new Error(
            'Multiple entry points are not supported when output formats include "umd" or "iife".'
          );
        }
        if (!libOptions.name) {
          throw new Error(
            'Option "build.lib.name" is required when output formats include "umd" or "iife".'
          );
        }
      }
      return libFormats.map((format) => ({ ...outputs, format }));
    }
    if (libOptions.formats) {
      logger.warn(
        colors$1.yellow(
          '"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.'
        )
      );
    }
    outputs.forEach((output) => {
      if ((output.format === "umd" || output.format === "iife") && !output.name) {
        throw new Error(
          'Entries in "build.rollupOptions.output" must specify "name" when the format is "umd" or "iife".'
        );
      }
    });
  }
  return outputs;
}
const warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
const dynamicImportWarningIgnoreList = [
  `Unsupported expression`,
  `statically analyzed`
];
function clearLine() {
  const tty = process.stdout.isTTY && !process.env.CI;
  if (tty) {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
  }
}
function onRollupLog(level, log, environment) {
  const debugLogger = createDebugger("vite:build");
  const viteLog = (logLeveling, rawLogging) => {
    const logging = typeof rawLogging === "object" ? rawLogging : { message: rawLogging };
    if (logging.code === "UNRESOLVED_IMPORT") {
      const id = logging.id;
      const exporter = logging.exporter;
      if (!id || !id.endsWith("?commonjs-external")) {
        throw new Error(
          `[vite]: Rollup failed to resolve import "${exporter}" from "${id}".
This is most likely unintended because it can break your application at runtime.
If you do want to externalize this module explicitly add it to
\`build.rollupOptions.external\``
        );
      }
    }
    if (logLeveling === "warn") {
      if (logging.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some(
        (msg) => logging.message.includes(msg)
      )) {
        return;
      }
      if (warningIgnoreList.includes(logging.code)) {
        return;
      }
    }
    switch (logLeveling) {
      case "info":
        environment.logger.info(logging.message);
        return;
      case "warn":
        environment.logger.warn(colors$1.yellow(logging.message));
        return;
      case "error":
        environment.logger.error(colors$1.red(logging.message));
        return;
      case "debug":
        debugLogger?.(logging.message);
        return;
      default:
        environment.logger.info(logging.message);
        return;
    }
  };
  clearLine();
  const userOnLog = environment.config.build.rollupOptions?.onLog;
  const userOnWarn = environment.config.build.rollupOptions?.onwarn;
  if (userOnLog) {
    if (userOnWarn) {
      const normalizedUserOnWarn = normalizeUserOnWarn(userOnWarn, viteLog);
      userOnLog(level, log, normalizedUserOnWarn);
    } else {
      userOnLog(level, log, viteLog);
    }
  } else if (userOnWarn) {
    const normalizedUserOnWarn = normalizeUserOnWarn(userOnWarn, viteLog);
    normalizedUserOnWarn(level, log);
  } else {
    viteLog(level, log);
  }
}
function normalizeUserOnWarn(userOnWarn, defaultHandler) {
  return (logLevel, logging) => {
    if (logLevel === "warn") {
      userOnWarn(
        normalizeLog(logging),
        (log) => defaultHandler("warn", typeof log === "function" ? log() : log)
      );
    } else {
      defaultHandler(logLevel, logging);
    }
  };
}
const normalizeLog = (log) => typeof log === "string" ? { message: log } : log;
function resolveUserExternal(user, id, parentId, isResolved) {
  if (typeof user === "function") {
    return user(id, parentId, isResolved);
  } else if (Array.isArray(user)) {
    return user.some((test) => isExternal(id, test));
  } else {
    return isExternal(id, user);
  }
}
function isExternal(id, test) {
  if (typeof test === "string") {
    return id === test;
  } else {
    return test.test(id);
  }
}
function injectEnvironmentAndFilterToHooks(environment, plugin) {
  const { resolveId, load, transform } = plugin;
  const clone = { ...plugin };
  for (const hook of Object.keys(clone)) {
    switch (hook) {
      case "resolveId":
        clone[hook] = wrapEnvironmentAndFilterResolveId(environment, resolveId);
        break;
      case "load":
        clone[hook] = wrapEnvironmentAndFilterLoad(environment, load);
        break;
      case "transform":
        clone[hook] = wrapEnvironmentAndFilterTransform(environment, transform);
        break;
      default:
        if (ROLLUP_HOOKS.includes(hook)) {
          clone[hook] = wrapEnvironmentHook(environment, clone[hook]);
        }
        break;
    }
  }
  return clone;
}
function wrapEnvironmentAndFilterResolveId(environment, hook) {
  if (!hook) return;
  const rawIdFilter = typeof hook === "object" ? hook.filter?.id : void 0;
  const idFilter = rawIdFilter ? createIdFilter(rawIdFilter) : void 0;
  const fn = getHookHandler(hook);
  const handler = function(id, importer, options) {
    if (idFilter && !idFilter(id)) {
      return;
    }
    return fn.call(
      injectEnvironmentInContext(this, environment),
      id,
      importer,
      injectSsrFlag(options, environment)
    );
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapEnvironmentAndFilterLoad(environment, hook) {
  if (!hook) return;
  const rawIdFilter = typeof hook === "object" ? hook.filter?.id : void 0;
  const idFilter = rawIdFilter ? createIdFilter(rawIdFilter) : void 0;
  const fn = getHookHandler(hook);
  const handler = function(id, ...args) {
    if (idFilter && !idFilter(id)) {
      return;
    }
    return fn.call(
      injectEnvironmentInContext(this, environment),
      id,
      injectSsrFlag(args[0], environment)
    );
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapEnvironmentAndFilterTransform(environment, hook) {
  if (!hook) return;
  const filters = typeof hook === "object" ? hook.filter : void 0;
  const filter = filters ? createFilterForTransform(filters.id, filters.code) : void 0;
  const fn = getHookHandler(hook);
  const handler = function(code, importer, ...args) {
    if (filter && !filter(importer, code)) {
      return;
    }
    return fn.call(
      injectEnvironmentInContext(this, environment),
      code,
      importer,
      injectSsrFlag(args[0], environment)
    );
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapEnvironmentHook(environment, hook) {
  if (!hook) return;
  const fn = getHookHandler(hook);
  if (typeof fn !== "function") return hook;
  const handler = function(...args) {
    return fn.call(injectEnvironmentInContext(this, environment), ...args);
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function injectEnvironmentInContext(context, environment) {
  context.environment ??= environment;
  return context;
}
function injectSsrFlag(options, environment) {
  const ssr = environment ? environment.config.consumer === "server" : true;
  return { ...options ?? {}, ssr };
}
const needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
const quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
const backSlashRegEx = /\\/g;
function escapeId(id) {
  if (!needsEscapeRegEx.test(id)) return id;
  return id.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
const getResolveUrl = (path2, URL = "URL") => `new ${URL}(${path2}).href`;
const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(
  `'${escapeId(partialEncodeURIPath(relativePath))}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`
);
const getFileUrlFromFullPath = (path2) => `require('u' + 'rl').pathToFileURL(${path2}).href`;
const getFileUrlFromRelativePath = (path2) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path2)}'`);
const relativeUrlMechanisms = {
  amd: (relativePath) => {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) => getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) => getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
const customRelativeUrlMechanisms = {
  ...relativeUrlMechanisms,
  "worker-iife": (relativePath) => getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', self.location.href`
  )
};
function toOutputFilePathInJS(environment, filename, type, hostId, hostType, toRelative) {
  const { experimental, base, decodedBase } = environment.config;
  const ssr = environment.config.consumer === "server";
  const { renderBuiltUrl } = experimental;
  let relative = base === "" || base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        return { runtime: result.runtime };
      }
      if (typeof result.relative === "boolean") {
        relative = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative && !ssr) {
    return toRelative(filename, hostId);
  }
  return joinUrlSegments(decodedBase, filename);
}
function createToImportMetaURLBasedRelativeRuntime(format, isWorker) {
  const formatLong = isWorker && format === "iife" ? "worker-iife" : format;
  const toRelativePath = customRelativeUrlMechanisms[formatLong];
  return (filename, importer) => ({
    runtime: toRelativePath(
      path$b.posix.relative(path$b.dirname(importer), filename)
    )
  });
}
function toOutputFilePathWithoutRuntime(filename, type, hostId, hostType, config, toRelative) {
  const { renderBuiltUrl } = config.experimental;
  let relative = config.base === "" || config.base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config.build.ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        throw new Error(
          `{ runtime: "${result.runtime}" } is not supported for assets in ${hostType} files: ${filename}`
        );
      }
      if (typeof result.relative === "boolean") {
        relative = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative && !config.build.ssr) {
    return toRelative(filename, hostId);
  } else {
    return joinUrlSegments(config.decodedBase, filename);
  }
}
const toOutputFilePathInCss = toOutputFilePathWithoutRuntime;
const toOutputFilePathInHtml = toOutputFilePathWithoutRuntime;
function areSeparateFolders(a, b) {
  const na = normalizePath$3(a);
  const nb = normalizePath$3(b);
  return na !== nb && !na.startsWith(withTrailingSlash(nb)) && !nb.startsWith(withTrailingSlash(na));
}
class BuildEnvironment extends BaseEnvironment {
  mode = "build";
  constructor(name, config, setup) {
    let options = config.environments[name] ?? getDefaultResolvedEnvironmentOptions(config);
    if (setup?.options) {
      options = mergeConfig(
        options,
        setup.options
      );
    }
    super(name, config, options);
  }
  async init() {
    if (this._initiated) {
      return;
    }
    this._initiated = true;
    this._plugins = await resolveEnvironmentPlugins(this);
  }
}
async function defaultBuildApp(builder) {
  for (const environment of Object.values(builder.environments)) {
    await builder.build(environment);
  }
}
const builderOptionsDefaults = Object.freeze({
  sharedConfigBuild: false,
  sharedPlugins: false
  // buildApp
});
function resolveBuilderOptions(options) {
  if (!options) return;
  return mergeWithDefaults(
    { ...builderOptionsDefaults, buildApp: defaultBuildApp },
    options
  );
}
async function createBuilder(inlineConfig = {}, useLegacyBuilder = false) {
  const patchConfig = (resolved) => {
    if (!(useLegacyBuilder ?? !resolved.builder)) return;
    const environmentName = resolved.build.ssr ? "ssr" : "client";
    resolved.build = {
      ...resolved.environments[environmentName].build
    };
  };
  const config = await resolveConfigToBuild(inlineConfig, patchConfig);
  useLegacyBuilder ??= !config.builder;
  const configBuilder = config.builder ?? resolveBuilderOptions({});
  const environments = {};
  const builder = {
    environments,
    config,
    async buildApp() {
      return configBuilder.buildApp(builder);
    },
    async build(environment) {
      return buildEnvironment(environment);
    }
  };
  async function setupEnvironment(name, config2) {
    const environment = await config2.build.createEnvironment(name, config2);
    await environment.init();
    environments[name] = environment;
  }
  if (useLegacyBuilder) {
    await setupEnvironment(config.build.ssr ? "ssr" : "client", config);
  } else {
    for (const environmentName of Object.keys(config.environments)) {
      let environmentConfig = config;
      if (!configBuilder.sharedConfigBuild) {
        const patchConfig2 = (resolved) => {
          resolved.build = {
            ...resolved.environments[environmentName].build
          };
        };
        const patchPlugins = (resolvedPlugins) => {
          let j = 0;
          for (let i = 0; i < resolvedPlugins.length; i++) {
            const environmentPlugin = resolvedPlugins[i];
            if (configBuilder.sharedPlugins || environmentPlugin.sharedDuringBuild) {
              for (let k = j; k < config.plugins.length; k++) {
                if (environmentPlugin.name === config.plugins[k].name) {
                  resolvedPlugins[i] = config.plugins[k];
                  j = k + 1;
                  break;
                }
              }
            }
          }
        };
        environmentConfig = await resolveConfigToBuild(
          inlineConfig,
          patchConfig2,
          patchPlugins
        );
      }
      await setupEnvironment(environmentName, environmentConfig);
    }
  }
  return builder;
}

var build$1 = {
	__proto__: null,
	BuildEnvironment: BuildEnvironment,
	build: build,
	buildEnvironmentOptionsDefaults: buildEnvironmentOptionsDefaults,
	builderOptionsDefaults: builderOptionsDefaults,
	createBuilder: createBuilder,
	createToImportMetaURLBasedRelativeRuntime: createToImportMetaURLBasedRelativeRuntime,
	injectEnvironmentAndFilterToHooks: injectEnvironmentAndFilterToHooks,
	onRollupLog: onRollupLog,
	resolveBuildEnvironmentOptions: resolveBuildEnvironmentOptions,
	resolveBuildOutputs: resolveBuildOutputs,
	resolveBuildPlugins: resolveBuildPlugins,
	resolveBuilderOptions: resolveBuilderOptions,
	resolveLibFilename: resolveLibFilename,
	resolveUserExternal: resolveUserExternal,
	toOutputFilePathInCss: toOutputFilePathInCss,
	toOutputFilePathInHtml: toOutputFilePathInHtml,
	toOutputFilePathInJS: toOutputFilePathInJS,
	toOutputFilePathWithoutRuntime: toOutputFilePathWithoutRuntime
};

async function fetchModule(environment, url, importer, options = {}) {
  if (url.startsWith("data:") || isBuiltin(environment.config.resolve.builtins, url)) {
    return { externalize: url, type: "builtin" };
  }
  const isFileUrl = url.startsWith("file://");
  if (isExternalUrl(url) && !isFileUrl) {
    return { externalize: url, type: "network" };
  }
  if (!isFileUrl && importer && url[0] !== "." && url[0] !== "/") {
    const { isProduction, root } = environment.config;
    const { externalConditions, dedupe, preserveSymlinks } = environment.config.resolve;
    const resolved = tryNodeResolve(url, importer, {
      mainFields: ["main"],
      conditions: externalConditions,
      externalConditions,
      external: [],
      noExternal: [],
      extensions: [".js", ".cjs", ".json"],
      dedupe,
      preserveSymlinks,
      isBuild: false,
      isProduction,
      root,
      packageCache: environment.config.packageCache,
      builtins: environment.config.resolve.builtins
    });
    if (!resolved) {
      const err = new Error(
        `Cannot find module '${url}' imported from '${importer}'`
      );
      err.code = "ERR_MODULE_NOT_FOUND";
      throw err;
    }
    const file = pathToFileURL$1(resolved.id).toString();
    const type = isFilePathESM(resolved.id, environment.config.packageCache) ? "module" : "commonjs";
    return { externalize: file, type };
  }
  url = unwrapId$1(url);
  const mod = await environment.moduleGraph.ensureEntryFromUrl(url);
  const cached = !!mod.transformResult;
  if (options.cached && cached) {
    return { cache: true };
  }
  let result = await environment.transformRequest(url);
  if (!result) {
    throw new Error(
      `[vite] transform failed for module '${url}'${importer ? ` imported from '${importer}'` : ""}.`
    );
  }
  if (options.inlineSourceMap !== false) {
    result = inlineSourceMap(mod, result, options.startOffset);
  }
  if (result.code[0] === "#")
    result.code = result.code.replace(/^#!.*/, (s) => " ".repeat(s.length));
  return {
    code: result.code,
    file: mod.file,
    id: mod.id,
    url: mod.url,
    invalidate: !cached
  };
}
const OTHER_SOURCE_MAP_REGEXP = new RegExp(
  `//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`,
  "gm"
);
function inlineSourceMap(mod, result, startOffset) {
  const map = result.map;
  let code = result.code;
  if (!map || !("version" in map) || code.includes(MODULE_RUNNER_SOURCEMAPPING_SOURCE))
    return result;
  OTHER_SOURCE_MAP_REGEXP.lastIndex = 0;
  if (OTHER_SOURCE_MAP_REGEXP.test(code))
    code = code.replace(OTHER_SOURCE_MAP_REGEXP, "");
  const sourceMap = startOffset ? Object.assign({}, map, {
    mappings: ";".repeat(startOffset) + map.mappings
  }) : map;
  result.code = `${code.trimEnd()}
//# sourceURL=${mod.id}
${MODULE_RUNNER_SOURCEMAPPING_SOURCE}
//# ${SOURCEMAPPING_URL}=${genSourceMapUrl(sourceMap)}
`;
  return result;
}

const debug$1 = createDebugger("vite:deps");
const debounceMs = 100;
function createDepsOptimizer(environment) {
  const { logger } = environment;
  const sessionTimestamp = Date.now().toString();
  let debounceProcessingHandle;
  let closed = false;
  const options = environment.config.optimizeDeps;
  const { noDiscovery, holdUntilCrawlEnd } = options;
  let metadata = initDepsOptimizerMetadata(
    environment,
    sessionTimestamp
  );
  const depsOptimizer = {
    init,
    metadata,
    registerMissingImport,
    run: () => debouncedProcessing(0),
    isOptimizedDepFile: createIsOptimizedDepFile(environment),
    isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
    getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
    close,
    options
  };
  let newDepsDiscovered = false;
  let newDepsToLog = [];
  let newDepsToLogHandle;
  const logNewlyDiscoveredDeps = () => {
    if (newDepsToLog.length) {
      logger.info(
        colors$1.green(
          `\u2728 new dependencies optimized: ${depsLogString(newDepsToLog)}`
        ),
        {
          timestamp: true
        }
      );
      newDepsToLog = [];
    }
  };
  let discoveredDepsWhileScanning = [];
  const logDiscoveredDepsWhileScanning = () => {
    if (discoveredDepsWhileScanning.length) {
      logger.info(
        colors$1.green(
          `\u2728 discovered while scanning: ${depsLogString(
            discoveredDepsWhileScanning
          )}`
        ),
        {
          timestamp: true
        }
      );
      discoveredDepsWhileScanning = [];
    }
  };
  let depOptimizationProcessing = promiseWithResolvers();
  let depOptimizationProcessingQueue = [];
  const resolveEnqueuedProcessingPromises = () => {
    for (const processing of depOptimizationProcessingQueue) {
      processing.resolve();
    }
    depOptimizationProcessingQueue = [];
  };
  let enqueuedRerun;
  let currentlyProcessing = false;
  let firstRunCalled = false;
  let warnAboutMissedDependencies = false;
  let waitingForCrawlEnd = false;
  let optimizationResult;
  let discover;
  async function close() {
    closed = true;
    await Promise.allSettled([
      discover?.cancel(),
      depsOptimizer.scanProcessing,
      optimizationResult?.cancel()
    ]);
  }
  let inited = false;
  async function init() {
    if (inited) return;
    inited = true;
    const cachedMetadata = await loadCachedDepOptimizationMetadata(environment);
    firstRunCalled = !!cachedMetadata;
    metadata = depsOptimizer.metadata = cachedMetadata || initDepsOptimizerMetadata(environment, sessionTimestamp);
    if (!cachedMetadata) {
      waitingForCrawlEnd = true;
      currentlyProcessing = true;
      const manuallyIncludedDeps = {};
      await addManuallyIncludedOptimizeDeps(environment, manuallyIncludedDeps);
      const manuallyIncludedDepsInfo = toDiscoveredDependencies(
        environment,
        manuallyIncludedDeps,
        sessionTimestamp
      );
      for (const depInfo of Object.values(manuallyIncludedDepsInfo)) {
        addOptimizedDepInfo(metadata, "discovered", {
          ...depInfo,
          processing: depOptimizationProcessing.promise
        });
        newDepsDiscovered = true;
      }
      environment.waitForRequestsIdle().then(onCrawlEnd);
      if (noDiscovery) {
        runOptimizer();
      } else {
        depsOptimizer.scanProcessing = new Promise((resolve) => {
          (async () => {
            try {
              debug$1?.(colors$1.green(`scanning for dependencies...`));
              discover = discoverProjectDependencies(
                devToScanEnvironment(environment)
              );
              const deps = await discover.result;
              discover = void 0;
              const manuallyIncluded = Object.keys(manuallyIncludedDepsInfo);
              discoveredDepsWhileScanning.push(
                ...Object.keys(metadata.discovered).filter(
                  (dep) => !deps[dep] && !manuallyIncluded.includes(dep)
                )
              );
              for (const id of Object.keys(deps)) {
                if (!metadata.discovered[id]) {
                  addMissingDep(id, deps[id]);
                }
              }
              const knownDeps = prepareKnownDeps();
              startNextDiscoveredBatch();
              optimizationResult = runOptimizeDeps(environment, knownDeps);
              if (!holdUntilCrawlEnd) {
                optimizationResult.result.then((result) => {
                  if (!waitingForCrawlEnd) return;
                  optimizationResult = void 0;
                  runOptimizer(result);
                });
              }
            } catch (e) {
              logger.error(e.stack || e.message);
            } finally {
              resolve();
              depsOptimizer.scanProcessing = void 0;
            }
          })();
        });
      }
    }
  }
  function startNextDiscoveredBatch() {
    newDepsDiscovered = false;
    depOptimizationProcessingQueue.push(depOptimizationProcessing);
    depOptimizationProcessing = promiseWithResolvers();
  }
  function prepareKnownDeps() {
    const knownDeps = {};
    const metadata2 = depsOptimizer.metadata;
    for (const dep of Object.keys(metadata2.optimized)) {
      knownDeps[dep] = { ...metadata2.optimized[dep] };
    }
    for (const dep of Object.keys(metadata2.discovered)) {
      const { processing, ...info } = metadata2.discovered[dep];
      knownDeps[dep] = info;
    }
    return knownDeps;
  }
  async function runOptimizer(preRunResult) {
    const isRerun = firstRunCalled;
    firstRunCalled = true;
    enqueuedRerun = void 0;
    if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle);
    if (closed) {
      currentlyProcessing = false;
      depOptimizationProcessing.resolve();
      resolveEnqueuedProcessingPromises();
      return;
    }
    currentlyProcessing = true;
    try {
      let processingResult;
      if (preRunResult) {
        processingResult = preRunResult;
      } else {
        const knownDeps = prepareKnownDeps();
        startNextDiscoveredBatch();
        optimizationResult = runOptimizeDeps(environment, knownDeps);
        processingResult = await optimizationResult.result;
        optimizationResult = void 0;
      }
      if (closed) {
        currentlyProcessing = false;
        processingResult.cancel();
        resolveEnqueuedProcessingPromises();
        return;
      }
      const newData = processingResult.metadata;
      const needsInteropMismatch = findInteropMismatches(
        metadata.discovered,
        newData.optimized
      );
      const needsReload = needsInteropMismatch.length > 0 || metadata.hash !== newData.hash || Object.keys(metadata.optimized).some((dep) => {
        return metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash;
      });
      const commitProcessing = async () => {
        await processingResult.commit();
        for (const id in metadata.discovered) {
          if (!newData.optimized[id]) {
            addOptimizedDepInfo(newData, "discovered", metadata.discovered[id]);
          }
        }
        if (!needsReload) {
          newData.browserHash = metadata.browserHash;
          for (const dep in newData.chunks) {
            newData.chunks[dep].browserHash = metadata.browserHash;
          }
          for (const dep in newData.optimized) {
            newData.optimized[dep].browserHash = (metadata.optimized[dep] || metadata.discovered[dep]).browserHash;
          }
        }
        for (const o in newData.optimized) {
          const discovered = metadata.discovered[o];
          if (discovered) {
            const optimized = newData.optimized[o];
            discovered.browserHash = optimized.browserHash;
            discovered.fileHash = optimized.fileHash;
            discovered.needsInterop = optimized.needsInterop;
            discovered.processing = void 0;
          }
        }
        if (isRerun) {
          newDepsToLog.push(
            ...Object.keys(newData.optimized).filter(
              (dep) => !metadata.optimized[dep]
            )
          );
        }
        metadata = depsOptimizer.metadata = newData;
        resolveEnqueuedProcessingPromises();
      };
      if (!needsReload) {
        await commitProcessing();
        if (!debug$1) {
          if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
          newDepsToLogHandle = setTimeout(() => {
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
            if (warnAboutMissedDependencies) {
              logDiscoveredDepsWhileScanning();
              logger.info(
                colors$1.magenta(
                  `\u2757 add these dependencies to optimizeDeps.include to speed up cold start`
                ),
                { timestamp: true }
              );
              warnAboutMissedDependencies = false;
            }
          }, 2 * debounceMs);
        } else {
          debug$1(
            colors$1.green(
              `\u2728 ${!isRerun ? `dependencies optimized` : `optimized dependencies unchanged`}`
            )
          );
        }
      } else {
        if (newDepsDiscovered) {
          processingResult.cancel();
          debug$1?.(
            colors$1.green(
              `\u2728 delaying reload as new dependencies have been found...`
            )
          );
        } else {
          await commitProcessing();
          if (!debug$1) {
            if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
            if (warnAboutMissedDependencies) {
              logDiscoveredDepsWhileScanning();
              logger.info(
                colors$1.magenta(
                  `\u2757 add these dependencies to optimizeDeps.include to avoid a full page reload during cold start`
                ),
                { timestamp: true }
              );
              warnAboutMissedDependencies = false;
            }
          }
          logger.info(
            colors$1.green(`\u2728 optimized dependencies changed. reloading`),
            {
              timestamp: true
            }
          );
          if (needsInteropMismatch.length > 0) {
            logger.warn(
              `Mixed ESM and CJS detected in ${colors$1.yellow(
                needsInteropMismatch.join(", ")
              )}, add ${needsInteropMismatch.length === 1 ? "it" : "them"} to optimizeDeps.needsInterop to speed up cold start`,
              {
                timestamp: true
              }
            );
          }
          fullReload();
        }
      }
    } catch (e) {
      logger.error(
        colors$1.red(`error while updating dependencies:
${e.stack}`),
        { timestamp: true, error: e }
      );
      resolveEnqueuedProcessingPromises();
      metadata.discovered = {};
    }
    currentlyProcessing = false;
    enqueuedRerun?.();
  }
  function fullReload() {
    environment.moduleGraph.invalidateAll();
    environment.hot.send({
      type: "full-reload",
      path: "*"
    });
  }
  async function rerun() {
    const deps = Object.keys(metadata.discovered);
    const depsString = depsLogString(deps);
    debug$1?.(colors$1.green(`new dependencies found: ${depsString}`));
    runOptimizer();
  }
  function getDiscoveredBrowserHash(hash, deps, missing) {
    return getHash(
      hash + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp
    );
  }
  function registerMissingImport(id, resolved) {
    const optimized = metadata.optimized[id];
    if (optimized) {
      return optimized;
    }
    const chunk = metadata.chunks[id];
    if (chunk) {
      return chunk;
    }
    let missing = metadata.discovered[id];
    if (missing) {
      return missing;
    }
    missing = addMissingDep(id, resolved);
    if (!waitingForCrawlEnd) {
      debouncedProcessing();
    }
    return missing;
  }
  function addMissingDep(id, resolved) {
    newDepsDiscovered = true;
    return addOptimizedDepInfo(metadata, "discovered", {
      id,
      file: getOptimizedDepPath(environment, id),
      src: resolved,
      // Adding a browserHash to this missing dependency that is unique to
      // the current state of known + missing deps. If its optimizeDeps run
      // doesn't alter the bundled files of previous known dependencies,
      // we don't need a full reload and this browserHash will be kept
      browserHash: getDiscoveredBrowserHash(
        metadata.hash,
        depsFromOptimizedDepInfo(metadata.optimized),
        depsFromOptimizedDepInfo(metadata.discovered)
      ),
      // loading of this pre-bundled dep needs to await for its processing
      // promise to be resolved
      processing: depOptimizationProcessing.promise,
      exportsData: extractExportsData(environment, resolved)
    });
  }
  function debouncedProcessing(timeout = debounceMs) {
    enqueuedRerun = void 0;
    if (debounceProcessingHandle) clearTimeout(debounceProcessingHandle);
    if (newDepsToLogHandle) clearTimeout(newDepsToLogHandle);
    newDepsToLogHandle = void 0;
    debounceProcessingHandle = setTimeout(() => {
      debounceProcessingHandle = void 0;
      enqueuedRerun = rerun;
      if (!currentlyProcessing) {
        enqueuedRerun();
      }
    }, timeout);
  }
  async function onCrawlEnd() {
    waitingForCrawlEnd = false;
    debug$1?.(colors$1.green(`\u2728 static imports crawl ended`));
    if (closed) {
      return;
    }
    await depsOptimizer.scanProcessing;
    if (optimizationResult && !options.noDiscovery) {
      const afterScanResult = optimizationResult.result;
      optimizationResult = void 0;
      const result = await afterScanResult;
      currentlyProcessing = false;
      const crawlDeps = Object.keys(metadata.discovered);
      const scanDeps = Object.keys(result.metadata.optimized);
      if (scanDeps.length === 0 && crawlDeps.length === 0) {
        debug$1?.(
          colors$1.green(
            `\u2728 no dependencies found by the scanner or crawling static imports`
          )
        );
        startNextDiscoveredBatch();
        runOptimizer(result);
        return;
      }
      const needsInteropMismatch = findInteropMismatches(
        metadata.discovered,
        result.metadata.optimized
      );
      const scannerMissedDeps = crawlDeps.some((dep) => !scanDeps.includes(dep));
      const outdatedResult = needsInteropMismatch.length > 0 || scannerMissedDeps;
      if (outdatedResult) {
        result.cancel();
        for (const dep of scanDeps) {
          if (!crawlDeps.includes(dep)) {
            addMissingDep(dep, result.metadata.optimized[dep].src);
          }
        }
        if (scannerMissedDeps) {
          debug$1?.(
            colors$1.yellow(
              `\u2728 new dependencies were found while crawling that weren't detected by the scanner`
            )
          );
        }
        debug$1?.(colors$1.green(`\u2728 re-running optimizer`));
        debouncedProcessing(0);
      } else {
        debug$1?.(
          colors$1.green(
            `\u2728 using post-scan optimizer result, the scanner found every used dependency`
          )
        );
        startNextDiscoveredBatch();
        runOptimizer(result);
      }
    } else if (!holdUntilCrawlEnd) {
      if (newDepsDiscovered) {
        debug$1?.(
          colors$1.green(
            `\u2728 new dependencies were found while crawling static imports, re-running optimizer`
          )
        );
        warnAboutMissedDependencies = true;
        debouncedProcessing(0);
      }
    } else {
      const crawlDeps = Object.keys(metadata.discovered);
      currentlyProcessing = false;
      if (crawlDeps.length === 0) {
        debug$1?.(
          colors$1.green(
            `\u2728 no dependencies found while crawling the static imports`
          )
        );
        firstRunCalled = true;
      }
      debouncedProcessing(0);
    }
  }
  return depsOptimizer;
}
function createExplicitDepsOptimizer(environment) {
  const depsOptimizer = {
    metadata: initDepsOptimizerMetadata(environment),
    isOptimizedDepFile: createIsOptimizedDepFile(environment),
    isOptimizedDepUrl: createIsOptimizedDepUrl(environment),
    getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
    registerMissingImport: () => {
      throw new Error(
        `Vite Internal Error: registerMissingImport is not supported in dev ${environment.name}`
      );
    },
    init,
    // noop, there is no scanning during dev SSR
    // the optimizer blocks the server start
    run: () => {
    },
    close: async () => {
    },
    options: environment.config.optimizeDeps
  };
  let inited = false;
  async function init() {
    if (inited) return;
    inited = true;
    depsOptimizer.metadata = await optimizeExplicitEnvironmentDeps(environment);
  }
  return depsOptimizer;
}
function findInteropMismatches(discovered, optimized) {
  const needsInteropMismatch = [];
  for (const dep in discovered) {
    const discoveredDepInfo = discovered[dep];
    if (discoveredDepInfo.needsInterop === void 0) continue;
    const depInfo = optimized[dep];
    if (!depInfo) continue;
    if (depInfo.needsInterop !== discoveredDepInfo.needsInterop) {
      needsInteropMismatch.push(dep);
      debug$1?.(colors$1.cyan(`\u2728 needsInterop mismatch detected for ${dep}`));
    }
  }
  return needsInteropMismatch;
}

class EnvironmentModuleNode {
  environment;
  /**
   * Public served url path, starts with /
   */
  url;
  /**
   * Resolved file system path + query
   */
  id = null;
  file = null;
  type;
  info;
  meta;
  importers = /* @__PURE__ */ new Set();
  importedModules = /* @__PURE__ */ new Set();
  acceptedHmrDeps = /* @__PURE__ */ new Set();
  acceptedHmrExports = null;
  importedBindings = null;
  isSelfAccepting;
  transformResult = null;
  // ssrModule and ssrError are no longer needed. They are on the module runner module cache.
  // Once `ssrLoadModule` is re-implemented on top of the new APIs, we can delete these.
  ssrModule = null;
  ssrError = null;
  lastHMRTimestamp = 0;
  /**
   * `import.meta.hot.invalidate` is called by the client.
   * If there's multiple clients, multiple `invalidate` request is received.
   * This property is used to dedupe those request to avoid multiple updates happening.
   * @internal
   */
  lastHMRInvalidationReceived = false;
  lastInvalidationTimestamp = 0;
  /**
   * If the module only needs to update its imports timestamp (e.g. within an HMR chain),
   * it is considered soft-invalidated. In this state, its `transformResult` should exist,
   * and the next `transformRequest` for this module will replace the timestamps.
   *
   * By default the value is `undefined` if it's not soft/hard-invalidated. If it gets
   * soft-invalidated, this will contain the previous `transformResult` value. If it gets
   * hard-invalidated, this will be set to `'HARD_INVALIDATED'`.
   * @internal
   */
  invalidationState;
  /**
   * The module urls that are statically imported in the code. This information is separated
   * out from `importedModules` as only importers that statically import the module can be
   * soft invalidated. Other imports (e.g. watched files) needs the importer to be hard invalidated.
   * @internal
   */
  staticImportedUrls;
  /**
   * @param setIsSelfAccepting - set `false` to set `isSelfAccepting` later. e.g. #7870
   */
  constructor(url, environment, setIsSelfAccepting = true) {
    this.environment = environment;
    this.url = url;
    this.type = isDirectCSSRequest(url) ? "css" : "js";
    if (setIsSelfAccepting) {
      this.isSelfAccepting = false;
    }
  }
}
class EnvironmentModuleGraph {
  environment;
  urlToModuleMap = /* @__PURE__ */ new Map();
  idToModuleMap = /* @__PURE__ */ new Map();
  etagToModuleMap = /* @__PURE__ */ new Map();
  // a single file may corresponds to multiple modules with different queries
  fileToModulesMap = /* @__PURE__ */ new Map();
  /**
   * @internal
   */
  _unresolvedUrlToModuleMap = /* @__PURE__ */ new Map();
  /**
   * @internal
   */
  _resolveId;
  /** @internal */
  _hasResolveFailedErrorModules = /* @__PURE__ */ new Set();
  constructor(environment, resolveId) {
    this.environment = environment;
    this._resolveId = resolveId;
  }
  async getModuleByUrl(rawUrl) {
    rawUrl = removeImportQuery(removeTimestampQuery(rawUrl));
    const mod = this._getUnresolvedUrlToModule(rawUrl);
    if (mod) {
      return mod;
    }
    const [url] = await this._resolveUrl(rawUrl);
    return this.urlToModuleMap.get(url);
  }
  getModuleById(id) {
    return this.idToModuleMap.get(removeTimestampQuery(id));
  }
  getModulesByFile(file) {
    return this.fileToModulesMap.get(file);
  }
  onFileChange(file) {
    const mods = this.getModulesByFile(file);
    if (mods) {
      const seen = /* @__PURE__ */ new Set();
      mods.forEach((mod) => {
        this.invalidateModule(mod, seen);
      });
    }
  }
  onFileDelete(file) {
    const mods = this.getModulesByFile(file);
    if (mods) {
      mods.forEach((mod) => {
        mod.importedModules.forEach((importedMod) => {
          importedMod.importers.delete(mod);
        });
      });
    }
  }
  invalidateModule(mod, seen = /* @__PURE__ */ new Set(), timestamp = Date.now(), isHmr = false, softInvalidate = false) {
    const prevInvalidationState = mod.invalidationState;
    if (softInvalidate) {
      mod.invalidationState ??= mod.transformResult ?? "HARD_INVALIDATED";
    } else {
      mod.invalidationState = "HARD_INVALIDATED";
    }
    if (seen.has(mod) && prevInvalidationState === mod.invalidationState) {
      return;
    }
    seen.add(mod);
    if (isHmr) {
      mod.lastHMRTimestamp = timestamp;
      mod.lastHMRInvalidationReceived = false;
    } else {
      mod.lastInvalidationTimestamp = timestamp;
    }
    const etag = mod.transformResult?.etag;
    if (etag) this.etagToModuleMap.delete(etag);
    mod.transformResult = null;
    mod.ssrModule = null;
    mod.ssrError = null;
    mod.importers.forEach((importer) => {
      if (!importer.acceptedHmrDeps.has(mod)) {
        const shouldSoftInvalidateImporter = (importer.staticImportedUrls?.has(mod.url) || softInvalidate) && importer.type !== "css";
        this.invalidateModule(
          importer,
          seen,
          timestamp,
          isHmr,
          shouldSoftInvalidateImporter
        );
      }
    });
    this._hasResolveFailedErrorModules.delete(mod);
  }
  invalidateAll() {
    const timestamp = Date.now();
    const seen = /* @__PURE__ */ new Set();
    this.idToModuleMap.forEach((mod) => {
      this.invalidateModule(mod, seen, timestamp);
    });
  }
  /**
   * Update the module graph based on a module's updated imports information
   * If there are dependencies that no longer have any importers, they are
   * returned as a Set.
   *
   * @param staticImportedUrls Subset of `importedModules` where they're statically imported in code.
   *   This is only used for soft invalidations so `undefined` is fine but may cause more runtime processing.
   */
  async updateModuleInfo(mod, importedModules, importedBindings, acceptedModules, acceptedExports, isSelfAccepting, staticImportedUrls) {
    mod.isSelfAccepting = isSelfAccepting;
    const prevImports = mod.importedModules;
    let noLongerImported;
    let resolvePromises = [];
    let resolveResults = new Array(importedModules.size);
    let index = 0;
    for (const imported of importedModules) {
      const nextIndex = index++;
      if (typeof imported === "string") {
        resolvePromises.push(
          this.ensureEntryFromUrl(imported).then((dep) => {
            dep.importers.add(mod);
            resolveResults[nextIndex] = dep;
          })
        );
      } else {
        imported.importers.add(mod);
        resolveResults[nextIndex] = imported;
      }
    }
    if (resolvePromises.length) {
      await Promise.all(resolvePromises);
    }
    const nextImports = new Set(resolveResults);
    mod.importedModules = nextImports;
    prevImports.forEach((dep) => {
      if (!mod.importedModules.has(dep)) {
        dep.importers.delete(mod);
        if (!dep.importers.size) {
          (noLongerImported || (noLongerImported = /* @__PURE__ */ new Set())).add(dep);
        }
      }
    });
    resolvePromises = [];
    resolveResults = new Array(acceptedModules.size);
    index = 0;
    for (const accepted of acceptedModules) {
      const nextIndex = index++;
      if (typeof accepted === "string") {
        resolvePromises.push(
          this.ensureEntryFromUrl(accepted).then((dep) => {
            resolveResults[nextIndex] = dep;
          })
        );
      } else {
        resolveResults[nextIndex] = accepted;
      }
    }
    if (resolvePromises.length) {
      await Promise.all(resolvePromises);
    }
    mod.acceptedHmrDeps = new Set(resolveResults);
    mod.staticImportedUrls = staticImportedUrls;
    mod.acceptedHmrExports = acceptedExports;
    mod.importedBindings = importedBindings;
    return noLongerImported;
  }
  async ensureEntryFromUrl(rawUrl, setIsSelfAccepting = true) {
    return this._ensureEntryFromUrl(rawUrl, setIsSelfAccepting);
  }
  /**
   * @internal
   */
  async _ensureEntryFromUrl(rawUrl, setIsSelfAccepting = true, resolved) {
    rawUrl = removeImportQuery(removeTimestampQuery(rawUrl));
    let mod = this._getUnresolvedUrlToModule(rawUrl);
    if (mod) {
      return mod;
    }
    const modPromise = (async () => {
      const [url, resolvedId, meta] = await this._resolveUrl(rawUrl, resolved);
      mod = this.idToModuleMap.get(resolvedId);
      if (!mod) {
        mod = new EnvironmentModuleNode(
          url,
          this.environment,
          setIsSelfAccepting
        );
        if (meta) mod.meta = meta;
        this.urlToModuleMap.set(url, mod);
        mod.id = resolvedId;
        this.idToModuleMap.set(resolvedId, mod);
        const file = mod.file = cleanUrl(resolvedId);
        let fileMappedModules = this.fileToModulesMap.get(file);
        if (!fileMappedModules) {
          fileMappedModules = /* @__PURE__ */ new Set();
          this.fileToModulesMap.set(file, fileMappedModules);
        }
        fileMappedModules.add(mod);
      } else if (!this.urlToModuleMap.has(url)) {
        this.urlToModuleMap.set(url, mod);
      }
      this._setUnresolvedUrlToModule(rawUrl, mod);
      return mod;
    })();
    this._setUnresolvedUrlToModule(rawUrl, modPromise);
    return modPromise;
  }
  // some deps, like a css file referenced via @import, don't have its own
  // url because they are inlined into the main css import. But they still
  // need to be represented in the module graph so that they can trigger
  // hmr in the importing css file.
  createFileOnlyEntry(file) {
    file = normalizePath$3(file);
    let fileMappedModules = this.fileToModulesMap.get(file);
    if (!fileMappedModules) {
      fileMappedModules = /* @__PURE__ */ new Set();
      this.fileToModulesMap.set(file, fileMappedModules);
    }
    const url = `${FS_PREFIX}${file}`;
    for (const m of fileMappedModules) {
      if (m.url === url || m.id === file) {
        return m;
      }
    }
    const mod = new EnvironmentModuleNode(url, this.environment);
    mod.file = file;
    fileMappedModules.add(mod);
    return mod;
  }
  // for incoming urls, it is important to:
  // 1. remove the HMR timestamp query (?t=xxxx) and the ?import query
  // 2. resolve its extension so that urls with or without extension all map to
  // the same module
  async resolveUrl(url) {
    url = removeImportQuery(removeTimestampQuery(url));
    const mod = await this._getUnresolvedUrlToModule(url);
    if (mod?.id) {
      return [mod.url, mod.id, mod.meta];
    }
    return this._resolveUrl(url);
  }
  updateModuleTransformResult(mod, result) {
    if (this.environment === "client") {
      const prevEtag = mod.transformResult?.etag;
      if (prevEtag) this.etagToModuleMap.delete(prevEtag);
      if (result?.etag) this.etagToModuleMap.set(result.etag, mod);
    }
    mod.transformResult = result;
  }
  getModuleByEtag(etag) {
    return this.etagToModuleMap.get(etag);
  }
  /**
   * @internal
   */
  _getUnresolvedUrlToModule(url) {
    return this._unresolvedUrlToModuleMap.get(url);
  }
  /**
   * @internal
   */
  _setUnresolvedUrlToModule(url, mod) {
    this._unresolvedUrlToModuleMap.set(url, mod);
  }
  /**
   * @internal
   */
  async _resolveUrl(url, alreadyResolved) {
    const resolved = alreadyResolved ?? await this._resolveId(url);
    const resolvedId = resolved?.id || url;
    if (url !== resolvedId && !url.includes("\0") && !url.startsWith(`virtual:`)) {
      const ext = extname$1(cleanUrl(resolvedId));
      if (ext) {
        const pathname = cleanUrl(url);
        if (!pathname.endsWith(ext)) {
          url = pathname + ext + url.slice(pathname.length);
        }
      }
    }
    return [url, resolvedId, resolved?.meta];
  }
}

function warmupFiles(server, environment) {
  const { root } = server.config;
  mapFiles(environment.config.dev.warmup, root).then((files) => {
    for (const file of files) {
      warmupFile(server, environment, file);
    }
  });
}
async function warmupFile(server, environment, file) {
  if (file.endsWith(".html")) {
    const url = htmlFileToUrl(file, server.config.root);
    if (url) {
      try {
        const html = await fsp.readFile(file, "utf-8");
        await server.transformIndexHtml(url, html);
      } catch (e) {
        environment.logger.error(
          `Pre-transform error (${colors$1.cyan(file)}): ${e.message}`,
          {
            error: e,
            timestamp: true
          }
        );
      }
    }
  } else {
    const url = fileToUrl(file, server.config.root);
    await environment.warmupRequest(url);
  }
}
function htmlFileToUrl(file, root) {
  const url = path$b.relative(root, file);
  if (url[0] === ".") return;
  return "/" + normalizePath$3(url);
}
function fileToUrl(file, root) {
  const url = path$b.relative(root, file);
  if (url[0] === ".") {
    return path$b.posix.join(FS_PREFIX, normalizePath$3(file));
  }
  return "/" + normalizePath$3(url);
}
async function mapFiles(files, root) {
  if (!files.length) return [];
  const result = [];
  const globs = [];
  for (const file of files) {
    if (isDynamicPattern(file)) {
      globs.push(file);
    } else {
      if (path$b.isAbsolute(file)) {
        result.push(file);
      } else {
        result.push(path$b.resolve(root, file));
      }
    }
  }
  if (globs.length) {
    result.push(
      ...await glob(globs, {
        absolute: true,
        cwd: root,
        expandDirectories: false,
        ignore: ["**/.git/**", "**/node_modules/**"]
      })
    );
  }
  return result;
}

class DevEnvironment extends BaseEnvironment {
  mode = "dev";
  moduleGraph;
  depsOptimizer;
  /**
   * @internal
   */
  _remoteRunnerOptions;
  get pluginContainer() {
    if (!this._pluginContainer)
      throw new Error(
        `${this.name} environment.pluginContainer called before initialized`
      );
    return this._pluginContainer;
  }
  /**
   * @internal
   */
  _pluginContainer;
  /**
   * @internal
   */
  _closing = false;
  /**
   * @internal
   */
  _pendingRequests;
  /**
   * @internal
   */
  _crawlEndFinder;
  /**
   * Hot channel for this environment. If not provided or disabled,
   * it will be a noop channel that does nothing.
   *
   * @example
   * environment.hot.send({ type: 'full-reload' })
   */
  hot;
  constructor(name, config, context) {
    let options = config.environments[name] ?? getDefaultResolvedEnvironmentOptions(config);
    if (context.options) {
      options = mergeConfig(
        options,
        context.options
      );
    }
    super(name, config, options);
    this._pendingRequests = /* @__PURE__ */ new Map();
    this.moduleGraph = new EnvironmentModuleGraph(
      name,
      (url) => this.pluginContainer.resolveId(url, void 0)
    );
    this._crawlEndFinder = setupOnCrawlEnd();
    this._remoteRunnerOptions = context.remoteRunner ?? {};
    this.hot = context.transport ? isWebSocketServer in context.transport ? context.transport : normalizeHotChannel(context.transport, context.hot) : normalizeHotChannel({}, context.hot);
    this.hot.setInvokeHandler({
      fetchModule: (id, importer, options2) => {
        return this.fetchModule(id, importer, options2);
      }
    });
    this.hot.on(
      "vite:invalidate",
      async ({ path, message, firstInvalidatedBy }) => {
        invalidateModule(this, {
          path,
          message,
          firstInvalidatedBy
        });
      }
    );
    const { optimizeDeps } = this.config;
    if (context.depsOptimizer) {
      this.depsOptimizer = context.depsOptimizer;
    } else if (isDepOptimizationDisabled(optimizeDeps)) {
      this.depsOptimizer = void 0;
    } else {
      this.depsOptimizer = (optimizeDeps.noDiscovery ? createExplicitDepsOptimizer : createDepsOptimizer)(this);
    }
  }
  async init(options) {
    if (this._initiated) {
      return;
    }
    this._initiated = true;
    this._plugins = await resolveEnvironmentPlugins(this);
    this._pluginContainer = await createEnvironmentPluginContainer(
      this,
      this._plugins,
      options?.watcher
    );
  }
  /**
   * When the dev server is restarted, the methods are called in the following order:
   * - new instance `init`
   * - previous instance `close`
   * - new instance `listen`
   */
  async listen(server) {
    this.hot.listen();
    await this.depsOptimizer?.init();
    warmupFiles(server, this);
  }
  fetchModule(id, importer, options) {
    return fetchModule(this, id, importer, {
      ...this._remoteRunnerOptions,
      ...options
    });
  }
  async reloadModule(module) {
    if (this.config.server.hmr !== false && module.file) {
      updateModules(this, module.file, [module], Date.now());
    }
  }
  transformRequest(url) {
    return transformRequest(this, url);
  }
  async warmupRequest(url) {
    try {
      await this.transformRequest(url);
    } catch (e) {
      if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP || e?.code === ERR_CLOSED_SERVER) {
        return;
      }
      this.logger.error(
        buildErrorMessage(e, [`Pre-transform error: ${e.message}`], false),
        {
          error: e,
          timestamp: true
        }
      );
    }
  }
  async close() {
    this._closing = true;
    this._crawlEndFinder.cancel();
    await Promise.allSettled([
      this.pluginContainer.close(),
      this.depsOptimizer?.close(),
      // WebSocketServer is independent of HotChannel and should not be closed on environment close
      isWebSocketServer in this.hot ? Promise.resolve() : this.hot.close(),
      (async () => {
        while (this._pendingRequests.size > 0) {
          await Promise.allSettled(
            [...this._pendingRequests.values()].map(
              (pending) => pending.request
            )
          );
        }
      })()
    ]);
  }
  /**
   * Calling `await environment.waitForRequestsIdle(id)` will wait until all static imports
   * are processed after the first transformRequest call. If called from a load or transform
   * plugin hook, the id needs to be passed as a parameter to avoid deadlocks.
   * Calling this function after the first static imports section of the module graph has been
   * processed will resolve immediately.
   * @experimental
   */
  waitForRequestsIdle(ignoredId) {
    return this._crawlEndFinder.waitForRequestsIdle(ignoredId);
  }
  /**
   * @internal
   */
  _registerRequestProcessing(id, done) {
    this._crawlEndFinder.registerRequestProcessing(id, done);
  }
}
function invalidateModule(environment, m) {
  const mod = environment.moduleGraph.urlToModuleMap.get(m.path);
  if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0 && !mod.lastHMRInvalidationReceived) {
    mod.lastHMRInvalidationReceived = true;
    environment.logger.info(
      colors$1.yellow(`hmr invalidate `) + colors$1.dim(m.path) + (m.message ? ` ${m.message}` : ""),
      { timestamp: true }
    );
    const file = getShortName(mod.file, environment.config.root);
    updateModules(
      environment,
      file,
      [...mod.importers],
      mod.lastHMRTimestamp,
      m.firstInvalidatedBy
    );
  }
}
const callCrawlEndIfIdleAfterMs = 50;
function setupOnCrawlEnd() {
  const registeredIds = /* @__PURE__ */ new Set();
  const seenIds = /* @__PURE__ */ new Set();
  const onCrawlEndPromiseWithResolvers = promiseWithResolvers();
  let timeoutHandle;
  let cancelled = false;
  function cancel() {
    cancelled = true;
  }
  function registerRequestProcessing(id, done) {
    if (!seenIds.has(id)) {
      seenIds.add(id);
      registeredIds.add(id);
      done().catch(() => {
      }).finally(() => markIdAsDone(id));
    }
  }
  function waitForRequestsIdle(ignoredId) {
    if (ignoredId) {
      seenIds.add(ignoredId);
      markIdAsDone(ignoredId);
    } else {
      checkIfCrawlEndAfterTimeout();
    }
    return onCrawlEndPromiseWithResolvers.promise;
  }
  function markIdAsDone(id) {
    registeredIds.delete(id);
    checkIfCrawlEndAfterTimeout();
  }
  function checkIfCrawlEndAfterTimeout() {
    if (cancelled || registeredIds.size > 0) return;
    if (timeoutHandle) clearTimeout(timeoutHandle);
    timeoutHandle = setTimeout(
      callOnCrawlEndWhenIdle,
      callCrawlEndIfIdleAfterMs
    );
  }
  async function callOnCrawlEndWhenIdle() {
    if (cancelled || registeredIds.size > 0) return;
    onCrawlEndPromiseWithResolvers.resolve();
  }
  return {
    registerRequestProcessing,
    waitForRequestsIdle,
    cancel
  };
}

function createRunnableDevEnvironment(name, config, context = {}) {
  if (context.transport == null) {
    context.transport = createServerHotChannel();
  }
  if (context.hot == null) {
    context.hot = true;
  }
  return new RunnableDevEnvironment(name, config, context);
}
function isRunnableDevEnvironment(environment) {
  return environment instanceof RunnableDevEnvironment;
}
class RunnableDevEnvironment extends DevEnvironment {
  _runner;
  _runnerFactory;
  _runnerOptions;
  constructor(name, config, context) {
    super(name, config, context);
    this._runnerFactory = context.runner;
    this._runnerOptions = context.runnerOptions;
  }
  get runner() {
    if (this._runner) {
      return this._runner;
    }
    const factory = this._runnerFactory || createServerModuleRunner;
    this._runner = factory(this, this._runnerOptions);
    return this._runner;
  }
  async close() {
    await super.close();
    if (this._runner) {
      await this._runner.close();
    }
  }
}

// NOTE: supports Node 6.x


const NOOP = () => {};
const MIMES = /text|javascript|\/json|xml/i;

/**
 * @param {any} chunk
 * @param {BufferEncoding} enc
 * @returns {number}
 */
function getChunkSize(chunk, enc) {
	return chunk ? Buffer.byteLength(chunk, enc) : 0;
}

/**
 * @param {import('./index.d.mts').Options} [options]
 * @returns {import('./index.d.mts').Middleware}
 */
function compression ({ threshold = 1024, level = -1, brotli = false, gzip = true, mimes = MIMES } = {}) {
	const brotliOpts = (typeof brotli === 'object' && brotli) || {};
	const gzipOpts = (typeof gzip === 'object' && gzip) || {};

	// disable Brotli on Node<12.7 where it is unsupported:
	if (!zlib$1.createBrotliCompress) brotli = false;

	return (req, res, next = NOOP) => {
		const accept = req.headers['accept-encoding'] + '';
		const encoding = ((brotli && accept.match(/\bbr\b/)) || (gzip && accept.match(/\bgzip\b/)) || [])[0];

		// skip if no response body or no supported encoding:
		if (req.method === 'HEAD' || !encoding) return next();

		/** @type {zlib.Gzip | zlib.BrotliCompress} */
		let compress;
		/** @type {Array<[string, function]>?} */
		let pendingListeners = [];
		let pendingStatus = 0;
		let started = false;
		let size = 0;

		function start() {
			started = true;
			// @ts-ignore
			size = res.getHeader('Content-Length') | 0 || size;
			const compressible = mimes.test(
				String(res.getHeader('Content-Type') || 'text/plain')
			);
			const cleartext = !res.getHeader('Content-Encoding');
			const listeners = pendingListeners || [];

			if (compressible && cleartext && size >= threshold) {
				res.setHeader('Content-Encoding', encoding);
				res.removeHeader('Content-Length');
				if (encoding === 'br') {
					compress = zlib$1.createBrotliCompress({
						params: Object.assign({
							[zlib$1.constants.BROTLI_PARAM_QUALITY]: level,
							[zlib$1.constants.BROTLI_PARAM_SIZE_HINT]: size,
						}, brotliOpts)
					});
				} else {
					compress = zlib$1.createGzip(
						Object.assign({ level }, gzipOpts)
					);
				}
				// backpressure
				compress.on('data', chunk => write.call(res, chunk) || compress.pause());
				on.call(res, 'drain', () => compress.resume());
				compress.on('end', () => end.call(res));
				listeners.forEach(p => compress.on.apply(compress, p));
			} else {
				pendingListeners = null;
				listeners.forEach(p => on.apply(res, p));
			}

			writeHead.call(res, pendingStatus || res.statusCode);
		}

		const { end, write, on, writeHead } = res;

		res.writeHead = function (status, reason, headers) {
			if (typeof reason !== 'string') [headers, reason] = [reason, headers];
			if (headers) for (let k in headers) res.setHeader(k, headers[k]);
			pendingStatus = status;
			return this;
		};

		res.write = function (chunk, enc) {
			size += getChunkSize(chunk, enc);
			if (!started) start();
			if (!compress) return write.apply(this, arguments);
			return compress.write.apply(compress, arguments);
		};

		res.end = function (chunk, enc) {
			if (arguments.length > 0 && typeof chunk !== 'function') {
				size += getChunkSize(chunk, enc);
			}
			if (!started) start();
			if (!compress) return end.apply(this, arguments);
			return compress.end.apply(compress, arguments);
		};

		res.on = function (type, listener) {
			if (!pendingListeners) on.call(this, type, listener);
			else if (compress) compress.on(type, listener);
			else pendingListeners.push([type, listener]);
			return this;
		};

		next();
	};
}

function resolvePreviewOptions(preview2, server) {
  return {
    port: preview2?.port ?? DEFAULT_PREVIEW_PORT,
    strictPort: preview2?.strictPort ?? server.strictPort,
    host: preview2?.host ?? server.host,
    allowedHosts: preview2?.allowedHosts ?? server.allowedHosts,
    https: preview2?.https ?? server.https,
    open: preview2?.open ?? server.open,
    proxy: preview2?.proxy ?? server.proxy,
    cors: preview2?.cors ?? server.cors,
    headers: preview2?.headers ?? server.headers
  };
}
async function preview(inlineConfig = {}) {
  const config = await resolveConfig(
    inlineConfig,
    "serve",
    "production",
    "production",
    true
  );
  const clientOutDir = config.environments.client.build.outDir;
  const distDir = path$b.resolve(config.root, clientOutDir);
  if (!fs__default.existsSync(distDir) && // error if no plugins implement `configurePreviewServer`
  config.plugins.every((plugin) => !plugin.configurePreviewServer) && // error if called in CLI only. programmatic usage could access `httpServer`
  // and affect file serving
  process.argv[1]?.endsWith(path$b.normalize("bin/vite.js")) && process.argv[2] === "preview") {
    throw new Error(
      `The directory "${clientOutDir}" does not exist. Did you build your project?`
    );
  }
  const httpsOptions = await resolveHttpsConfig(config.preview.https);
  const app = connect$1();
  const httpServer = await resolveHttpServer(config.preview, app, httpsOptions);
  setClientErrorHandler(httpServer, config.logger);
  const options = config.preview;
  const logger = config.logger;
  const closeHttpServer = createServerCloseFn(httpServer);
  let closeServerPromise;
  const closeServer = async () => {
    teardownSIGTERMListener(closeServerAndExit);
    await closeHttpServer();
    server.resolvedUrls = null;
  };
  const server = {
    config,
    middlewares: app,
    httpServer,
    async close() {
      if (!closeServerPromise) {
        closeServerPromise = closeServer();
      }
      return closeServerPromise;
    },
    resolvedUrls: null,
    printUrls() {
      if (server.resolvedUrls) {
        printServerUrls(server.resolvedUrls, options.host, logger.info);
      } else {
        throw new Error("cannot print server URLs before server is listening.");
      }
    },
    bindCLIShortcuts(options2) {
      bindCLIShortcuts(server, options2);
    }
  };
  const closeServerAndExit = async (_, exitCode) => {
    try {
      await server.close();
    } finally {
      process.exitCode ??= exitCode ? 128 + exitCode : void 0;
      process.exit();
    }
  };
  setupSIGTERMListener(closeServerAndExit);
  const postHooks = [];
  for (const hook of config.getSortedPluginHooks("configurePreviewServer")) {
    postHooks.push(await hook(server));
  }
  const { cors } = config.preview;
  if (cors !== false) {
    app.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
  }
  const { allowedHosts } = config.preview;
  if (allowedHosts !== true && !config.preview.https) {
    app.use(hostCheckMiddleware(config, true));
  }
  const { proxy } = config.preview;
  if (proxy) {
    app.use(proxyMiddleware(httpServer, proxy, config));
  }
  app.use(compression());
  if (config.base !== "/") {
    app.use(baseMiddleware(config.rawBase, false));
  }
  const headers = config.preview.headers;
  const viteAssetMiddleware = (...args) => sirv(distDir, {
    etag: true,
    dev: true,
    extensions: [],
    ignores: false,
    setHeaders(res) {
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]);
        }
      }
    },
    shouldServe(filePath) {
      return shouldServeFile(filePath, distDir);
    }
  })(...args);
  app.use(viteAssetMiddleware);
  if (config.appType === "spa" || config.appType === "mpa") {
    app.use(htmlFallbackMiddleware(distDir, config.appType === "spa"));
  }
  postHooks.forEach((fn) => fn && fn());
  if (config.appType === "spa" || config.appType === "mpa") {
    const normalizedDistDir = normalizePath$3(distDir);
    app.use(indexHtmlMiddleware(normalizedDistDir, server));
    app.use(notFoundMiddleware());
  }
  const hostname = await resolveHostname(options.host);
  await httpServerStart(httpServer, {
    port: options.port,
    strictPort: options.strictPort,
    host: hostname.host,
    logger
  });
  server.resolvedUrls = await resolveServerUrls(
    httpServer,
    config.preview,
    httpsOptions,
    config
  );
  if (options.open) {
    const url = getServerUrlByHost(server.resolvedUrls, options.host);
    if (url) {
      const path2 = typeof options.open === "string" ? new URL(options.open, url).href : url;
      openBrowser(path2, true, logger);
    }
  }
  return server;
}

var preview$1 = {
	__proto__: null,
	preview: preview,
	resolvePreviewOptions: resolvePreviewOptions
};

const ssrConfigDefaults = Object.freeze({
  // noExternal
  // external
  target: "node",
  optimizeDeps: {}
  // resolve
});
function resolveSSROptions(ssr, preserveSymlinks) {
  const defaults = mergeWithDefaults(ssrConfigDefaults, {
    optimizeDeps: { esbuildOptions: { preserveSymlinks } }
  });
  return mergeWithDefaults(defaults, ssr ?? {});
}

async function runnerImport(moduleId, inlineConfig) {
  const isModuleSyncConditionEnabled = (await import('#module-sync-enabled')).default;
  const config = await resolveConfig(
    mergeConfig(inlineConfig || {}, {
      configFile: false,
      envDir: false,
      cacheDir: process.cwd(),
      environments: {
        inline: {
          consumer: "server",
          dev: {
            moduleRunnerTransform: true
          },
          resolve: {
            external: true,
            mainFields: [],
            conditions: [
              "node",
              ...isModuleSyncConditionEnabled ? ["module-sync"] : []
            ]
          }
        }
      }
    }),
    "serve"
  );
  const environment = createRunnableDevEnvironment("inline", config, {
    runnerOptions: {
      hmr: {
        logger: false
      }
    },
    hot: false
  });
  await environment.init();
  try {
    const module = await environment.runner.import(moduleId);
    const modules = [
      ...environment.runner.evaluatedModules.urlToIdModuleMap.values()
    ];
    const dependencies = modules.filter((m) => {
      if (!m.meta || "externalize" in m.meta) {
        return false;
      }
      return m.exports !== module;
    }).map((m) => m.file);
    return {
      module,
      dependencies
    };
  } finally {
    await environment.close();
  }
}

const debug = createDebugger("vite:config", { depth: 10 });
const promisifiedRealpath = promisify$4(fs__default.realpath);
function defineConfig(config) {
  return config;
}
function defaultCreateClientDevEnvironment(name, config, context) {
  return new DevEnvironment(name, config, {
    hot: true,
    transport: context.ws
  });
}
function defaultCreateDevEnvironment(name, config) {
  return createRunnableDevEnvironment(name, config);
}
const configDefaults = Object.freeze({
  define: {},
  dev: {
    warmup: [],
    // preTransformRequests
    /** @experimental */
    sourcemap: { js: true },
    sourcemapIgnoreList: void 0
    // createEnvironment
    // recoverable
    // moduleRunnerTransform
  },
  build: buildEnvironmentOptionsDefaults,
  resolve: {
    // mainFields
    // conditions
    externalConditions: ["node"],
    extensions: [".mjs", ".js", ".mts", ".ts", ".jsx", ".tsx", ".json"],
    dedupe: [],
    /** @experimental */
    noExternal: [],
    external: [],
    preserveSymlinks: false,
    alias: []
  },
  // root
  base: "/",
  publicDir: "public",
  // cacheDir
  // mode
  plugins: [],
  html: {
    cspNonce: void 0
  },
  css: cssConfigDefaults,
  json: {
    namedExports: true,
    stringify: "auto"
  },
  // esbuild
  assetsInclude: void 0,
  /** @experimental */
  builder: builderOptionsDefaults,
  server: serverConfigDefaults,
  preview: {
    port: DEFAULT_PREVIEW_PORT
    // strictPort
    // host
    // https
    // open
    // proxy
    // cors
    // headers
  },
  /** @experimental */
  experimental: {
    importGlobRestoreExtension: false,
    renderBuiltUrl: void 0,
    hmrPartialAccept: false,
    skipSsrTransform: false
  },
  future: {
    removePluginHookHandleHotUpdate: void 0,
    removePluginHookSsrArgument: void 0,
    removeServerModuleGraph: void 0,
    removeServerHot: void 0,
    removeServerTransformRequest: void 0,
    removeSsrLoadModule: void 0
  },
  legacy: {
    proxySsrExternalModules: false,
    skipWebSocketTokenCheck: false
  },
  logLevel: "info",
  customLogger: void 0,
  clearScreen: true,
  envDir: void 0,
  envPrefix: "VITE_",
  worker: {
    format: "iife",
    plugins: () => []
    // rollupOptions
  },
  optimizeDeps: {
    include: [],
    exclude: [],
    needsInterop: [],
    // esbuildOptions
    /** @experimental */
    extensions: [],
    /** @deprecated @experimental */
    disabled: "build",
    // noDiscovery
    /** @experimental */
    holdUntilCrawlEnd: true,
    // entries
    /** @experimental */
    force: false
  },
  ssr: ssrConfigDefaults,
  environments: {},
  appType: "spa"
});
function resolveDevEnvironmentOptions(dev, environmentName, consumer, skipSsrTransform, preTransformRequest) {
  const resolved = mergeWithDefaults(
    {
      ...configDefaults.dev,
      sourcemapIgnoreList: isInNodeModules$1,
      preTransformRequests: preTransformRequest ?? consumer === "client",
      createEnvironment: environmentName === "client" ? defaultCreateClientDevEnvironment : defaultCreateDevEnvironment,
      recoverable: consumer === "client",
      moduleRunnerTransform: skipSsrTransform !== void 0 && consumer === "server" ? skipSsrTransform : consumer === "server"
    },
    dev ?? {}
  );
  return {
    ...resolved,
    sourcemapIgnoreList: resolved.sourcemapIgnoreList === false ? () => false : resolved.sourcemapIgnoreList
  };
}
function resolveEnvironmentOptions(options, alias, preserveSymlinks, forceOptimizeDeps, logger, environmentName, skipSsrTransform, isSsrTargetWebworkerSet, preTransformRequests) {
  const isClientEnvironment = environmentName === "client";
  const consumer = options.consumer ?? (isClientEnvironment ? "client" : "server");
  const isSsrTargetWebworkerEnvironment = isSsrTargetWebworkerSet && environmentName === "ssr";
  if (options.define?.["process.env"]) {
    const processEnvDefine = options.define["process.env"];
    if (typeof processEnvDefine === "object") {
      const pathKey = Object.entries(processEnvDefine).find(
        // check with toLowerCase() to match with `Path` / `PATH` (Windows uses `Path`)
        ([key, value]) => key.toLowerCase() === "path" && !!value
      )?.[0];
      if (pathKey) {
        logger.warnOnce(
          colors$1.yellow(
            `The \`define\` option contains an object with ${JSON.stringify(pathKey)} for "process.env" key. It looks like you may have passed the entire \`process.env\` object to \`define\`, which can unintentionally expose all environment variables. This poses a security risk and is discouraged.`
          )
        );
      }
    }
  }
  const resolve = resolveEnvironmentResolveOptions(
    options.resolve,
    alias,
    preserveSymlinks,
    logger,
    consumer,
    isSsrTargetWebworkerEnvironment
  );
  return {
    define: options.define,
    resolve,
    keepProcessEnv: options.keepProcessEnv ?? (isSsrTargetWebworkerEnvironment ? false : consumer === "server"),
    consumer,
    optimizeDeps: resolveDepOptimizationOptions(
      options.optimizeDeps,
      resolve.preserveSymlinks,
      forceOptimizeDeps,
      consumer
    ),
    dev: resolveDevEnvironmentOptions(
      options.dev,
      environmentName,
      consumer,
      skipSsrTransform,
      preTransformRequests
    ),
    build: resolveBuildEnvironmentOptions(
      options.build ?? {},
      logger,
      consumer
    )
  };
}
function getDefaultEnvironmentOptions(config) {
  return {
    define: config.define,
    resolve: {
      ...config.resolve,
      // mainFields and conditions are not inherited
      mainFields: void 0,
      conditions: void 0
    },
    dev: config.dev,
    build: config.build
  };
}
function checkBadCharactersInPath(name, path2, logger) {
  const badChars = [];
  if (path2.includes("#")) {
    badChars.push("#");
  }
  if (path2.includes("?")) {
    badChars.push("?");
  }
  if (path2.includes("*")) {
    badChars.push("*");
  }
  if (badChars.length > 0) {
    const charString = badChars.map((c) => `"${c}"`).join(" and ");
    const inflectedChars = badChars.length > 1 ? "characters" : "character";
    logger.warn(
      colors$1.yellow(
        `${name} contains the ${charString} ${inflectedChars} (${colors$1.cyan(
          path2
        )}), which may not work when running Vite. Consider renaming the directory / file to remove the characters.`
      )
    );
  }
}
const clientAlias = [
  {
    find: /^\/?@vite\/env/,
    replacement: path$b.posix.join(FS_PREFIX, normalizePath$3(ENV_ENTRY))
  },
  {
    find: /^\/?@vite\/client/,
    replacement: path$b.posix.join(FS_PREFIX, normalizePath$3(CLIENT_ENTRY))
  }
];
function resolveEnvironmentResolveOptions(resolve, alias, preserveSymlinks, logger, consumer, isSsrTargetWebworkerEnvironment) {
  const resolvedResolve = mergeWithDefaults(
    {
      ...configDefaults.resolve,
      mainFields: consumer === void 0 || consumer === "client" || isSsrTargetWebworkerEnvironment ? DEFAULT_CLIENT_MAIN_FIELDS : DEFAULT_SERVER_MAIN_FIELDS,
      conditions: consumer === void 0 || consumer === "client" || isSsrTargetWebworkerEnvironment ? DEFAULT_CLIENT_CONDITIONS : DEFAULT_SERVER_CONDITIONS.filter((c) => c !== "browser"),
      builtins: resolve?.builtins ?? (consumer === "server" ? isSsrTargetWebworkerEnvironment && resolve?.noExternal === true ? [] : nodeLikeBuiltins : [])
    },
    resolve ?? {}
  );
  resolvedResolve.preserveSymlinks = preserveSymlinks;
  resolvedResolve.alias = alias;
  if (
    // @ts-expect-error removed field
    resolve?.browserField === false && resolvedResolve.mainFields.includes("browser")
  ) {
    logger.warn(
      colors$1.yellow(
        `\`resolve.browserField\` is set to false, but the option is removed in favour of the 'browser' string in \`resolve.mainFields\`. You may want to update \`resolve.mainFields\` to remove the 'browser' string and preserve the previous browser behaviour.`
      )
    );
  }
  return resolvedResolve;
}
function resolveResolveOptions(resolve, logger) {
  const alias = normalizeAlias(
    mergeAlias(clientAlias, resolve?.alias || configDefaults.resolve.alias)
  );
  const preserveSymlinks = resolve?.preserveSymlinks ?? configDefaults.resolve.preserveSymlinks;
  if (alias.some((a) => a.find === "/")) {
    logger.warn(
      colors$1.yellow(
        `\`resolve.alias\` contains an alias that maps \`/\`. This is not recommended as it can cause unexpected behavior when resolving paths.`
      )
    );
  }
  return resolveEnvironmentResolveOptions(
    resolve,
    alias,
    preserveSymlinks,
    logger,
    void 0
  );
}
function resolveDepOptimizationOptions(optimizeDeps, preserveSymlinks, forceOptimizeDeps, consumer) {
  return mergeWithDefaults(
    {
      ...configDefaults.optimizeDeps,
      disabled: void 0,
      // do not set here to avoid deprecation warning
      noDiscovery: consumer !== "client",
      esbuildOptions: {
        preserveSymlinks
      },
      force: forceOptimizeDeps ?? configDefaults.optimizeDeps.force
    },
    optimizeDeps ?? {}
  );
}
async function resolveConfig(inlineConfig, command, defaultMode = "development", defaultNodeEnv = "development", isPreview = false, patchConfig = void 0, patchPlugins = void 0) {
  let config = inlineConfig;
  let configFileDependencies = [];
  let mode = inlineConfig.mode || defaultMode;
  const isNodeEnvSet = !!process.env.NODE_ENV;
  const packageCache = /* @__PURE__ */ new Map();
  if (!isNodeEnvSet) {
    process.env.NODE_ENV = defaultNodeEnv;
  }
  const configEnv = {
    mode,
    command,
    isSsrBuild: command === "build" && !!config.build?.ssr,
    isPreview
  };
  let { configFile } = config;
  if (configFile !== false) {
    const loadResult = await loadConfigFromFile(
      configEnv,
      configFile,
      config.root,
      config.logLevel,
      config.customLogger,
      config.configLoader
    );
    if (loadResult) {
      config = mergeConfig(loadResult.config, config);
      configFile = loadResult.path;
      configFileDependencies = loadResult.dependencies;
    }
  }
  mode = inlineConfig.mode || config.mode || mode;
  configEnv.mode = mode;
  const filterPlugin = (p) => {
    if (!p) {
      return false;
    } else if (!p.apply) {
      return true;
    } else if (typeof p.apply === "function") {
      return p.apply({ ...config, mode }, configEnv);
    } else {
      return p.apply === command;
    }
  };
  const rawPlugins = (await asyncFlatten(config.plugins || [])).filter(
    filterPlugin
  );
  const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawPlugins);
  const isBuild = command === "build";
  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
  config = await runConfigHook(config, userPlugins, configEnv);
  config.environments ??= {};
  if (!config.environments.ssr && (!isBuild || config.ssr || config.build?.ssr)) {
    config.environments = { ssr: {}, ...config.environments };
  }
  if (!config.environments.client) {
    config.environments = { client: {}, ...config.environments };
  }
  const logger = createLogger(config.logLevel, {
    allowClearScreen: config.clearScreen,
    customLogger: config.customLogger
  });
  const resolvedRoot = normalizePath$3(
    config.root ? path$b.resolve(config.root) : process.cwd()
  );
  checkBadCharactersInPath("The project root", resolvedRoot, logger);
  const configEnvironmentsClient = config.environments.client;
  configEnvironmentsClient.dev ??= {};
  const deprecatedSsrOptimizeDepsConfig = config.ssr?.optimizeDeps ?? {};
  let configEnvironmentsSsr = config.environments.ssr;
  const warmupOptions = config.server?.warmup;
  if (warmupOptions?.clientFiles) {
    configEnvironmentsClient.dev.warmup = warmupOptions.clientFiles;
  }
  if (warmupOptions?.ssrFiles) {
    configEnvironmentsSsr ??= {};
    configEnvironmentsSsr.dev ??= {};
    configEnvironmentsSsr.dev.warmup = warmupOptions.ssrFiles;
  }
  if (configEnvironmentsSsr) {
    configEnvironmentsSsr.optimizeDeps = mergeConfig(
      deprecatedSsrOptimizeDepsConfig,
      configEnvironmentsSsr.optimizeDeps ?? {}
    );
    configEnvironmentsSsr.resolve = mergeConfig(
      {
        conditions: config.ssr?.resolve?.conditions,
        externalConditions: config.ssr?.resolve?.externalConditions,
        mainFields: config.ssr?.resolve?.mainFields,
        external: config.ssr?.external,
        noExternal: config.ssr?.noExternal
      },
      configEnvironmentsSsr.resolve ?? {}
    );
  }
  if (config.build?.ssrEmitAssets !== void 0) {
    configEnvironmentsSsr ??= {};
    configEnvironmentsSsr.build ??= {};
    configEnvironmentsSsr.build.emitAssets = config.build.ssrEmitAssets;
  }
  if (!config.environments.client || !config.environments.ssr && !isBuild) {
    throw new Error(
      "Required environments configuration were stripped out in the config hook"
    );
  }
  const defaultEnvironmentOptions = getDefaultEnvironmentOptions(config);
  const defaultClientEnvironmentOptions = {
    ...defaultEnvironmentOptions,
    resolve: config.resolve,
    // inherit everything including mainFields and conditions
    optimizeDeps: config.optimizeDeps
  };
  const defaultNonClientEnvironmentOptions = {
    ...defaultEnvironmentOptions,
    dev: {
      ...defaultEnvironmentOptions.dev,
      createEnvironment: void 0,
      warmup: void 0
    },
    build: {
      ...defaultEnvironmentOptions.build,
      createEnvironment: void 0
    }
  };
  for (const name of Object.keys(config.environments)) {
    config.environments[name] = mergeConfig(
      name === "client" ? defaultClientEnvironmentOptions : defaultNonClientEnvironmentOptions,
      config.environments[name]
    );
  }
  await runConfigEnvironmentHook(
    config.environments,
    userPlugins,
    configEnv,
    config.ssr?.target === "webworker"
  );
  config.resolve ??= {};
  config.resolve.conditions = config.environments.client.resolve?.conditions;
  config.resolve.mainFields = config.environments.client.resolve?.mainFields;
  const resolvedDefaultResolve = resolveResolveOptions(config.resolve, logger);
  const resolvedEnvironments = {};
  for (const environmentName of Object.keys(config.environments)) {
    resolvedEnvironments[environmentName] = resolveEnvironmentOptions(
      config.environments[environmentName],
      resolvedDefaultResolve.alias,
      resolvedDefaultResolve.preserveSymlinks,
      inlineConfig.forceOptimizeDeps,
      logger,
      environmentName,
      config.experimental?.skipSsrTransform,
      config.ssr?.target === "webworker",
      config.server?.preTransformRequests
    );
  }
  const backwardCompatibleOptimizeDeps = resolvedEnvironments.client.optimizeDeps;
  const resolvedDevEnvironmentOptions = resolveDevEnvironmentOptions(
    config.dev,
    // default environment options
    void 0,
    void 0
  );
  const resolvedBuildOptions = resolveBuildEnvironmentOptions(
    config.build ?? {},
    logger,
    void 0
  );
  const patchedConfigSsr = {
    ...config.ssr,
    external: resolvedEnvironments.ssr?.resolve.external,
    noExternal: resolvedEnvironments.ssr?.resolve.noExternal,
    optimizeDeps: resolvedEnvironments.ssr?.optimizeDeps,
    resolve: {
      ...config.ssr?.resolve,
      conditions: resolvedEnvironments.ssr?.resolve.conditions,
      externalConditions: resolvedEnvironments.ssr?.resolve.externalConditions
    }
  };
  const ssr = resolveSSROptions(
    patchedConfigSsr,
    resolvedDefaultResolve.preserveSymlinks
  );
  let envDir = config.envFile === false ? false : config.envDir;
  if (envDir !== false) {
    envDir = config.envDir ? normalizePath$3(path$b.resolve(resolvedRoot, config.envDir)) : resolvedRoot;
  }
  const userEnv = loadEnv(mode, envDir, resolveEnvPrefix(config));
  const userNodeEnv = process.env.VITE_USER_NODE_ENV;
  if (!isNodeEnvSet && userNodeEnv) {
    if (userNodeEnv === "development") {
      process.env.NODE_ENV = "development";
    } else {
      logger.warn(
        `NODE_ENV=${userNodeEnv} is not supported in the .env file. Only NODE_ENV=development is supported to create a development build of your project. If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`
      );
    }
  }
  const isProduction = process.env.NODE_ENV === "production";
  const relativeBaseShortcut = config.base === "" || config.base === "./";
  const resolvedBase = relativeBaseShortcut ? !isBuild || config.build?.ssr ? "/" : "./" : resolveBaseUrl(config.base, isBuild, logger);
  const pkgDir = findNearestPackageData(resolvedRoot, packageCache)?.dir;
  const cacheDir = normalizePath$3(
    config.cacheDir ? path$b.resolve(resolvedRoot, config.cacheDir) : pkgDir ? path$b.join(pkgDir, `node_modules/.vite`) : path$b.join(resolvedRoot, `.vite`)
  );
  const assetsFilter = config.assetsInclude && (!Array.isArray(config.assetsInclude) || config.assetsInclude.length) ? createFilter$1(config.assetsInclude) : () => false;
  const { publicDir } = config;
  const resolvedPublicDir = publicDir !== false && publicDir !== "" ? normalizePath$3(
    path$b.resolve(
      resolvedRoot,
      typeof publicDir === "string" ? publicDir : configDefaults.publicDir
    )
  ) : "";
  const server = resolveServerOptions(resolvedRoot, config.server, logger);
  const builder = resolveBuilderOptions(config.builder);
  const BASE_URL = resolvedBase;
  let resolved;
  let createUserWorkerPlugins = config.worker?.plugins;
  if (Array.isArray(createUserWorkerPlugins)) {
    createUserWorkerPlugins = () => config.worker?.plugins;
    logger.warn(
      colors$1.yellow(
        `worker.plugins is now a function that returns an array of plugins. Please update your Vite config accordingly.
`
      )
    );
  }
  const createWorkerPlugins = async function(bundleChain) {
    const rawWorkerUserPlugins = (await asyncFlatten(createUserWorkerPlugins?.() || [])).filter(filterPlugin);
    let workerConfig = mergeConfig({}, config);
    const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] = sortUserPlugins(rawWorkerUserPlugins);
    const workerUserPlugins = [
      ...workerPrePlugins,
      ...workerNormalPlugins,
      ...workerPostPlugins
    ];
    workerConfig = await runConfigHook(
      workerConfig,
      workerUserPlugins,
      configEnv
    );
    const workerResolved = {
      ...workerConfig,
      ...resolved,
      isWorker: true,
      mainConfig: resolved,
      bundleChain
    };
    const resolvedWorkerPlugins = await resolvePlugins(
      workerResolved,
      workerPrePlugins,
      workerNormalPlugins,
      workerPostPlugins
    );
    await Promise.all(
      createPluginHookUtils(resolvedWorkerPlugins).getSortedPluginHooks("configResolved").map((hook) => hook(workerResolved))
    );
    return {
      ...workerResolved,
      plugins: resolvedWorkerPlugins
    };
  };
  const resolvedWorkerOptions = {
    format: config.worker?.format || "iife",
    plugins: createWorkerPlugins,
    rollupOptions: config.worker?.rollupOptions || {}
  };
  const base = withTrailingSlash(resolvedBase);
  const preview = resolvePreviewOptions(config.preview, server);
  resolved = {
    configFile: configFile ? normalizePath$3(configFile) : void 0,
    configFileDependencies: configFileDependencies.map(
      (name) => normalizePath$3(path$b.resolve(name))
    ),
    inlineConfig,
    root: resolvedRoot,
    base,
    decodedBase: decodeBase(base),
    rawBase: resolvedBase,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode,
    isWorker: false,
    mainConfig: null,
    bundleChain: [],
    isProduction,
    plugins: userPlugins,
    // placeholder to be replaced
    css: resolveCSSOptions(config.css),
    json: mergeWithDefaults(configDefaults.json, config.json ?? {}),
    esbuild: config.esbuild === false ? false : {
      jsxDev: !isProduction,
      ...config.esbuild
    },
    server,
    builder,
    preview,
    envDir,
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode,
      DEV: !isProduction,
      PROD: isProduction
    },
    assetsInclude(file) {
      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
    },
    logger,
    packageCache,
    worker: resolvedWorkerOptions,
    appType: config.appType ?? "spa",
    experimental: {
      importGlobRestoreExtension: false,
      hmrPartialAccept: false,
      ...config.experimental
    },
    future: config.future,
    ssr,
    optimizeDeps: backwardCompatibleOptimizeDeps,
    resolve: resolvedDefaultResolve,
    dev: resolvedDevEnvironmentOptions,
    build: resolvedBuildOptions,
    environments: resolvedEnvironments,
    // random 72 bits (12 base64 chars)
    // at least 64bits is recommended
    // https://owasp.org/www-community/vulnerabilities/Insufficient_Session-ID_Length
    webSocketToken: Buffer.from(
      crypto$2.getRandomValues(new Uint8Array(9))
    ).toString("base64url"),
    getSortedPlugins: void 0,
    getSortedPluginHooks: void 0,
    /**
     * createResolver is deprecated. It only works for the client and ssr
     * environments. The `aliasOnly` option is also not being used any more
     * Plugins should move to createIdResolver(environment) instead.
     * create an internal resolver to be used in special scenarios, e.g.
     * optimizer & handling css @imports
     */
    createResolver(options) {
      const resolve = createIdResolver(this, options);
      const clientEnvironment = new PartialEnvironment("client", this);
      let ssrEnvironment;
      return async (id, importer, aliasOnly, ssr2) => {
        if (ssr2) {
          ssrEnvironment ??= new PartialEnvironment("ssr", this);
        }
        return await resolve(
          ssr2 ? ssrEnvironment : clientEnvironment,
          id,
          importer,
          aliasOnly
        );
      };
    },
    fsDenyGlob: picomatch$2(
      // matchBase: true does not work as it's documented
      // https://github.com/micromatch/picomatch/issues/89
      // convert patterns without `/` on our side for now
      server.fs.deny.map(
        (pattern) => pattern.includes("/") ? pattern : `**/${pattern}`
      ),
      {
        matchBase: false,
        nocase: true,
        dot: true
      }
    ),
    safeModulePaths: /* @__PURE__ */ new Set(),
    additionalAllowedHosts: getAdditionalAllowedHosts(server, preview)
  };
  resolved = {
    ...config,
    ...resolved
  };
  patchConfig?.(resolved);
  const resolvedPlugins = await resolvePlugins(
    resolved,
    prePlugins,
    normalPlugins,
    postPlugins
  );
  patchPlugins?.(resolvedPlugins);
  resolved.plugins = resolvedPlugins;
  Object.assign(resolved, createPluginHookUtils(resolved.plugins));
  await Promise.all(
    resolved.getSortedPluginHooks("configResolved").map((hook) => hook(resolved))
  );
  optimizeDepsDisabledBackwardCompatibility(resolved, resolved.optimizeDeps);
  optimizeDepsDisabledBackwardCompatibility(
    resolved,
    resolved.ssr.optimizeDeps,
    "ssr."
  );
  if (resolved.environments.ssr) {
    resolved.environments.ssr.build.emitAssets = resolved.build.ssrEmitAssets || resolved.build.emitAssets;
  }
  debug?.(`using resolved config: %O`, {
    ...resolved,
    plugins: resolved.plugins.map((p) => p.name),
    worker: {
      ...resolved.worker,
      plugins: `() => plugins`
    }
  });
  const outputOption = config.build?.rollupOptions?.output ?? [];
  if (Array.isArray(outputOption)) {
    const assetFileNamesList = outputOption.map(
      (output) => output.assetFileNames
    );
    if (assetFileNamesList.length > 1) {
      const firstAssetFileNames = assetFileNamesList[0];
      const hasDifferentReference = assetFileNamesList.some(
        (assetFileNames) => assetFileNames !== firstAssetFileNames
      );
      if (hasDifferentReference) {
        resolved.logger.warn(
          colors$1.yellow(`
assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
`)
        );
      }
    }
  }
  if (
    // @ts-expect-error Option removed
    config.legacy?.buildSsrCjsExternalHeuristics || // @ts-expect-error Option removed
    config.ssr?.format === "cjs"
  ) {
    resolved.logger.warn(
      colors$1.yellow(`
(!) Experimental legacy.buildSsrCjsExternalHeuristics and ssr.format were be removed in Vite 5.
    The only SSR Output format is ESM. Find more information at https://github.com/vitejs/vite/discussions/13816.
`)
    );
  }
  const resolvedBuildOutDir = normalizePath$3(
    path$b.resolve(resolved.root, resolved.build.outDir)
  );
  if (isParentDirectory(resolvedBuildOutDir, resolved.root) || resolvedBuildOutDir === resolved.root) {
    resolved.logger.warn(
      colors$1.yellow(`
(!) build.outDir must not be the same directory of root or a parent directory of root as this could cause Vite to overwriting source files with build outputs.
`)
    );
  }
  return resolved;
}
function resolveBaseUrl(base = configDefaults.base, isBuild, logger) {
  if (base[0] === ".") {
    logger.warn(
      colors$1.yellow(
        colors$1.bold(
          `(!) invalid "base" option: "${base}". The value can only be an absolute URL, "./", or an empty string.`
        )
      )
    );
    return "/";
  }
  const isExternal = isExternalUrl(base);
  if (!isExternal && base[0] !== "/") {
    logger.warn(
      colors$1.yellow(
        colors$1.bold(`(!) "base" option should start with a slash.`)
      )
    );
  }
  if (!isBuild || !isExternal) {
    base = new URL(base, "http://vite.dev").pathname;
    if (base[0] !== "/") {
      base = "/" + base;
    }
  }
  return base;
}
function decodeBase(base) {
  try {
    return decodeURI(base);
  } catch {
    throw new Error(
      'The value passed to "base" option was malformed. It should be a valid URL.'
    );
  }
}
function sortUserPlugins(plugins) {
  const prePlugins = [];
  const postPlugins = [];
  const normalPlugins = [];
  if (plugins) {
    plugins.flat().forEach((p) => {
      if (p.enforce === "pre") prePlugins.push(p);
      else if (p.enforce === "post") postPlugins.push(p);
      else normalPlugins.push(p);
    });
  }
  return [prePlugins, normalPlugins, postPlugins];
}
async function loadConfigFromFile(configEnv, configFile, configRoot = process.cwd(), logLevel, customLogger, configLoader = "bundle") {
  if (configLoader !== "bundle" && configLoader !== "runner" && configLoader !== "native") {
    throw new Error(
      `Unsupported configLoader: ${configLoader}. Accepted values are 'bundle', 'runner', and 'native'.`
    );
  }
  const start = performance$1.now();
  const getTime = () => `${(performance$1.now() - start).toFixed(2)}ms`;
  let resolvedPath;
  if (configFile) {
    resolvedPath = path$b.resolve(configFile);
  } else {
    for (const filename of DEFAULT_CONFIG_FILES) {
      const filePath = path$b.resolve(configRoot, filename);
      if (!fs__default.existsSync(filePath)) continue;
      resolvedPath = filePath;
      break;
    }
  }
  if (!resolvedPath) {
    debug?.("no config file found.");
    return null;
  }
  try {
    const resolver = configLoader === "bundle" ? bundleAndLoadConfigFile : configLoader === "runner" ? runnerImportConfigFile : nativeImportConfigFile;
    const { configExport, dependencies } = await resolver(resolvedPath);
    debug?.(`config file loaded in ${getTime()}`);
    const config = await (typeof configExport === "function" ? configExport(configEnv) : configExport);
    if (!isObject$1(config)) {
      throw new Error(`config must export or return an object.`);
    }
    return {
      path: normalizePath$3(resolvedPath),
      config,
      dependencies
    };
  } catch (e) {
    const logger = createLogger(logLevel, { customLogger });
    checkBadCharactersInPath("The config path", resolvedPath, logger);
    logger.error(colors$1.red(`failed to load config from ${resolvedPath}`), {
      error: e
    });
    throw e;
  }
}
async function nativeImportConfigFile(resolvedPath) {
  const module = await import(pathToFileURL$1(resolvedPath).href + "?t=" + Date.now());
  return {
    configExport: module.default,
    dependencies: []
  };
}
async function runnerImportConfigFile(resolvedPath) {
  const { module, dependencies } = await runnerImport(resolvedPath);
  return {
    configExport: module.default,
    dependencies
  };
}
async function bundleAndLoadConfigFile(resolvedPath) {
  const isESM = typeof process.versions.deno === "string" || isFilePathESM(resolvedPath);
  const bundled = await bundleConfigFile(resolvedPath, isESM);
  const userConfig = await loadConfigFromBundledFile(
    resolvedPath,
    bundled.code,
    isESM
  );
  return {
    configExport: userConfig,
    dependencies: bundled.dependencies
  };
}
async function bundleConfigFile(fileName, isESM) {
  const isModuleSyncConditionEnabled = (await import('#module-sync-enabled')).default;
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await build$3({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    write: false,
    target: [`node${process.versions.node}`],
    platform: "node",
    bundle: true,
    format: isESM ? "esm" : "cjs",
    mainFields: ["main"],
    sourcemap: "inline",
    // the last slash is needed to make the path correct
    sourceRoot: path$b.dirname(fileName) + path$b.sep,
    metafile: true,
    define: {
      __dirname: dirnameVarName,
      __filename: filenameVarName,
      "import.meta.url": importMetaUrlVarName,
      "import.meta.dirname": dirnameVarName,
      "import.meta.filename": filenameVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build2) {
          const packageCache = /* @__PURE__ */ new Map();
          const resolveByViteResolver = (id, importer, isRequire) => {
            return tryNodeResolve(id, importer, {
              root: path$b.dirname(fileName),
              isBuild: true,
              isProduction: true,
              preferRelative: false,
              tryIndex: true,
              mainFields: [],
              conditions: [
                "node",
                ...isModuleSyncConditionEnabled ? ["module-sync"] : []
              ],
              externalConditions: [],
              external: [],
              noExternal: [],
              dedupe: [],
              extensions: configDefaults.resolve.extensions,
              preserveSymlinks: false,
              packageCache,
              isRequire,
              builtins: nodeLikeBuiltins
            })?.id;
          };
          build2.onResolve(
            { filter: /^[^.#].*/ },
            async ({ path: id, importer, kind }) => {
              if (kind === "entry-point" || path$b.isAbsolute(id) || isNodeBuiltin(id)) {
                return;
              }
              if (isNodeLikeBuiltin(id)) {
                return { external: true };
              }
              const isImport = isESM || kind === "dynamic-import";
              let idFsPath;
              try {
                idFsPath = resolveByViteResolver(id, importer, !isImport);
              } catch (e) {
                if (!isImport) {
                  let canResolveWithImport = false;
                  try {
                    canResolveWithImport = !!resolveByViteResolver(
                      id,
                      importer,
                      false
                    );
                  } catch {
                  }
                  if (canResolveWithImport) {
                    throw new Error(
                      `Failed to resolve ${JSON.stringify(
                        id
                      )}. This package is ESM only but it was tried to load by \`require\`. See https://vite.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`
                    );
                  }
                }
                throw e;
              }
              if (idFsPath && isImport) {
                idFsPath = pathToFileURL$1(idFsPath).href;
              }
              return {
                path: idFsPath,
                external: true
              };
            }
          );
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build2) {
          build2.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await fsp.readFile(args.path, "utf-8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(
              path$b.dirname(args.path)
            )};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify(
              pathToFileURL$1(args.path).href
            )};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: Object.keys(result.metafile.inputs)
  };
}
const _require = createRequire$1(import.meta.url);
async function loadConfigFromBundledFile(fileName, bundledCode, isESM) {
  if (isESM) {
    let nodeModulesDir = typeof process.versions.deno === "string" ? void 0 : findNearestNodeModules(path$b.dirname(fileName));
    if (nodeModulesDir) {
      try {
        await fsp.mkdir(path$b.resolve(nodeModulesDir, ".vite-temp/"), {
          recursive: true
        });
      } catch (e) {
        if (e.code === "EACCES") {
          nodeModulesDir = void 0;
        } else {
          throw e;
        }
      }
    }
    const hash = `timestamp-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const tempFileName = nodeModulesDir ? path$b.resolve(
      nodeModulesDir,
      `.vite-temp/${path$b.basename(fileName)}.${hash}.mjs`
    ) : `${fileName}.${hash}.mjs`;
    await fsp.writeFile(tempFileName, bundledCode);
    try {
      return (await import(pathToFileURL$1(tempFileName).href)).default;
    } finally {
      fs__default.unlink(tempFileName, () => {
      });
    }
  } else {
    const extension = path$b.extname(fileName);
    const realFileName = await promisifiedRealpath(fileName);
    const loaderExt = extension in _require.extensions ? extension : ".js";
    const defaultLoader = _require.extensions[loaderExt];
    _require.extensions[loaderExt] = (module, filename) => {
      if (filename === realFileName) {
        module._compile(bundledCode, filename);
      } else {
        defaultLoader(module, filename);
      }
    };
    delete _require.cache[_require.resolve(fileName)];
    const raw = _require(fileName);
    _require.extensions[loaderExt] = defaultLoader;
    return raw.__esModule ? raw.default : raw;
  }
}
async function runConfigHook(config, plugins, configEnv) {
  let conf = config;
  for (const p of getSortedPluginsByHook("config", plugins)) {
    const hook = p.config;
    const handler = getHookHandler(hook);
    const res = await handler(conf, configEnv);
    if (res && res !== conf) {
      conf = mergeConfig(conf, res);
    }
  }
  return conf;
}
async function runConfigEnvironmentHook(environments, plugins, configEnv, isSsrTargetWebworkerSet) {
  const environmentNames = Object.keys(environments);
  for (const p of getSortedPluginsByHook("configEnvironment", plugins)) {
    const hook = p.configEnvironment;
    const handler = getHookHandler(hook);
    for (const name of environmentNames) {
      const res = await handler(name, environments[name], {
        ...configEnv,
        isSsrTargetWebworker: isSsrTargetWebworkerSet && name === "ssr"
      });
      if (res) {
        environments[name] = mergeConfig(environments[name], res);
      }
    }
  }
}
function optimizeDepsDisabledBackwardCompatibility(resolved, optimizeDeps, optimizeDepsPath = "") {
  const optimizeDepsDisabled = optimizeDeps.disabled;
  if (optimizeDepsDisabled !== void 0) {
    if (optimizeDepsDisabled === true || optimizeDepsDisabled === "dev") {
      const commonjsOptionsInclude = resolved.build.commonjsOptions.include;
      const commonjsPluginDisabled = Array.isArray(commonjsOptionsInclude) && commonjsOptionsInclude.length === 0;
      optimizeDeps.noDiscovery = true;
      optimizeDeps.include = void 0;
      if (commonjsPluginDisabled) {
        resolved.build.commonjsOptions.include = void 0;
      }
      resolved.logger.warn(
        colors$1.yellow(`(!) Experimental ${optimizeDepsPath}optimizeDeps.disabled and deps pre-bundling during build were removed in Vite 5.1.
    To disable the deps optimizer, set ${optimizeDepsPath}optimizeDeps.noDiscovery to true and ${optimizeDepsPath}optimizeDeps.include as undefined or empty.
    Please remove ${optimizeDepsPath}optimizeDeps.disabled from your config.
    ${commonjsPluginDisabled ? "Empty config.build.commonjsOptions.include will be ignored to support CJS during build. This config should also be removed." : ""}
  `)
      );
    } else if (optimizeDepsDisabled === false || optimizeDepsDisabled === "build") {
      resolved.logger.warn(
        colors$1.yellow(`(!) Experimental ${optimizeDepsPath}optimizeDeps.disabled and deps pre-bundling during build were removed in Vite 5.1.
    Setting it to ${optimizeDepsDisabled} now has no effect.
    Please remove ${optimizeDepsPath}optimizeDeps.disabled from your config.
  `)
      );
    }
  }
}

export { normalizePath$3 as A, BuildEnvironment as B, mergeConfig as C, DevEnvironment as D, mergeAlias as E, createFilter$1 as F, rollupVersion as G, send$1 as H, createLogger as I, searchForWorkspaceRoot as J, isFileServingAllowed as K, isFileLoadingAllowed as L, loadEnv as M, resolveEnvPrefix as N, colors$1 as O, getDefaultExportFromCjs as P, commonjsGlobal as Q, index$1 as R, index as S, build$1 as T, preview$1 as U, arraify as a, perEnvironmentState as b, createServer as c, defineConfig as d, preview as e, build as f, createBuilder as g, createIdResolver as h, isInNodeModules$1 as i, formatPostcssSourceMap as j, preprocessCSS as k, loadConfigFromFile as l, buildErrorMessage as m, createRunnableDevEnvironment as n, optimizeDeps as o, perEnvironmentPlugin as p, isRunnableDevEnvironment as q, resolveConfig as r, sortUserPlugins as s, transformWithEsbuild as t, runnerImport as u, fetchModule as v, createServerModuleRunner as w, createServerModuleRunnerTransport as x, createServerHotChannel as y, ssrTransform as z };
